<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STM32标准库</title>
      <link href="/posts/cb085122.html"/>
      <url>/posts/cb085122.html</url>
      
        <content type="html"><![CDATA[<h1>keil配置与芯片包下载</h1><h2 id="固件库文件">固件库文件</h2><p>以F103固件库为例：</p><p>STM32F10x_StdPeriph_Lib_V3.5.0固件库是为STM32F1系列微控制器设计的开发辅助库，主要用于简化对STM32F1外设的控制和配置。该库封装了对各类外设（如GPIO、ADC、USART、SPI、I2C等）的控制接口，使开发者无需直接操作复杂的寄存器就能使用这些硬件外设。通过它，开发者可以轻松地进行外设的初始化、配置和数据处理。</p><p><strong>主要结构</strong>：</p><ul><li><strong>_htmresc</strong>：图片没什么用</li><li><strong>Libraries</strong>：库函数的文件，我们之后建工程时会用<ul><li><strong>CMSIS</strong>：包含Cortex-Mx内核的相关定义和启动代码。<ul><li>CoreSupport：包含了与Cortex-M系列内核相关的文件，主要是一些适用于ARM Cortex-M内核的通用代码和数据结构，用于管理核心处理器功能。</li><li>DeviceSupport：含与特定厂商的微控制器设备相关的文件，特别是该设备特定的外设寄存器定义和访问方法。它提供了Cortex-M内核之外的硬件支持，适用于具体的MCU型号。</li></ul></li><li><strong>STM32F10x_StdPeriph_Driver</strong>：<strong>标准外设驱动库</strong>，包含STM32F1系列的外设驱动源文件和头文件。</li></ul></li><li><strong>Projects</strong>：是官方提供的工程示例和模板，使用库函数时可以参考</li><li><strong>Utilities</strong>：是STM32官方评估板的相关例程，这个评估版就是官方用STM32做的一个小电路板用来测评STM32的，文件夹内存放的就是小电路板的测评程序</li><li><strong>Release_Notes.html</strong>：这个是库函数的发布文档</li><li><strong>stm32f10x_stdperiph_lib_um.chm</strong>：使用手册，教大家如何使用库函数</li></ul><h2 id="keil新建工程">keil新建工程</h2><ol><li>新建一个 new μVision Project，设置名称后，会出现选择芯片，如果只有ARM，则需要将官方的芯片包(在官方下载.pack文件)导入。</li></ol><blockquote><p>最后会弹出来Manage Run-time Environment的界面，manage run-time environment是一个新建工程的小助手也有固件库，可以帮我快速建立工程，直接勾选即可，是keil5的新功能**。今天我们创建工程的方式是自己去搬运官网给的库，加深一下理解和增加动手能力，所以没有使用manage run-time environment来添加库，直接点击OK即可**</p></blockquote><p>此时就只有一个Target里面什么都没有，我们需要给它添加一点工程的必要文件。</p><p>此时我们可以看到刚刚创建的项目文件夹自动生成一堆文件夹，为了便于管理<strong>我们先在工程文件夹中创建一个Startup文件夹用于存放启动文件</strong></p><ol start="2"><li>此时打开固件库文件夹-&gt;“STM32F10x_StdPeriph_Lib_V3.5.0”-“Libraries”-“CMSIS”-“CM3”-“DeviceSupport”-“ST”-“STM32F10x”-“startup”，然后选中全部一起复制到刚刚我们创建的Startup文件夹中。</li></ol><blockquote><p>这些就是STM32的启动文件，STM32程序就是从这些启动文件开始执行的</p></blockquote><ol start="3"><li>“Libraries”-“CMSIS”-“CM3”-“DeviceSupport”-“ST”-“STM32F10x，我们把这三个文件也复制下来粘贴到Startup文件夹下</li></ol><blockquote><p>我们可以看到stm32f10x.h和两个system开头的文件</p><p>stm32f10x.h：是STM32的<strong>外设寄存器描述文件，用来描述STM32有哪些寄存器和它对应的地址。</strong></p><p>system文件：这个两个system文件(system_stm32f10x.c/h)用于配置时钟，STM32F103主频72MHz就是在system文件里配置的。</p></blockquote><hr><p><strong>接下来，因为STM32是内核和内核外围设备(外设)组成的，而且内核的寄存器描述和外围设备的描述文件不是在一起的，所以我们还需要添加内核寄存器的描述文件</strong></p><ol start="4"><li>进入“STM32F10x_StdPeriph_Lib_V3.5.0”-“Libraries”-“CMSIS”-“CM3”-“CoreSupport”。然后也把这两个相关内核相关的文件复制到Startup文件后所有的准备完成</li></ol><blockquote><p>里面有两个cm3(core_cm3.c和core_cm3.h)，这两个Cortex-M3文件就是<strong>内核的寄存器描述文件</strong>，还有一些内核配置函数</p></blockquote><ol start="5"><li>返回keil中将刚刚的文件添加到工程中，在Target 1中add group然后将新建的文件夹改名为Startup，将刚刚所有的Startup文件夹中的文件添加进去。</li></ol><blockquote><ol><li><p>首先是启动文件的添加，有一堆startup文件，我们选择其中的一个startup_stm32f10x_md.s添加到工程中。</p><p><strong>有关启动文件的选择，请看下面的笔记</strong></p></li><li><p>然后剩下的所有.c和.h文件都要添加进去</p></li></ol><p>我们可以按住Ctrl键，然后依次选择他们，点击Add，Close即可</p><p>这里的文件都是STM32里最基本的文件，是不需要我们修改的，添加到工程即可，此时可以看到这些文件都带有钥匙图标，代表只读文件</p></blockquote><ol start="6"><li>点击魔术棒，打开工程选项，在C/C++中找到include Paths，添加Startup文件夹的路径至其中。</li></ol><blockquote><p>最后我们还要在工程选项里添加上该文件夹的头文件路径，否则找不到.h文件</p></blockquote><ol start="7"><li>回到该项目的文件夹下，新建一个User文件夹，main函数就放在其中。再回到keil中，在Target添加一个组，改名为User，对其右键创建main.c到其中，此时在main.c中创建我们的main函数，进行开发即可。</li></ol><p><code>由于此时工程还没有添加STM32的库函数，所以是基于寄存器开发工程，如果想要使用寄存器开发那么到这里就可以结束了</code></p><hr><p><code>接下来继续添加库函数</code></p><ol start="8"><li>打开项目文件夹，新建Library文件夹用于存放库函数，接着打开固件库的文件夹，“STM32F10x_StdPeriph_Lib_V3.5.0”-“Libraries”-“STM32F10x_StdPeriph_Driver”-“src”，全选复制粘贴到Library中去，然后再回到Inc中去，再次将头文件全部复制粘贴到Library中去。</li></ol><blockquote><ol><li><p>其中misc.c是内核的库函数</p></li><li><p>其他的就是外设库函数</p></li></ol></blockquote><ol start="9"><li>回到keil中，在Target下添加一个组命名为Library，再将Library文件夹中的所有文件添加到工程中去，但是此时的库函数还不能直接使用，我们还需要在添加文件。继续打开固件库文“STM32F10x_StdPeriph_Lib_V3.5.0”-“Project”-“STM32F10x_StdPeriph_Template”中，把一个conf.h文件和两个it中断文件复制粘贴到User文件下，<strong>回到keil中将这三个文件添加到User的组中</strong></li></ol><blockquote><p>我们可以看到一个stm32f10x_conf.h的文件，这个config文件是用来配置库函数头文件包含关系，以及用来参数检查的函数定义，这是所有库函数都需要的</p><p>两个stm32f10x_it.c/h文件是用来存放中断函数的</p></blockquote><ol start="10"><li>最后我们还需要一个宏定义USE_STDPERIPH_DRIVER，我们打开<strong>b</strong>，切换到C/C++中，在Define中添加&quot;USE_STDPERIPH_DRIVER&quot;，最后别忘了在下方的include Paths再将User和Library目录的路径添加进去。</li></ol><blockquote><p>我们可以在stm32f10x.h文件中的最下方看到有一段</p><p>#ifdef USE_STDPERIPH_DRIVER<br>#include “stm32f10x_conf.h”<br>#endif</p><p>这个的意思是如果定义了USE_STDPERIPH_DRIVER(使用标准外设驱动)这个宏定义，才会包含stm32f10x_conf.h，即才会生效。</p><p><code>由于stm32f10x_conf.h文件包含了所有库函数的头文件，所以我们只需要include stm32f10x.h文件就可以任意调用库函数了</code></p></blockquote><p>最终我们的基本模板为：</p><blockquote><ul><li>DebugConfig</li><li>Listings</li><li>Objects</li><li>Library</li><li>Startup</li><li>User</li></ul><p>前三个为创建项目后自动生成的文件夹，后三个为我们手动创建的。</p></blockquote><p><code>一定记得将所有带有头文件的目录添加到C/C++的include Paths中以便于编译器能够找到头文件</code></p><h2 id="启动文件的选择">启动文件的选择</h2><p>我们在新建工程向Startup文件夹添加启动文件的时候，有一堆startup文件。当时我们选择其中的一个startup_stm32f10x_md.s添加到工程中。</p><p>现在来解释一下这个文件怎么选取：</p><p><strong>启动文件有很多类型，至于选择哪一个，我们要根据芯片的型号来选择</strong></p><p>看这张表：</p><blockquote><p>缩写                                翻译             FLASH容量        型号</p><p>LD(High Density)       小容量产品        16-32K             STM32F101/102/103</p><p>MD(Middle Density)      中容量产品      64-128K             STM32F101/102/103</p><p>HD(High Density)       大容量产品     256-512K             STM32F101/102/103</p><p>XL(Extra Large)       加大容量产品    大于512K             STM32F101/102/103</p><p>CL                                互联网产品       -                           STMF105/107</p><p>LD_VL(value line)       小容量产品超值系列        16-32K             STM32F100</p><p>MD_V                      中容量产品超值系列      64-128K             STM32F100</p><p>HD_VL                     大容量产品超值系列     256-512K             STM32F100</p></blockquote><ol><li><strong>先根据型号选择是哪个系列的启动文件</strong></li><li><strong>根据Flash容量选择对应的启动文件添加到Startup即可</strong></li></ol><h2 id="stm32f10x-h">stm32f10x.h</h2><p>我们可以在stm32f10x.h文件中的最下方看到有一段</p><p>#ifdef USE_STDPERIPH_DRIVER<br>#include “stm32f10x_conf.h”<br>#endif</p><p>这个的意思是如果定义了USE_STDPERIPH_DRIVER(使用标准外设驱动)这个宏定义，才会包含stm32f10x_conf.h，即才会生效。</p><p><code>由于stm32f10x_conf.h文件包含了所有库函数的头文件，所以我们只需要在编程的时候include stm32f10x.h文件就可以任意调用库函数了</code></p><h2 id="新建工程步骤总结">新建工程步骤总结</h2><ol><li><strong>建立工程文件夹，Keil中新建工程、选择型号</strong></li><li><strong>工程文件夹中建立Startup、Library、User等文件夹，复制固件库里面的文件到工程文件夹</strong></li><li><strong>工程里对应建立Start、Library、User等同名称的分组，并将文件夹内的文件添加到工程分组里</strong></li><li><strong>工程选项(魔法棒)，C/C++ Include Paths内添加所有包含头文件的文件夹</strong></li><li><strong>工程选项(魔法棒)，C/C++，Define中定义宏定义USE_STDPERIPH_DRIVER</strong></li><li><strong>工程选项(魔法棒)，Debug，下拉列表选择对应调试器，Settings，Flash，Download里勾选Reset and Run</strong></li></ol><h1>模块化编程</h1><p>如果我们把所有的初始化代码都写到main函数中就会显得很杂乱，为此我们单独创建一个Hardware文件夹用于存放各外设驱动(LED.c，LED.h，Key.c，Key.h等)</p><ol><li>在项目文件夹下创一个Hartware文件夹</li><li>回到keil中添加一个名为Hardware的组，然后添加或创建对应外设驱动的文件。</li><li>将Hardware添加到魔法棒中的C/C++的include Paths中</li></ol><p>最终我们的基本模板为：</p><blockquote><ul><li>DebugConfig</li><li>Listings</li><li>Objects</li><li>Library</li><li>Startup</li><li><strong>Hardware</strong></li><li>User</li></ul><p>前三个为创建项目后自动生成的文件夹，后四个个为我们手动创建的。</p></blockquote><p>例如在Hardware里的，LED驱动函数就是这样写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_ON</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_OFF</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_ON</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_OFF</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Turn</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_6 | GPIO_Pin_7);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_ON</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOC,GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Turn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadOutputDataBit(GPIOC,GPIO_Pin_2)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(GPIOC,GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOC,GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>所有的外设都可以这样独立写成驱动函数，初始化函数等。这样使的项目更好管理</p></blockquote><h1>STM32启动文件</h1><p>startup_stm32xx.s就是启动文件，这是一个用汇编写的文件，定义了中断向量表和中断服务函数等。启动有个复位中断是程序的入口，当stm32按下复位或者上电的时候，程序就会进入复位中断函数执行，复位中断函数做的就是调用SystemInit函数和调用main函数。</p><p>我们可以在启动文件文件的注释中知道流程为：</p><ol><li>初始化堆栈指针SP</li><li>初始化程序计数器PC为Reset_Handler</li><li>初始化堆、栈的大小</li><li>设置中断向量表的入口地址</li></ol><p>转向Reset_Handler执行：</p><ol start="5"><li>调用SystemInit()函数完成系统初始化(系统时钟、闪存接口配置等)</li><li>设置C库的分支入口为 __main(调用我们的main函数)</li></ol><hr><h1>GPIO</h1><ul><li><p>GPIO(General Purpose Input Output) 通用输入输出端口，可配置共8种输入输出模式。</p></li><li><p>引脚电平位0~3.3V，部分引脚可以容忍5V</p></li><li><p>输出模式下可控制端口输出高低电平，用于驱动LED，控制蜂鸣器，模拟通信协议输出时序</p></li><li><p>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</p></li></ul><p><a href="https://blog.csdn.net/qq_44016222/article/details/123206403?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stm32GPIO&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-123206403.nonecase&amp;spm=1018.2226.3001.4187">STM32-GPIO介绍_stm32 gpio-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_52162042/article/details/121278274?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%BC%B1%E4%B8%8A%E6%8B%89%E5%92%8C%E5%BC%BA%E4%B8%8A%E6%8B%89&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-121278274.142%5Ev100%5Epc_search_result_base6&amp;spm=1018.2226.3001.4187">上、下拉电阻（定义、强弱上拉、常见作用、吸电流、拉电流、灌电流）_弱上拉和强上拉的区别-CSDN博客</a></p><p><strong>操作stm32的GPIO分为三个步骤</strong>：</p><ol><li><strong>使用RCC开启GPIO时钟</strong></li><li><strong>使用GPIO_Init(库函数)函数初始化GPIO</strong></li><li><strong>使用输出或输入函数控制GPIO口</strong></li></ol><h2 id="RCC开启时钟">RCC开启时钟</h2><p>在stm32f10x_rcc.h中，有很多RCC相关函数但是我们最常用的是这三个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*RCC AHB总线外设时钟控制*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*RCC APB2总线外设时钟控制*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*RCC APB1总线外设时钟控制*/</span></span><br></pre></td></tr></table></figure><blockquote><p>我们可以跳到这些函数的定义查看注释我们可以知道，这些时钟控制函数就是<code>使能或失能外设时钟的</code></p><p>参数1：选择外设</p><p>参数2：使能或失能</p><p>如果不知道该外设是否在这个总线上，我们可以在注释上面的列表看，如果出现了代表在这个总线上</p></blockquote><h2 id="GPIO标准库函数">GPIO标准库函数</h2><p>在stm32f10x_gpio.h中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_DeInit</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">/*指定GPIO外设被复位*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_AFIODeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*指定AFIO复位*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">/*初始化外设，为指定的GPIO初始化，使用的是我们自己创建的结构体*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_StructInit</span><span class="params">(GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">/*指定结构体赋值*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadInputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadInputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadOutputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadOutputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">/*GPIO读取函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;<span class="comment">//指定端口拉高</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;<span class="comment">//指定端口拉低</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, BitAction BitVal)</span>;<span class="comment">//端口写入指定值：Bit_SET或Bit_RESET</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> PortVal)</span>;</span><br><span class="line"><span class="comment">/*读写GPIO函数*/</span></span><br></pre></td></tr></table></figure><ul><li>对应GPIO的结构体定义如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> GPIO_Pin;             <span class="comment">/*!&lt; Specifies the GPIO pins to be configured.</span></span><br><span class="line"><span class="comment">                                      This parameter can be any value of @ref GPIO_pins_define */</span></span><br><span class="line"></span><br><span class="line">  GPIOSpeed_TypeDef GPIO_Speed;  <span class="comment">/*!&lt; Specifies the speed for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */</span></span><br><span class="line"></span><br><span class="line">  GPIOMode_TypeDef GPIO_Mode;    <span class="comment">/*!&lt; Specifies the operating mode for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOMode_TypeDef */</span></span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure><blockquote><p><strong>标准库的GPIO_InitTypeDef结构体参数只有三个：mode、pin、speed</strong></p><p><strong>这些跳转到对应定义可以知道值</strong></p><p>HAL库有5个参数，对比起来标准库更简单了</p></blockquote><h2 id="具体流程代码">具体流程代码</h2><p>假设我们需要点亮PC2的LED，查看手册后发现挂载再APB2总线上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1.开启对应外设时钟*/</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2. 初始化GPIOC*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    <span class="comment">//定义GPIO_InitStructure结构体，三个参数赋值</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    <span class="comment">//调用GPIO_Init初始化对应GPIO口，函数中读取结构体自动配置写入到对应寄存器</span></span><br><span class="line">GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验-LED流水灯">实验-LED流水灯</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_WriteBit(GPIOC,GPIO_Pin_2,Bit_RESET);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_WriteBit(GPIOC,GPIO_Pin_2,Bit_SET);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_WriteBit(GPIOC,GPIO_Pin_3,Bit_RESET);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_WriteBit(GPIOC,GPIO_Pin_3,Bit_SET);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*使用Write函数同时操控多个端口*/</span></span><br><span class="line"> <span class="comment">//GPIO_Write(GPIOC,~0x0004);</span></span><br><span class="line"><span class="comment">//Delay_ms(500);</span></span><br><span class="line"><span class="comment">//GPIO_Write(GPIOC,0x0004);</span></span><br><span class="line"><span class="comment">//Delay_ms(500);</span></span><br><span class="line"><span class="comment">//GPIO_Write(GPIOC,~0x0008);</span></span><br><span class="line"><span class="comment">//Delay_ms(500);</span></span><br><span class="line"><span class="comment">//GPIO_Write(GPIOC,0x0008);</span></span><br><span class="line"><span class="comment">//Delay_ms(500);</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当有多个引脚时，我们可以使用<strong>按位或的方式同时选中多个Pin</strong>：</p><p>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | …;      选中了Pin2和Pin3</p><p>我们来看对应定义：</p><p>#define GPIO_Pin_0                 ((uint16_t)0x0001)<br>#define GPIO_Pin_1                 ((uint16_t)0x0002)</p><p>#define GPIO_Pin_3                 ((uint16_t)0x0008)</p><p>…</p><p>#define GPIO_Pin_15                ((uint16_t)0x8000)</p><p>#define GPIO_Pin_All               ((uint16_t)0xFFFF)</p><p><code>一共16位，每一个引脚对应一个位，只需要使用按位或的操作既可以选中指定端口</code></p></blockquote><p><strong>知道这个后我们可以使用GPIO_Write函数同时操控多个端口：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*由于C语言不支持写2进制，故使用16进制来写*/</span></span><br><span class="line">GPIO_Write(GPIOC,~<span class="number">0x0004</span>);<span class="comment">//~(0000 0000 0000 0100),pin2亮</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOC,<span class="number">0x0004</span>);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOC,~<span class="number">0x0008</span>);<span class="comment">//~(0000 0000 0000 1000),pin3亮</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOC,<span class="number">0x0008</span>);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用Systick实现的延时函数，直接使用即可</strong>，使用时创建一个System文件夹，并把他们放到System文件夹下，在keil创建System组即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Delay.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint32_t</span> us)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">uint32_t</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_s</span><span class="params">(<span class="type">uint32_t</span> s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Delay.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  微秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xus 延时时长，范围：0~233015</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint32_t</span> xus)</span></span><br><span class="line">&#123;</span><br><span class="line">SysTick-&gt;LOAD = <span class="number">72</span> * xus;<span class="comment">//设置定时器重装值</span></span><br><span class="line">SysTick-&gt;VAL = <span class="number">0x00</span>;<span class="comment">//清空当前计数值</span></span><br><span class="line">SysTick-&gt;CTRL = <span class="number">0x00000005</span>;<span class="comment">//设置时钟源为HCLK，启动定时器</span></span><br><span class="line"><span class="keyword">while</span>(!(SysTick-&gt;CTRL &amp; <span class="number">0x00010000</span>));<span class="comment">//等待计数到0</span></span><br><span class="line">SysTick-&gt;CTRL = <span class="number">0x00000004</span>;<span class="comment">//关闭定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  毫秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xms 延时时长，范围：0~4294967295</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">uint32_t</span> xms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(xms--)</span><br><span class="line">&#123;</span><br><span class="line">Delay_us(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xs 延时时长，范围：0~4294967295</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_s</span><span class="params">(<span class="type">uint32_t</span> xs)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(xs--)</span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="输入模式">输入模式</h2><h2 id="GPIO相关寄存器">GPIO相关寄存器</h2><p>查看芯片对应参考手册，结合对应代码可以得知如何使用GPIO相关寄存器</p><h2 id="引脚重映射-复用功能重映像">引脚重映射(复用功能重映像)</h2><p>在<code>参考手册</code>中，有一节复用功能I/O和调试配置(AFIO)，这一章节专门就是讲的引脚复用重映像功能，手册描述如下：</p><p>为了优化64脚或100脚封装的外设数目，可以把一些复用功能重新映射到其他引脚上。设置复用重映射和调试I/O配置寄存器(AFIO_MAPR)实现引脚的重新映射。这时，复用功能不再映射到它们的原始分配</p><blockquote><p>如果多个外设需要使用同一组引脚，默认引脚的配置可能会导致冲突。引脚重映像允许开发者重新分配功能到其他引脚，避免资源冲突。<br><strong>实际意义：</strong><br>在复杂系统中，可以高效利用芯片的引脚资源，而不用为了冲突放弃某些外设功能。</p><p>例如：</p><ul><li>需要同时使用<code>USART1</code>和<code>SPI1</code>，但两者默认引脚有重叠。</li><li>通过重映像将<code>USART1</code>从<code>PA9/PA10</code>移到<code>PB6/PB7</code>，释放<code>PA9/PA10</code>供其他功能使用。</li><li>这样我们就可以同时使用<code>USART1</code>和<code>SPI1</code>了</li></ul></blockquote><p><strong>对应库函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinRemapConfig</span><span class="params">(<span class="type">uint32_t</span> GPIO_Remap, FunctionalState NewState)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数1：对应外设重映射方式，一般是部分重映像或者完全重映像，具体查看对应手册</span></span><br><span class="line"><span class="comment"> * 参数2：是否是能</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>使用方式</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1.开启AFIO时钟*/</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line">    <span class="comment">/*2.选择对应外设的映射，映射方式即可*/</span></span><br><span class="line">GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2,ENABLE);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);</span></span><br><span class="line">    <span class="comment">/*接触JTAG复用，以便于TIM2能够重映射/</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意使用端口映射前，可能有些端口已经被占用了，比如调试端口JTAG，如果重映射使用的是调试端口，那么使用前需要先解除JTAG端口复用</p></blockquote><h1>EXTI(外部中断)</h1><h2 id="介绍">介绍</h2><p><strong>EXTI可以监测指定的GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序。</strong></p><p><strong>支持的触发方式</strong>：上升沿/下降沿/双边沿/软件触发</p><p><strong>支持的GPIO口</strong>：所有GPIO口，但相同的Pin不能同时触发中断(如：PA1与PB1与PC1之间)</p><p><strong>通道数</strong>：16个GPIO_Pin，外加PVD输出、RTC闹钟等</p><p><strong>触发响应的方式</strong>：<strong>中断响应/事件响应</strong></p><ul><li><strong>中断响应</strong>：正常的引脚电平变化触发中断</li><li><strong>事件响应</strong>：不会触发中断，而是触发别的外设操作，属于外设之间的联合工作</li></ul><h2 id="库函数">库函数</h2><p><code>相关的EXTI库函数去stm32f10x_exti.h中查看，这里直接使</code></p><h2 id="初始化配置流程">初始化配置流程</h2><p>只需要从GPIO到NVIC这一路出现的外设模块配置好即可，一共5步</p><p><img src="./image/98.png" alt="image-20241117144622580"></p><ol><li><strong>配置RCC，打开相关的外设时钟</strong>。这里涉及到的是GPIO、AFIO、EXTI、NVIC的时钟，但由于EXTI和NVIC时钟(内核外设不需要开启时钟)一直都是打开的，不需要我们开启，所以只需要开启GPIO和AFIO时钟即可。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//开启对应AFIO时钟</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>配置GPIO，配置我们的端口为输入模式</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>在我们的手册中有对应外设每个引脚推荐配置模式，我们可以找到EXTI推荐配置为:浮空，上拉，下拉</strong></p></blockquote><ol start="3"><li><strong>配置AFIO 通过 AFIO 外设将 PC13 引脚映射到 EXTI 外设上，以便用于外部中断</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数1：使用哪个GPIO作为外部中断源,GPIO_PortSourceGPIOx where x can be (A..G).</span></span><br><span class="line"><span class="comment"> * 参数2：指定需要配置的外部中断线, GPIO_PinSourcex where x can be (0..15).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里配置AFIO只需要这个函数即可*/</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOC,GPIO_PinSource13);</span><br></pre></td></tr></table></figure><blockquote><p>没有单独写AFIO的库函数，与GPIO库函数放在一起的，可以去gpio的库函数中找这个函数查看对应参数。虽然写的是GPIO，但是我们查看该函数定义可以发现里面操作的是AFIO的寄存器</p></blockquote><ol start="4"><li><strong>配置EXTI，选择边沿触发方式，比如上升沿、双边沿等，还有触发响应方式，可以选择中断响应和事件响应。</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">EXTI_InitStructure.EXTI_Line= EXTI_Line13;<span class="comment">//对应选择的外部中断线</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd= ENABLE; <span class="comment">// 使能或不使能</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode= EXTI_Mode_Interrupt ; <span class="comment">//两种模式，一种是中断响应，一种是事件响应</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger= EXTI_Trigger_Falling; <span class="comment">// 触发方式</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br></pre></td></tr></table></figure><blockquote><p>相关的EXTI库函数去stm32f10x_exti.h中查看，这里直接使用</p></blockquote><ol start="5"><li><strong>配置NVIC，给我们的中断选择一个合适的优先级</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//优先级配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NVIC_PriorityGroupConfig()分组方式整个芯片只能只能用一种，按理来说这个分组的代码整个工程只需要执行一次即可。如果把这个函数放到模块里面进行分组，一定要确保每个模块分组都选的是同一个。也可以把这个代码放在主函数的开始，这样就不用每个模块分组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">// 使能</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span> ; <span class="comment">//指定抢占优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span> ;  <span class="comment">//指定子优先级</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br></pre></td></tr></table></figure><blockquote><p>因为NVIC是内核外设，库函数被分配到了misc.h/c(杂项)文件中去了，在这里查找对应参数，对应函数用法。</p><p>NVIC_InitTypeDef 中查看注释我们可以知道IRQ需要到stm32f10x.h去找，我们要选择对应芯片的<strong>选择编译</strong>，这里我们是stm32f10x_MD</p><p>在里面的选择编译中，我们找到了EXTI15_10_IRQn = 40 (stm32的EXTI10到15都是合并到了这个通道里)</p><p>所以我们定义为EXTI15_10_IRQn即可</p><hr><p><code>注意:配置NVIC时，NVIC_IRQChannel只能接受一个中断通道号，不能接收多个中断通道的组合，如果有多个中断通道配置需要配置多次</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn | EXTI0_IRQn;</span><br></pre></td></tr></table></figure><p><code>这样配置不会报错，但是两个中断都不会生效!!!</code></p><p><code>需要单独调用两次NVIC_Init初始化</code></p><hr><p>对应的设置抢占优先级和子优先级设置我们可以跳转到对应定义处，继续跳转到注释中提到的中断优先级对应的优先级表查看即可</p></blockquote><p><strong>只有两个按键配置流程连起来就是</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.配置RCC启用对应外设时钟*/</span></span><br><span class="line">     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line"> <span class="comment">/*2.配置GPIO*/</span></span><br><span class="line">     GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13|GPIO_Pin_12;</span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*3.配置AFIO*/</span>    GPIO_EXTILineConfig(GPIO_PortSourceGPIOC,GPIO_PinSource12); GPIO_EXTILineConfig(GPIO_PortSourceGPIOC,GPIO_PinSource13);</span><br><span class="line">     <span class="comment">/*4.配置EXTI*/</span></span><br><span class="line">  EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">  EXTI_InitStructure.EXTI_Line= EXTI_Line12 | EXTI_Line13;<span class="comment">//对应选择的按键外部中断线</span></span><br><span class="line">      EXTI_InitStructure.EXTI_LineCmd= ENABLE; <span class="comment">// 使能或不使能</span></span><br><span class="line">  EXTI_InitStructure.EXTI_Mode= EXTI_Mode_Interrupt ; <span class="comment">//两种模式，一种是中断，一种是事件</span></span><br><span class="line">      EXTI_InitStructure.EXTI_Trigger= EXTI_Trigger_Falling; <span class="comment">// 触发方式为下降沿触发</span></span><br><span class="line">  EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*5.配置NVIC*/</span></span><br><span class="line">  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">      NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">// 使能</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span> ; <span class="comment">//指定抢占优先级</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span> ;  <span class="comment">//指定子优先级</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中断函数">中断函数</h2><p><strong>完成了外部中断初始化配置后，接下来就是编写中断函数</strong></p><p>在启动文件的中断向量表中找到对应的中断函数的名字，这里是<code>EXTI15_10_IRQHandler</code></p><p>将其从启动文件中复制到对应位置进行编写，名字一定不能错，错了就无法进入了</p><p><strong>编写步骤如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*1.判断对应中断标志位是否为1(SET),如果是*/</span></span><br><span class="line"><span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line12) == SET)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*2.清除对应中断标志位，否则会一直触发中断*/</span></span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line12);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*3.用户干的事情*/</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line13) == SET)</span><br><span class="line">&#123;</span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line13);</span><br><span class="line">         <span class="comment">/*用户干的事情*/</span></span><br><span class="line">  ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>中断函数的返回值和参数都是void</p></li><li><p>此函数不用声明，中断触发自动调用</p></li><li><p>使用的相关函数在对应的exti标准库中去找(EXTI_GetITStatus等)，有两个获取标志位的函数，带有IT的是只能在中断中使用的，不带IT的是在中断外使用的</p></li></ol></blockquote><h2 id="实验-旋转编码器计数">实验- 旋转编码器计数</h2><p>旋转编码器相关知识见HAL库</p><p>此处旋转编码器<strong>A相对应：PB0</strong>，<strong>B相对应：PB1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Encoder.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ENCODER_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ENCODER_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int16_t</span> EncoderCount;<span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 1.打开对应外设时钟 */</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE );</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE );<span class="comment">//选择AFIO这个外设，开启时钟，通常用于启用或禁用 AFIO 外设的时钟，以便进行相应的配置操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.配置对应GPIO输入模式 */</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入，默认为高电平的输入方式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0|GPIO_Pin_1;<span class="comment">//旋转编码器分两相，PB0 为A相，PB1为B相</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init (GPIOB ,&amp;GPIO_InitStructure);<span class="comment">//初始化GPIOB外设</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.AFIO配置，映射到对应EXTI线上去 */</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource0);</span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource1);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 4.EXTI配置 */</span></span><br><span class="line">EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">EXTI_InitStructure.EXTI_Line=EXTI_Line0|EXTI_Line1;<span class="comment">//将第0条线路和第1条线路都初始化为中断模式，下降沿触发连线</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd=ENABLE;<span class="comment">//开启中断</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt;<span class="comment">//中断模式</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling;<span class="comment">//下降沿触发，离开就+1</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5.NVIC配置,这个地方需要两个中断初始化 */</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//选两位抢占两位响应，整个程序只需要配置一次</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=EXTI0_IRQn;<span class="comment">//外部中断0</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;/</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;<span class="comment">//响应优先级</span></span><br><span class="line">NVIC_Init (&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=EXTI1_IRQn;<span class="comment">//外部中断1</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">2</span>;<span class="comment">//响应优先级2大于1</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"><span class="comment">//PB0和PB1为同一抢占优先级，但PB1的响应优先级比PB0大，所以PB0可以被PB1打断</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//获取中断服务函数中改变的数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int8_t</span> num;</span><br><span class="line">num=EncoderCount;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//这个函数只有0这个引脚可以触发</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(EXTI_GetFlagStatus (EXTI_Line0)==SET)<span class="comment">//外部中断0的线被触发，进入中断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>)<span class="comment">//A下降沿，B低电平，反转</span></span><br><span class="line">&#123;</span><br><span class="line">EncoderCount --;<span class="comment">//计数--</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line0);<span class="comment">//清除中断标志位，跳出中断</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//这个函数只有1这个引脚可以触发</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(EXTI_GetFlagStatus (EXTI_Line1)==SET)<span class="comment">//外部中断1的线被触发，进入中断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)==<span class="number">0</span>)<span class="comment">//B下降沿，A低电平正转，</span></span><br><span class="line">&#123;</span><br><span class="line">EncoderCount ++;<span class="comment">//计数++</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line1);<span class="comment">//清除中断标志位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>正转编码器，counter增加，反转编码器，counter增加</strong></p></blockquote><h2 id="实验-对射式红外传感器计次">实验-对射式红外传感器计次</h2><h2 id="使用中断注意事项">使用中断注意事项</h2><ol><li><strong>中断函数中不要执行耗时过长的代码，不要使用延时函数</strong></li><li><strong>不要再中断函数中和主函数调用相同的函数或操作同一个硬件，操作用一个全局变量时要将该变量声明为volatile,避免编译器优化</strong></li><li><strong>中断建议操作变量或者标志位(状态位)</strong></li></ol><h1>TIM(定时器)</h1><h2 id="介绍-2">介绍</h2><ul><li><p>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断。</p></li><li><p>16位计数器、预分频器、自动重装载寄存器的时基单元，在72HZ计数时钟下可以实现最大59.65s((65535*65535)/72MHz)的定时时间</p></li><li><p>具备基本的定时中断功能，还包含内外时钟源选择、时钟捕获、输出比较、编码器接口，主从触发模式等多种功能</p></li><li><p>分为三种：<strong>高级定时器、通用定时器、基本定时器</strong>，难度依次递减</p></li></ul><p><img src="./image/33.png" alt="image-20241118144626208"></p><h2 id="计数器模式">计数器模式</h2><p><strong>三种：向上计数模式、向下计数模式，中央对齐模式</strong></p><p><strong>基本定时器</strong>：只支持向上计数模式</p><p><strong>通用定时器和高级定时器</strong>：支持向上计数、向下计数、中央对齐计数</p><h2 id="时基单元">时基单元</h2><p>定时器框图中最重要的是时基单元，由三部分构成：<strong>预分频器PSC、自动重装载器ARR、计数器CNT</strong></p><ol><li><p><strong>Prescaler(psc)-预分频值</strong>：内部有一个预分频器PSC，内部时钟先输入到这里完成分频。简单来说就是分频值</p><p>时钟信号被分频后的频率 F= TCLK/(PSC+1)</p></li><li><p><strong>auto-reload preload(arr)-自动重装载值</strong>：内部有一个自动重装载寄存器，简单来说就是设置计数值上限，最大为65535</p></li><li><p><strong>CNT-计数器</strong>：内部有一个计数器自增，会与自动重装在寄存器比较，当计数值等于自动重装载值arr时，将会触发<strong>更新中断或更新事件</strong>，同时清零计数器</p></li></ol><p><code>定时器溢出时间 Tout =  (arr+1)/F   =   (arr+1)*(PSC+1) /TCLK</code></p><h2 id="时钟源">时钟源</h2><p><strong>在手册上我们可以看到，stm32通用定时器的时钟源有4种</strong>：</p><p>1、<strong>内部时钟(CK_INT)</strong></p><p>2、<strong>外部时钟模式1</strong>：外部输入引脚(TIx)</p><p>3、<strong>外部时钟模式2</strong>：外部触发输入(ETR)</p><p>4、<strong>内部触发输入(ITRx)</strong>：使用一个定时器作为另一个定时器的预分频器。如可以配置一个定时器Timer1而作为另一个定时器Timer2的预分频器。用于定时器级联</p><hr><p>基本定时器：只能选择内部时钟，也就是系统主频72MHz(F103)</p><p>通用(高级)定时器：时钟源不仅可以选择<strong>内部时钟输入</strong>，也可以选择<strong>外部时钟输入ETR</strong>(外部引脚输入)</p><p>在下面的<strong>参考手册通用定时器框图</strong>中可以看到通过TIMx_ETR引脚上可以外接一个外部方波时钟，在配置内部极性选择，边沿检测和预分频器，再配置一下输入滤波电路(对外部引脚输入进行滤波)，最后分为两路去<strong>ETRF(外部时钟模式2)<strong>和</strong>TRGI（外部时钟模式1）</strong></p><p><img src="../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/image/image-20241118151537820.png" alt="image-20241118151537820"></p><p><img src="./image/0.png" alt="image-20241118153011362"></p><blockquote><p>总结：看上面手册中的框图</p><p><strong>内部时钟输入</strong>：APB1/APB2，一般为系统主频</p><p><strong>外部时钟输入</strong>：分为外部时钟模式1和外部时钟模式2</p><ol><li><p>ETR引脚(外部引脚输入)：经过一堆(极性选择、边沿检测、滤波等)后</p><ul><li>独立进入触发控制器(ETR独享)，是外部时钟模式2</li><li>通过触发器进入从模式控制器，是外部时钟模式1</li></ul></li><li><p>其他定时器(ITR)：是内部触发输入，来源于其他TIM，可以实现定时器级联，是外部时钟模式1</p></li><li><p>TIMx_CH1引脚的边沿(TI1F_ED)：外部时钟模式1</p></li><li><p>TIMx_CH1引脚(TI1FP1)：外部时钟模式1</p></li><li><p>TIMx_CH2引脚(TI2FP2)：外部时钟模式1</p></li></ol><p>TI1FP1：Timer Input 1 Filter Polarity 1</p></blockquote><blockquote><p><code>一般情况下外部时钟通过ETR引脚就可以，其他这么多输入是为了某些特定场景使用，比如：ITR是为了定时器级联设置的</code></p></blockquote><h2 id="库函数-2">库函数</h2><p><code>相关的库函数直接在stm32f10x_tim.h寻找使用,这里给出常用的</code></p><p><strong>时钟源选择</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_InternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="comment">//1.内部时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity,<span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br><span class="line"><span class="comment">//2.外部输入模式1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity, <span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br><span class="line"><span class="comment">//3.外部输入模式2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_TIxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_TIxExternalCLKSource,<span class="type">uint16_t</span> TIM_ICPolarity, <span class="type">uint16_t</span> ICFilter)</span>;</span><br><span class="line"><span class="comment">//4.外部输入模式1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITRxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_InputTriggerSource)</span>;</span><br><span class="line"><span class="comment">//5.内部触发输入，级联</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity,<span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br></pre></td></tr></table></figure><p><strong>时基单元配置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_TimeBaseInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span>;</span><br></pre></td></tr></table></figure><p><strong>中断输出控制配置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><p><strong>NVIC配置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NVIC_Init</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><strong>运行控制配置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_Cmd</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><hr><p><strong>单独更改预分频值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_PrescalerConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Prescaler, <span class="type">uint16_t</span> TIM_PSCReloadMode)</span>;</span><br></pre></td></tr></table></figure><p><strong>计数器模式配置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CounterModeConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_CounterMode)</span>;</span><br></pre></td></tr></table></figure><p><strong>计数器预装载配置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ARRPreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><p><strong>手动写入计数器值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCounter</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Counter)</span>;</span><br></pre></td></tr></table></figure><p><strong>手动写入ARR值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetAutoreload</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Autoreload)</span>;</span><br></pre></td></tr></table></figure><p><strong>获取计数器或预分频值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCounter</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetPrescaler</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br></pre></td></tr></table></figure><p><strong>中断相关函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">TIM_GetFlagStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_FLAG)</span>;<span class="comment">//中断外使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearFlag</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_FLAG)</span>;</span><br><span class="line">ITStatus <span class="title function_">TIM_GetITStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span>;<span class="comment">//中断内使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearITPendingBit</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span>;</span><br></pre></td></tr></table></figure><h2 id="定时器中断-定时或计数功能">定时器中断(定时或计数功能)</h2><p><a href="https://postimg.cc/kR4B9vCC"><img src="https://i.postimg.cc/ZnP38wDW/image-20241118154510279.png" alt="image-20241118154510279.png"></a></p><h3 id="TIM配置流程">TIM配置流程</h3><p>首先新建Timer.c和Timer.h文件到Hardware中</p><p>我们将上方的定时中断基本结构图打通就完成了配置</p><p>具体流程：</p><ol><li><strong>RCC开启时钟</strong>：查看手册我们可以发现TIM2在APB1总线上，故开启APB1总线时钟</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>选择时基单元的时钟源</strong>：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//上电后单片机默认使用内部时钟，这一行其实可以省略</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>配置时基单元</strong>：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode =TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>; </span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br></pre></td></tr></table></figure><blockquote><p>这里并没有对CNT计数器的初始化，如果我们想更改，调用TIM_SetCounter函数进行更改即可</p><p>TIM_ClockDivision参数：与滤波器相关的分频，这里随便选</p><p>TIM_RepetitionCounter参数：<strong>重复计数器的值，高级定时器才有的，不用给0</strong></p></blockquote><ol start="4"><li><strong>配置中断，即配置输出中断控制，允许更新中断输出到NVIC</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>这里的第二个参数我们选择的是更新中断，其他选择请跳转到对应函数的注释中查看</strong></p></blockquote><ol start="5"><li><strong>配置NVIC，在NVIC中打开定时器中断的通道，并分配一个优先级</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//优先级分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//NVIC配置</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn  ;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>运行控制，我们需要使能定时器的运行，否则不会工作</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br></pre></td></tr></table></figure><p><strong>连起来就是</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*1.RCC使能时钟*/</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*2.时基单元时钟源选择：此处选择内部时钟*/</span></span><br><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//上电后单片机默认使用内部时钟，这一行其实可以省略</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*3.时基单元配置*/</span></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<span class="comment">//与滤波器相关的分频，这里随便选</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//计数器模式</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>; <span class="comment">//周期，也就是ARR的值</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;<span class="comment">//预分频器的值</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//重复计数器的值，高级定时器才有</span></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4.输出中断控制配置，允许更新中断输出到NVIC*/</span></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5.NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn  ;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*6.定时器运行控制，使能一下*/</span></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>中断函数</strong>：同样在启动文件中寻找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update)== SET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*中间为用户代码*/</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>上方函数调用查看更新中断的标志位</strong></p></blockquote><h3 id="实验-使用定时器每秒计数-内部时钟">实验-使用定时器每秒计数(内部时钟)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Timer.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Timer.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> Num;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//上电后单片机默认使用内部时钟，这一行其实可以省略</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<span class="comment">//与滤波器相关的分频，这里随便选</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//计数器模式</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>; <span class="comment">//周期，也就是ARR的值</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;<span class="comment">//预分频器的值</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//重复计数器的值，高级定时器才有</span></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">    </span><br><span class="line">        TIM_ClearFlag(TIM2,TIM_FLAG_Update);<span class="comment">//避免上电立即进入中断    </span></span><br><span class="line">    </span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update)== SET)</span><br><span class="line">&#123;</span><br><span class="line">Num++;</span><br><span class="line"></span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Timer_Init();</span><br><span class="line">OLED_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowSignedNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);</span><br><span class="line">        OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">5</span>,TIM_GetCounter(TIM2),<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里有个问题，上电后我们可以发现计数器的值直接为1，这代表在上电时就已经进入了一次中断处理程序了。</p><p>这是由于TIM_TimeBaseInit()函数中最后一排有个TIMx-&gt;EGR = TIM_PSCReloadMode_Immediate;</p><p>查看注释可以知道其手动生成了一个更新事件(为了让预分频器缓冲寄存器起作用，更新才会起作用)，导致上电立即进入中断。</p><p>解决方案：</p><p>在TIM_TimeBaseInit()后，开启中断前使用手动清除标志位。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"><span class="comment">/*添加到这里即可*/</span></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);</span><br><span class="line"></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br></pre></td></tr></table></figure><h3 id="实验-对射式红外传感器-外部时钟模式2">实验-对射式红外传感器(外部时钟模式2)</h3><p><strong>参考手册查看到芯片的TIM2_CH1_ETR复用输入引脚为PA0，可以通过PA0引脚将传感器0模块的DO引脚输出波形引入到定时器TIM2中</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Timer.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> Num;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有外部引脚输出，故先配置外部引脚</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    <span class="comment">/*这里的GPIO输入模式在参考手册可以查到，使用TIM2外部输入，推荐为浮空输入*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*这里选择的外部时钟模式2，对应参数选择跳转到对应函数查看注释*/</span></span><br><span class="line">TIM_ETRClockMode2Config(TIM2,TIM_ExtTRGPSC_OFF,TIM_ExtTRGPolarity_NonInverted,<span class="number">0x0F</span>);</span><br><span class="line">    <span class="comment">//选择的是上升沿触发，最后一个参数是外部触发滤波器，取值对应可以在参考手册中从模式控制寄存器(TIMx_SMCR)中看到，取值为0x00~0x0f,如果我们不滤波(0x00)的话就会有很多抖动脉冲，计数很多次。这里一般选择0x0F(15)即可</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10</span><span class="number">-1</span>; </span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span><span class="number">-1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);</span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);</span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update)== SET)</span><br><span class="line">&#123;</span><br><span class="line">Num++;</span><br><span class="line"></span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Timer_Init();</span><br><span class="line">Key_Init();</span><br><span class="line">LED_Init();</span><br><span class="line">OLED_Init();</span><br><span class="line"><span class="comment">//OLED_ShowChar(10,10,&#x27;a&#x27;);</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowSignedNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">5</span>,TIM_GetCounter(TIM2),<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当我们把手放遮挡在拿开，计数器+1，计数9次后，Num+1</p></blockquote><h3 id="实验-循迹模块测量商品数量-外部时钟模式2">实验-循迹模块测量商品数量(外部时钟模式2)</h3><p><a href="https://www.bilibili.com/video/BV1N94y1u7Uz?spm_id_from=333.788.videopod.sections&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32】动画讲解定时器外部时钟 &amp; 实战传送带测速装置_哔哩哔哩_bilibili</a></p><p><strong>参考手册查看到芯片的TIM2_CH1_ETR复用输入引脚为PA0，可以通过PA0引脚将传感器0模块的DO引脚输出波形引入到定时器TIM2中。</strong></p><p>代码与上方完全相同</p><p>同样也可以使用外部时钟模式1的ETR从模式、TI1F_ED、TI1FP1、TI1FP2都可以实现</p><blockquote><p>最终我们将任意物品从循迹模块下方穿过，一个物品计数+1</p></blockquote><h2 id="输出比较功能-OC">输出比较功能(OC)</h2><h3 id="OC简介">OC简介</h3><p>OC(Output Compare)--------输出比较</p><p>输出比较可以通过比较<strong>CNT计数器</strong>与<strong>CCR</strong>(Capture/Compare Register)值的关系进行置1、置0或者翻转的操作，用于输出一定频率和占空比的PWM波形</p><blockquote><p><strong>CCR全称：Capture/Compare Register  –   捕获/比较寄存器</strong></p><p><strong>使用输入捕获时：就是捕获寄存器</strong></p><p><strong>使用输出比较时：就是比较寄存器</strong></p></blockquote><ul><li>每个高级定时器和通用定时器都拥有4个输出比较通道</li><li>高级定时器的前三个通道额外拥有死区生成和互补输出的功能</li></ul><h3 id="PWM输出简介">PWM输出简介</h3><p><strong>脉冲宽度调制-PWM</strong>，是英文“Pulse Width Modulation”的缩写，简称<strong>脉宽调制</strong>，其实是在利用微控制器的<strong>定时器模块</strong>来生成一种特定频率和占空比的<strong>脉冲信号(一段高低电平)</strong>，调整脉冲的宽度从而影响功率等。PWM信号是一种周期性的脉冲信号，通过调整脉冲的宽度（高电平时间）可以模拟模拟信号，控制电机速度、LED亮度、蜂鸣器响度等。必须具有惯性的系统才能使用PWM。</p><p><strong>PWM参数</strong>：</p><ol><li><p><strong>频率</strong> = 1 / Ts</p></li><li><p><strong>占空比</strong> =  Ton / Ts (图中的高电平占整个周期的时间)</p></li><li><p><strong>分辨率</strong> = 占空比变化步距(占空比以多少百分比跳变，1%到%2到%3，分辨率就是1%)</p></li></ol><p><img src="./image/1.png" alt="image-20241119175400365"></p><blockquote><p>PWM频率越快，等效模拟的信号也就越平稳，对应的性能开销也就越大</p><p><strong>一般来说PWM的频率都在几K到几十K，这个频率就足够快了</strong></p></blockquote><hr><p><strong>原理图：CCR=30时</strong></p><p><img src="./image/2.png" alt="image-20241120214655665"></p><blockquote><p>参数计算：</p><p>PWM频率：Freq = CK_PSC/(PSC+1)*(ARR+1)</p><p>PWM占空比：Duty = CCR/(ARR+1)</p><p>PWM分辨率：Reso = 1 / (ARR+1)   <strong>占空比越细腻越好</strong></p></blockquote><h3 id="舵机简介">舵机简介</h3><p>舵机是一种根据输入<strong>PWM信号占空比来控制输出角度的装置</strong></p><p>常见的舵机型号有：SG90，SG92</p><p>输入PWM信号要求：<strong>周期为20ms</strong>，<strong>高电平时长为0.5ms~2.5ms(0~180°)，可以查看对应舵机手册得到驱动角度对应PWM的周期</strong></p><p>三根线：一根VCC，一根GND，一根信号线</p><p><img src="./image/3.png" alt="image-20241120215627230"></p><blockquote><p>给一个PWM，舵机就会固定在某一个角度，机械臂等机械机构就可以使用</p><p><strong>这里的PWM输出当成通信协议很常见，PWM波形通过信号线输出</strong></p></blockquote><h3 id="直流电机及驱动简介">直流电机及驱动简介</h3><p>直流电机是一种将电能转换为机械能的装置，有两个电极，当电极正接时，电机正转，当电极反接时，电机反转。(对应一个引脚高电平一个引脚低电平)</p><p><strong>直流电机属于大功率器件，GPIO口无法直接驱动，需要配合<code>电机驱动芯片</code>来操作</strong></p><p>TB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并控制其转速和方向，还有<strong>DRV8833驱动芯片</strong>等</p><p><img src="./image/4.png" alt="image-20241120221616621"></p><blockquote><p>在对应模块使用手册可以查看使用方法以及原理图，各引脚含义</p></blockquote><h3 id="库函数-3">库函数</h3><p>主要初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="comment">/*对应的是四个输出比较通道的输出比较单元结构体的初始化*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OCStructInit</span><span class="params">(TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="comment">/*用于为一个结构体赋初值*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="comment">/*极性配置</span></span><br><span class="line"><span class="comment"> * 对每个通道极性的单独配置 </span></span><br><span class="line"><span class="comment"> * 带N是高级定时器中互补通道的配置，OC4没有互补通道</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCxCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_CCx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCxNCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_CCxN)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单独修改输出使能参数*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectOCxM</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_OCMode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单独修改输出比较模式的函数*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare1</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare2</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare3</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare3)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare4</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare4)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单独修改CCR寄存器的函数</span></span><br><span class="line"><span class="comment"> * 可用于调整占空比</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CtrlPWMOutputs</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>该函数仅高级定时器使用，在使用高级定时器输出PWM时，需要调用这个函数，使能主输出，否则PWM将不能正常输出</p></blockquote><hr><p><strong>一些小功能配置：使用不多</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC3Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC4Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="comment">/*配置强制输出模式：在运行中想要暂停输出波形并且强制输出高或低电平使用</span></span><br><span class="line"><span class="comment"> * 一般不怎么使用，修改占空比为0或100也能实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCPreloadControl</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="comment">/*用于配置CCR寄存器的预装功能，也就是影子寄存器</span></span><br><span class="line"><span class="comment"> * 也就是：写入的值不会立即生效，而是在更新时间才会生效</span></span><br><span class="line"><span class="comment"> * 一般不使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于配置快速使能</span></span><br><span class="line"><span class="comment"> * 功能手册中，单脉冲模式有介绍</span></span><br><span class="line"><span class="comment"> * 一般不使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC1Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC2Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC3Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC4Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外部事件时清楚REF信号</span></span><br><span class="line"><span class="comment"> * 不怎么使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="输出比较配置流程">输出比较配置流程</h3><ol><li><p><strong>RCC开启时钟</strong></p></li><li><p><strong>配置GPIO：把PWM对应的GPIO口初始化为复用推挽输出模式(TIM复用)</strong></p></li><li><p><strong>选择时基单元时钟源</strong></p></li><li><p><strong>配置时基单元</strong></p></li><li><p><strong>配置输出比较单元：输出比较模式、极性选择、输出状态使能、CCR的值等</strong></p></li><li><p><strong>运行控制：启动对应TIM</strong></p></li></ol><h3 id="实验-PWM呼吸灯">实验-PWM呼吸灯</h3><h4 id="配置流程">配置流程</h4><ol><li><p><strong>RCC开启时钟，开启对应GPIO和TIM时钟</strong></p></li><li><p><strong>配置GPIO：把PWM对应的GPIO口初始化为复用推挽输出模式(TIM复用)</strong></p></li><li><p><strong>选择时基单元时钟源</strong></p></li><li><p><strong>配置时基单元</strong></p></li><li><p><strong>配置输出比较单元：输出比较模式、极性选择、输出状态使能、CCR的值等</strong></p></li><li><p><strong>运行控制：启动对应TIM</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*PWM.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PWM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PWM_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*PWM.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//1.RCC开启时钟</span></span><br><span class="line"> RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"> <span class="comment">//2.配置GPIO</span></span><br><span class="line"> GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽模式</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//3.配置时基单元时钟源</span></span><br><span class="line"> TIM_InternalClockConfig(TIM3);</span><br><span class="line"> <span class="comment">//4.配置时基单元</span></span><br><span class="line"> TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up ;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span><span class="number">-1</span>;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">720</span><span class="number">-1</span>;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line"> TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure); </span><br><span class="line"> <span class="comment">//5.配置输出比较单元</span></span><br><span class="line"> TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line"> TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1 ;  <span class="comment">/*PWM1模式*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High ; <span class="comment">/*极性为高：有效电平为高电平*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;  <span class="comment">/*输出状态使能*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">//配置CCR</span></span><br><span class="line"><span class="comment">/*这里时通用定时器，只需要列举需要的参数即可，高级定时器的参数可以不用管*/</span></span><br><span class="line"> TIM_OC2Init(TIM3,&amp;TIM_OCInitStructure);</span><br><span class="line"> <span class="comment">//6.运行控制，TIM使能</span></span><br><span class="line"> TIM_Cmd(TIM3,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> pwmVal = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">PWM_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(;pwmVal&lt;<span class="number">100</span>;pwmVal++)</span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare2(TIM3,pwmVal);</span><br><span class="line">Delay_ms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;pwmVal&gt;<span class="number">0</span>;pwmVal--)</span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare2(TIM3,pwmVal);</span><br><span class="line">Delay_ms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验-PWM驱动舵机">实验-PWM驱动舵机</h3><blockquote><p>驱动舵机工作的频率为50HZ，也就是周期为20ms。</p><p>这里对应PSC设置为72-1，ARR设置为20000-1</p><p>舵机旋转角度对应的周期为500us~2500us(0.5ms~2.5ms)的高电平时长，对应占空比为：0.5ms/20ms = 2.5%  到    2.5ms/20 =12.5%</p><p>即设置ARR的范围应该是500~2500(对应0~180°)</p></blockquote><p><code>配置流程与上一个实验一样</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Servo.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SERVO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SERVO_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_SetAngle</span><span class="params">(<span class="type">float</span> Angle)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Servo.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line"> GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽模式</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;</span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line"> <span class="comment">/*PB8为舵机的信号线*/</span></span><br><span class="line"></span><br><span class="line"> TIM_InternalClockConfig(TIM4);</span><br><span class="line"></span><br><span class="line"> TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up ;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_Period = <span class="number">20000</span><span class="number">-1</span>;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line"> TIM_TimeBaseInit(TIM4,&amp;TIM_TimeBaseInitStructure); </span><br><span class="line"></span><br><span class="line"> TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line"> TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1 ;  <span class="comment">/*PWM1模式*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High ; <span class="comment">/*有效电平为高电平*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;  <span class="comment">/*输出状态使能*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_Pulse = <span class="number">500</span>; <span class="comment">//配置CCR</span></span><br><span class="line"><span class="comment">/*这里时通用定时器，只需要列举需要的参数即可，高级定时器的参数可以不用管*/</span></span><br><span class="line"> TIM_OC3Init(TIM4,&amp;TIM_OCInitStructure);</span><br><span class="line"> </span><br><span class="line"> TIM_Cmd(TIM4,ENABLE);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置舵机角度*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_SetAngle</span><span class="params">(<span class="type">float</span> Angle)</span></span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare3(TIM4,(Angle/<span class="number">180</span>)*(<span class="number">2000</span>)+<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Servo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Key_Init();</span><br><span class="line"></span><br><span class="line">Servo_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"> Num = Key_GetNum();</span><br><span class="line">       <span class="keyword">if</span>(Num == <span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">                <span class="type">static</span> <span class="type">float</span> angle=<span class="number">0</span>;</span><br><span class="line">                  angle+=<span class="number">30</span>;</span><br><span class="line">                  <span class="keyword">if</span>(angle &gt; <span class="number">180</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        angle = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">              Servo_SetAngle(angle);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>按键按下，舵机旋转30度</strong></p></blockquote><h3 id="实验-PWM驱动DRV8833电机">实验-PWM驱动DRV8833电机</h3><p>DRV8833相关知识见HAL库笔记</p><blockquote><p>DRV8833对应两个输入引脚，一个PWM输入，一个给高/低电平可以实现正反转，对应查表见HAL库对应章节。</p><p><strong>对应PWM占空比越高，电机转速越快</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DRV8833.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DRV8833_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DRV8833_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_SetSpeed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>这里两个输入引脚为：PA0，PA1。PA0为PWM引脚，PA1为低电平引脚</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DRV8833.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//1.</span></span><br><span class="line"> RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">      </span><br><span class="line">     <span class="comment">//2.</span></span><br><span class="line"> GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"> <span class="comment">/*配置PA1引脚为输出模式*/</span></span><br><span class="line">  </span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽模式</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOA,&amp;GPIO_InitStructure); </span><br><span class="line"> <span class="comment">/*配置PWM引脚PA0，为复用推挽输出模式*/</span> </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//3.</span></span><br><span class="line"> TIM_InternalClockConfig(TIM2);</span><br><span class="line"> <span class="comment">//4.</span></span><br><span class="line"> TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up ;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span><span class="number">-1</span>;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line"> TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure); </span><br><span class="line"> </span><br><span class="line">     <span class="comment">//5.</span></span><br><span class="line"> TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line"> TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1 ;  <span class="comment">/*PWM1模式*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High ; <span class="comment">/*有效电平为高电平*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;  <span class="comment">/*输出状态使能*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">//修改CCR的值可以改变转速</span></span><br><span class="line"><span class="comment">/*这里时通用定时器，只需要列举需要的参数即可，高级定时器的参数可以不用管*/</span></span><br><span class="line"> TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//6.</span></span><br><span class="line"> TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">   </span><br><span class="line"> GPIO_ResetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line"> <span class="comment">/*设置PA1为低电平*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_SetSpeed</span><span class="params">(<span class="type">uint8_t</span> speed)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(speed&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TIM_SetCompare1(TIM2,speed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DRV8833.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">DRV8833_Init();</span><br><span class="line">    DRV8833_SetSpeed(<span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>转速最大值可以设置100，为ARR最大值</strong></p></blockquote><h2 id="输入捕获功能-IC">输入捕获功能(IC)</h2><h3 id="IC简介">IC简介</h3><p><strong>IC(Input Capture)--------输入捕获</strong></p><p>输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR(捕获寄存器)中，<strong>可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数。</strong></p><blockquote><p><strong>CCR全称：Capture/Compare Register  –   捕获/比较寄存器</strong></p><p><strong>使用输入捕获时：就是捕获寄存器</strong></p><p><strong>使用输出比较时：就是比较寄存器</strong></p></blockquote><p>每个高级定时器和通用定时器都拥有4个输入捕获通道：</p><ul><li><p>可配置为<code>PWMI模式</code>，同时测量频率和占空比</p></li><li><p>可配合主从触发模式，实现硬件全自动测量</p></li></ul><h3 id="频率测量">频率测量</h3><p><img src="./image/5.png" alt="image-20241125154510808"></p><blockquote><p><strong>测频法(测频率)</strong>：适合测量<code>高频</code>信号，<strong>计次数量多一些，有助于减小误差</strong></p><p><strong>特点</strong>：测量结果更新速度较慢，但是平均值，相当于均值滤波，结果比较稳定</p><p>fx = N / T</p><hr><p><strong>测周法(测周期)</strong>：适合测量<code>低频</code>信号，<strong>周期比较长，计次比较多，有助于减小误差</strong></p><p><strong>特点：只测量一个周期</strong>，测量结果更新速度较快，但结果值会受噪声的影响，波动比较大</p><p>fx = fc / N     fc为标准频率：标准频率就是经过PSC分频后的时钟频率</p><p><strong>在这里fc可以是使用输入捕获时定时器的频率，使用时需要每次触发后将CNT的值清0才是一个周期</strong></p><hr><p><strong>中界频率</strong>fm：</p><p>待测<code>信号频率&lt;中界频率</code>时，选用<code>测频法</code>误差更小</p><p>待测<code>信号频率&gt;中界频率</code>时，选用<code>测周法</code>误差更小</p><p>fm = 根号下(fc / T)</p></blockquote><h3 id="输入捕获通道">输入捕获通道</h3><p><img src="./image/6.png" alt="image-20241125161551723"></p><blockquote><p>同一个引脚TIx的输入信号映射到两个输入通道IC1和IC2，且两个通道的<code>极性检测相反</code>即这里的</p><p><strong>TI1引脚的输入信号可以映射到TI1FP1和TI1FP2</strong></p><p>TI1FP1连接到的是输入通道1，TI1FP2连接到的是输入通道2，可以使用两个捕获寄存器CCR</p><p><strong>T2引脚的输入信号可以映射到TI2FP1和TI2FP2</strong></p><p>TI2FP1连接到的是输入通道1，TI2FP2连接到的是输入通道2，也可以使用两个捕获寄存器CCR</p><p>一共四种连接方式</p></blockquote><blockquote><p><code>输入捕获的直接模式和间接模式</code>：信号从TI1引入，在自己的捕获寄存器1上进行输入捕获，就叫做<strong>输入捕获的直接模式</strong>。信号从TI1引入借用捕获寄存器2进行输入捕获，则叫做<strong>输入捕获的间接模式(交叉模式)</strong>。</p></blockquote><h3 id="主从触发模式">主从触发模式</h3><p>主从触发模式是：<code>主模式</code>、<code>从模式</code>、<code>触发源</code>选择这三个功能的简称</p><p><img src="./image/7.png" alt="image-20241125162539989"></p><blockquote><p><code>主模式</code>：可以将定时器内部信号映射到TRGO 引脚，用于触发别的外设</p><p><code>从模式</code>：接收其他外设或者自身外设的一些信号，用于控制自身定时器的运行，也就是被别的信号控制</p><p><code>触发源选择</code>：就是选择从模式的触发信号源的，可以认为是从模式的一部分。选择指定的一个信号，得到TRGI，TRGI去触发从模式，在从模式列表中选择一项操作自动执行</p><p><strong>如：选择TI1FP1触发源，选择Reset操作就可以自动触发从模式，从模式自动清零CNT</strong></p></blockquote><blockquote><p><code>主模式选择</code>可以在对应手册<strong>TIMx_CRx控制寄存器</strong>中查看</p><p><code>从模式选择</code>可以在对应手册<strong>TIMx_SMCR从模式控制寄存器</strong>中查看</p></blockquote><h3 id="输入捕获和PWMI基本结构图">输入捕获和PWMI基本结构图</h3><p><img src="./image/8.png" alt="image-20241125163454859"></p><blockquote><p><strong>特点</strong>：只使用了一个通道，<code>只能测量频率</code>，使用的是测周法测量频率，所以需要每次触发后将CNT的值清0，使用从模式实现信号触发后自动清0</p><p><strong>F = fc / N</strong></p><p><strong>fc为标准频率：标准频率就是经过PSC分频后的时钟频率</strong></p><p><strong>因为CNT要自增，所以ARR的值要设置的足够大，设置为上限65535</strong></p></blockquote><p><img src="./image/9.png" alt="image-20241125164342932"></p><blockquote><p><code>PWMI模式（PWM输入模式）</code>：<strong>使用两个通道来捕获，可以测量<code>频率</code>和<code>占空比</code>，使用的是测周法测量频率，所以需要每次触发后将CNT的值清0，使用从模式实现信号触发后自动清0</strong></p><p><strong>下面部分</strong>：</p><p>TI1FP1和TI1FP2以相反的极性检测(TI1FP1检测上升沿，TI1FP2检测下降沿)</p><p>CCR1：一整个周期的计数值，每一次上升沿到来时对应CNT都会清零</p><p>CCR2：高电平期间的计数值</p><p>占空比：duty = CCR2 / CCR1</p><p><strong>因为CNT要自增，所以ARR的值要设置的足够大，设置为上限65535</strong></p><hr><p><strong>上面部分</strong>：选择TI1FP1触发源，使用从模式配合输入捕获，实现CNT自动清零(Reset)，完成硬件自动化</p></blockquote><p><code>相关介绍对应在参考手册的输入捕获和PWM输入模式对应部分</code></p><h3 id="库函数-4">库函数</h3><p><code>初始化函数：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ICInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;</span><br><span class="line"><span class="comment">/*配置输入捕获单元函数，输出比较是四个通道分别有一个函数，而输入捕获配置是4个通道共用一个函数，具体通道选择在结构体中*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_PWMIConfig</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;</span><br><span class="line"><span class="comment">/* 也是配置输入捕获单元的函数，但是这个函数可以快速配置两个通道，将外设电路配置为PWMI模式</span></span><br><span class="line"><span class="comment"> * 传入一个结构体之后，该函数会根据传入结构体通道配置自动初始化另外一个通道为相反的配置</span></span><br><span class="line"><span class="comment"> * 比如：传入结构体配置为通道1，上升沿触发，直接模式，调用该函数就会配置通道2为下降沿触发，且为交叉模式(间接模式)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 该函数只支持通道1和通道2，不能传入通道3和通道4!!!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ICStructInit</span><span class="params">(TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;</span><br><span class="line"><span class="comment">/*输入捕获结构体初始化，一般在某些参数不用初始化的时后调用，防止没有初始化某些值造成意外错误*/</span></span><br></pre></td></tr></table></figure><p><code>主从模式相关函数</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectOutputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_TRGOSource)</span>;</span><br><span class="line"><span class="comment">/*选择输出触发源TRGO，对应主模式输出的触发源*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectInputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_InputTriggerSource)</span>;</span><br><span class="line"><span class="comment">/*选择输入触发源TRGI，对应从模式的触发源选择*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectSlaveMode</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_SlaveMode)</span>;</span><br><span class="line"><span class="comment">/*选择从模式，对应从模式执行操作*/</span></span><br></pre></td></tr></table></figure><p><code>预分频配置</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC1Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC2Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC3Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC4Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="comment">/*分别配置通道1~4的预分频值，这个参数可以在结构体中配置*/</span></span><br></pre></td></tr></table></figure><p><code>获取捕获寄存器值</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture1</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture2</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture3</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture4</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="comment">/*分别获取四个通道的捕获寄存器CCR的值*/</span></span><br></pre></td></tr></table></figure><h3 id="输入捕获配置流程">输入捕获配置流程</h3><p><code>根据上面的结构图可以得到输入捕获配置流程:</code></p><ol><li><p><strong>RCC开启时钟，将GPIO和TIM的时钟打开</strong></p></li><li><p><strong>GPIO初始化，配置GPIO为输入模式(上拉或者浮空)</strong></p></li><li><p><strong>配置时基单元的时钟源</strong></p></li><li><p><strong>配置时基单元，让CNT计数器在内部时钟的驱动下自增运行</strong></p></li><li><p><strong>配置输入捕获单元，包括滤波器、极性、直连通道还是交叉通道、分频器等参数</strong></p></li><li><p><strong>配置从模式触发源，触发源选择TI1FP1等</strong> (调用库函数)</p></li><li><p><strong>配置从模式执行的操作</strong>（调用库函数）</p></li><li><p><strong>运行控制，开启定时器TIM</strong></p></li></ol><h3 id="实验-输入捕获模式测频率-输入捕获直接模式">实验-输入捕获模式测频率(输入捕获直接模式)</h3><blockquote><p>这个地方没有信号发生器，选择将另外一个引脚TIM输出信号输入到该TIM引脚。从PB8输入到PA0</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __IC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IC_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.开启对应GPIO和TIM时钟</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"> <span class="comment">//2.配置GPIO为</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_0;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">      GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"><span class="comment">//3.时基单元时钟源配置</span></span><br><span class="line">  TIM_InternalClockConfig(TIM2);</span><br><span class="line"><span class="comment">//4.时基单元配置</span></span><br><span class="line">      TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>;<span class="comment">//ARR</span></span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;<span class="comment">//PSC,标准频率fc = 72M/72 = 1MHz</span></span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span> ;</span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//5.输入捕获单元配置</span></span><br><span class="line">  TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">  TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; <span class="comment">//CH1</span></span><br><span class="line">  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; <span class="comment">//滤波值，越大滤波效果越好</span></span><br><span class="line">  TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//上升沿捕获</span></span><br><span class="line">  TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; <span class="comment">//对应触发信号分频器，不分频DIV1就是每次触发都有效，2分频就是每隔一次生效一次</span></span><br><span class="line">      TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;<span class="comment">//输入捕获直接模式</span></span><br><span class="line">  TIM_ICInit(TIM2,&amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.从模式触发源配置</span></span><br><span class="line">TIM_SelectInputTrigger(TIM2,TIM_TS_TI1FP1);<span class="comment">//配置从模式输入触发源</span></span><br><span class="line">    <span class="comment">//7.从模式执行操作</span></span><br><span class="line">TIM_SelectSlaveMode(TIM2,TIM_SlaveMode_Reset);<span class="comment">//配置从模式操作</span></span><br><span class="line"><span class="comment">//8.运行控制，启动TIM</span></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1000000</span>/TIM_GetCapture1(TIM2)<span class="number">-1</span>; <span class="comment">//这里的-1是为了弥补+-1的误差</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个地方标准频率fc = 72MHz / 72 = 1MHz = 1000000</p><p>fc即为经过PSC分频过后的频率</p><p>测量最低频率为：1MHz / 65535 = 15Hz，再低会溢出。</p><p><strong>如果想要降低最低频率，只需要增大PSC的值</strong></p><p><strong>如果想要增大最低频率，只需要减小PSC的值</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">  PWM_Init();<span class="comment">//输出PWM信号</span></span><br><span class="line">  PWM_SetPrescaler(<span class="number">720</span><span class="number">-1</span>);</span><br><span class="line">  PWM_SetCompare3(<span class="number">25</span>);<span class="comment">//CCR = 25</span></span><br><span class="line">   </span><br><span class="line">  IC_Init();<span class="comment">//输入捕获</span></span><br><span class="line"></span><br><span class="line">  OLED_Init();</span><br><span class="line">  OLED_ShowString(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&quot;Freq:00000HZ&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">5</span>,<span class="number">6</span>,IC_GetFreq(),<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验-PWMI模式测频率和占空比-输入捕获交叉-间接模式">实验-PWMI模式测频率和占空比(输入捕获交叉/间接模式)</h3><blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __IC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IC_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.开启对应GPIO和TIM时钟</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"> <span class="comment">//2.配置GPIO为</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_0;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">      GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"><span class="comment">//3.时基单元时钟源配置</span></span><br><span class="line">  TIM_InternalClockConfig(TIM2);</span><br><span class="line"><span class="comment">//4.时基单元配置</span></span><br><span class="line">      TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>;<span class="comment">//ARR</span></span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;<span class="comment">//PSC,标准频率fc = 72M/72 = 1MHz</span></span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span> ;</span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//5.输入捕获单元配置</span></span><br><span class="line">  TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; <span class="comment">//CH1</span></span><br><span class="line">  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; <span class="comment">//滤波值，越大滤波效果越好</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//上升沿捕获</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; <span class="comment">//对应触发信号分频器，不分频DIV1就是每次触发都有效，2分频就是每隔一次生效一次</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;<span class="comment">//输入捕获直接模式</span></span><br><span class="line">    TIM_PWMIConfig(TIM2,&amp;TIM_ICInitStructure);</span><br><span class="line">        <span class="comment">/*输入捕获模式和PWMI模式差别就在这里*/</span></span><br><span class="line"><span class="comment">//  TIM_ICInit(TIM2,&amp;TIM_ICInitStructure);</span></span><br><span class="line"><span class="comment">//  TIM_ICInitStructure.TIM_Channel = TIM_Channel_2; //CH2</span></span><br><span class="line"><span class="comment">//  TIM_ICInitStructure.TIM_ICFilter = 0xF; </span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling ;//下降沿捕获，与通道一相反</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; </span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_IndirectTI;//输入捕获交叉模式</span></span><br><span class="line"><span class="comment">//TIM_ICInit(TIM2,&amp;TIM_ICInitStructure);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.从模式触发源配置</span></span><br><span class="line">TIM_SelectInputTrigger(TIM2,TIM_TS_TI1FP1);<span class="comment">//配置从模式输入触发源</span></span><br><span class="line">    <span class="comment">//7.从模式执行操作</span></span><br><span class="line">TIM_SelectSlaveMode(TIM2,TIM_SlaveMode_Reset);<span class="comment">//配置从模式操作</span></span><br><span class="line"><span class="comment">//8.运行控制，启动TIM</span></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取频率*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1000000</span>/TIM_GetCapture1(TIM2)<span class="number">-1</span>; <span class="comment">//这里的-1是为了弥补+-1的误差</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取占空比*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetDuty</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TIM_GetCapture2(TIM2)*<span class="number">100</span>/TIM_GetCapture1(TIM2)+<span class="number">1</span>;<span class="comment">//弥补误差</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><strong>使用TIM_PWMIConfig(TIM2,&amp;TIM_ICInitStructure)函数可以快速配置两个通道，见源码可知，该函数自动初始化该通道和初始化另外一个通道为相反的配置。</strong></p></li><li><p><strong>不使用该函数，就配置两次即可，即上方注释部分，通道1配置为上升沿捕获，直接模式，通道2就配置为下降沿捕获，交叉模式，调用两次初始化函数即可。</strong></p></li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">  PWM_Init();<span class="comment">//输出PWM信号</span></span><br><span class="line">  PWM_SetPrescaler(<span class="number">720</span><span class="number">-1</span>);</span><br><span class="line">  PWM_SetCompare3(<span class="number">25</span>);<span class="comment">//CCR = 25</span></span><br><span class="line">   </span><br><span class="line">  IC_Init();<span class="comment">//输入捕获</span></span><br><span class="line"></span><br><span class="line">  OLED_Init();</span><br><span class="line">  OLED_ShowString(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&quot;Freq:00000HZ&quot;</span>);</span><br><span class="line">  OLED_ShowString(<span class="number">10</span>,<span class="number">1</span>,<span class="string">&quot;Duty:00%&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">5</span>,<span class="number">6</span>,IC_GetFreq(),<span class="number">5</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">10</span>,<span class="number">6</span>,IC_GetDuty(),<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编码器接口">编码器接口</h2><h3 id="编码器接口简介">编码器接口简介</h3><p>Encoder Interface - 编码器接口</p><p>编码器接口可接收增量(正交编码器)的信号，根据编码器旋转产生的正交信号脉冲，自动控制<code>CNT</code>自增或自减，从而指示编码器的位置、<strong>旋转方向和旋转速度</strong></p><ul><li><p>每个高级定时器和通用定时器都拥有1个编码器接口，基本定时器没有编码器接口</p></li><li><p>两个输入引脚(CH1、CH2)借用了输入捕获通道的<code>通道1</code>和<code>通道2</code></p></li></ul><blockquote><p>之前我们使用了编码器中断来手动计次，使用编码器接口可以实现自动计次，减少资源浪费，避免频繁中断</p></blockquote><h3 id="正交编码器介绍">正交编码器介绍</h3><p>拥有A相和B相，输出的两个<code>正交方波信号</code>，相位相差90°，超前90°和滞后90°代表正传和反转。</p><p>编码器测速使用的是<code>测频法</code>测量</p><p><img src="./image/10.png" alt="image-20241126213304783"></p><blockquote><p><code>编码器的上升沿和下降沿都有效</code></p><p>正传CNT自增</p><p>反转CNT自减</p></blockquote><p><img src="./image/12.png" alt="image-20241126222220541"></p><blockquote><p><strong>三种工作方式</strong>：</p><p>1.仅在T1计数</p><p>2.仅在T2计数</p><p>3.在T1和T2都计数</p><p><code>一般我们使用第三种</code></p><p><strong>编码器接口执行逻辑总结下来就一句话</strong>：</p><p>正转的时候向上计数，反转的时候向下计数</p></blockquote><hr><p><img src="./image/13.png" alt="image-20241126222801623"></p><blockquote><p><code>正交编码器是抗噪声的原理</code>：</p><p>当遇到毛刺现象时，CNT的值会来回跳动，一会自增一会自减，但最终的值保持不变。</p></blockquote><p><img src="./image/14.png" alt="image-20241126223216790"></p><blockquote><p>当TI极性选择反相时，需要将图中TI的波形反向后才能得到正确的计数方向。</p><p>当我实际使用过程中如果出现想要正传计数+1，但是却出现-1的情况，我们把任意一个引脚极性反相，就能反转计数方向了。或者直接交换A、B相引脚即可</p></blockquote><h3 id="应用">应用</h3><p>比较常见的应用场景：</p><p>编码器测速一般应用在电机控制的项目上，使用PWM驱动电机，再使用编码器测量电机的速度，然后再用PID算法进行闭环控制。</p><p>一般电机旋转速度较高，会使用无接触式的霍尔传感器或者光栅进行测速。</p><p>这里为了方便，我们使用触点式的旋转编码器。电机旋转呢，我们就用人工旋转来模拟，但实际上旋转编码器和电机的霍尔，光栅编码器都是一样的效果</p><h3 id="编码器接口基本结构图">编码器接口基本结构图</h3><p><img src="./image/11.png" alt="image-20241126221118178"></p><blockquote><p>对应CH1的TI1FP1和CH2的TI2FP2，与CH3和CH4无关。</p><p>ARR是有效的，一般设置为65535，利用补码的特性可以CNT从0自减时得到的是65535、65534…</p><p><code>编码器的时钟会直接托管驱动计数器，所以在编码器接口模式下时基单元不需要配置内部时钟并且计数模式无效</code></p><hr><p><code>同时输入捕获单元并没有完全使用，只需要配置滤波器和极性选择即可</code></p></blockquote><p><code>更多内容可以在参考手册中的TIM编码器接口模式中查看</code></p><h3 id="库函数-5">库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_EncoderInterfaceConfig</span></span><br><span class="line"><span class="params">(TIM_TypeDef* TIMx,</span></span><br><span class="line"><span class="params"> <span class="type">uint16_t</span> TIM_EncoderMode,</span></span><br><span class="line"><span class="params"> <span class="type">uint16_t</span> TIM_IC1Polarity, </span></span><br><span class="line"><span class="params"> <span class="type">uint16_t</span> TIM_IC2Polarity)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**配置编码器接口的函数</span></span><br><span class="line"><span class="comment"> * 参数1：哪个定时器</span></span><br><span class="line"><span class="comment"> * 参数2：编码器模式,三种：1.仅在T1计数 2.仅在TI2计数 3.T1和T2都计数</span></span><br><span class="line"><span class="comment"> * 一般我们使用第三种T1,T2都计数</span></span><br><span class="line"><span class="comment"> * 参数3：通道1极性,Rising为不反相，Falling为反相</span></span><br><span class="line"><span class="comment"> * 参数4：通道2极性,Rising为不反相，Falling为反相</span></span><br><span class="line"><span class="comment"> * 参数3和参数4根据实际情况选择</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="编码器接口配置流程">编码器接口配置流程</h3><ol><li><p><strong>RCC开启时钟，开启GPIO和对应TIM的时钟</strong></p></li><li><p><strong>配置GPIO，将对应引脚配置为输入模式</strong></p></li><li><p><strong>配置时基单元，预分频器不分频，ARR设置为65535</strong>(不用配置时基单元的内部时钟，编码器会托管相当于外部时钟)</p></li><li><p><strong>配置输入捕获单元，此处输入捕获单元只有滤波器和极性两个参数有用，其他参数没用到</strong></p></li><li><p><strong>配置编码器接口模式</strong></p></li><li><p><strong>运行控制，启动定时器</strong></p></li></ol><blockquote><p>初始化完成后，CNT就会随着编码器旋转而自增自减。</p><p>如果想要读出编码器位置，直接读出CNT的值就行了</p><p>如果想要测量编码器的速度和方向，就需要每隔一定阀门时间，取出一次CNT，然后再把CNT清零，即<code>测频法</code>测量速度</p></blockquote><h3 id="实验-正交编码器测速">实验-正交编码器测速</h3><p>我们使用的是A相：PA8，B相PA9，对应定时器TIM1_CH1和TIM1_CH2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Encoder.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ENCODER_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ENCODER_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Encoder.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//1.配置RCC，开启GPIO和对应TIM </span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB2Periph_TIM1,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//2.GPIO端口配置，配置A，B相端口为输入</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_8 | GPIO_Pin_9;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  TIM_InternalClockConfig(TIM1); </span></span><br><span class="line">  <span class="comment">/*编码器接口就不用这个，因为编码器接口就是一个带方向控制的外部时钟，内部时钟没有用了*/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3.时基单元配置</span></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//参数无效，编码器托管</span></span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>;<span class="comment">//ARR</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span><span class="number">-1</span>;<span class="comment">//不分频，编码器的时钟直接驱动计数器</span></span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span> ;</span><br><span class="line">TIM_TimeBaseInit(TIM1,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//4.输入捕获单元配置</span></span><br><span class="line">  TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">TIM_ICStructInit(&amp;TIM_ICInitStructure);<span class="comment">//部分参数未使用，调用该函数防止未初始化参数产生影响</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; </span><br><span class="line">  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; </span><br><span class="line">TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//编码器上升沿和下降沿都有效，所以此处代表极性不反转</span></span><br><span class="line">  TIM_ICInit(TIM1,&amp;TIM_ICInitStructure);</span><br><span class="line"> </span><br><span class="line">TIM_ICInitStructure.TIM_Channel = TIM_Channel_2; </span><br><span class="line">  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; </span><br><span class="line">TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//编码器上升沿和下降沿都有效，所以此处代表极性不反转</span></span><br><span class="line">    TIM_ICInit(TIM1,&amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.编码器接口配置</span></span><br><span class="line">TIM_EncoderInterfaceConfig(TIM1,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);<span class="comment">//这里的极性与上方极性配置的同一个寄存器，可以删除上方极性配置</span></span><br><span class="line">    <span class="comment">//6.运行控制TIM使能</span></span><br><span class="line">TIM_Cmd(TIM1,ENABLE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> speed = TIM_GetCounter(TIM1);</span><br><span class="line">TIM_SetCounter(TIM1,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> speed;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*放到缓存的speed当中，再清零CNT即可，最终在主循环中实现延时即可*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Encoder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> OLED_Init();</span><br><span class="line"> Encoder_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>,<span class="number">5</span>,Encoder_Get(),<span class="number">5</span>);</span><br><span class="line">        Delay_ms(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">/*1s测一次速*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果实现效果与想要的不符合，修改编码器接口配置中任意一个引脚的极性参数即可</p><p><code>此处在循环中使用了Delay函数，影响了效率，更加好的办法是开启一个1s的定时器中断，在定时器中断中更新speed的值即可</code></p></blockquote><h1>ADC</h1><h2 id="ADC简介">ADC简介</h2><p>ADC(Analog-Digital Converter)模拟-数字转换器</p><p>ADC可以将引脚上连续变化的模拟电压转换为内存中储存的数字变量，建立模拟电路到数字电路的桥梁</p><p>12位逐次逼近型ADC，1us的转换时间(ADC转化频率为1MHz)</p><p><strong>输入电压范围：0~3.3V，转化结果范围：0~4095(2的12次方)</strong></p><p>一共<code>18个输入通道</code>，可测量<code>16个外部信号</code>和<code>2个内部信号源</code><strong>(内部温度传感器和内部参考电压，不随外部电压变化)</strong></p><p>分为<code>规则组(规则通道)</code>和<code>注入组(注入通道)</code>两个转换单元</p><p>可模拟看门狗自动监测输入电压范围</p><p>STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p><p><code> 对应所有的知识都能在芯片参考手册中查看</code></p><h2 id="ADC内部结构">ADC内部结构</h2><p><img src="./image/15.png" alt="image-20241127201536862"></p><blockquote><p>逐次逼近型通过二分法给DAC值进行比较，直到找到未知电压编码</p><p>比如8位：0~255，先给128，再给64…相当于二进制的高位到低位</p><p>对于8位ADC，高位到低位判断8次即可找到位置电压编码</p><p>对于12位ADC，高位到低位判断12次即可找到位置电压编码</p></blockquote><hr><p><code>STM32的ADC</code></p><p><img src="./image/16.png" alt="image-20241127202456782"></p><blockquote><p>ADCx_IN0~15 就是对应的16个外部信号</p><p>温度传感器和Vrefint就是内部2个信号源</p><hr><p>通道分为<strong>注入通道(注入组)<strong>和</strong>规则通道(规则组)</strong></p><p><code>规则通道</code>：可以同时转选择16个通道，但是对于转化结果，因为<strong>规则通道只有一个数据寄存器</strong>，所以存在<code>数据覆盖问题</code>。如果不想结果被覆盖，需要在转换完成后尽快把数据拿走。此时一般配合DMA进行搬运</p><p><code>注入通道</code>：可以同时选择4个通道，拥有四个数据寄存器，不用担心数据被覆盖</p><p><code>对应规则通道和注入通道可以在参考手册中找到对应介绍</code></p><hr><p><code>流程</code>：</p><p>前面的通道选择后到模拟至数字转换器，</p><p>然后模拟至数字转换器中就执行逐次比较的过程，最终结果放在了注入通道/规则通道数据寄存器中。</p><p><strong>转换结束后会有一个EOC信号，该信号是规则组或注入组的完成信号，还有个JEOC是注入组完成的信号，会置状态寄存器标志位，可以读取该标志位判断是否转换完成</strong></p><p><strong>同时这两个标志位也可以去到NVIC申请中断，如果开启对应NVIC通道就可以触发中断</strong></p></blockquote><hr><p><strong>触发转换部分</strong>：对应START信号启动ADC的转换</p><p><img src="./image/17.png" alt="image-20241127203720470"></p><blockquote><p>对应STM32ADC，触发ADC开始转换的信号有两种：<code>软件触发</code>和<code>硬件触发</code></p><p><code>硬件触发</code>：对应图中注入组的触发源和规则组的触发源，主要来自<strong>定时器</strong>，在定时器章节中我们知道，定时器可以通向ADC、DAC外设，用于触发转换。也可以使用<strong>外部中断引脚</strong>触发</p><p>比如图中我们给TIM3指定1ms时间，将TIM3的更新事件选择为TIM3_TRGO输出，再把ADC选择开始触发信号为TIM3_TRGO，这样TIM3的更新事件就能通过硬件自动触发ADC转换了，不需要进中断</p><p><code>软件触发</code>：程序中调用代码完成ADC转换触发。</p></blockquote><hr><p><code>ADC时钟</code></p><p><img src="./image/18.png" alt="image-20241127204615868"></p><blockquote><p>ADC时钟来自RCC，经过ADC预分频器到达，注意此处最大位14MHz，2分频和4分频结果超过了最大值，不建议使用，这里<strong>至少6分频</strong></p><p>ADC预分频器小于14MHz即可</p></blockquote><p><code>模拟看门狗</code></p><p><img src="./image/19.png" alt="image-20241127204756265"></p><blockquote><p><strong>模拟看门狗用于监测转换结果的范围</strong>，其中可以存一个阈值高限和阈值低限，如果启动了看门狗并且设定了通道，该看门狗就会关注看门的通道，一旦超过阈值范围就可以申请一个通向NVIC的ADC中断。</p></blockquote><h2 id="ADC输入通道">ADC输入通道</h2><p><img src="./image/21.png" alt="image-20241127210445125"></p><blockquote><p>我们可以在引脚定义表中找到对应ADC通道0~9的通道对应引脚，这代表该芯片只有10个通道</p><p>同时我们可以发现ADC12_INx 这样写代表ADC1和ADC2都是这个引脚。我们可以单独使用一个ADC，也可以同时使用。</p><p><strong>ADC还有一种高级模式叫双ADC模式，就是ADC1和ADC2一起配贼和使用，可以配合组成同步、交叉模式等，可以进一步提高采样率</strong></p></blockquote><h2 id="ADC转换模式">ADC转换模式</h2><p><strong>一共有四种转换方式：多通道只能使用后面两种模式，必须开启扫描模式</strong></p><ol><li><code>单次转换，非扫描模式</code></li></ol><p><img src="./image/22.png" alt="image-20241127211229845"></p><blockquote><p>只会转换第一个序列的通道，每次转换都需要触发一次</p><p>想要更换通道转换只需要更改序列1的通道即可</p></blockquote><ol start="2"><li><code>连续转换，非扫描模式</code></li></ol><p><img src="./image/23.png" alt="image-20241127211310674"></p><blockquote><p>只会转换第一个序列的通道，但触发转换后不会停止，会一直持续转换。只需要第一次触发即可</p></blockquote><ol start="3"><li><code>单次转换，扫描模式</code></li></ol><p><img src="./image/24.png" alt="image-20241127211656061"></p><blockquote><p><strong>按顺序依次转换一组通道</strong>，可以指定通道数目，指定的所有通道转换完成后才会触发EOC信号。每次转换都需要触发</p></blockquote><ol start="4"><li><code>连续转换，扫描模式</code></li></ol><p><img src="./image/25.png" alt="image-20241127211932067"></p><blockquote><p><strong>按顺序依次转换一组通道</strong>，可以指定通道数目，指定的所有通道转换完成后才会触发EOC信号。只需要一次触发就可以一直转换</p></blockquote><p><code>其实还有个间断模式</code>：可以说是对扫描模式的补充</p><blockquote><p>触发一次，转换一个通道，在触发，在转换。在所选转换通道循环，**由触发信号启动新一轮的转换，直到转换完成为止。**例如：可以把0,1,4,5这四个通道进行分组。可以分成0,1一组，4,5一组。也可以每个通道单独配置为一组。这样每一组转换之前都需要先触发一次。</p></blockquote><h2 id="ADC触发控制">ADC触发控制</h2><p><img src="./image/26.png" alt="image-20241127212108346"></p><h2 id="ADC数据对齐">ADC数据对齐</h2><p><img src="./image/27.png" alt="image-20241127212138053"></p><blockquote><p>寄存器总共16位需要对齐，高位或低位补0</p><p><strong>一般使用右对齐，可以直接读取寄存器就是结果</strong></p><p>左对齐得到的结果比实际值偏大16倍，对于裁剪分辨率使用</p></blockquote><h2 id="ADC转换时间">ADC转换时间</h2><p><img src="./image/28.png" alt="image-20241127212422377"></p><blockquote><p><code>量化、编码</code>：就是ADC逐次比较的过程，位数越多花费时间越长</p><p><code>采样、保持</code>：量化编码需要时间，通过开启采样开关，一段时间后断开后使电压在量化编码时保持不变</p><hr><p><strong>ADC总转换时间中</strong>：</p><p><code>采样时间：</code>就是采样保持时间，采样时间可以在程序中配置，时间越长越能避免毛刺信号的干扰，但会导致转换时间延长。</p><p><code>12.5个ADC周期：</code>量化编码所花费时间，因为是12位，所以需要12个周期，多余的0.5周期可能做了一些其他事情</p><p>14个周期：14/14MHz = 1μs</p><hr><p><code>采样时间选择</code>：</p><p><strong>需要更快的转换，就选小的参数，但容易受干扰</strong></p><p><strong>需要更稳定的转换，就选大的参数，转换时间长</strong></p></blockquote><h2 id="ADC校准">ADC校准</h2><p><img src="./image/29.png" alt="image-20241127220041612"></p><blockquote><p><strong>校准过程我们不需要理解，校准过程固定，只需要在ADC初始化的最后，加几行代码就行了，至于怎么计算、怎么校准的，我们不需要管</strong></p><hr><p><strong>流程</strong>：</p><p><code>复位校准</code>-<code>等待复位校准(判断标志位)</code>-<code>开始校准</code>-<code>等待校准(判断标志位)</code></p></blockquote><h2 id="硬件电路">硬件电路</h2><p><img src="./image/30.png" alt="image-20241127220346370"></p><blockquote><p>第一个是电位器产生可调电路，通过滑动变阻器可以调节电压0~3.3V</p><hr><p>第二个是传感器输出电压电路，光敏电阻、热敏电阻等都可等效为一个可变电阻，电阻阻值没法直接测量，<strong>一般直接通过和一个固定电阻串联分压来得到反应电阻值电压</strong>的电路。</p><p><code>固定电阻一般可以选择和传感器阻值相近的电阻较好</code></p><p>传感器阻值变小时，下拉作用变强，输出端电压就下降，传感器阻值变大时，下拉作用变弱，输出端受上拉作用电压就会升高</p><hr><p>第三个是一个简易电压转换电路，使用电阻分压。根据分压公式可以得到中间的电压位(VIN/50K) * 33K，高电压一般不适用比较危险，高电压一般使用一些采集芯片，做好高低电压的隔离</p></blockquote><h2 id="ADC基本结构图">ADC基本结构图</h2><p><img src="./image/20.png" alt="image-20241127205844255"></p><h2 id="库函数-6">库函数</h2><p><code>配置ADCCLK分频器</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_ADCCLKConfig</span><span class="params">(<span class="type">uint32_t</span> RCC_PCLK2)</span>;</span><br><span class="line"><span class="comment">/*在stm32f10x_rcc.h中可以找到，该函数用于配置ADCCLK分频器，可以对APB2的72MHz时钟选择2、4、6、8分频，输入到ADCCLK*/</span></span><br></pre></td></tr></table></figure><p><code>ADC初始化:stm32f10x_adc.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_DeInit</span><span class="params">(ADC_TypeDef* ADCx)</span>;<span class="comment">//恢复缺省配置</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Init</span><span class="params">(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_StructInit</span><span class="params">(ADC_InitTypeDef* ADC_InitStruct)</span>;</span><br></pre></td></tr></table></figure><p><code>ADC启动</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_Cmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;<span class="comment">//开启ADC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DMACmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;<span class="comment">//开启DMA输出信号，使用DMA需要调用</span></span><br></pre></td></tr></table></figure><p><code>ADC通道配置</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_RegularChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel, <span class="type">uint8_t</span> Rank, <span class="type">uint8_t</span> ADC_SampleTime)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 规则组通道配置，为序列添加通道</span></span><br><span class="line"><span class="comment"> * 参数1：对应ADC</span></span><br><span class="line"><span class="comment"> * 参数2：指定ADC通道</span></span><br><span class="line"><span class="comment"> * 参数3：对应序列号</span></span><br><span class="line"><span class="comment"> * 参数4：指定通道采样时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多个通道指定时，多次调用该函数配置即可</span></span><br></pre></td></tr></table></figure><p><code>ADC外部触发转换控制</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*是否允许外部触发转换*/</span></span><br></pre></td></tr></table></figure><p><code>ADC中断</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_ITConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*用于控制某个中断，能否通往NVIC*/</span></span><br></pre></td></tr></table></figure><p><code>ADC控制校准：在ADC初始化完成后依次调用即可</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_ResetCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*复位校准*/</span></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetResetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*获取复位校准状态*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_StartCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*开始校准*/</span></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*获取开始校准复位状态*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ADC触发控制</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_SoftwareStartConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*ADC软件触发控制，调用即可设置为软件触发*/</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetSoftwareStartConvStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*ADC获取软件开始转换状态，返回SWSTART状态，与转换是否结束无关，一般不适用*/</span></span><br></pre></td></tr></table></figure><p><code>ADC间断模式配置</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_DiscModeChannelCountConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> Number)</span>;</span><br><span class="line"><span class="comment">/*ADC间断模式配置，设置Number可以设置每隔几个通道间断一次*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DiscModeCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*使能间断模式*/</span></span><br></pre></td></tr></table></figure><p><code>ADC转换结束判断</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">ADC_GetFlagStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;</span><br><span class="line"><span class="comment">/*参数给EOC标志位可以判断是否转换完成*/</span></span><br></pre></td></tr></table></figure><p><code>ADC获取转换值</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetConversionValue</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">//获取AD转换数据寄存器，读取转换结果</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ADC_GetDualModeConversionValue</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//双ADC模式读取转换结果</span></span><br></pre></td></tr></table></figure><p><code>ADC注入组</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_AutoInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedDiscModeCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigInjectedConvConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint32_t</span> ADC_ExternalTrigInjecConv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_SoftwareStartInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line">FlagStatus <span class="title function_">ADC_GetSoftwareStartInjectedConvCmdStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel, <span class="type">uint8_t</span> Rank, <span class="type">uint8_t</span> ADC_SampleTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedSequencerLengthConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_SetInjectedOffset</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_InjectedChannel, <span class="type">uint16_t</span> Offset)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetInjectedConversionValue</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_InjectedChannel)</span>;</span><br></pre></td></tr></table></figure><p><code>ADC模拟看门狗</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogCmd</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint32_t</span> ADC_AnalogWatchdog)</span>;</span><br><span class="line"><span class="comment">/*是否启动看门狗*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogThresholdsConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> HighThreshold, <span class="type">uint16_t</span> LowThreshold)</span>;</span><br><span class="line"><span class="comment">/*配置看门狗高低阈值*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogSingleChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel)</span>;</span><br><span class="line"><span class="comment">/*配置看门通道*/</span></span><br></pre></td></tr></table></figure><p><code>ADC内部信号配置</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_TempSensorVrefintCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*ADC温度传感器，内部参考电压控制，用于开启内部两个通道，需要使用时调用开启即可*/</span></span><br></pre></td></tr></table></figure><p><code>ADC标志位</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">ADC_GetFlagStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ClearFlag</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;</span><br><span class="line"></span><br><span class="line">ITStatus <span class="title function_">ADC_GetITStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ClearITPendingBit</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT)</span>;</span><br><span class="line"><span class="comment">//常用的标志位相关函数，带IT的应该在中断服务函数中使用</span></span><br></pre></td></tr></table></figure><h2 id="ADC配置流程">ADC配置流程</h2><p>打通上方ADC基本结构图即可：</p><ol><li><p><strong>RCC开启时钟，开启ADC和GPIO时钟，配置ADCCLK分频器</strong></p></li><li><p><strong>配置GPIO，配置对应GPIO为<code>模拟输入</code>的模式</strong></p></li><li><p><strong>配置多路开关，将左边对应通道接入规则组/注入组中(规则/注入通道配置)</strong></p></li><li><p><strong>配置ADC转换器，结构体(单次转换/连续转换、扫描/非扫描，几个通道等)</strong></p></li><li><p>如果需要模拟看门狗，配置阈值和监测通道，没有就跳过</p></li><li><p>如果想要使用中断，使用ADITConfig开启对应中断输出，配置NVIC即可，没有跳过</p></li><li><p><strong>开启ADC，调用ADC_Cmd函数</strong></p></li><li><p><strong>校准ADC，减小误差</strong></p></li></ol><h2 id="实验-ADC读取电位器电压-ADC单通道">实验-ADC读取电位器电压(ADC单通道)</h2><p>对应引脚定义可知电位器PA5对应通道为ADC_IN5，选择ADC_Channel_5即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*AD.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __AD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __AD_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetValue</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*AD.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.开启RCC时钟，ADC和GPIO</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.ADC预分频器配置，72Mhz / 6 =12Mhz，不能超过14Mhz，至少6分频</span></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.GPIO配置为模拟输入</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.规则通道配置,将通道5写入规则通道的第一个位置(序列1)</span></span><br><span class="line">  ADC_RegularChannelConfig(ADC1,ADC_Channel_5,<span class="number">1</span>,ADC_SampleTime_239Cycles5);</span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_1,2,ADC_SampleTime_55Cycles5); 如果还有其他通道，继续调用配置即可</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_2,3,ADC_SampleTime_239Cycles5); 如果还有其他通道，继续调用配置即可</span></span><br><span class="line"><span class="comment">//5.ADC转换器配置</span></span><br><span class="line">ADC_InitTypeDef ADC_InitStruct;</span><br><span class="line">ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; <span class="comment">//ADC转换模式，该参数为独立ADC工作，剩余的其他参数都是双ADC模式</span></span><br><span class="line">ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;<span class="comment">//数据右对齐</span></span><br><span class="line">ADC_InitStruct.ADC_ExternalTrigConv =ADC_ExternalTrigConv_None;<span class="comment">//这里选择软件触发，剩下的都为硬件触发</span></span><br><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;<span class="comment">//启动连续转换模式</span></span><br><span class="line">ADC_InitStruct.ADC_ScanConvMode = DISABLE;<span class="comment">//是否启动扫描模式</span></span><br><span class="line">ADC_InitStruct.ADC_NbrOfChannel = <span class="number">1</span>; <span class="comment">// 指定扫描模式下总共使用的通道数</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStruct);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5.开启ADC</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.ADC校准</span></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1)== SET)&#123;&#125;;<span class="comment">//RSTCAL寄存器由软件置1后开始复位校准，完成后硬件自动清0该位</span></span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET)&#123;&#125;;<span class="comment">//CAL寄存器由软件置1后开始校准，校准结束后硬件自动清0该位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ADC_SoftwareStartConvCmd(ADC1, ENABLE);在启动连续转换模式时，只需要在这里触发转换一次即可，不需要每次获取值都调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取ADC值流程：</span></span><br><span class="line"><span class="comment"> *  1.触发转换</span></span><br><span class="line"><span class="comment"> *  2.判断标志位等待转换完成</span></span><br><span class="line"><span class="comment"> *  3.读取转换结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.触发转换,上面没开启连续转换模式，开启连续转换模式只需要启动一次即可</span></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1, ENABLE);<span class="comment">//启动软件触发转换,也可以使用硬件触发</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.判断标志位,等待转换完成</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC) == RESET)&#123;&#125;;<span class="comment">//在手册中有介绍，转换完成前为0，转换完成后自动置1</span></span><br><span class="line"><span class="comment">/*等待转换时间为上面设置的采样周期，239+12.5=251.5个周期，时间为251.5/12Mhz=20.9us*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.读取转换结果</span></span><br><span class="line"><span class="keyword">return</span> ADC_GetConversionValue(ADC1);<span class="comment">//读取DR寄存器时自动清除EOC位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"><span class="type">float</span> Voltage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> OLED_Init();</span><br><span class="line"> AD_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> adValue = ADC_GetValue();</span><br><span class="line">Voltage = (<span class="type">float</span>)adValue / <span class="number">4095</span> * <span class="number">3.3</span>;<span class="comment">//根据精度对应计算出电压值</span></span><br><span class="line">OLED_ShowNum(<span class="number">5</span>,<span class="number">5</span>,adValue,<span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">10</span>,<span class="number">5</span>,Voltage,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意实验中OLED得到的AD值末尾持续抖动，这是正常波动</p><p><strong>但是如果我们需要对该AD值进行判断，再执行一些操作时，比如AD值大于某一值开灯，小于某一值就关灯。此时由于AD值存在波动就可能会来回开灯关灯。</strong></p><p><code>解决方法</code>：</p><ol><li><strong>使用迟滞比较法，设置上下阈值，高于上阈值开灯，低于下阈值关灯，类似于施密特触发器</strong></li><li><strong>如果数据跳变太厉害，可以使用均值滤波的方式，读取10~20个值取平均值作为输出结果</strong></li><li><strong>还可以裁剪分辨率去掉数据的尾数，也可以避免跳动</strong></li></ol></blockquote><h2 id="实验-ADC多通道采集">实验- ADC多通道采集</h2><blockquote><p>多通道采集，我们想到的是启动扫描模式，但是存在<code>数据覆盖</code>的问题。扫描模式是会一次将所有通道全部转换完之后才会发出EOC信号，每一个通道单独转换完成不会产生任何标志位，也不会有中断，同时AD转换很快，所以我们很难做到在一个通道转换完成后将数据手动转移。</p><p>但是很难不是不行，我们可以使用间断模式，扫描时没转换一个通道就暂停一次，我们此时可以转移数据，再继续触发，继续下一次转换。由于没有单个通道转换完成后没有标志位，我们只能通过Delay的方式延时等待转换时间，所以这种方式不推荐</p><p><strong>所以如果我们想用扫描模式实现多通道，最好配合DMA来实现</strong></p><p><code>扫描模式+DMA搬运实现ADC多通道采集见下一节DMA实验</code></p></blockquote><p>其实我们可以使用<strong>单次转换非扫描模式</strong>实现，只需要为AD_GetValue添加一个ADC_Channel的参数，调用时都重新配置规则通道再触发转换即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    adValue1 = ADC_GetValue(ADC_Channel_0);</span><br><span class="line">    adValue2 = ADC_GetValue(ADC_Channel_1);</span><br><span class="line">    adValue3 = ADC_GetValue(ADC_Channel_2);</span><br><span class="line">    adValue4 = ADC_GetValue(ADC_Channel_3);</span><br><span class="line">    Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>DMA</h1><h2 id="DMA简介">DMA简介</h2><p><img src="./image/31.png" alt="image-20241128195544055"></p><blockquote><p><strong>DMA-直接内存访问，是一个数据转运小助手，主要是协助CPU完成数据转运的工作，无须CPU干预，CPU就可以干其他更重要的事</strong></p><p>这里的<code>外设</code>一般指<code>外设数据寄存器</code>，<code>存储器</code>一般指<code>运行内存SRAM和程序存储器</code>(存储变量数组和程序代码的地方)</p><hr><p><strong>存储器到存储器</strong>的数据转运，一般使用<code>软件触发</code>，比如从FLASH到SRAM，因为软件触发是以最快的方式一股脑搬运过去，越快越好</p><p><strong>存储器到外设</strong>的数据转运，一般使用<code>特定硬件触发</code>(每个外设对应DMA通道)，比如ADC一个通道转换完成后，硬件触发一次DMA，DMA再转运。这样得到的值才正确</p></blockquote><blockquote><p><code>常见的用途：</code></p><ul><li><strong>最常见：配合ADC的扫描模式，解决ADC数据覆盖问题</strong></li><li><strong>各外设提高效率</strong></li></ul></blockquote><p><code>阅读参考手册获得所有介绍!!!</code></p><h2 id="STM32存储器映像">STM32存储器映像</h2><p><img src="./image/32.png" alt="image-20241128201135199"></p><blockquote><p><code>FLASH：</code>存放我们编译后的程序以及常量数据(const等)</p><p><code>SRAM：</code>程序的临时变量存储，变量地址都是以20开头</p><p><code>外设寄存器：</code>对应每个外设的寄存器</p><p><code>内核外设</code>：<strong>只有NVIC和Systick</strong>，与其他外设不是一个厂家设计的，所以地址被分开了</p><hr><p><code>1.在STM32的数据手册，也会有个存储器映像的图,里面可以查看各外设起始地址等</code></p><p><code>2.在对应代码的宏定义不断跳转我们可以看到定义的SRAM、外设等基地址也是上表中给出的地址，通过基地址+偏移量可以得到各外设地址等</code></p></blockquote><h2 id="DMA框图">DMA框图</h2><p><img src="./image/image-20241129210721223.png" alt="image-20241129210721223"></p><p><strong>主要包括</strong>：</p><ul><li><p><strong>用于访问各个存储器的DMA总线</strong></p></li><li><p><strong>内部的多个通道，可以进行独立的数据转运</strong></p></li><li><p><strong>仲裁器，用于调度各个通道，防止产生冲突</strong></p></li><li><p><strong>AHB从设备：是DMA自身的寄存器，用于配置DMA参数</strong></p></li><li><p><strong>DMA请求，用于硬件触发DMA的数据转运</strong></p></li></ul><p><img src="./image/34.png" alt="image-20241129204758768"></p><blockquote><p><code>寄存器：</code></p><p>各个外设都可以看成是寄存器，也是一种SRAM存储器，寄存器是一种特殊的存储器，一方面，CPU可以对寄存器进行读写，另一方面寄存器的每一位背后，都连接了一个线，这些线可以用于控制外设电路的状态，比如设置引脚高低电平，导通和断开开关等，或者多位组合起来当做计数器、数据寄存器等</p><p>寄存器是连接软件和硬件的桥梁，软件读写寄存器就相当在控制硬件的执行</p><hr><p>外设寄存器，有些是只读的，有些是可读可写的，具体看参考手册上的介绍</p></blockquote><p><img src="./image/image-20241129205958030.png" alt="image-20241129205958030"></p><blockquote><p><code>DMA请求：</code></p><p>请求就是触发的意思，DMA请求线路的触发源是各个外设，DMA请求就是DMA的硬件触发源，比如ADC转换完成、串口接收到数据时，需要触发DMA转运数据时，就会通过这条线路向DMA发出硬件触发信号，之后DMA就可以在执行数据转运的工作了。</p></blockquote><blockquote><p><code>FLASH :</code></p><p>这里是ROM只读存储器的一种，如果通过总线直接访问，无论是CPU还是DMA都是只读的，如果DMA转运的目的地址填写的是FLASH就会出错。</p><p><code>SRAM:</code>可以任意读写</p></blockquote><h2 id="DMA-基本结构图">DMA 基本结构图</h2><p><img src="./image/image-20241129213600867.png" alt="image-20241129213600867"></p><blockquote><p><code>图中所有参数都是使用结构体配置</code></p><p>有个方向控制的参数可以控制外设寄存器到存储器的方向</p><p>外设寄存器和存储器(Flash、SRAM)都有三个参数：</p><ol><li>起始地址</li><li>数据宽度</li><li>地址是否自增</li></ol><hr><p><code>传输计数器：</code>用于指定转运次数，是一个自建计数器，每转运一次，值减1，直到减小到0之后DMA停止转运，对应自增过后的地址恢复到起始地址的位置，以方便DMA开始新一轮转换</p><p><strong>注意：不能在DMA开启时，写传输计数器，这是手册的规定！！！</strong></p><p><strong>需要写计数器时按照即可：DMA失能–写传输计数器–DMA使能</strong></p><p><code>自动重装器：</code>传输计数器减小到0之后是否需要恢复到最初的值，指定重装就是循环模式</p><hr><p><strong>触发控制</strong>：决定DMA什么时间进行转运，由M2M(Memory to Memory)参数决定软件触发还是硬件触发</p><p><code>软件触发：</code><strong>一般用于存储器到存储器的转运，这些转运不需要一定时机</strong>，参数<code>M2M为1时</code>为软件触发，并不是调用一个函数一次就触发一次，而是以最快的速度，连续不断的触发DMA，以最快速度将传输计数器减少到0，与外部中断和ADC的软件触发可能不太一样，可以理解为<strong>自动连续触发</strong></p><p><strong>软件触发和循环模式不能同时使用，因为软件触发是想把计数器清0，而循环模式会重载，DMA就停不下来了</strong></p><p><code>硬件触发：</code><strong>一般用于与外设有关的转运，转运需要一定时机当硬件达到这些时机时传一个信号，触发DMA进行转运，比如ADC转换完成等</strong>，<code>参数M2M为0</code>时为硬件触发，触发源可以选择ADC、串口、定时器等等</p><hr><p><code>开关控制</code>：</p><p>DMA_Cmd函数</p></blockquote><blockquote><p><code>DMA转运需要有三个条件：</code></p><ol><li>使能DMA，开关控制</li><li>传输计数器不为0</li><li>必须要有触发源</li></ol></blockquote><h2 id="DMA请求映像">DMA请求映像</h2><p><img src="./image/image-20241129223925869.png" alt="image-20241129223925869"></p><blockquote><p>每个通道有一个数据选择器，选择硬件触发或者软件触发，EN位决定数据选择器是否工作</p><p><code>硬件触发注意</code>：<strong>M2M = 0</strong></p><p><strong>每个外设触发通道都不一样，所以我们在选择硬件触发源时，一定要先找到对应通道触发</strong>，比如ADC1在通道1，定时器更新事件(TIM2_UP)在通道2</p><p>对应的有ADC_DMACmd、TIM_DMACmd函数等</p><p><code>软件触发</code>：<strong>M2M = 1</strong></p><p><strong>DMA和通道任意选择，每个通道软件触发都是一样的</strong></p><hr><p><code>优先级:</code></p><p>类似与中断优先级判断，通道号越小优先级越高，也可在程序中配置</p></blockquote><h2 id="数据宽度与对齐">数据宽度与对齐</h2><p><img src="./image/image-20241129224639834.png" alt="image-20241129224639834"></p><blockquote><p><code>源端宽度</code>和<code>目标宽度</code>相同时和不同时的数据传输处理：与变量赋值类似</p><p>源端宽度=目标宽度，不变</p><p>源端宽度&lt;目标宽度，高位补0</p><p>源端宽度&gt;目标宽度，高位舍弃</p></blockquote><h2 id="例子">例子</h2><h3 id="数据转运-DMA-存储器到存储器转运">数据转运+DMA(存储器到存储器转运)</h3><p><img src="./image/image-20241129225329602.png" alt="image-20241129225329602"></p><blockquote><p>不需要转运时间同步等，使用软件触发即可</p></blockquote><h3 id="ADC扫描模式-DMA-外设到存储器">ADC扫描模式+DMA(外设到存储器)</h3><p><img src="./image/image-20241129225519836.png" alt="image-20241129225519836"></p><blockquote><p>我们需要在每个单独的通道转换完成后，进行一个DMA转运，并且使目的地址自增，源地址不自增，方向为外设到存储器，传输计数器7次</p><p>ADC连续扫描，DMA可以使用自动重装，使ADC和DMA同时工作</p><p>DMA转运时机需要和ADC单个通道转换同步，所以DMA触发要选择ADC硬件触发。</p><p><strong>单个通道转换完成时应该可以触发DMA传输，否则无法完成</strong></p></blockquote><h2 id="库函数-7">库函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化相关函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_DeInit</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Init</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_StructInit</span><span class="params">(DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使能DMA对应通道,第一个参数不再是DMAx，而是DMAy_x,即选择了哪个DMA，又选择了DMA的通道，DMA几的通道几</span></span><br><span class="line"><span class="comment">  * 软件触发随意选择通道</span></span><br><span class="line"><span class="comment">  * 硬件触发，先查看手册找到对应外设的通道在设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Cmd</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA中断输出使能*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ITConfig</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="type">uint32_t</span> DMA_IT, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*传输计数器值设置和获取*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_SetCurrDataCounter</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="type">uint16_t</span> DataNumber)</span>; </span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">DMA_GetCurrDataCounter</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关函数*/</span></span><br><span class="line">FlagStatus <span class="title function_">DMA_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> DMAy_FLAG)</span>;<span class="comment">//获取标志位状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> DMAy_FLAG)</span>;<span class="comment">//清除标志位</span></span><br><span class="line">ITStatus <span class="title function_">DMA_GetITStatus</span><span class="params">(<span class="type">uint32_t</span> DMAy_IT)</span>;<span class="comment">//获取中断状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ClearITPendingBit</span><span class="params">(<span class="type">uint32_t</span> DMAy_IT)</span>;<span class="comment">//清除中断挂起位</span></span><br></pre></td></tr></table></figure><h2 id="DMA配置流程">DMA配置流程</h2><p><code>根据DMA基本结构图配置如下：</code></p><ol><li><strong>RCC开启DMA时钟</strong></li><li><strong>配置DMA，调用DMA_Init，初始化各个参数(外设和存储器站点的起始地址、数据宽度、地址是否自增、方向、传输计数器、是否需要自动重装、选择触发源等参数)</strong></li><li>如果需要DMA中断，调用DMA_ITConfig开启中断输出，配置NVIC各个参数，写好对应中断服务函数即可，<strong>不用中断可以直接跳过</strong></li><li><strong>DMA使能，DMA_Cmd函数(别忘了对应在外设XXX_DMACmd开启触发信号输出)</strong></li></ol><h2 id="实验-DMA数据转运-存储器到存储器">实验-DMA数据转运(存储器到存储器)</h2><p><code>DMA不涉及外围硬件电路，故.c/.h文件放在System文件夹中</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DMA.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DMA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DMA_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMAInit</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint32_t</span> Size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Transfer</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DMA.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> DMA_Size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMAInit</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint32_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.RCC开启DMA时钟</span></span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.配置DMA</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line">DMA_InitStruct.DMA_PeripheralBaseAddr = AddrA;<span class="comment">//外设站点起始地址</span></span><br><span class="line">DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;<span class="comment">//外设站点数据宽度,这里以字节传输</span></span><br><span class="line">DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Enable;<span class="comment">//地址是否自增(Increment)，这里启用</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryBaseAddr = AddrB;<span class="comment">//存储器站点起始地址</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;<span class="comment">//存储器站点数据宽度</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//地址是否自增</span></span><br><span class="line">DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC ; <span class="comment">// 传输方向(direction),这里选择的是外设站点作为数据源</span></span><br><span class="line">DMA_InitStruct.DMA_BufferSize = Size; <span class="comment">// 传输计数器的值,其实就是传输次数,一次传输上面设置的数据宽度的值</span></span><br><span class="line">DMA_InitStruct.DMA_Mode = DMA_Mode_Normal; <span class="comment">// 传输模式，就是是否使用自动重装。Normal不重装，circular是循环重装</span></span><br><span class="line">DMA_InitStruct.DMA_M2M = DMA_M2M_Enable; <span class="comment">//配置软件触发还是硬件触发位(0,1),Enable是软件触发</span></span><br><span class="line">DMA_InitStruct.DMA_Priority = DMA_Priority_Medium; <span class="comment">// 配置优先级，选择中等</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStruct);<span class="comment">//软件触发使用任意通道都可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.DMA使能</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line"></span><br><span class="line">DMA_Size = Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改传输计数器的值，使DMA能循环传输*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Transfer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,DMA_Size); </span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET)&#123;&#125;;<span class="comment">//等待转换完成</span></span><br><span class="line"></span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DMA.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> DataA[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x04</span>&#125;;<span class="comment">//加上const发现存储在FLASH区</span></span><br><span class="line"><span class="type">uint8_t</span> DataB[] =  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">DMAInit((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;DataA:&quot;</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataA,<span class="number">8</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">5</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">8</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">11</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">2</span>,<span class="string">&quot;DataB:&quot;</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataB,<span class="number">8</span>);</span><br><span class="line">  OLED_ShowHexNum(<span class="number">4</span>,<span class="number">2</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">5</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">8</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">11</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//DataA[0]++;</span></span><br><span class="line"><span class="comment">//DataA[1]++;</span></span><br><span class="line"><span class="comment">//DataA[2]++;</span></span><br><span class="line"><span class="comment">//DataA[3]++;</span></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;DataA:&quot;</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">5</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">8</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">11</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">      </span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">DMA_Transfer();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">2</span>,<span class="string">&quot;DataB:&quot;</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">2</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">5</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">8</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">11</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验-DMA-ADC多通道采集">实验-DMA+ADC多通道采集</h2><p><code>ADC多通道(连续转换+扫描模式+DMA循环转移):</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*AD.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __AD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __AD_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> ADValue[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void ADC_GetValue();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> ADValue[<span class="number">2</span>];<span class="comment">//有几个通道的结果长度就设定为几</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.开启RCC时钟，ADC和GPIO,以及DMA</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.ADC预分频器配置，72Mhz / 6 =12Mhz，不能超过14Mhz，至少6分频</span></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.GPIO配置为模拟输入</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_4;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.规则通道配置,将通道4,5,分贝写入规则通道的第一个位置和第二个位置(序列1，序列2)</span></span><br><span class="line">  ADC_RegularChannelConfig(ADC1,ADC_Channel_4,<span class="number">1</span>,ADC_SampleTime_239Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_5,<span class="number">2</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line"><span class="comment">//  ADC_RegularChannelConfig(ADC1,ADC_Channel_6,3,ADC_SampleTime_55Cycles5); 还有通道继续配置即可</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.ADC转换器配置</span></span><br><span class="line">ADC_InitTypeDef ADC_InitStruct;</span><br><span class="line">ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; <span class="comment">//ADC转换模式，该参数为独立ADC工作，剩余的其他参数都是双ADC模式</span></span><br><span class="line">ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;<span class="comment">//数据右对齐</span></span><br><span class="line">ADC_InitStruct.ADC_ExternalTrigConv =ADC_ExternalTrigConv_None;<span class="comment">//这里选择软件触发，剩下的都为硬件触发</span></span><br><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;<span class="comment">//启动连续转换模式</span></span><br><span class="line">ADC_InitStruct.ADC_ScanConvMode = ENABLE;<span class="comment">//是否启动扫描模式,这里多通道启动</span></span><br><span class="line">ADC_InitStruct.ADC_NbrOfChannel = <span class="number">2</span>; <span class="comment">// 指定扫描模式下总共使用的通道数，使用了几个通道就填几</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStruct);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.配置DMA</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line">DMA_InitStruct.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//ADC1寄存器地址</span></span><br><span class="line">DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;<span class="comment">//ADC选择半字16位传输,对于12位，舍弃4位</span></span><br><span class="line">DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增(Increment)，这里对同一个地方的值运输，不启用</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)ADValue;<span class="comment">//存放到SRAM中的数组中</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;<span class="comment">//以半字16位传输</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//由于多个值，需要移动数组的地址，需要自增</span></span><br><span class="line">DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC ; <span class="comment">// 传输方向(direction),这里选择的是外设站点作为数据源</span></span><br><span class="line">DMA_InitStruct.DMA_BufferSize = <span class="number">2</span>; <span class="comment">//其实就是传输次数,一次传输上面设置的数据宽度的值，这里两个通道一共传输2次</span></span><br><span class="line">DMA_InitStruct.DMA_Mode = DMA_Mode_Circular; <span class="comment">// 传输模式，就是是否使用自动重装。Normal不重装，circular是循环重装</span></span><br><span class="line">DMA_InitStruct.DMA_M2M = DMA_M2M_Disable; <span class="comment">// 配置硬件触发，M2M位为0</span></span><br><span class="line">DMA_InitStruct.DMA_Priority = DMA_Priority_Medium; <span class="comment">// 配置优先级，选择中等</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStruct);<span class="comment">//查看手册得到ADC1通道为1，只能使用通道1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.使能DMA和开启ADC到DMA输出</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//必须在ADC使能之前开启输出到DMA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//8.使能ADC</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.ADC校准</span></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1)== SET)&#123;&#125;;<span class="comment">//RSTCAL寄存器由软件置1后开始复位校准，完成后硬件自动清0该位</span></span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET)&#123;&#125;;<span class="comment">//CAL寄存器由软件置1后开始校准，校准结束后硬件自动清0该位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//10.ADC触发转换</span></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1, ENABLE);</span><br><span class="line">    <span class="comment">/*连续转换，扫描模式下，DMA循环模式下只需要触发一次，ADC和DMA都不用等待，ADC和DMA就同时开始持续协同工作了*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里是触发使用单次转换时需要的*/</span></span><br><span class="line"><span class="comment">//void ADC_GetValue()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//DMA_Cmd(DMA1_Channel1,DISABLE);</span></span><br><span class="line"><span class="comment">//DMA_SetCurrDataCounter(DMA1_Channel1,2); </span></span><br><span class="line"><span class="comment">//DMA_Cmd(DMA1_Channel1,ENABLE);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//ADC_SoftwareStartConvCmd(ADC1, ENABLE);//启动软件触发转换</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">///*不需要等待ADC转换完成了，只需要等待DMA*/</span></span><br><span class="line"><span class="comment">//while(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET)&#123;&#125;;//等待DMA传输完成</span></span><br><span class="line"><span class="comment">//DMA_ClearFlag(DMA1_FLAG_TC1);//清除标志位</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Voltage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">OLED_Init();</span><br><span class="line">AD_Init();</span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Voltage = (<span class="type">float</span>)ADValue[<span class="number">1</span>] / <span class="number">4095</span> * <span class="number">3.3</span>;<span class="comment">//根据精度对应计算出电压值</span></span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">5</span>,<span class="number">5</span>,ADValue[<span class="number">0</span>],<span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">10</span>,<span class="number">5</span>,ADValue[<span class="number">1</span>],<span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">15</span>,<span class="number">5</span>,Voltage,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>ADC连续转换+扫描模式下，配合DMA，只需要触发ADC转换后，每当有一个通道转换完成，DMA迅速将值转运到ADValue中，我们直接对ADValue的值进行读取即可</strong></p><hr><p><strong>这里我们其实还可以再加一个定时器，ADC用单次扫描，再用定时器去定时触发</strong></p><p><code>即：定时器触发ADC-&gt;ADC触发DMA</code></p><p><strong>这样的好处就是整个过程完全自动，不需要手动进行操作，节省软件资源，实现硬件自动化</strong></p></blockquote><h1>通信接口</h1><h2 id="接口简介">接口简介</h2><p><img src="./image/image-20241130220652564.png" alt="image-20241130220652564"></p><blockquote><p><strong>这里列举的是最常用，最简单的配置，还有很多配置没有列出</strong></p><p><strong>全双工一般都有两根数据线，比如串口、SPI</strong></p></blockquote><h2 id="串口通信">串口通信</h2><h3 id="介绍-3">介绍</h3><p><img src="./image/image-20241201171647997.png" alt="image-20241201171647997"></p><blockquote><p><strong>串口是点对点通信，就是一对一之间通讯</strong></p><p><strong>图一</strong>：<strong>USB转串口模块</strong>，上面是<strong>CH340芯片</strong>，可以将串口协议转换为USB协议，USB端可以接在电脑上，另一端串口引脚接在支持串口的芯片上</p><p><strong>图二</strong>：<strong>陀螺仪传感器模块</strong>，测量加速度，角速度，一边是串口引脚，一边是I2C引脚</p><p><strong>图三</strong>：<strong>蓝牙串口模块</strong>，上面的芯片可以和手机互联，实现手机遥控单片机的功能</p></blockquote><h3 id="CH340串口驱动">CH340串口驱动</h3><p>CH340芯片作为USB和串行通信之间的桥梁，它允许你的电脑通过USB端口与仅支持串行通信协议的设备（如许多基于STM32的开发板）进行通信。安装了正确的驱动后，电脑上的应用程序（例如串口调试工具、编程软件等）才能通过这个虚拟出来的COM端口与STM32开发板交换数据。</p><p><strong>串口连接我们电脑时，对应设备管理器中找到是否有CH340的驱动，没有的安装即可，有的话就可以使用了。</strong></p><p><img src="./image/image-20241203185913944.png" alt="image-20241203185913944"></p><h3 id="硬件电路-2">硬件电路</h3><p><img src="./image/image-20241201172828258.png" alt="image-20241201172828258"></p><blockquote><p><strong>一般串口通信模块有四个引脚：VCC、TX、RX、GND</strong></p><p><strong>简单的串口通信只有RX和TX两个信号线，复杂的还有时钟线</strong></p><p>TX和RX是单端信号，它们的高低电平都是相对于GND，所以串口通信的RX、TX、GND是必须接的</p><p>对于VCC，如果两个设备都有独立供电，VCC可以不用接。如果其中一个设备没有供电，比如设备1是STM32，设备2是蓝牙串口模块，STM32有独立供电，蓝牙串口模块没有独立供电，此时就需要把蓝牙串口的VCC和STM32的VCC接在一起</p><hr><p><strong>两根通信线为全双工，只接一根通信线的情况下就变成了单工通信</strong></p><hr><p><strong>电平标准不一致需要加电平转换芯片才能通信，一般设备直接出来的是TTL电平，需要另外一个也是TTL电平才能通信</strong></p></blockquote><h3 id="电平标准">电平标准</h3><p><img src="./image/image-20241201173753315.png" alt="image-20241201173753315"></p><blockquote><p><code>TTL电平</code>：单片机这种低压小型设备，使用的都是TTL电平，最远几十米。所以在单片机中如果线路对地是3.3V，就代表发送了逻辑1，对地是0V，就代表发送了逻辑0</p><p><code>RS232</code>：最远几十米。</p><p><code>RS485</code>：两线压差，所以电平是差分信号，差分信号的抗干扰能力非常强，使用RS485电平标准，通讯距离可以达到上千米</p><p><strong>不同的电平间，加上电平转换芯片即可使用</strong></p></blockquote><h3 id="串口参数及时序">串口参数及时序</h3><p><img src="./image/image-20241201174831622.png" alt="image-20241201174831622"></p><blockquote><p><code>波特率</code>：每秒传送码元的个数，单片机中的话一个码元对应一位，码元/s对应bit/s</p><p><code>起始位</code>：空闲状态时为<strong>高电平</strong>，起始位为<strong>低电平</strong>产生一个下降沿，标志数据发送的开始</p><p><code>数据位</code>：<strong>低位先行</strong>，从数据的低位开始发送。可以把校验位算在数据位中，也可以把校验位单独出来</p><p><code>校验位</code>：三种方式，无校验，奇校验，偶校验，根据数据来决定是0还是1</p><p><code>停止位</code>：固定为<strong>高电平</strong>为下个起始位做准备</p><hr><p><code>数据帧格式：</code></p><p>&lt;--------10位/11位 -----------&gt;</p><p><strong>起始位(低电平)+数据位+停止位(高电平)</strong></p><p>​            1位               8/9位        1 位</p><p>8位数据位：不含有奇偶校验位</p><p>9位数据为：最后一位添加了一位奇偶校验位</p><hr></blockquote><h3 id="USART简介">USART简介</h3><p><img src="./image/image-20241201231743375.png" alt="image-20241201231743375"></p><blockquote><p><strong>一般串口很少使用同步功能，只是多了个时钟输出，只支持输出不支持输入，同步模式更多是为了兼容别的协议和其他用途，并不支持两个USART之间进行同步通信</strong></p><hr><p><code>硬件流控制:</code>在A、B之间有一根单独的一根线，高低电平可以决定接收方是否准备好，准备好了再发送，可以防止接收方处理慢而导致数据丢失的问题。我们一般不使用</p><p><code>DMA:</code>串口有大量的数据时，可以使用DMA，减小CPU负担，提高效率</p></blockquote><h3 id="USART框图">USART框图</h3><p><img src="./image/image-20241202174332315.png" alt="image-20241202174332315"></p><blockquote><p><code>发送数据寄存器TDR</code>：只写，当数据从TDR全部到发送移位寄存器中后，<code>TXE标志位</code>(TX Empty)-<strong>发送数据寄存器为空</strong>，会置1，此时检查这个标志位为1的话就可以就可以写入下一个数据到TDR</p><p><code>发送移位寄存器</code>：把一个字节的数据一位一位地移出去，正好对应串口协议的波形数据位。通过下方发送器控制，向右移位，一位一位地把数据输出到TX引脚，正好对应串口的低位先行，当数据移位完成后，新的数据会再次自动的从TDR移动到发送移位寄存器中(移位未完成时TDR会等待完成)。</p><p>发送整个过程连续，效率高</p><hr><p><code>接收数据寄存器RDR</code>：只读</p><p><code>接收移位寄存器</code>：数据从RX引脚通向接收移位寄存器，在接受器控制下，一位一位地读取RX电平，先放在最高位，然后向右移。当这一个字节数据移位完成后，整体全部转移到<strong>接收数据寄存器RDR</strong>中，此时将<code>RXNE</code>(RX Not Empty )-<strong>接收数据寄存器非空</strong>，检测到RXNE置1之后，就可以将数据从RDR读走</p><hr><p><code>硬件数据流控(流控)</code>：<strong>如果发送设备发得太快，接收设备来不及处理，就会出现丢弃或覆盖数据得现象，有了流控就可以避免这个问题。一般不使用！！！</strong></p><p>对应有两个引脚：</p><p><code>nRTS(Request To Send)：</code>请求发送，是输出脚，告诉别人当前是否能接收，n代表低电平有效</p><p><code>nCTS(Clear To Send)：</code>是清除发送，是输入脚，用于接收别人nRTS信号b，n代表低电平有效</p><p>两个有流控的设备RTS和CTS交叉连接即可，CTS引脚接对方RTS引脚，用于判断对方能否接收，RTS引脚接对方CTS引脚，用于告诉对方我能不能接收</p><hr><p><code>右边边的SCLK</code>：</p><p>产生同步的时钟信号，用于配合发送移位寄存器输出。只支持输出不支持输入，两个USART之间不能实现同步的串口通信。我们一般不使用</p><p>作用：</p><ol><li>兼容别的协议，串口加上时钟后和SPI很像，所以可以兼容SPI协议</li><li>自适应波特率</li></ol><hr><p><code>唤醒单元：</code></p><p>实现多设备功能，一般不使用</p><hr><p><code>中断控制：</code></p><p>两个标志位比较重要，<code>TXE</code>(发送中断标志位)和<code>RXNE</code>(接收中断标志位)，这两个标志位可以去申请接收中断和发送中断，就可以在接收或者发送数据时，直接进入中断服务函数</p><p><strong>其他的标志位看手册可以知道有什么作用</strong></p><hr><p><code>波特率发生器：</code></p><p>波特率发生器其实就是<strong>分频器</strong>，对APB时钟进行分频，得到发送器和接收器的时钟</p></blockquote><p><code>对应所有的寄存器等更多知识都能在参考手册中查看！！！！</code></p><h3 id="USART基本结构">USART基本结构</h3><p><img src="./image/image-20241202164204771.png" alt="image-20241202164204771"></p><blockquote><p><code> 波特率发生器</code>：用于产生约定的通信速率</p><p><code>对于TDR和RDR</code>：在软件层面，只有一个DR寄存器可以让我们读写，只不过是在接收或者发送时走上面或者下面这条路</p><p><code>开关控制</code>：对应的Cmd函数</p></blockquote><h3 id="数据帧">数据帧</h3><p><code>发送电路：</code></p><p><img src="./image/image-20241202164659015.png" alt="image-20241202164659015"></p><blockquote><p><strong>四种选择：</strong></p><p><strong>8位字长，无校验</strong></p><p><strong>8位字长，有校验</strong></p><p><strong>9位字长，无校验</strong></p><p><strong>9位字长，有校验</strong></p></blockquote><h3 id="起始位侦测">起始位侦测</h3><p><code>接收电路:</code></p><p><img src="./image/image-20241202165836050.png" alt="image-20241202165836050"></p><blockquote><p><strong>以波特率的16倍进行采样，一位的长度中，每三位至少有2个0，否则认为是噪声。</strong></p><p><strong>采样位设置在8，9，10，之后也这样采样就能保证在数据中间</strong></p></blockquote><h3 id="数据采样">数据采样</h3><p><img src="./image/image-20241202170417412.png" alt="image-20241202170417412"></p><blockquote><p><strong>连续采样三次，无噪声下三次采样都为0或1</strong></p><p><strong>如果有噪声，以2:1进行确定，2次0，数据就为0，2次1，采样的数据就为1。此时会对噪声标志位NE置1，告诉收到数据，但有噪声</strong></p></blockquote><h3 id="波特率发生器">波特率发生器</h3><p><img src="./image/image-20241202170724981.png" alt="image-20241202170724981"></p><blockquote><p><strong>DIV(分频系数)分为整数部分和小数部分，可以实现更细腻的分频</strong></p><p>16是因为内部有一个16倍波特率的采样时钟，所以**（fpclk2/1 / DIV)= 16  * 波特率(16倍波特率)**，最终计算波特率要多除以一个16</p><p><strong>例：配置9600波特率</strong></p><p>带公式：9600 = 72MHz /(16*DIV) ，得到DIV = 468.75</p><p>然后将DIV写入到该波特比率寄存器USART_BRR中，转换为2进制写入，有整数位和小数位</p><p><code>我们使用库函数直接输入需要的波特率9600即可，自动计算配置完成</code></p></blockquote><h3 id="数据模式">数据模式</h3><p><img src="./image/image-20241203190308931.png" alt="image-20241203190308931"></p><blockquote><p><strong>通过串口助手显示的数据有以上两种方式：HEX和ASCII</strong></p><p>HEX：以原始数据(0x41等)的形式显示，为十六进制</p><p>ASCII：将原始数据(0x41)按照ASCII编码码表对应显示(0x41对应编码为‘A’)</p></blockquote><h3 id="库函数-8">库函数</h3><p>stm32f10x_usart.h中找到</p><p><code>初始化函数：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_DeInit</span><span class="params">(USART_TypeDef* USARTx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_Init</span><span class="params">(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_StructInit</span><span class="params">(USART_InitTypeDef* USART_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这两个函数用于配置同步时钟输出的，包括时钟使能，极性，相位等参数使用结构体*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClockInit</span><span class="params">(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClockStructInit</span><span class="params">(USART_ClockInitTypeDef* USART_ClockInitStruct)</span>;</span><br></pre></td></tr></table></figure><p><code>中断配置：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_ITConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><p><code>USART相关使能：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_Cmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*使能USART*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_DMACmd</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_DMAReq, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*开启对应的USART到DMA的触发通道*/</span></span><br></pre></td></tr></table></figure><p><code>USART发送和接收数据：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_SendData</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="comment">//写DR寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">USART_ReceiveData</span><span class="params">(USART_TypeDef* USARTx)</span>;</span><br><span class="line"><span class="comment">//读DR寄存器</span></span><br></pre></td></tr></table></figure><p><code>标志位相关：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">USART_GetFlagStatus</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClearFlag</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_FLAG)</span>;</span><br><span class="line"><span class="comment">/*终端外使用的标志位函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断服务程序中使用的标志位函数*/</span></span><br><span class="line">ITStatus <span class="title function_">USART_GetITStatus</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClearITPendingBit</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT)</span>;</span><br></pre></td></tr></table></figure><hr><p><code>不常用</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_SetAddress</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint8_t</span> USART_Address)</span>;<span class="comment">//设置地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_WakeUpConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_WakeUp)</span>;<span class="comment">//唤醒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ReceiverWakeUpCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_LINBreakDetectLengthConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_LINBreakDetectLength)</span>;<span class="comment">//LIN</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_LINCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一大段函数，智能卡、IrDA等相关函数不怎么使用*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendBreak</span><span class="params">(USART_TypeDef* USARTx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SetGuardTime</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint8_t</span> USART_GuardTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SetPrescaler</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint8_t</span> USART_Prescaler)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SmartCardCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SmartCardNACKCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_HalfDuplexCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_OverSampling8Cmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_OneBitMethodCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_IrDAConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IrDAMode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_IrDACmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="USART配置流程">USART配置流程</h3><ol><li><p><strong>RCC开启时钟，打开需要的USART和GPIO时钟</strong></p></li><li><p><strong>配置GPIO，对应TX配置为复用输出，RX配置为上拉或浮空输入</strong></p></li><li><p><strong>配置USART，使用结构体配置即可</strong></p></li><li><p>如果需要接收中断，加上ITConfig和NVIC配置即可。如果不需要中断跳过配置即可</p></li><li><p><strong>使能USART，USART_Cmd</strong></p></li></ol><h3 id="实验-串口发送和串口接收">实验-串口发送和串口接收</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*包括对Usart的初始化，和对一些常用的函数封装*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSend</span><span class="params">(<span class="type">uint8_t</span> Data)</span>;<span class="comment">//发送一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendArray</span><span class="params">(<span class="type">uint8_t</span>* Array,<span class="type">uint8_t</span> Length)</span>;<span class="comment">//发送数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendString</span><span class="params">(<span class="type">char</span>* String)</span>;<span class="comment">//发送字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">UsartPow</span><span class="params">(<span class="type">uint32_t</span> x,<span class="type">uint8_t</span> y)</span>;<span class="comment">//幂函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendNum</span><span class="params">(<span class="type">uint32_t</span> Num,<span class="type">uint8_t</span> Length)</span>;<span class="comment">//发送数字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1. RCC开启时钟，打开需要的USART和GPIO时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.配置GPIO，对应TX配置为复用输出，RX配置为上拉或浮空输入，如果只选择一种模式，那么就只配置一个引脚即可</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//TX引脚配置</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//RX引脚配置</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//3.配置USART，使用结构体配置即可</span></span><br><span class="line">USART_InitTypeDef USART_InitStruct;</span><br><span class="line">USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;<span class="comment">//波特率配置</span></span><br><span class="line">USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//硬件流控配置,这里不适用</span></span><br><span class="line">USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; <span class="comment">//这里配置串口接收和发送模式都使用，可以只配置一个</span></span><br><span class="line">USART_InitStruct.USART_Parity = USART_Parity_No; <span class="comment">//校验位，不使用校验</span></span><br><span class="line">USART_InitStruct.USART_StopBits = USART_StopBits_1; <span class="comment">//停止位配置1位</span></span><br><span class="line">USART_InitStruct.USART_WordLength = USART_WordLength_8b;<span class="comment">//数据位长度，没有奇偶校验位，所以选择8位数据位</span></span><br><span class="line">USART_Init(USART2,&amp;USART_InitStruct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果需要使用中断，需要在此处调用USART_ITConfig函数，然后再配置NVIC即可*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.使能USART，USART_Cmd</span></span><br><span class="line">USART_Cmd(USART2,ENABLE);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSend</span><span class="params">(<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">USART_SendData(USART2,Data);</span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USART2,USART_FLAG_TXE) == RESET);<span class="comment">//等待数据移动到移位寄存器中，避免发生数据覆盖</span></span><br><span class="line"><span class="comment">/*手册中可以知道，下一次调用SendData时该TXE标志位会自动清0*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendArray</span><span class="params">(<span class="type">uint8_t</span>* Array,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">UsartSend(Array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendString</span><span class="params">(<span class="type">char</span>* String)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;String[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">UsartSend(String[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">UsartPow</span><span class="params">(<span class="type">uint32_t</span> x,<span class="type">uint8_t</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(y--)</span><br><span class="line">&#123;</span><br><span class="line">result*=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendNum</span><span class="params">(<span class="type">uint32_t</span> Num,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">UsartSend((Num/UsartPow(<span class="number">10</span>,Length-i<span class="number">-1</span>))%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);<span class="comment">//加上一个字符0得到对应数字的ascii码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> myArray[] = &#123;<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>&#125;;</span><br><span class="line"></span><br><span class="line">  UsartInit();</span><br><span class="line">    </span><br><span class="line">  UsartSend(<span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">UsartSendArray(myArray,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">UsartSendString(<span class="string">&quot;hello\r\nworld&quot;</span>);<span class="comment">//需要两个转义字符才能换行，\r代表回车，\n代表换行</span></span><br><span class="line"></span><br><span class="line">UsartSendNum(<span class="number">65535</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验-串口接收单字节-轮询-中断">实验-串口接收单字节(轮询+中断)</h3><p><code>在while循环中轮询读取：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(USART_GetFlagStatus(USART2,USART_FLAG_RXNE)== SET)<span class="comment">//手册可知该RXNE标志位再下方调用读取时会自动清0</span></span><br><span class="line">&#123;</span><br><span class="line">rData = USART_ReceiveData(USART2);</span><br><span class="line">&#125;</span><br><span class="line">      OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,rData,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>使用中断:</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSend</span><span class="params">(<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendArray</span><span class="params">(<span class="type">uint8_t</span>* Array,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendString</span><span class="params">(<span class="type">char</span>* String)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">UsartPow</span><span class="params">(<span class="type">uint32_t</span> x,<span class="type">uint8_t</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendNum</span><span class="params">(<span class="type">uint32_t</span> Num,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetFlag</span><span class="params">()</span>;<span class="comment">//自定义标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetData</span><span class="params">()</span>;<span class="comment">//自定义Get方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData;</span><br><span class="line"><span class="type">uint8_t</span> rFlag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1. RCC开启时钟，打开需要的USART和GPIO时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.配置GPIO，对应TX配置为复用输出，RX配置为上拉或浮空输入，如果只选择一种模式，那么就只配置一个引脚即可</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//TX引脚配置</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//RX引脚配置</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//3.配置USART，使用结构体配置即可</span></span><br><span class="line">USART_InitTypeDef USART_InitStruct;</span><br><span class="line">USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;<span class="comment">//波特率配置</span></span><br><span class="line">USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//硬件流控配置,这里不适用</span></span><br><span class="line">USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; <span class="comment">//这里配置串口接收和发送模式都使用，可以只配置一个</span></span><br><span class="line">USART_InitStruct.USART_Parity = USART_Parity_No; <span class="comment">//校验位，不使用校验</span></span><br><span class="line">USART_InitStruct.USART_StopBits = USART_StopBits_1; <span class="comment">//停止位配置1位</span></span><br><span class="line">USART_InitStruct.USART_WordLength = USART_WordLength_8b;<span class="comment">//数据位长度，没有奇偶校验位，所以选择8位数据位</span></span><br><span class="line">USART_Init(USART2,&amp;USART_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果需要使用中断，需要在此处调用USART_ITConfig函数，然后再配置NVIC即可*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.配置中断和NVIC</span></span><br><span class="line">USART_ITConfig(USART2,USART_IT_RXNE,ENABLE);</span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel = USART2_IRQn;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.使能USART，USART_Cmd</span></span><br><span class="line">USART_Cmd(USART2,ENABLE);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetData</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> rData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用extern也是同样的效果’</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetFlag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(rFlag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">rFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//自定义清除标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART2,USART_IT_RXNE)== SET)</span><br><span class="line">&#123;</span><br><span class="line">  rData = USART_ReceiveData(USART2);</span><br><span class="line">  rFlag = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">USART_ClearITPendingBit(USART2,USART_IT_RXNE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中断服务函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Data;</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">  UsartInit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(UsartGetFlag()== <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Data = UsartGetData();</span><br><span class="line">UsartSend(Data);</span><br><span class="line">&#125;</span><br><span class="line">      OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,Data,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>该实验只能实现对单字符的接收</strong></p></blockquote><h3 id="实验-USART串口数据包">实验-USART串口数据包</h3><h3 id="实验-printf函数的移植">实验-printf函数的移植</h3><blockquote><p><strong>在Keil中，使用printf函数之前我们需要打开工程选项，找到Target，勾选Use MicroLIB(使用微库)</strong></p><p>MicroLIB：是Keil为嵌入式平台优化的一个精简库</p></blockquote><p><code>方法1：printf的重定向：</code>printf默认输出到屏幕，但是单片机没有屏幕，所以需要我们重定向到串口</p><p>在对应串口模块中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*该定义usart.c的结尾加上*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//该stdio.h头文件在usart.h中再进行引用一次，即可在调用usart.h时使用printf了</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE* f)</span></span><br><span class="line">&#123;</span><br><span class="line">    UsartSend(ch);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*fputc是printf函数底层，使用printf时，是不断调用fputc进行打印的，我们把fputc函数重定向到串口，printfzi*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c中*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    UsartInit();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Num=%d\r\n&quot;</span>,<span class="number">66666</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方法只能将printf输出到调用串口发送函数的那一个串口当中，无法在其他串口中使用。</p><p>解决方法：使用标准库函数sprintf</p></blockquote><p><code>方法2：sprintf函数使用</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c中*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    UsartInit();</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line"> <span class="built_in">sprintf</span>(String,<span class="string">&quot;Num=%d\r\n&quot;</span>,<span class="number">99999</span>);</span><br><span class="line">UsartSendString(String);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>sprintf的作用是：发动格式化字符串到指定str中，可以实现拼接字符串，这样即可实现每个串口的格式化打印</strong></p></blockquote><p><code>方法三：使用可变参数封装sprintf</code></p><p>使用头文件<code>&lt;stdarg.h&gt;</code></p><p>具体封装过程百度即可</p><h3 id="数据包">数据包</h3><h4 id="数据包介绍">数据包介绍</h4><p><strong>数据包分为</strong>：<code>HEX数据包</code>和<code>文本数据包</code>，分别对应<strong>文本模式和HEX模式</strong></p><p><strong>作用</strong>：将属于同一批的数据进行打包和分割。</p><ol><li><code>HEX数据包:</code></li></ol><p><img src="./image/image-20241204165308342.png" alt="image-20241204165308342"></p><blockquote><p>通过添加包头包尾分割数据</p><p>数据包头：0xFF</p><p>数据包尾：0xFE</p><hr><p><code>优点:</code><strong>传输最直接，解析数据非常简单，比较适合一些模块发送原始的数据，比如一些使用串口通信的陀螺仪、温湿度传感器数据</strong></p><p><code>缺点：</code>灵活性不足，载荷容易和包头包尾重复(可能传输的数据是包头包尾的数据)</p><p><code>解决方案：</code></p><ol><li><strong>限制载荷数据的范围，在发送时对数据变化范围显示</strong></li><li><strong>如果无法避免载荷数据和包头包尾重复，我们就尽量使用固定长度的数据包，经过几个数据包的数据对齐后，剩下的数据包应该就没有问题了</strong></li><li><strong>增加包头包尾的数量，并且尽量呈现出载荷数据出现不了的状态</strong></li></ol><hr><p><code>HEX数据包格式选择</code>：</p><ol><li>如果数据容易出现与包头包尾重复的情况，就最好选择固定包长</li><li>如果数据不容易出现与包头包尾重复的情况，可以选择可变包长，这样就非常的灵活，只需要确定唯一的包头包尾就知道数据包长度</li></ol></blockquote><ol start="2"><li><code>文本数据包:</code></li></ol><p><img src="./image/image-20241204184721167.png" alt="image-20241204184721167"></p><blockquote><p>在HEX数据包中，数据是以原始字节数据本身呈现，而在文本数据包中，每个字节都经过了编码和译码，表现出的就是文本格式，但实际上都还是一个字节的HEX数据</p></blockquote><blockquote><p><strong>文本数据包基本不用担心载荷和包头包尾重复的问题</strong></p><p><strong>包头：‘@’</strong></p><p><strong>包尾：‘\r’  ‘\n’</strong></p><p><strong>载荷数据：除了包头包尾的数据</strong></p><hr><p><code>优点:</code><strong>数据直观易理解，非常灵活，比较适合一些输入指令进行人机交互的场合，比如蓝牙模块常用的AT指令，CNC和3D打印机常用的G代码</strong></p><p><code>缺点：</code>解析效率低，比如100，HEX发送的就是一个字节100，文本数据包却是三个字符’1’，‘1’，‘0’。</p></blockquote><h4 id="数据包的发送和接收">数据包的发送和接收</h4><ol><li><p><code>数据包的发送:</code>使用串口对应发送**数组(HEX数据包)<strong>或者</strong>字符串函数(文本数据包)**即可</p></li><li><p><code>数据包的接收</code>：</p></li></ol><ul><li>固定包长HEX数据包接收</li></ul><p><img src="./image/image-20241204190804966.png" alt="image-20241204190804966"></p><blockquote><p><strong>使用状态机编程思想</strong>：先根据项目要求定义状态，画几个圈，然后考虑号各个状态会在什么情况下会进行转移，如何转移，画好线和转移条件，最后根据这个来编程</p></blockquote><ul><li>可变包长文本数据包接收</li></ul><p><img src="./image/image-20241204192226109.png" alt="image-20241204192226109"></p><h3 id="实验-串口收发HEX数据包">实验-串口收发HEX数据包</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*此处只列举出了新添加的变量和函数，具体的见上方*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> RxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> TxPacket[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendPacket</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*发送数据包,包头包尾自定义*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendPacket</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">UsartSend(<span class="number">0xFF</span>);<span class="comment">//包头</span></span><br><span class="line">UsartSendArray(TxPacket,<span class="number">4</span>);<span class="comment">//固定长度为4的数据</span></span><br><span class="line">  UsartSend(<span class="number">0xFE</span>);<span class="comment">//包尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用状态机的编程思想，每次中断接收一个字节数据*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART2,USART_IT_RXNE)== SET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="number">0xFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxPacket[count++] = RxData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(count&gt;=<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="number">0xFE</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">rFlag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART2,USART_IT_RXNE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">LED_Init();</span><br><span class="line">Key_Init();</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">  UsartInit();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(UsartGetFlag()== <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">                UsartSendPacket(TxPacket);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用串口助手发送FF 05 06 07 08 FE，可以发现串口回显FF 05 06 07 08 FE，OLED上显示05 06 07 08的数据</p></blockquote><h3 id="实验-串口收发文本数据包">实验-串口收发文本数据包</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> RxTextPacket[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> rFlag=<span class="number">0</span>;<span class="comment">//接受完成标志,还可以避免接收太快来不及使用数据就被覆盖了</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART2,USART_IT_RXNE)== SET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">&#x27;@&#x27;</span>&amp;&amp;rFlag == <span class="number">0</span>)<span class="comment">//接收慢一点，等主函数使用完,避免主函数中的数据可能是上一个数据包和这个数据包中的内容</span></span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">RxTextPacket[count++] = RxData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxTextPacket[count] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//组成完成字符串</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">rFlag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART2,USART_IT_RXNE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">LED_Init();</span><br><span class="line">OLED_Init();</span><br><span class="line">  UsartInit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(rFlag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(RxTextPacket,<span class="string">&quot;LED_ON&quot;</span>)== <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> LED1_ON();</span><br><span class="line"> UsartSendString(<span class="string">&quot;LED1_ON_OK\r\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(RxTextPacket,<span class="string">&quot;LED_OFF&quot;</span>)== <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> LED1_OFF();</span><br><span class="line"> UsartSendString(<span class="string">&quot;LED1_OFF_OK\r\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> UsartSendString(<span class="string">&quot;ERROR\r\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> rFlag = <span class="number">0</span>;<span class="comment">//使用完成数据标志，可以避免接收太快，之前那种方式可能会造成接收过快数据覆盖问题</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>使用串口助手发送@LED_ON + 换行回车，LED灯亮起</strong></p><p><strong>使用串口助手发送@LED_OFF + 换行回车，LED灯熄灭</strong></p></blockquote><h2 id="I2C">I2C</h2><h3 id="I2C介绍">I2C介绍</h3><p><img src="./image/image-20241206141429374.png" alt="image-20241206141429374"></p><blockquote><p><strong>SPI特点</strong>：同步、半双工，两根通信线SCL和SDA</p><hr><p>第1个模块：MPU6050模块，进行姿态测量，使用I2C通信协议</p><p>第2个模块：OLED模块，显示图片，字符灯信息，使用I2C协议</p><p>第3个模块：AT24C02，存储器模块，使用I2C协议</p><p>第4个模块：DS3231，实时时钟模块，使用I2C协议</p><hr><p>I2C多主多从：相当于发生总线冲突，I2C协议会进行仲裁，胜利的一方取得总线控制权，失败的一方变回从机。同时在多主机的模型下，还要进行时钟同步</p></blockquote><h3 id="硬件电路与优缺点">硬件电路与优缺点</h3><p><img src="./image/image-20241206144150840.png" alt="image-20241206144150840"></p><blockquote><p><code>一主多从模式：</code></p><p>SCL上挂载多个从设备，任何情况下从机不允许控制SCL，对于SDA数据线，从机不允许主动发起对SDA的控制，只有等待主机发送请求时，从机响应才能短暂获取</p><hr><p><strong>I2C采用外置<code>弱上拉电阻加开漏输出</code>的电路结构</strong>：</p><p><code>1.选择开漏输出，而不选择推挽输出：</code></p><p>如果使用推挽输出，如果总线时序没调整好，可能主机和从机都处于输出状态，且一个输出高电平，一个输出低电平，此时就会出现电源短路的问题。</p><p>而开漏输出只能直接输出低电平，高电平下没有驱动能力，输出取决于外部电路。</p><p>这样的话，就保证了所有设备都只能输出低电平而不能输出高电平</p><p><code>2.加上拉电阻:</code></p><p>为了避免开漏输出高电平时造成的引脚浮空，同时I2C通信需要输出高电平的能力，由于开漏输出下不能直接输出高电平，此时需要在外部加一个上拉电阻，此时为弱上拉，使能被外部拉高</p><p><code>这样设计电路的好处:</code></p><ol><li>完全杜绝电源短路现象，保证电路安全</li><li>避免引脚模式的频繁切换，开漏加弱上拉的模式，同时兼具了输入和输出的功能</li><li><strong>开漏模式下具有&quot;线与&quot;的特性，即：只要有任意一个或多个设备输出了低电平，总线就处于低电平，只有所有的设备输出高电平，总线才输出高电平。I2C可以利用这个特性，执行多主机模式下的时钟同步和总线仲裁。</strong></li></ol><p><code>限制：</code></p><p>​<strong>由于I2C开漏外加上拉电阻的电路结构，使得通信线高电平的驱动能力比较弱，导致通信线由低电平转换为高电平时，上升沿耗时会比较长，这样就限制了I2C的最大通信速度，所以I2C标准模式为100Khz，快速模式也只有400Khz，一般来说我们就认为I2C最快速度为400khz，相对于SPI的速度来说慢了许多</strong></p></blockquote><h3 id="I2C时序基本单元">I2C时序基本单元</h3><ul><li><code>1.起始条件和终止条件:</code></li></ul><p><img src="./image/image-20241206170442283.png" alt="image-20241206170442283"></p><blockquote><p><strong>正常情况下：SCL和SDA都处于高电平</strong></p><p><strong>起始条件：S/Sr</strong></p><p><strong>终止条件：P</strong></p><p>从机收到起始条件后，自身复位，等待主机发送信息</p></blockquote><ul><li><code>2.主机发送字节时序</code>：</li></ul><p><img src="./image/image-20241206170806836.png" alt="image-20241206170806836"></p><blockquote><p><strong>I2C发送字节与串口不同，I2C是高位先行，串口是低位先行</strong></p><p><code>发送字节过程总结下来就是</code>：</p><p><strong>时钟线SCL处于低电平时，主机设置数据线SDA的电平</strong></p><p><strong>时钟线SCL处于高电平时，从机读取数据线SDA的电平。</strong></p><p>显然，从机读取到的电平就是主机在时钟线低电平时设置的电平</p><hr><p><code>对中断处理：</code></p><p>如果主机一个字节发送一半，突然进中断了，那么此时SCL和SDA上的电平暂停变化，会不断拉长，传输完全暂停，等中断结束后，主机回来继续操作</p><hr><p><code>SCL和SDA控制权：</code></p><p><strong>该过程中，SCL和SDA都由主机掌控，从机只能被动读取</strong></p></blockquote><ul><li><code>主机接收字节时序:</code></li></ul><p><img src="./image/image-20241206172222919.png" alt="image-20241206172222919"></p><blockquote><p><code>发送字节过程总结下来就是</code>：</p><p><strong>时钟线SCL处于低电平时，从机设置数据线SDA的电平</strong></p><p><strong>时钟线SCL处于高电平时，主机读取数据线SDA的电平。</strong></p><p>显然，主机读取到的电平就是从机在时钟线低电平时设置的电平</p><hr><p><code>SCL和SDA控制权:</code></p><p>SCL全程由主机控制</p><p><strong>主机在接收之前，需要释放SDA(SDA拉高)，此时让从机获得SDA控制权才能将数据放到SDA上!!!</strong></p></blockquote><ul><li><code>3.应答机制:</code></li></ul><p><img src="./image/image-20241206172908982.png" alt="image-20241206172908982"></p><blockquote><p>根据应答机制，可以判断对方是否接收到了该数据</p><p>0：表示从机应答</p><p>1：表示从机非应答</p></blockquote><h3 id="I2C从机地址">I2C从机地址</h3><blockquote><p><code>从机地址介绍:</code></p><p>从机地址，每个从机设备出厂时都会分配一个7位或者10位地址，对应地址是什么可以在对应模块找到地址，比如MPU6050的7位地址为1101 000，AT24C02的7位地址为1010 000</p><hr><p><code>相同芯片挂载时对地址的处理:</code></p><p>一般不同芯片地址不同，相同型号芯片地址相同。</p><p>当相同芯片挂载在同一条总线时，此时需要用到地址中的可变部分，一般地址最后几位是可以在电路中改变的，比如MPU6050，最后一位由芯片上的AD0引脚决定，当该引脚接低电平就是1101 000，接高电平就是1101 001。而AT24C02地址的最后三位分明由引脚A0,A1,A2决定</p><p>一般I2C的从机设备地址，高位都是厂商确定，低位可以由不同引脚切换，这样就可以保证多个相同芯片挂载时地址都不一样</p></blockquote><h3 id="I2C时序">I2C时序</h3><p><code>时序1：指定地址写(常用)</code></p><p><img src="./image/image-20241206174948487.png" alt="image-20241206174948487"></p><p><img src="../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/image/image-20241206175159856.png" alt="image-20241206175159856"></p><blockquote><p><strong>该时序是对指定设备的指定寄存器写入指定数据的操作</strong></p><p>上图为逻辑分析仪的结果：</p><ol><li><p><strong>最开始为起始条件</strong></p></li><li><p><strong>之后，必须是发送一个字节的时序，内容为从机地址+读写位(7+1共8位)</strong></p></li></ol><p>上图对应为：1101 000 0(前七位为MPU6050地址，最后一位为0代表写入操作)</p><ol start="3"><li><strong>紧跟着的单元就是，接收从机的应答位(ACK，RA)。RA之后有个上升沿，代表从机释放SDA产生，交出了SDA控制权。</strong></li></ol><p>上图对应为：高电平器件，主机读取SDA，发现是0，代表主机进行寻址，有人应答了</p><ol start="4"><li><strong>然后的一个字节为寄存器地址。</strong></li></ol><p>上图为00011001(0x19)，即操作0x19地址的寄存器</p><ol start="5"><li><p><strong>紧接着又是从机应答位</strong></p></li><li><p><strong>然后发送写入寄存器的内容</strong></p></li></ol><p>上图为10101010，即发送数据为0xAA</p><ol start="7"><li><p><strong>又是一个从机应答位</strong></p></li><li><p><strong>最后一个为终止条件</strong></p></li></ol><hr><p><code>指定地址连续写入多个字节：</code></p><p><strong>如果想要发送多个字节，只需要将第6步发送写入字节和接收应答重复N次即可，写入几个字节就重复几次。</strong></p><p><strong>因为地址指针会在写入一个数据后自动+1，所以不用移动地址指针</strong></p></blockquote><p><code>时序2：当前地址读(不怎么使用):</code></p><p><img src="./image/image-20241206213240665.png" alt="image-20241206213240665"></p><p><img src="../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/image/image-20241206213259135.png" alt="image-20241206213259135"></p><blockquote><ol><li><strong>起始条件</strong></li><li><strong>主机发送一个字节(从机地址+读写位)，发送完后紧跟一个从机应答ACK</strong></li></ol><p><strong>图上为1101000 1 表示读取1101000的数据</strong></p><ol start="3"><li><strong>然后SDA控制权移交给从机，主机开始读取从机发送数据(不用发送读取寄存器地址，从机会将当前地址指针指向的寄存器的值发送)，不能指定读的地址。接收完后紧跟发送一个非应答(SA:1)，这样从机读取到主机非应答后，就知道主机不想要继续了，交还SDA控制权</strong></li></ol><p><strong>图上接收的数据为00001111(0x0F)</strong></p><ol start="4"><li><strong>结束条件</strong></li></ol><p><code>由于不能指定读的地址。所以该时序(当前地址读)用的不多</code></p><hr><p><code>当前地址连续读多个字节：</code></p><p><strong>如果想要读取多个字节，3处的读取一个字节后，就应该发送<code>应答</code>(RA:0)，然后重复读取字节，发送应答，最后一个字节读取完后，跟上一个<code>非应答</code>就可以结束读取</strong></p><p><strong>因为地址指针也会在读取一个数据后自动+1，所以不用移动地址指针</strong></p></blockquote><p><code>时序3：指定地址读(常用):</code></p><p><img src="./image/image-20241206214232444.png" alt="image-20241206214232444"></p><p><img src="../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/image/image-20241206214817354.png" alt="image-20241206214817354"></p><p><img src="../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/image/image-20241206214842186.png" alt="image-20241206214842186"></p><blockquote><p><strong>指定地址读为复合格式，是指定地址写和当前地址读的混合</strong></p><p>复合格式：前面部分为指定地址写(写的数据的前面)，后面部分为当前地址读</p><hr><ol><li><strong>起始条件</strong></li><li><strong>发送一个字节，从机地址+读写位(此处应为写位为0)，然后是从机应答位ACK(RA:0)</strong></li><li><strong>在发送一个字节，指定写入的地址，指定完成后从机寄存器指针就指向该地址，然后是从机应答位ACK(RA:0</strong>)</li></ol><p><code>该部分为指定地址写前面部分</code></p><hr><ol start="4"><li><strong>(这里前面可以加一个停止，也可以不加)不发送写入的内容，而重复起始条件Sr(Start Repeat)，相当于另起一个时序</strong></li><li><strong>重新发送一个字节，从机地址+读写位(此处应为读位为0），从机应答位ACK(RA:0)</strong></li><li><strong>主机接收一个字节，主机接收到的数据就是指定写入地址处的数据，然后发送一个非应答(SA:1)</strong></li><li><strong>停止条件</strong></li></ol><p><strong>连起来就是：先起始，写入地址，停止。再起始，读当前位置，停止</strong></p><hr><p><code>指定地址连续读多个字节：</code></p><p><strong>如果想要读取多个字节，6处的读取一个字节后，就应该发送<code>应答</code>(RA:0)，然后重复读取字节，发送应答，最后一个字节读取完后，跟上一个<code>非应答</code>就可以结束读取</strong></p><p><strong>因为地址指针也会在读取一个数据后自动+1，所以不用移动地址指针</strong></p></blockquote><h3 id="MPU6050">MPU6050</h3><h4 id="MPU6050简介">MPU6050简介</h4><p><img src="./image/image-20241207201409336.png" alt="image-20241207201409336"></p><blockquote><p><code>6轴姿态传感器：</code>3轴加速度(加速度计) + 3轴角速度(陀螺仪传感器)</p><p><code>9轴姿态传感器：</code>3轴加速度 + 3轴角速度 + 3轴磁场强度(磁力计)</p><p><code>10轴姿态传感器：</code>3轴加速度 + 3轴角速度 + 3轴磁场强度 + 1个气压强度(气压计)</p></blockquote><blockquote><p><code>一些术语：</code></p><p><code>加速度计：</code>简称为Accel或者Acc或A，X,Y,Z三轴都有一个测量加速度。<strong>上面第二幅图就是加速度计</strong>，实际上加速度就是一个就是一个测力计。</p><p>使用加速度计求角度的时候只能在物体静止的时候使用，当物体运动起来时，这个角度会受运动加速度的影响而变得不准确。</p><p><code>即特性：</code>加速度计具有静态稳定性，不具有动态稳定性</p><hr><p><code>陀螺仪传感器：</code>简称为Gyro或者G，可以测量三轴的角速度值，分别表示芯片绕X轴、Y轴、Z轴旋转的角速度，<strong>对应上面第三幅图，为陀螺仪的机械模型</strong>。该芯片只能测得角速度，而不能直接测得角度，通过对角速度积分可以得到角度</p><p>当物体静止时，角速度的值会因为噪声无法完全归零，经过积分的不断累积，小噪声就会导致计算出来的角度产生缓慢的漂移，角速度积分得到的角度经不起时间的考验，但角度无论是运动还是静止都是没问题的</p><p><code>特性：</code>陀螺仪具有动态稳定性，不具有静态稳定性</p><hr><p><code>姿态解算：</code></p><p>这两个传感器特性刚好互补，通过互补滤波就能融合得到静态和动态都稳定的姿态角了。</p><hr><p><code>了解姿态角/欧拉角:</code></p><p><a href="https://blog.csdn.net/sinolover/article/details/90671784">什么是欧拉角/姿态角？_欧拉角和姿态角区别-CSDN博客</a></p></blockquote><h4 id="MPU6050参数">MPU6050参数</h4><p><img src="./image/image-20241207205112946.png" alt="image-20241207205112946"></p><blockquote><p><code>部分重要参数，具体参数清查看MPU6050手册</code></p><p>芯片输出的是一个随姿态变化而变化的电压，要想量化电压那么就需要AD转换器，芯片自带16位ADC，输出结果是有符号数</p><hr><p><code>满量程：</code>决定对应16位ADC值达到最大值时对应的物理参量，具有多个选择，根据具体物体运动的剧烈程度(实际情况)选择，避免超过满量程。</p><p>量程越小，分辨率越高，量程越大，范围越广</p><hr><p><code>低通滤波:</code>如果输出数据抖动很厉害，可以加一点低通滤波，这样就会更平缓</p><p><code>可配置时钟源和采样分频:</code>两个参数配合使用，时钟源通过采样分频为AD转换和内部其他电路提供时钟，控制分频系数就可以控制AD转换的快慢了</p><hr><p><code>对从机地址的处理</code>：</p><p>第一种从机地址：110 1000(0x68)</p><p>第二种从机地址(读写位)：1101 0000(0xD0)或者1101 0001(0xD1)</p><p>所以这两种从机地址说法都是正确的，一个是没带上读写位的从机地址，一个是带上从机位的地址。</p><p>实际发送一个字节时，只需要不带读写为的从机地址左移1位，再或上读写位即可</p><p>(0x68 &lt;&lt; 1 ) |   1/0</p><p>也可以直接就写融入读写位的从机地址</p><p>0xD1/0xD0</p></blockquote><h4 id="硬件电路-3">硬件电路</h4><p><img src="./image/image-20241207221537437.png" alt="image-20241207221537437"></p><blockquote><p><strong>最右边的是MPU6050的芯片</strong>：</p><p>芯片本身引脚非常多，包括I2C通信引脚，供电，帧同步等，很多引脚用不到，还有些引脚是芯片最小系统里的固定连接，一般手册中有</p><hr><p><strong>左下角是8针的排针</strong>：</p><ul><li><strong>VCC和GND</strong>：电源供电</li><li><strong>SCL和SDA</strong>：I2C通信引脚，可以看到外部电路已经内置两个4.7K上拉电阻了，直接接即可，不用再接上拉电阻了</li><li><strong>XCL、XDA</strong>：主机I2C引脚，设计是为了扩展芯片功能，6轴传感器不够时，这个XCL和XDL用于外接磁力计或者气压计扩展为9轴传感器等，接上后MPU6050主机接口可以直接访问这些扩展芯片的数据，将数据读入MPU6050,里面有DMP单元进行数据融合和姿态解算。</li></ul><p>如果不需要解算功能，可以直接把磁力计或气压计挂载到SCL和SDA上，因为I2C本来就可以挂载多设备</p><ul><li><strong>AD0</strong>：7位从机地址最低位，电路中可以看到默认若下拉到低电平所以悬空状态下为0。对应从机地址为1101 000，接VCC的话就是1101 001</li><li><strong>INT</strong>：中断输出引脚，可以配置芯片内部事件触发中断引脚输出，如：数据准备好了、I2C主机错误等，不使用可以不配置</li></ul><p>除此之外，芯片内部还内置了一些实用的小功能：自由落体监测、运动监测、零运动监测等，这些信号都可以触发INT引脚产生电平跳变，可以进行中断信号的配置</p><hr><p><strong>左上角是LDO，低压差线性稳压器</strong>：</p><p>这部分是供电的逻辑，手册中可以看到MPU6050的VDD供电为2.375~3.46V，属于3.3V供电设备，不能直接接5V，为了扩大供电范围，就加了个3.3V的稳压器，使输入端电压VCC_5V可以再3.3V到5V之间，经过3.3V的稳压器给芯片端供电。最后跟上的是一个电源知识灯，如果有点就会亮。</p><p>这一模块是否需要可以根据需求来，如果已经有稳定的3.3V的电源就不需要这部分了</p></blockquote><h4 id="MPU6050框图">MPU6050框图</h4><p><img src="./image/image-20241207225256921.png" alt="image-20241207225256921"></p><blockquote><p><strong>时钟部分</strong>：一般使用内部时钟，硬件电路上也是直接接地和没有引出</p><hr><p><strong>灰色部分</strong>：</p><p>是芯片内部传感器，包括XYZ轴的加速度计(X Accel等)，XYZ轴的角速度计(X Gyro等)</p><p>还内置了一个温度传感器(Temp Sensor)，也可用于测量温度。</p><p>这些传感器转换完成后，数据统一放在传感器寄存器(Sensor Register)中，读取该数据寄存器就能得到传感器测量的值。</p><p>芯片内部转换都是全自动进行(类似与AD连续转换+DMA转运)，每个ADC输出对应都是16位数据寄存器，不存在数据覆盖问题。需要数据直接读取即可</p><hr><p><strong>最左边Self test</strong>：</p><p>这是芯片的自测单元，当启动自测后，芯片内部会模拟一个外力施加在传感器上，这个外力导致传感器数据会比平时大一些。</p><p><strong>自测方法：先使能自测，读取数据，再失能自测，读取数据。两个数据相减得到的数据叫做自测响应，芯片手册中给出了一个范围，如果在这个范围内，代表芯片没问题。如果不在，就说明芯片可能坏了，使用的话就要小心点。</strong></p><p><code>手册找到自测范围如下：在这个范围内就代表芯片正常</code></p><p><img src="./image/image-20241207235118026.png" alt="image-20241207235118026"></p><hr><p><strong>最下方Charge Pump</strong>：电荷泵，进行升压操作</p><hr><p><strong>最右边是寄存器和通信接口部分：</strong></p><p>很多寄存器：配置寄存器等</p><p>通信接口：从机I2C和SPI接口，主机I2C接口用于扩展设备通信</p><p>里面有个Digital Motion Processor-数字运动处理器简称DMP，是芯片内部自带的一个姿态解算的硬件算法，配合官方DMP库可以进行姿态解算</p><hr><p><strong>右下角为供电部分</strong>：按照手册电压要求和参考电路接线即可</p></blockquote><h4 id="MPU6050产品手册">MPU6050产品手册</h4><p>I2C通信，电气特性等知识均可查看</p><h4 id="MPU6050寄存器映像手册">MPU6050寄存器映像手册</h4><p>所有的寄存器都在里面，但是不需要全部了解</p><p><strong>需要了解的如下：每个寄存器具体介绍在手册向下翻即可</strong></p><p><img src="./image/image-20241207233440068.png" alt="image-20241207233440068"></p><blockquote><p><code>SMPLRT_DIV</code>：<strong>采样频率分频寄存器</strong>，配置采样寄存器的分频系数，分频越小，内部AD转换越快，数据刷新越快。</p><p>采样频率 = (陀螺仪晶振)陀螺仪输出时钟频率/(1+分频值)</p><p><img src="./image/image-20241218223941780.png" alt="image-20241218223941780"></p><p>Bit7~Bit0：值越小，越快，根据实际需求来</p><p><strong>对应配置：0x09 (对应10分频)</strong></p><hr><p><code>CONFIG</code>：<strong>配置寄存器</strong>，分为外部同步设置和低通滤波器配置，外部同步这里不使用不看。低通滤波器可以使输出数据更平滑，选择值为0~7，数值越大，抖动越下，0代表不滤波</p><p><img src="./image/image-20241218224001365.png" alt="image-20241218224001365"></p><p>Bit7~6：无关位</p><p>Bit5~3：外部同步，不需要，给0即可</p><p>Bit2~0：数字低通滤波器，也是根据需求配置。我们给个110，比较平滑的配置</p><p><strong>对应配置为：0x06</strong></p><hr><p><code>GYRO_CONFIG</code>：<strong>陀螺仪配置寄存器</strong>，高3位是XYZ轴的自测使能位，中间两位是满量程选择位，最后三位没使用</p><p><img src="./image/image-20241218224017264.png" alt="image-20241218224017264"></p><p>Bit7~Bit5：自测使能位，不自测给0即可</p><p>Bit4~Bit3:满量程选择，根据实际需求选择。我们给11为最大量程</p><p>Bit2~Bit0：无关位</p><p><strong>对应配置为：0x18</strong></p><p><img src="./image/image-20241207235348661.png" alt="image-20241207235348661"></p><hr><p><code>ACCEL_CONFIG</code>：<strong>加速度计配置寄存器</strong>，高3位是XYZ轴的自测使能位，中间两位是满量程选择位，最后三位用于配置高通滤波器(内置小功能会用到)</p><p><img src="./image/image-20241218224036938.png" alt=""></p><p>Bit7~Bit5：自测使能位，不自测给0即可</p><p>Bit4~Bit3:满量程选择，根据实际需求选择。我们给11为最大量程</p><p>Bit2~Bit0：高通滤波器，不使用给00</p><p><strong>对应配置为：0x18</strong></p></blockquote><p><img src="./image/image-20241207233637672.png" alt="image-20241207233637672"></p><blockquote><p><code>加速度计XYZ轴寄存器：</code>_L 表示低8位，_H表示高8位</p><p>ACCEL_XOUT_H ：</p><p>ACCEL_XOUT_L ：</p><p>ACCEL_YOUT_H ：</p><p>ACCEL_YOUT_L ：</p><p>ACCEL_ZOUT_H ：</p><p>ACCEL_ZOUT_L ：</p><p><code>加速度计XYZ轴寄存器：</code>_L 表示低8位，_H表示高8位</p><p>GYRO_XOUT_H：</p><p>GYRO_XOUT_L ：</p><p>GYRO_YOUT_H ：</p><p>GYRO_YOUT_L ：</p><p>GYRO_ZOUT_H ：</p><p>GYRO_ZOUT_L ：</p><p><code>温度传感器寄存器：</code></p><p>TEMP_OUT_H ：</p><p>TEMP_OUT_L ：</p><p><code>查看对应手册的寄存器讲解部分即可</code></p></blockquote><p><img src="./image/image-20241207234205598.png" alt="image-20241207234205598"></p><blockquote><p><code>具体某位干什么查看手册对应寄存器功能</code></p><p><code>PWR_MGMT_1：电源管理寄存器1:</code></p><p><img src="../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/image/image-20241208000537943.png" alt="image-20241208000537943"></p><p><img src="./image/image-20241218222543311.png" alt="image-20241218222543311"></p><p>Bit7(DEVICE)：设备复位，配置给0不复位</p><p>Bit6(SLEEP)：设备睡眠，配置时给0不睡眠</p><p>Bit5(CYCLE)：循环模式，配置给0不循环</p><p>Bit4(无关位)：配置给0即可</p><p>Bit3(温度传感器失能)：配置给0，不失能</p><p>Bit2~0(选择时钟)：000选择内部时钟，手册非常建议选择陀螺仪时钟，我们配置为001，选择X轴陀螺仪时钟</p><p><strong>对应配置为：0x01</strong></p><hr><p><code>PWR_MGMT_2：电源管理寄存器2:</code></p><p><img src="./image/image-20241218223451238.png" alt="image-20241218223451238"></p><p>Bit7~6：循环模式唤醒频率，给00，不需要</p><p>Bit5~0：后六位为每个轴的待机位，不需要待机，全部给0即可</p><p><strong>对应配置为：0x00</strong></p><hr><p><code>WHO_AM_I：器件ID号:</code>只读的，中间六位固定为110100</p><p><img src="./image/image-20241208000027373.png" alt="image-20241208000027373"></p></blockquote><p><img src="./image/image-20241208000214450.png" alt="image-20241208000214450"></p><blockquote><p>注意这里写的是：所有寄存器上电后默认都是0x00，除了107号寄存器和117号寄存器</p><p><strong>107号</strong>：<strong>电源管理寄存器1</strong>，默认为0x40(01000000)，可以看到SLEEP位为1，及<strong>上电默认睡眠模式，使用时记得解除睡眠模式，否则操作其他寄存器是无效的</strong></p></blockquote><blockquote><p><strong>117号</strong>：器件ID寄存器配置初始化值为0x68</p><p><img src="./image/image-20241208000407336.png" alt="image-20241208000407336"></p></blockquote><h3 id="软件模拟I2C读写">软件模拟I2C读写</h3><blockquote><p><strong>使用任意GPIO口模拟即可，步骤为：</strong></p><ol><li><strong>开启对应RCC时钟</strong></li><li><strong>配置GPIO口为开漏输出</strong></li><li><strong>配置SCL和SDA引脚默认高电平</strong></li></ol></blockquote><h4 id="软件I2C代码实现">软件I2C代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyI2C.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYI2C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYI2C_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元1：起始条件SCL高电平期间，SDA从高电平切换到低电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元1：结束条件SCL高电平期间，SDA从低电平切换到高电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：发送一个字节，1位1位的发送，从最高位开始*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：接收一个字节，SCL低从机设置，SCL高主机读取*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveByte</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：发送应答，逻辑和发送字节类似*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendAck</span><span class="params">(<span class="type">uint8_t</span> AckBit)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：接收应答，逻辑和接收字节类似*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveAck</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyI2C.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SCL</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line"> GPIO_WriteBit(GPIOA,GPIO_Pin_2,(BitAction)BitVal);</span><br><span class="line"> Delay_ms(<span class="number">10</span>);<span class="comment">//延时用于控制每个时序步骤之间的时间，确保I2C时序的稳定性。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SDA</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line"> GPIO_WriteBit(GPIOA,GPIO_Pin_3,(BitAction)BitVal);</span><br><span class="line"> Delay_ms(<span class="number">10</span>);<span class="comment">//延时用于控制每个时序步骤之间的时间，确保I2C时序的稳定性。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_R_SCL</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">uint8_t</span> bitValue;</span><br><span class="line">   bitValue = GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2);</span><br><span class="line"> Delay_ms(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bitValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_R_SDA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">uint8_t</span> bitValue;</span><br><span class="line">   bitValue = GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_3);</span><br><span class="line"> Delay_ms(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bitValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通过前面几个函数的封装我们实现了函数名称、端口号的替换，需要替换端口或者移植时就只需要对前四个函数修改即可,这样编程很方便*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">  GPIO_SetBits(GPIOA,GPIO_Pin_2 | GPIO_Pin_3);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元1：起始条件SCL高电平期间，SDA从高电平切换到低电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//Sr重复起始条件时SCL是低电平，SDA高低电平不确定，所以先拉高SDA再拉高SCL确保都能回归高电平</span></span><br><span class="line"> MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"> MyI2C_W_SDA(<span class="number">0</span>);<span class="comment">//SDA先拉低</span></span><br><span class="line"> MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*基本单元1：结束条件SCL高电平期间，SDA从低电平切换到高电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> MyI2C_W_SDA(<span class="number">0</span>);<span class="comment">//SCL一定为低电平，SDA高低电平不确定，为了确保释放SDA时能产生上升沿，要先拉低SDA</span></span><br><span class="line"></span><br><span class="line"> MyI2C_W_SCL(<span class="number">1</span>);<span class="comment">//SCL先拉高</span></span><br><span class="line"> MyI2C_W_SDA(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：发送一个字节，1位1位的发送，从最高位开始*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// /*发送最高位*/</span></span><br><span class="line"><span class="comment">//   进来时SCL为低电平</span></span><br><span class="line"><span class="comment">// MyI2C_W_SDA(Byte &amp; 0x80);//因为保证了SCL是低电平，所以此时直接放入数据即可</span></span><br><span class="line"><span class="comment">// MyI2C_W_SCL(1);//SCL先拉高后从机会立刻读取刚刚放入的数据</span></span><br><span class="line"><span class="comment">// MyI2C_W_SCL(0);//SCL拉低完成一个脉冲</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// /*发送次高位*/</span></span><br><span class="line"><span class="comment">// MyI2C_W_SDA(Byte &amp; 0x40);</span></span><br><span class="line"><span class="comment">// MyI2C_W_SCL(1);</span></span><br><span class="line"><span class="comment">// MyI2C_W_SCL(0);</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里使用循环直接实现8个字节的发送，SCL低主机设置，SCL高从机读取*/</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">  MyI2C_W_SDA(Byte &amp; (<span class="number">0x80</span> &gt;&gt; i));</span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：接收一个字节，SCL低从机设置，SCL高主机读取*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveByte</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> Byte = <span class="number">0x00</span>;</span><br><span class="line">  </span><br><span class="line">MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//主机在接受数据前需要将SDA释放让从机获取SDA控制权，使从机能够将数据放入SDA</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(MyI2C_R_SDA()==<span class="number">1</span>) <span class="comment">//从机发送的数据</span></span><br><span class="line">&#123;</span><br><span class="line">Byte |= (<span class="number">0x80</span> &gt;&gt; i); <span class="comment">// 设置第i位为1,否则为0</span></span><br><span class="line">&#125;</span><br><span class="line">MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Byte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：发送应答，逻辑和发送字节类似*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendAck</span><span class="params">(<span class="type">uint8_t</span> AckBit)</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//进来时SCL为低电平</span></span><br><span class="line">MyI2C_W_SDA(AckBit);<span class="comment">//主机发送ACK</span></span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);<span class="comment">//SCL为高，从机接收ACK</span></span><br><span class="line">MyI2C_W_SCL(<span class="number">0</span>);<span class="comment">//结束一个脉冲</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：接收应答，逻辑和接收字节类似*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveAck</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> AckBit = <span class="number">0x00</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//进来时SCL为低电平</span></span><br><span class="line">MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//释放SDA使从机能操控SDA线(使其具有能拉高或拉低SDA的能力)，在SCL置高电平之前，从机将ACK放到SDA线上</span></span><br><span class="line"></span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">AckBit = MyI2C_R_SDA();<span class="comment">//读取ACK</span></span><br><span class="line">MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> AckBit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyI2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  UsartInit();</span><br><span class="line">  MyI2C_Init();</span><br><span class="line">    </span><br><span class="line">  MyI2C_Start();</span><br><span class="line">  MyI2C_SendByte(<span class="number">0xD0</span>); <span class="comment">// 1101000 0 MPU6050地址+写位</span></span><br><span class="line">   <span class="comment">//  MyI2C_SendByte(0xB0); // 1101000 0 MPU6050地址+写位</span></span><br><span class="line">  <span class="type">uint8_t</span> ack = MyI2C_ReceiveAck();</span><br><span class="line">  MyI2C_Stop();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">UsartSend(ack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试是否能收到ACK，改变对应从机地址后是否应答</p></blockquote><h4 id="MPU6050-测试读写">MPU6050-测试读写</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyI2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">MyI2C_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*1.起始，对应从机地址MPU6050，应答*/</span></span><br><span class="line">MyI2C_Start();</span><br><span class="line">  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">MyI2C_ReceiveAck();<span class="comment">//可以对应答位判断是否收到从机数据进行处理，这里默认应答</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*2.发送要写入的寄存器地址，应答*/</span></span><br><span class="line">  MyI2C_SendByte(RegAddress);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*3.发送写入数据*/</span></span><br><span class="line">MyI2C_SendByte(Data);</span><br><span class="line">MyI2C_ReceiveAck(); <span class="comment">//这里只发送一个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">//  MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">/*当要写入多个字节时，使用循环依次将数组的各个字节发送出去*/</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/*4.结束*/</span></span><br><span class="line">  MyI2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> Data;</span><br><span class="line"></span><br><span class="line">MyI2C_Start();</span><br><span class="line">  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line"></span><br><span class="line">  MyI2C_SendByte(RegAddress);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*前一半为写的时序*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*后一半为读的时序*/</span></span><br><span class="line">  MyI2C_Start();<span class="comment">//Sr</span></span><br><span class="line">  MyI2C_SendByte(MPU6050_ADDRESS|<span class="number">0x01</span>);<span class="comment">//最后一位改成读</span></span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*接收从机数据*/</span></span><br><span class="line">  Data = MyI2C_ReceiveByte();</span><br><span class="line">MyI2C_SendAck(<span class="number">1</span>);<span class="comment">//想继续读数据给应答，这里只读一位，直接不应答了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    Datas[i] = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">//        if(i==7)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//MyI2C_SendAck(1);//最后一位读取后不应答</span></span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//MyI2C_SendAck(0);//读取多个数据给应答</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//多个数据读取</span></span><br><span class="line">    </span><br><span class="line">  MyI2C_Stop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="读功能">读功能</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> Id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> UsartInit();</span><br><span class="line"> MPU6050_Init();</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*读取寄存器*/</span></span><br><span class="line">    Id = MPU6050_ReadReg(<span class="number">0x75</span>);<span class="comment">//WHO_AM_I，ID寄存器</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">UsartSend(Id);</span><br><span class="line">Delay_ms(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./image/image-20241218220447684.png" alt="image-20241218220447684"></p><blockquote><p>读读取0x75后，得到的结果是0x68，与手册对应代表一字节时序正确</p></blockquote><h5 id="写功能">写功能</h5><p><code>在使用写功能是必须先接触睡眠模式，否则操控其他寄存器无效</code></p><p><img src="./image/image-20241218220917107.png" alt="image-20241218220917107"></p><blockquote><p>睡眠模式由该电源资源管理寄存器的SLEEP位控制，对应寄存器地址为0x6B，初始值为0x40(0100000)，SLEEP位为1</p><p><strong>只需要对该寄存器写入0x00即可</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="type">uint8_t</span> Data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">LED_Init();</span><br><span class="line"></span><br><span class="line">  UsartInit();</span><br><span class="line">  MPU6050_Init();</span><br><span class="line">  </span><br><span class="line">  MPU6050_WriteReg(<span class="number">0x6B</span>,<span class="number">0x00</span>);<span class="comment">//电源资源管理寄存器，必选先接触睡眠模式</span></span><br><span class="line">  </span><br><span class="line">  MPU6050_WriteReg(<span class="number">0x19</span>,<span class="number">0xAA</span>);<span class="comment">//采样分频寄存器</span></span><br><span class="line">    </span><br><span class="line">  Data = MPU6050_ReadReg(<span class="number">0x19</span>);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">UsartSend(Data);</span><br><span class="line">Delay_ms(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试发现对应寄存器值修改成功，串口显示AA</p></blockquote><h4 id="MPU6050-读取加速度-角速度">MPU6050-读取加速度/角速度</h4><blockquote><p>当需要使用的寄存器宏定义比较多时，建议单独创建头文件管理。</p><p>该头文件为MPU6050部分寄存器，从MPU6050寄存器手册搬过来即可</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_REG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_REG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_SMPLRT_DIV0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_CONFIG0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_CONFIG0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_CONFIG0x1C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_XOUT_H0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_XOUT_L0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_YOUT_H0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_YOUT_L0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_ZOUT_H0x3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_ZOUT_L0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_TEMP_OUT_H0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_TEMP_OUT_L0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_XOUT_H0x43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_XOUT_L0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_YOUT_H0x45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_YOUT_L0x46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_ZOUT_H0x47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_ZOUT_L0x48</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_PWR_MGMT_10x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_PWR_MGMT_20x6C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_WHO_AM_I0x75</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ, <span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">()</span></span><br><span class="line"><span class="comment">/*读取对应MPU6050ID*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyI2C.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_Reg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0 <span class="comment">//1101000 0</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*1.起始，对应从机地址MPU6050，应答*/</span></span><br><span class="line">MyI2C_Start();</span><br><span class="line">  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">MyI2C_ReceiveAck();<span class="comment">//可以对应答位判断是否收到从机数据进行处理，这里默认应答</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*2.发送要写入的寄存器地址，应答*/</span></span><br><span class="line">  MyI2C_SendByte(RegAddress);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*3.发送写入数据*/</span></span><br><span class="line">MyI2C_SendByte(Data);</span><br><span class="line">MyI2C_ReceiveAck(); <span class="comment">//这里只发送一个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">//  MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">/*当要写入多个字节时，使用循环依次将数组的各个字节发送出去*/</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/*4.结束*/</span></span><br><span class="line">  MyI2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> Data;</span><br><span class="line"></span><br><span class="line">MyI2C_Start();</span><br><span class="line">  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line"></span><br><span class="line">  MyI2C_SendByte(RegAddress);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*前一半为写的时序*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*后一半为读的时序*/</span></span><br><span class="line">  MyI2C_Start();<span class="comment">//Sr</span></span><br><span class="line">  MyI2C_SendByte(MPU6050_ADDRESS|<span class="number">0x01</span>);<span class="comment">//最后一位改成读</span></span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*接收从机数据*/</span></span><br><span class="line">  Data = MyI2C_ReceiveByte();</span><br><span class="line">MyI2C_SendAck(<span class="number">1</span>);<span class="comment">//想继续读数据给应答，这里只读一位，直接不应答了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    Datas[i] = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">//        if(i==7)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//MyI2C_SendAck(1);//最后一位读取后不应答</span></span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//MyI2C_SendAck(0);//读取多个数据给应答</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//多个数据读取</span></span><br><span class="line">    </span><br><span class="line">  MyI2C_Stop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主要修改如下*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">MyI2C_Init();</span><br><span class="line">  MPU6050_WriteReg(MPU6050_PWR_MGMT_1,<span class="number">0x01</span>);<span class="comment">//配置电源管理寄存器1,解除睡眠选择陀螺仪时钟</span></span><br><span class="line">  MPU6050_WriteReg(MPU6050_PWR_MGMT_2,<span class="number">0x00</span>);<span class="comment">//配置电源管理寄存器2,6个轴均不待机</span></span><br><span class="line"></span><br><span class="line">  MPU6050_WriteReg(MPU6050_SMPLRT_DIV,<span class="number">0x09</span>);<span class="comment">//配置采样分频寄存器，选择10分频，滤波参数给最大</span></span><br><span class="line">MPU6050_WriteReg(MPU6050_CONFIG,<span class="number">0x06</span>);<span class="comment">//配置寄存器，滤波参数110</span></span><br><span class="line">  MPU6050_WriteReg(MPU6050_GYRO_CONFIG,<span class="number">0x18</span>);<span class="comment">//陀螺仪最大量程</span></span><br><span class="line">  MPU6050_WriteReg(MPU6050_ACCEL_CONFIG,<span class="number">0x18</span>);<span class="comment">//加速度计最大量程</span></span><br><span class="line"><span class="comment">/*这里配置完后，陀螺仪内部就在不停的转换了，对应数据存放在对应各轴数据寄存器中*/</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对应6轴的数据都是16位，分为高8位和低8位，分别读取高8位和低8位拼接后*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,<span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> DataH,DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">  </span><br><span class="line">*AccX =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">  DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line"></span><br><span class="line">  *AccY =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">  </span><br><span class="line">  DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line"></span><br><span class="line">  *AccZ =    (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">  DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line"></span><br><span class="line">  *GyroX = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line"></span><br><span class="line">  *GyroY =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line"></span><br><span class="line">  *GyroZ =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里的读取分为12次，我们可以改进，使用连续读取的时序，大大提升效率*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"><span class="type">int16_t</span> AX=<span class="number">0</span>,AY=<span class="number">0</span>,AZ=<span class="number">0</span>,GX=<span class="number">0</span>,GY=<span class="number">0</span>,GZ=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="type">uint8_t</span> Data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  LED_Init();</span><br><span class="line">   </span><br><span class="line">  UsartInit();</span><br><span class="line"></span><br><span class="line">  MPU6050_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">MPU6050_GetData(&amp;AX,&amp;AY,&amp;AZ,&amp;GX,&amp;GY,&amp;GZ);</span><br><span class="line">UsartSend(AX);</span><br><span class="line">UsartSend(AY);</span><br><span class="line">UsartSend(AZ);</span><br><span class="line">UsartSend(GX);</span><br><span class="line">UsartSend(GY);</span><br><span class="line">UsartSend(GZ);</span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>对应数据：</code></p><p>X轴加速度：水平基本没加速度</p><p>Y轴加速度：水平基本没加速度</p><p>Z轴加速度：平放在水面通过得到AZ，我们选择的是满量程16g(看手册上)</p><p>对应加速度计算公式为 AZ / 32768 =  x / 16g ，解方程的得到的x为Z轴方向加速度，这个值理论上来说应该是重力加速度g</p><hr><p>X轴角速度：</p><p>Y轴角速度：</p><p>Z轴角速度：</p><hr><p><strong>上方所有数据计算的公式为：</strong></p><p><strong>（读取的数据）/（32768） = （x）  /（ 满量程）</strong></p><p><strong>解出对应x的值即可</strong></p></blockquote><h3 id="I2C外设-硬件读写I2C">I2C外设(硬件读写I2C)</h3><p><img src="./image/image-20241220151445355.png" alt="image-20241220151445355"></p><blockquote><p>由硬件电路自动实现引脚电平反转，软件只需要写入<strong>控制寄存器CR</strong>和<strong>数据寄存器DR</strong>即可。</p><p>为了监控时序状态，软件还得读取<strong>状态寄存器SR</strong>来了解当前的外设电路处于什么状态</p><p><strong>这就像开车一样：写入控制寄存器CR，就像是踩油门、打方向盘来控制汽车的运行，读取状态寄存器SR，就像是观看仪表盘，来了解汽车的运行状态。</strong></p><p>使用库函数封装后，有了I2C外设，硬件就可以自动实现时序，就可以减轻CPU的负担，节省软件资源</p><hr><p><strong>一主多从</strong>：一个主机多个从设备…</p><p><strong>多主机模式</strong>：分为固定多主机和可变多主机</p><ul><li>固定多主机：固定有几个主机，多个主机控制产生冲突时需要仲裁</li><li>可变多主机：总线上无固定主机和从机，任何设备可以在总线空闲时主动跳出作为主机与其他从机通信，通信完成后回归从机</li></ul><p><code>对于STM32使用的是可变多主机模型</code></p><hr><p><strong>地址模式</strong>：7/10位</p><p>7位：一个字节中的前7位为设备地址，最后一位是读写位。</p><p>10位：使用两个字节，如果第二个字节也是寻址的话，第一个字节的前5位必须是11110<code>(10位地址标志位)</code>，第一个字节剩下2位和第二个字节的8位一共10位作为寻址</p><p>7位与10位区别：前5位是否为11110</p><hr><p><strong>通讯速度</strong>：</p><ul><li><p>标准速度：100KHz</p></li><li><p>快速速度：400KHz</p></li></ul><hr><p><strong>DMA</strong>：…</p><hr><p><strong>兼容SMBus：System Management Bus-系统管理总线</strong></p><p>类似于I2C，是兼容的另一种总线</p></blockquote><p><strong>对应寄存器，标志位查看芯片参考手册的I2C接口模块阅读即可!!!</strong></p><h4 id="I2C框图">I2C框图</h4><p><img src="./image/image-20241221144132847.png" alt="image-20241221144132847"></p><blockquote><p><strong>对应使用时一般是GPIO口复用，查询对应引脚定义表即可，使用<code>硬件I2C时只能使用指定的引脚</code>，不能像<code>软件I2C那样引脚任意指定</code></strong></p><hr><p>由于I2C是半双工，只有<code>一组移位寄存器和数据寄存器</code>，接收和发送都是使用这组，而串口有两组</p><hr><p><code>比较器和地址寄存器：</code>从机模式使用，支持同时响应两个从机地址，在多主机模式下使用</p><hr><p><code>帧错误校验PEC计算</code>：CRC校验算法，数据有效性验证，对应数据错误标志位置位</p><hr><p><code>中断</code>：某个紧急事件发生后可以申请中断</p><hr><p><code>DMA</code>：配合提高效率</p></blockquote><blockquote><p>SMBALERT是SMBus相关，I2C使用时不用管它</p></blockquote><h4 id="I2C基本结构">I2C基本结构</h4><p><img src="./image/image-20241221150048169.png" alt="image-20241221150048169"></p><blockquote><p>图中是简化的一主多从结构，如果是多主机应该还有时钟输入</p><p>图中的两个GPIO：一个是复用输入，另一个是复用输出</p><hr><p><strong>移位寄存器和数据寄存器DR</strong>：</p><p><code>发送时数据先写入数据寄存器DR，如果移位寄存器没有数据，就会转到移位寄存器进行发送</code></p></blockquote><h4 id="主机发送流程">主机发送流程</h4><p><img src="./image/image-20241221162408618.png" alt="image-20241221162408618"></p><blockquote><p><code>EV事件</code> 是多个标志位的集合，所有标志位在手册中都可以找到</p><p>EV5,EV6,EV8…</p><p>流程简化下来就是：操作-等待-操作-等待…</p></blockquote><h4 id="主机接收流程">主机接收流程</h4><p><img src="./image/image-20241221162433975.png" alt="image-20241221162433975"></p><blockquote><p>图中给的时序是当前地址读的，想要指定地址读数据需要组合一下即可</p><p>具体的流程见下面的代码</p></blockquote><h4 id="从机发送接收">从机发送接收</h4><p>见手册！！！</p><h4 id="库函数-9">库函数</h4><p><code>初始化函数：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_DeInit</span><span class="params">(I2C_TypeDef* I2Cx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Init</span><span class="params">(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_StructInit</span><span class="params">(I2C_InitTypeDef* I2C_InitStruct)</span>;</span><br></pre></td></tr></table></figure><p><code>起始条件和终止条件：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_GenerateSTART</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//调用该函数生成起始条件，对I2C_CR1寄存器中的START位置1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_GenerateSTOP</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//调用该函数生成终止条件，对I2C_CR1寄存器中的STOP位置1</span></span><br></pre></td></tr></table></figure><p><code>应答ACK：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_AcknowledgeConfig</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//手动ACK配置，在收到一个字节后，是否给从机应答</span></span><br></pre></td></tr></table></figure><p><code>发送和接收数据：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_SendData</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint8_t</span> Data)</span>;<span class="comment">//写入数据到数据寄存器DR</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">I2C_ReceiveData</span><span class="params">(I2C_TypeDef* I2Cx)</span>;<span class="comment">//读取数据寄存器DR作为返回值，接收到下一个字节之前读出数据寄存器，防止数据覆盖，实现连续数据流</span></span><br></pre></td></tr></table></figure><p><code>发送地址专用函数:</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_Send7bitAddress</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint8_t</span> Address, <span class="type">uint8_t</span> I2C_Direction)</span>;<span class="comment">//主要用于设置自动设置读写位</span></span><br></pre></td></tr></table></figure><blockquote><p>这个函数可以不使用，而是自己确定读写位的最后一位，直接使用SendData函数进行发送</p></blockquote><p><code>中断配置：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_ITConfig</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint16_t</span> I2C_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><p><code>DMA相关：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_DMACmd</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_DMALastTransferCmd</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><p><code>使能函数：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_Cmd</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><p><code>标志位：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">I2C_GetFlagStatus</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_ClearFlag</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_FLAG)</span>;</span><br><span class="line"><span class="comment">/*中断外使用*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ITStatus <span class="title function_">I2C_GetITStatus</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_ClearITPendingBit</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_IT)</span>;</span><br><span class="line"><span class="comment">/*中断中使用*/</span></span><br></pre></td></tr></table></figure><p><code>状态监控：给了三种方法</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一种：基本状态监控，同时判断一个或多个标志位，来确定EV几EV几这个状态是否发生,对应发送接收流程*/</span></span><br><span class="line">ErrorStatus <span class="title function_">I2C_CheckEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span>;<span class="comment">//推荐使用！！！,第二个参数为监测的事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第二种：高级状态监控，实际上并不高级，对应库函数注释可以找到是将SR1和SR2这两个状态寄存器拼接成16位数据然后给你就完了*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">I2C_GetLastEvent</span><span class="params">(I2C_TypeDef* I2Cx)</span>;。<span class="comment">//一般不使用，了解即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三种：基于标志位的状态监控，我们一直使用的判断某个标志位方法*/</span></span><br><span class="line">FlagStatus <span class="title function_">I2C_GetFlagStatus</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_FLAG)</span>;</span><br></pre></td></tr></table></figure><h4 id="I2C外设配置">I2C外设配置</h4><p><code>参考上方I2C框图和基本结构进行配置：</code></p><ol><li><strong>开启I2C外设和对应GPIO口的时钟</strong></li><li><strong>结构体配置对应GPIO口为复用开漏输出模式(区别：软件模拟I2C是直接开漏没有复用开漏)</strong></li><li><strong>结构体配置I2C</strong></li><li><strong>使能I2C，I2C_Cmd</strong></li></ol><h4 id="实验-硬件I2C读取MPU6050数据">实验-硬件I2C读取MPU6050数据</h4><blockquote><p>部分与软件I2C相同，去掉了软件I2C最底层的部分，使用库函数代替</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,<span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;MyI2C.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_Reg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0 <span class="comment">//1101000 0</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序中出现大量while等待的情况比较危险，容易发生卡死的现象，所以我们需要让它超时退出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *不必使用定时器，我们只需要简单用一个计数值循环判断即可，该Timeout值根据实际情况更改大小，while循环正常不会执行到Timeout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">uint32_t</span> Timeout;</span><br><span class="line"> Timeout = <span class="number">10000</span>;</span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2Cx,I2C_EVENT)!=SUCCESS)</span><br><span class="line"> &#123;</span><br><span class="line"> Timeout --;</span><br><span class="line"> <span class="keyword">if</span>(Timeout ==<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该函数为CheckEvent的封装</span></span><br><span class="line"><span class="comment"> * 下方没有替换，该函数使用时只需要将使用while循环的部分直接使用该函数全部替换即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*软件I2C代码：*/</span></span><br><span class="line"><span class="comment">//  /*1.起始，对应从机地址MPU6050，应答*/</span></span><br><span class="line"><span class="comment">//MyI2C_Start();</span></span><br><span class="line"><span class="comment">//  MyI2C_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">//MyI2C_ReceiveAck();//可以对应答位判断是否收到从机数据进行处理，这里默认应答</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  /*2.发送要写入的寄存器地址，应答*/</span></span><br><span class="line"><span class="comment">//  MyI2C_SendByte(RegAddress);</span></span><br><span class="line"><span class="comment">//MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  /*3.发送写入数据*/</span></span><br><span class="line"><span class="comment">//MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">//MyI2C_ReceiveAck(); //这里只发送一个字节</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">////&#123;</span></span><br><span class="line"><span class="comment">////MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">////  MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">////&#125;</span></span><br><span class="line"><span class="comment">//    /*当要写入多个字节时，使用循环依次将数组的各个字节发送出去*/</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">///*4.结束*/</span></span><br><span class="line"><span class="comment">//  MyI2C_Stop();</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*硬件I2C下使用的都是非阻塞的函数，需要等待标志位结束才能保证对应波形执行完成*/</span></span><br><span class="line"> <span class="comment">/*对应等待的事件根据硬件I2C发送流程中来写*/</span></span><br><span class="line"> </span><br><span class="line"> I2C_GenerateSTART(I2C1,ENABLE);<span class="comment">//1.发送起始条件</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)!=SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">&#125;<span class="comment">//等待EV5事件完成</span></span><br><span class="line"> </span><br><span class="line"> I2C_Send7bitAddress(I2C1,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//2.发送从机地址，第三个参数自动置读写位,应答位会自动处理</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)!=SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">&#125;<span class="comment">//等待发送模式的EV6事件完成</span></span><br><span class="line"> </span><br><span class="line"> I2C_SendData(I2C1,RegAddress);<span class="comment">//3.发送指定寄存器地址</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTING)!=SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">&#125;<span class="comment">//等待EV8事件</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*发送多个字节数据时，中间的数据发送完成后等待EV8事件，而最后一个字节变为等待EV8_2事件*/</span></span><br><span class="line"> </span><br><span class="line"> I2C_SendData(I2C1,Data);<span class="comment">//4.发送要写入的数据</span></span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)!=SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">&#125;<span class="comment">//发送最后一个字节完成后，等待EV8_2事件</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> I2C_GenerateSTOP(I2C1,ENABLE);<span class="comment">//5.终止条件</span></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*软件模拟I2C:*/</span></span><br><span class="line"><span class="comment">//MyI2C_Start();</span></span><br><span class="line"><span class="comment">//  MyI2C_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">//MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  MyI2C_SendByte(RegAddress);</span></span><br><span class="line"><span class="comment">//MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">///*前一半为写的时序*/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">///*后一半为读的时序*/</span></span><br><span class="line"><span class="comment">//  MyI2C_Start();//Sr</span></span><br><span class="line"><span class="comment">//  MyI2C_SendByte(MPU6050_ADDRESS|0x01);//最后一位改成读</span></span><br><span class="line"><span class="comment">//MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">///*接收从机数据*/</span></span><br><span class="line"><span class="comment">//  Data = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">//MyI2C_SendAck(1);//想继续读数据给应答，这里只读一位，直接不应答了</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">////&#123;</span></span><br><span class="line"><span class="comment">////    Datas[i] = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">////        if(i==7)</span></span><br><span class="line"><span class="comment">////&#123;</span></span><br><span class="line"><span class="comment">////MyI2C_SendAck(1);//最后一位读取后不应答</span></span><br><span class="line"><span class="comment">////break;</span></span><br><span class="line"><span class="comment">////&#125;</span></span><br><span class="line"><span class="comment">////MyI2C_SendAck(0);//读取多个数据给应答</span></span><br><span class="line"><span class="comment">////&#125;</span></span><br><span class="line"><span class="comment">////多个数据读取</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//  MyI2C_Stop();</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*硬件I2C:实现指定地址接收一个字节，使用的是复合形式*/</span></span><br><span class="line"> I2C_GenerateSTART(I2C1,ENABLE);<span class="comment">//1.发送起始条件</span></span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)!=SUCCESS);<span class="comment">//起始条件等待EV5事件完成</span></span><br><span class="line"> </span><br><span class="line"> I2C_Send7bitAddress(I2C1,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//2.发送从机地址，第三个参数自动置读写位,应答位会自动处理</span></span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)!=SUCCESS)<span class="comment">//等待发送模式的EV6事件完成</span></span><br><span class="line"> </span><br><span class="line"> I2C_SendData(I2C1,RegAddress);<span class="comment">//3.发送指定寄存器地址</span></span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)!=SUCCESS)<span class="comment">//这里因为是数据流最后一个字节所以变成了等待EV8_2事件</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*前一半为写的时序*/</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*后一半为读的时序*/</span></span><br><span class="line"> </span><br><span class="line"> I2C_GenerateSTART(I2C1,ENABLE);<span class="comment">//4.重复起始条件。这个地方会等待上方字节发送完成后才会产生，所以上方用TRANSMITTING或TRANSMITTED都可以</span></span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)!=SUCCESS);<span class="comment">//起始条件等待EV5事件完成</span></span><br><span class="line"></span><br><span class="line"> I2C_Send7bitAddress(I2C1,MPU6050_ADDRESS,I2C_Direction_Receiver);<span class="comment">//2.发送从机地址，这个地方应变成读的方向，第三个参数修改</span></span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)!=SUCCESS)<span class="comment">//等待接收模式的EV6事件完成，与上方EV6事件不同</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> <span class="comment">//如果只需要读取一个字节，需要恰好在EV6之后，立刻把ACK置0，STOP置1，避免在本次ACK发送之后才去置0，这样时序会多一个字节</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果是需要读取多个字节，直接等待EV7事件，读取DR,就能收到数据，依次接收，直到最后一个字节之前也就是EV7_1事件(EV7_1不用等待)，提前把ACK置0，STOP置1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> I2C_AcknowledgeConfig(I2C1, DISABLE);</span><br><span class="line">I2C_GenerateSTOP(I2C1,ENABLE);<span class="comment">//STOP置1后该终止条件不会截断当前字节，会等当前字节接收完成后，再产生终止条件波形</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)!=SUCCESS)<span class="comment">//等待EV7事件完成</span></span><br><span class="line">Data = I2C_ReceiveData(I2C1);<span class="comment">//5.接收从机数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//     for(int i=0;i&lt;N;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//if(i==N-1)</span></span><br><span class="line"><span class="comment">//I2C_AcknowledgeConfig(I2C1, DISABLE);</span></span><br><span class="line"><span class="comment">//I2C_GenerateSTOP(I2C1,ENABLE);//STOP置1后该终止条件不会截断当前字节，会等当前字节接收完成后，再产生终止条件波形</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)!=SUCCESS)//等待EV7事件完成</span></span><br><span class="line"><span class="comment">//Data = I2C_ReceiveData(I2C1);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//   接收多个字节:使用循环处理，最后一个字节前执行一次ACK=0和STOP</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">I2C_AcknowledgeConfig(I2C1, ENABLE);<span class="comment">//最后再恢复默认ACK=1，方便收多个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*软件I2C:*/</span></span><br><span class="line"><span class="comment">//MyI2C_Init();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*硬件I2C:*/</span></span><br><span class="line">  <span class="comment">/*第1步*/</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1,ENABLE);</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*第2步*/</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2|GPIO_Pin_3;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*第3步*/</span></span><br><span class="line">  I2C_InitTypeDef I2C_InitStruct;</span><br><span class="line">I2C_InitStruct.I2C_Mode = I2C_Mode_I2C ;</span><br><span class="line">I2C_InitStruct.I2C_Ack = I2C_Ack_Enable;<span class="comment">//确认要发送应答位</span></span><br><span class="line">I2C_InitStruct.I2C_ClockSpeed = <span class="number">100000</span>;<span class="comment">//最大为400KHZ，0~100KHZ为标准速度，100~400khz为快速</span></span><br><span class="line">  I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_2;<span class="comment">//时钟占空比参数，用与快速模式，只有当时钟频率大于100Khz才有效，小于100Khz是占空比固定为1：1</span></span><br><span class="line">I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;<span class="comment">//响应7或10位地址，stm32作为从机时才使用。作为主机随便给</span></span><br><span class="line">I2C_InitStruct.I2C_OwnAddress1 = <span class="number">0x00</span>;<span class="comment">//自身地址1，stm32作为从机才使用，方便别的主机呼叫，指定地址位数=上一个参数选择响应的位数。作为主机随便给</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*第4步*/</span></span><br><span class="line">  I2C_Cmd(I2C1,ENABLE);</span><br><span class="line">  </span><br><span class="line">MPU6050_WriteReg(MPU6050_PWR_MGMT_1,<span class="number">0x01</span>);<span class="comment">//配置电源管理寄存器1,解除睡眠选择陀螺仪时钟</span></span><br><span class="line">  MPU6050_WriteReg(MPU6050_PWR_MGMT_2,<span class="number">0x00</span>);<span class="comment">//配置电源管理寄存器2,6个轴均不待机</span></span><br><span class="line"></span><br><span class="line">  MPU6050_WriteReg(MPU6050_SMPLRT_DIV,<span class="number">0x09</span>);<span class="comment">//配置采样分频寄存器，选择10分频，滤波参数给最大</span></span><br><span class="line">MPU6050_WriteReg(MPU6050_CONFIG,<span class="number">0x06</span>);<span class="comment">//配置寄存器，滤波参数110</span></span><br><span class="line">  MPU6050_WriteReg(MPU6050_GYRO_CONFIG,<span class="number">0x18</span>);<span class="comment">//陀螺仪最大量程</span></span><br><span class="line">  MPU6050_WriteReg(MPU6050_ACCEL_CONFIG,<span class="number">0x18</span>);<span class="comment">//加速度计最大量程</span></span><br><span class="line"><span class="comment">/*这里配置完后，陀螺仪内部就在不停的转换了，对应数据存放在对应各轴数据寄存器中*/</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对应6轴的数据都是16位，分为高8位和低8位，分别读取高8位和低8位拼接后*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,</span></span><br><span class="line"><span class="params"> <span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> DataH,DataL;</span><br><span class="line"></span><br><span class="line">DataH =  MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">  </span><br><span class="line">*AccX =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">  DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">  DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line"></span><br><span class="line">  *AccY =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">  </span><br><span class="line">  DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line"></span><br><span class="line">  *AccZ =    (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">  DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line"></span><br><span class="line">  *GyroX = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line"></span><br><span class="line">  *GyroY =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line"></span><br><span class="line">  *GyroZ =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里的读取分为12次，我们可以改进，使用连续读取的时序，大大提升效率*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>程序中出现大量while等待的情况比较危险，容易发生卡死的现象，所以我们需要让它超时退出。</p><p>不必使用定时器，我们只需要简单用一个计数值循环判断即可，该Timeout值根据实际情况更改大小，while循环正常不会执行到Timeout</p></blockquote><h3 id="软件和硬件I2C对比">软件和硬件I2C对比</h3><p><code>波形对比：</code></p><p><strong>上方是软件波形，下方是硬件波形</strong></p><p><img src="./image/image-20241221171144668.png" alt=""></p><blockquote><p><strong>从时钟线的规整程度上看：</strong></p><p>硬件I2C：SCL波形会更加规整，每个时钟的周期、占空比都非常一致</p><p>软件I2C：由于操作引脚后都加了延时，有时候加的多有时候加的少，所以软件时序的时钟周期、占空比可能不规整，但由于是同步时序不规整也不会影响通信</p><hr><p>在SCL低电平写，高电平读的时候，可以在整个电平的任意时候都可以读写，但是一般要求保证尽早原则，所以可以认为SCL下降沿写，上升沿读。</p><p>软件波形中，因为操作端口后有延时，所以都是等了一会在写的</p><p>硬件波形中，可以看到SCL下降沿的时候，SDA也立马切换数据。读写都是紧贴上下沿进行</p><hr><p><strong>应答结束时最为明显：</strong></p><p>从机在SCL下降沿立刻释放SDA，但是软件I2C由于有延时，所以在应答结束后主机等了一会才变换数据，所以在软件I2C中有一个短暂的高电平后才拉低SDA。</p><p>硬件I2C中应答结束后，从机在SCL下降沿立刻释放SDA，同时主机也立刻拉低SDA，所以就是直接一个小尖峰。</p></blockquote><blockquote><p><code>软件模拟I2C (Bit-Banging)：</code></p><p><strong>优点：</strong></p><ul><li><strong>灵活性高</strong>：可以完全控制每个I2C数据位的发送和接收过程，适用于没有硬件I2C模块的STM32型号，或者需要多个I2C总线时，可以通过软件模拟多个I2C设备。</li><li><strong>成本低</strong>：不依赖硬件I2C外设，因此适合成本敏感的应用。</li><li><strong>可以在任意GPIO上运行</strong>：可以自定义SCL和SDA引脚，不需要专用的硬件I2C引脚。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>效率低</strong>：每个数据位的发送和接收都需要进行软件延时处理，导致比硬件I2C慢得多。对于高速通信，可能无法满足实时性要求。</li><li><strong>占用CPU资源</strong>：模拟I2C需要CPU不断参与数据的传输，可能影响系统其他任务的执行，尤其是当系统负载较高时。</li><li><strong>稳定性差</strong>：如果系统中有其他任务需要占用大量CPU时间，可能会导致I2C通信不稳定，或者丢失数据。</li></ul><hr><p><code>硬件I2C (利用硬件I2C模块)：</code></p><p><strong>优点：</strong></p><ul><li><strong>高效</strong>：硬件I2C通过专用的I2C控制器进行数据传输，不需要CPU参与数据位的传送，速度快且稳定，通常能够提供更高的传输速率。</li><li><strong>节省CPU资源</strong>：硬件I2C控制器可以自动完成数据传输任务，释放CPU处理其他任务，特别适合多任务或实时系统。</li><li><strong>稳定性强</strong>：硬件I2C模块有专门的硬件实现，避免了由于软件延迟或CPU占用过高导致的通信不稳定问题。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>硬件资源有限</strong>：不同型号的STM32有不同数量的硬件I2C模块，因此可用的硬件I2C通道有限。如果需要多个I2C总线，可能无法满足需求。</li><li><strong>引脚固定</strong>：硬件I2C通常需要专用的引脚（SCL和SDA），不能任意选择GPIO。如果这些引脚已被占用或在项目设计中不方便，可能会限制设计的灵活性。</li><li><strong>复杂性较高</strong>：硬件I2C需要配置硬件相关的寄存器和管理中断等，比软件模拟I2C配置复杂一些。</li></ul><hr><p><strong>使用场景总结</strong>：</p><p>**软件模拟I2C：**灵活、成本低，但效率低、占用CPU资源。不受限制，引脚够基本上就是想开几路就是几路</p><p>硬件I2C不足时可以使用软件I2C</p><p>**硬件I2C：**效率高、稳定，节省CPU资源，但受硬件资源和引脚限制。</p><p>对性能指标要求比较高，实时性、多任务等时使用硬件I2C</p></blockquote><h2 id="SPI">SPI</h2><h3 id="SPI介绍">SPI介绍</h3><p><img src="./image/image-20250101153932297.png" alt="image-20250101153932297"></p><blockquote><p>图中的四种使用SPI通信的芯片：引脚名称可能不标注，可以查看对应手册了解</p><ol><li>W25QXX，FLASH存储芯片，作为从机，引脚写的DI和DO</li><li>OLED屏幕</li><li>2.4G无线通信模块，芯片型号为NRF24L01</li><li>Micro SD卡：官方通信协议为SDIO，但也支持SPI协议，可以对其进行读写操作</li></ol></blockquote><blockquote><p><strong>SPI特点：同步，全双工，四根通信线</strong></p><hr><p><code>SPI的四根线：</code></p><ol><li><strong>SCK(Serial Clock)</strong>：时钟线，也叫做SCLK、CLK、CK等</li><li><strong>MOSI(Master Output Slave Input)</strong>：主机输出从机输入线，也叫做DI(Data Output-对应从机输入)</li><li><strong>MISO(Master Output Slave Input)</strong>：主机输入从机输出线，也叫做DO(Data Input-对应从机输出))</li><li><strong>SS(Slave Select)</strong>：从机选择线，片选，也叫做NSS(Not Slave Select)、CS(Chip Select-片选)，有几个从机就用几条线。这样以后就不用像I2C那样先发送一个字节寻址、分配地址等操作</li></ol><p>注意：主机和从机不能同时配置为输入或输出</p><hr><p><strong>SPI没有应答位，SPI是不管你有没有收到信息的</strong></p><hr><p><code>SPI相对于I2C的优缺点：</code></p><ul><li><p><code>速度上：</code>SPI传输比I2C更快，SPI协议并没有严格规定最大传输速度，最大传输速度一般由芯片厂商的设计需求，如W25Q64存储器芯片，手册中写的是最大可达80MHz</p></li><li><p><code>设计上：</code>SPI设计比较简单粗暴，实现的功能没有I2C那么多，<strong>仅支持一主多从，不支持多主机</strong></p></li><li><p><code>开销上：</code>SPI的硬件开销比较大，通信线的个数比较多，通信过程中经常会有资源浪费的情况</p></li></ul></blockquote><h3 id="硬件电路-4">硬件电路</h3><p><img src="./image/image-20250101165230579.png" alt="image-20250101165230579"></p><blockquote><p>主机一般是STM32，从机一般是存储器、显示屏、通信 模块、传感器等，对应有几个从设备就有几个SS线</p><hr><p><code>SCK：</code>时钟线完全由主机掌控，对于主机来说时钟线为输出，对于从机来说时钟线为输入</p><p><code>MOSI：</code>主机输出从机输入，左边主机对应MO，主机输出，右边从机SI，从机输入。数据从MOSI输出，所有从机从MOSI输入</p><p><code>MISO：</code>主机输入从机输入，与MOSI类似</p><p><code>SS：</code>从机选择线，低电平有效，主机初始化后所有的SS都输出高电平，代表都不指定，需要与谁通信，就将对应的SS线拉低即可，当对应从机通信完之后，对应SS线就重新置回高电平。同一时间只能选择一个从机(只能置一个为低电平)</p><hr><p><strong>输出引脚配置为推挽输出</strong>：高低电平均有很强驱动能力，使得SPI信号引脚上升沿和下降沿信号非常迅速，不像I2C那样下降沿迅速上升沿缓慢，所以SPI信号变化的快所以SPI具有更快的传输速度，一般的SPI信号都能轻松达到Mhz的速度级别。</p><p><code>输出引脚为：SCK、MOSI、SS</code></p><p><strong>输入引脚配置为浮空或上拉输入</strong></p><p><code>输入引脚为：MISO</code></p><p><code>SPI可能存在的冲突</code>：</p><p>​对于SPI的从机MISO引脚，当某个从机的SS引脚被选择后，其他从机的SS引脚会被保持为高阻态，相当于断开不输出，这样可以防止一条线有多个输出而导致的电平冲突的问题</p></blockquote><h3 id="数据移位示意图">数据移位示意图</h3><p><img src="./image/image-20250101173950632.png" alt="image-20250101173950632"></p><blockquote><p><strong>SPI数据是高位先行，通信基础是<code>交换一个字节</code>，数据收发都是基于<code>字节交换</code>这个基本单元进行</strong>。主机要发送的数据跑到从机，从机要发送的数据跑到主机，这样就可以实现发送一个字节、接收一个字节、发送同时接收一个字节<code>三种功能</code></p><p><strong>对于只想接收数据时</strong>：我们会随便发送数据(一般统一为0x00或0xFF)，把数据置换过来即可</p><p><strong>对于只想发送数据时</strong>：只需要把数据发送过去，对方置换过来的数据不管即可</p><hr><p><strong>这里波特率发生器就是时钟</strong></p><p>主机移位寄存器左边出去的数据通过MOSI引脚，输入到从机移位寄存器的右边，从机移位寄存器左边移出去的数据通过MISO引脚，输入到主机移位寄存器的右边，形成一个环</p><p><strong>每当规定的时钟沿(上升沿/下降沿)到来时，对应移位寄存器的最高位分别移动，分别放到MOSI和MISO的通信线上，然后对应的时钟沿(上升沿或下降沿)再次到来时，数据分别从MOSI和MISO线上，采样到从机和主机的最低位。这样就完成了一个时钟</strong></p><p>例：规定上升沿数据移动，下降沿数据采集。就是在上升沿时移位寄存器的最高位到对应的线上。下降沿时，会采样输入到对应的最低位。</p><hr></blockquote><h3 id="SPI时序基本单元">SPI时序基本单元</h3><ul><li><code>起始条件和终止条件:</code></li></ul><p><img src="./image/image-20250101174746261.png" alt="image-20250101174746261"></p><blockquote><p>起始条件：SS由高到低，代表选中从机通信开始</p><p>结束条件：SS由低到高，代表结束选中从机通信结束</p><p>所以SS低电平期间就代表正在通信</p></blockquote><hr><p>​<strong>SPI中有两个可以配置的位，每一位可以配置为1或0，组合起来就有模式0、模式1、模式2、模式共四种模式，但功能实际都是一样的，任意选择一种使用即可。</strong></p><p><code>CPOL(Clock Polarity)：</code><strong>时钟极性</strong>，决定空闲时SCK的低电平，值为0或1</p><p><code>CPHA(Clock Phase)：</code><strong>时钟相位</strong>，决定第一个时钟采样移入还是第二时钟采样移入，并不是规定上升沿采样还是下降沿采样，值为0或1</p><hr><ul><li><code>模式0：使用最多重点掌握！！！</code></li></ul><p><img src="./image/image-20250101175308487.png" alt="image-20250101175308487"></p><blockquote><p>CPOL = 0：代表空闲状态SCK低电平</p><p>CPHA = 0：SCK<code>第一个</code>边沿<code>移入数据</code>，<code>第二个</code>边沿<code>移出数据</code>。</p><p><strong>由于数据需要先移出来，才能移入，所以SCK第一个边沿之前就要提前开始移出数据了。</strong></p><p>​这里把SS当作了时钟下降沿所以要移出数据，MOSI就提前移出数据，等SCK上升沿来到，两个数据B7分别移入到主机和从机。然后SCK到下降沿，两个B6数据就移出，上升沿的两个B6数据采样输入到主机和从机…一直到B0最后一位，SS拉高，MOSI任意，MISO高阻态，这样一个字节的交换就完成。</p><p><strong>如果想要交换多个字节，只需要在B0最后继续紧跟第二个字节的B7重复前述过程即可</strong></p><hr><p><strong>总结交换字节步骤</strong>：</p><ol><li>SS拉低后，主机和从机立刻移出数据(主机移出它的数据最高位放到MOSI上，从机移出它的最高位数据放到MISO上)。从机的事主机不管，所以我们直接写MOSI即可</li><li>SCK上升沿，主机和从机同时移入数据(从机会自动把这位数据读走)，主机只需要读入MISO的数据位即可</li><li>SCK下降沿，主机和从机同时移出次高位数据，开始循环8次，共1字节8bit</li></ol></blockquote><ul><li><code>模式1：与上方的移位过程相同</code></li></ul><p><img src="./image/image-20250101180327881.png" alt="image-20250101180327881"></p><blockquote><p><strong>模式1与模式0的区别：模式0把数据变化的实际提前了，而模式1没有</strong></p><hr><p>CPOL = 0：代表空闲状态SCK低电平</p><p>CPHA = 1：SCK<code>第一个</code>边沿<code>移出数据</code>，<code>第二个</code>边沿<code>移入数据</code>。</p><p>也能表述为：CPHA=1表示SCK的第二个边沿进行数据采样，或SCK的偶数边沿进行数据采样</p><p>MOSI为主机发送的B7，B6…，默认状态下没有规定高低电平(均可)</p><p>MISO为从机发送的B7，B6…，默认状态下应为高阻态</p></blockquote><ul><li><code>模式2：</code></li></ul><p><img src="./image/image-20250101183828210.png" alt="image-20250101183828210"></p><blockquote><p><strong>模式2与模式0区别：就把SCK极性取反即可</strong></p></blockquote><ul><li><code>模式3：</code></li></ul><p><img src="./image/image-20250101183921953.png" alt="image-20250101183921953"></p><blockquote><p><strong>模式1与模式3区别：就把SCK极性取反即可</strong></p></blockquote><h3 id="SPI时序">SPI时序</h3><p>​SPI对字节流功能的规定与I2C不同，I2C是有效数据流第一个字节是寄存器地址，之后依次是读写的数据，<strong>使用的是读写寄存器的模型</strong>。</p><p>​而在SPI中，通常<strong>采用指令码加读写数据的模型</strong>，即SPI第一个发送给从机的数据叫做指令码，在从机中对应的会定义一个指令集，只需要发送指令集中对应的数据即可指定想要完成的功能。</p><p>​不同的指令，可以有不同的数据个数，有的指令只需要一个字节的指令码就可以完成，比如：W25Q64的写使能失能等。而写数据时，包含指令码+在哪里写+写的数据</p><p>​       <code>对应的指令集都会在SPI从机芯片手册中可以找到！！！！</code></p><p><strong>时序举例</strong>：</p><ul><li><code>写使能</code></li></ul><p><img src="./image/image-20250101184358794.png" alt="image-20250101184358794"></p><p><img src="./image/image-20250101185239046.png" alt="image-20250101185239046"></p><blockquote><p>在W25Q64中0x06代表写使能。</p><p><strong>这里使用SPI模式0，SS拉低后，立马准备移出数据，这里数据第一个Bit为0，所以没有变化，SCK第一个上升沿采样移入数据，从机采样输入(MOSI)得到0，主机采样输入(MISO)得到1。然后第一个下降沿移除数据…一直到最后一位交换完成一个字节。SS置回高电平结束</strong></p><p><code>结果：</code>主机用收到从机的0xFF，即从机输出不使用(0xFF为默认值)，从机收到主机的0x06，就会进行写使能</p><p><strong>由于使用软件模拟时序有延时，所以图中的MOSI数据变化有些延迟，没有紧贴SCK的下降沿是正常的</strong></p></blockquote><ul><li><code>指定地址写一个/多个字节</code></li></ul><p><img src="./image/image-20250101191437487.png" alt="image-20250101191437487"></p><blockquote><p>由于W25Q64有8M的存储空间，一个字节的8位地址不够，所以这里的指定地址使用24位分成3个字节发送</p></blockquote><p><img src="./image/image-20250101191742942.png" alt="image-20250101191742942">`</p><blockquote><p><strong>在0x123456的地址下写入0x55数据</strong>：</p><p><code>指令码</code></p><p>第一个字节：主机先发送0x02指令代表写数据，收到从机数据为0xFF不使用</p><hr><p><code>指定地址</code></p><p>第二个字节：主机发送地址前8位(第23~16位)为0x12，收到从机数据0xFF</p><p>第三个字节：主机发送地址中8位(第15~8位)为0x34，收到从机数据0xFF</p><p>第四个字节：主机发送地址后8位(第7~0位)为0x56，收到从机数据0xFF</p><p><strong>从机收到的地址为0x123456</strong></p><hr><p><code>发送的数据</code></p><p>第五个字节：主机写入的数据0x55，收到从机数据0xFF</p><p>到这里便写入一个字节，没有应答位，一个接一个交换字节即可</p><hr><p><code>如果想指定地址，写入多个字节：</code></p><p>SPI中也有类似于I2C中的地址指针，每读写一个字节，地址指针自动+1，如果发送一个字节后不停止，继续发送的字节就会依次写入到后续的存储空间里，这样即实现多个字节写入</p></blockquote><ul><li><code>指定地址读一个/多个字节：</code></li></ul><p><img src="./image/image-20250101193028026.png" alt="image-20250101193028026"></p><p><img src="./image/image-20250101193633764.png" alt="image-20250101193633764"></p><blockquote><p><strong>和指定地址写时序差不多</strong></p><p>指令码：0x03</p><p>地址三个字节：0x123456</p><p>读取的数据：主机随便发送数据0xFF，交换数据后得到0x55。</p><p>这样就读取到了0x123456地址的数据为0x55</p><hr><p><code>实现读取指定地址的多个字节：</code></p><p>也是有地址指针，读取自动+1，实现连续读取即可</p><hr><p><strong>时序细节</strong>：</p><p>图中MISO是硬件控制波形，所以数据变化紧贴下降沿</p></blockquote><h3 id="W25Q64介绍">W25Q64介绍</h3><p><img src="./image/image-20250101193816880.png" alt="image-20250101193816880"></p><blockquote><p><code>容量：</code></p><p>该芯片存储为M级别，在手机可能很小，但是在嵌入式领域还是挺大的</p><p>还有的芯片是KB级别的，例如AT24C02芯片，使用的I2C通信的E2PROM芯片</p><hr><p><code>存储器分类：</code></p><p>分为非易失性存储器(FLASH、E2PROM)和易失性存储器(SRAM、DRAM)</p><p>该芯片是非易失性存储器，数据掉电不丢失，存储介质为Nor Flash</p><hr><p><code>通信协议：</code></p><p>使用SPI串行通信，SCK时钟线频率最大为80MHz，双重SPI模式等效频率为160Mhz，四重SPI模式等效的频率为320MHz</p><p>频率相对于stm32非常快</p><hr><p><code>应用：</code></p><p>数据存储：</p><p>字库存储：可以存放中文字库等，使用时读取数据后显示中文</p><hr><p><code>型号：</code></p><p><strong>芯片使用24位地址，3个字节</strong></p><p>2的24方 = 16MB，所以24位地址的最大寻址空间为16MB，所W25Q40~W25Q128都是够用的，但是W25Q256是32MB的存储不够用</p><p>W25Q256分为3字节地址模式和4字节地址模式，使用3字节模式下只能读写到前16MB地址，而要想读写所有的地址进入4字节地址模式即可</p><p>更换芯片型号，硬件电路和底层驱动程序都不用更改</p></blockquote><h4 id="硬件电路-5">硬件电路</h4><p><img src="./image/image-20250101233710004.png" alt="image-20250101233710004"></p><blockquote><p>该芯片的供电VCC接3.3V</p><hr><p>WP：写保护，低电平不允许写，高电平可以写</p><p>HOLD：数据保持，低电平有效</p><p>作用：在正常读写时突然产生中断，然后想用SPI通信线去操控其他器件，此时如果把CS置回高电平，那时序就会终止，但如果不想终止总线又想操作其他器件，此时就可以将HOLD引脚置低电平，芯片释放总线，芯片的时序也不会终止，会记住当前的状态，操作完后可以回来HOLD置高电平，继续之前的时序。</p><p>相当于SPI总线进了一次中断</p><p><strong>HOLD和WP如果想用就接到GPIO引脚上，如果不想用就直接接VCC即可</strong></p><hr><p>IO1 、IO2与双重SPI和四重SPI有关</p></blockquote><h4 id="框图">框图</h4><p><img src="./image/image-20250102170255168.png" alt="image-20250102170255168"></p><blockquote><p><code>几个基本概念：块、扇区、页:</code></p><p><code>块大小：</code>64KB</p><p><code>扇区大小：</code>4KB</p><p><code>页大小：</code>256B</p><p>8MB的地址空间从0x000000到0x7FFFFF</p><p><strong>右边</strong>：以64KB为一个基本单元块划分为若干个块Block  8MB/64KB = 128块(块0~127)</p><p><strong>左上</strong>：以4KB为一个基本单元再将每个Block划分为若干个单元，每个单元叫做Sector-扇区 64KB/4KB = 16个扇区(扇区0~15)</p><p>我们在写入数据时其实还有一个划分叫做页，是对扇区进行的一个更细的划分，一页为256字节 4KB/256 = 16页(0~15页)</p><hr><p><strong>左下角：芯片的控制逻辑</strong></p><p>芯片内部的地址锁存、数据读写等操作都由控制逻辑自动完成</p><p>控制逻辑的左边连接的是SPI的引脚</p><p>控制逻辑上方是状态寄存器，可以知道芯片是否处于忙状态、是否写使能等</p><p>状态寄存器上方是写控制逻辑与WP引脚连接，实现硬件写保护</p><p>内部集成了高电压发生器(High Voltage Generators)，用于实现掉电不丢失</p><hr><p><strong>最下方：字节地址锁存/计数器</strong></p><p>用于指定地址，SPI放过来3个字节的地址，前2个字节进到<strong>页地址锁存计数器</strong>，最后一个字节进入<strong>字节地址锁存计数器</strong>中</p><p>然后页地址锁存计数器通过写保护和行解码选择操作的哪一页</p><p>字节地址锁存计数器通过列解码和256字节页缓存来进行指定字节的读写操作</p><p>其中的计数器与地址指针自动+1有关</p><hr><p><strong>右下方：列解码和256Byte 页缓冲区</strong></p><p>实际上是个RAM缓冲区，写入数据时先放到这个RAM缓冲区，时序结束后，芯片对应状态BUSY会置1，芯片再将缓冲区的数据复制到对应的Flash中，此时不会响应新的写入</p><p><strong>缓冲区作用</strong>：SPI的写入频率是非常高的，而Flash的写入速度比较慢(掉电不丢失特性)，所以需要使用一个RAM页缓存区来存储写入的数据，从而可以跟得上SPI总线的速度。</p></blockquote><h4 id="Flash操作注意事项">Flash操作注意事项</h4><p><img src="./image/image-20250102173909328.png" alt="image-20250102173909328"></p><blockquote><p>第1条规定：直接使能即可</p><p>第2条规定：不擦除写入数据可能会与实际不符，实际值为(写入数据&amp;芯片内数据)</p><p><code>第3条规定：</code>是为了弥补第2条规定设立，保证每次写入数据不出错，由专门的擦除电路自动进行，我们只需要发送擦除的指令即可</p><p><code>一定要在每次写入前擦除数据!!!</code></p><p>第4条规定：擦除时只能选择整个芯片擦除、按块擦除、按扇区擦除，所以最小的擦除单元是一个扇区为4KB-4096字节。不能指定对某个字节擦除，如果想要擦除某一个字节，只能对该字节所在的扇区的4096个字节进行擦除</p><p>为了弥补这个缺点，我们需要在程序逻辑上进行一些优化：比如上电后先将Flash备份一份到RAM中</p><p>第5条规定：一次性不能写太多，一个写入时序最多写256字节(由缓冲区限制)</p><p>第6条规定：写入时序结束或者擦除芯片之后，芯片进入忙状态(BUSY位=1)，当状态寄存器BUSY位为0后才会继续响应</p><p>第7条规定：读取时序基本没有限制，唯一就是不能在忙状态时读取</p><hr><p>由于Flash掉电不丢失的特性，成本低，存储量大，所以在操作的便携性上不是很友好，以及速度不是很快。但在非易失性存储器中速度却是很快的。</p><p>与RAM想在哪些就在哪写，想写多少就写多少不同，且可以覆盖写入区别较大</p></blockquote><h4 id="芯片手册">芯片手册</h4><p>主要包含写保护配置表、状态寄存器、指令集，以及对每条指令的详细解释。还有芯片电器特性(供电电压范围等)</p><ul><li><code>状态寄存器:</code></li></ul><blockquote><p><img src="./image/image-20250102191517893.png" alt="image-20250102191517893"></p><p><code>BUSY位：</code></p><p>当设备执行页编程（Page Program）、扇区擦除（Sector Erase）、块擦除（Block Erase）、芯片擦除（Chip Erase）或写状态寄存器指令时会被设置为1。在该位为1时，表示设备正在忙碌，不会响应其他指令，除了读取状态寄存器和进入/擦除挂起操作的指令。程序、擦除或写状态寄存器操作完成后，“BUSY”位会清零，表明设备已准备好接收新的指令。</p><p><code>WEL位(写使能锁存位)：</code></p><p>WEL 是一个状态寄存器（Status Register）中的位，仅在执行了 Write Enable 指令后被设置为。在数据写入完成后，该位会被清零以禁用写操作。 当电源关闭或者执行以下任一指令时，WEL也会被禁用：Write Disable、Page Program(页编程)、Sector Erase（扇区擦除）、Block Erase（块擦除）、Chip Erase(芯片擦除) 和 <strong>Write Status Register(写入数据后会自动进行写使能)。</strong></p><p>例子说明： 假设你有一块闪存芯片，在你想要向其写入数据之前，必须先发送 Write Enable 指令来激活WEL位。只有当这个位是激活状态（即值为1），才能对芯片进行编程或擦除操作。一旦这些操作完成或者直接通过发送特定指令显式地禁用它（比如Write Disable），WEL会回到未激活状态（即值为0），从而防止意外改变数据。</p><p><code>注意：一条写指令只能保证后续的一条写指令可以执行，所以每次写入都要进行写使能</code></p><hr><p><code>其他的位请自行查看手册！！</code></p></blockquote><ul><li><code>指令集(Instruction):</code></li></ul><blockquote><p><img src="./image/image-20250102193355258.png" alt="image-20250102193355258"></p><p>厂商ID是：0xEF</p><p>设备ID：</p><p>0x16 (如果使用0xAB和0x90来读)</p><p>0x4017 (使用0x9F来读)</p><hr><p><img src="./image/image-20250102193817312.png" alt="image-20250102193817312"></p><p><code>Write Enable：</code>写使能，发送0x06</p><p><code>Write Disable：</code>写失能，发送0x04</p><hr><p><code>Read Status Register-1：</code>读取状态寄存器第1位，发送0x05，用于查看忙状态，S0是BUSY位，S1是WEL位</p><hr><p><code>Page Program：</code>页编程就是写数据，发送0x02，然后继续发送地址23-16位，15-8位，7-0位三个字节，然后发送写入的数据</p><p><strong>注意：该芯片不能跨页写入，在执行跨页写入时，多出来的数据会从页首的地方覆盖写入，一页为256B对应16进制为0x000000~0x0000FF。</strong></p><p><strong>若确实需要跨页写入，需要连续写入很大的数组，只能从软件上进行分批次写入，先计算数组要跨多少也，擦除对应区域,最后分批次一页一页写，最后封装成一个函数</strong></p><hr><p><code>Block Erase：</code>块擦除，包括按64KB的块擦除、32KB的块擦除、4KB的扇区擦除。发送0xD8/0x62，再发送三个字节的地址即可</p><p><code>Sector Erase：</code>扇区擦除，包括4KB的扇区擦除。发送0x20，再发送三个字节的地址即可，对应一个扇区为0x000000~0x000FFF</p><p><code>Chip Erase：</code>发送0xC7或0x60h即可</p><hr><p><code>JEDEC ID：</code>读取ID指令，发送0x9F，然后连续交换三个字节数据，得到的第一个字节是厂商ID，后两个字节是设备ID</p></blockquote><blockquote><p><img src="./image/image-20250102195113035.png" alt="image-20250102195113035"></p><p><code>Read Data：</code>读取数据，发送0x03，之后交换发送3个字节地址，接下来读取的就是该地址下的数据</p></blockquote><ul><li><code>执行所用时间：</code></li></ul><blockquote><p><img src="./image/image-20250102200118784.png" alt="image-20250102200118784"></p><p>页编程以及各种擦除所用时间，基本都是ms级别</p></blockquote><ul><li><code>dummy数据：</code></li></ul><blockquote><p><img src="./image/image-20250104225524682.png" alt="image-20250104225524682"></p><p><strong>手册中可以看到发送的数据为dummy，这个dummy就代表无用数据，发送0xFF即可此时发送和接收的数据都没有意义。</strong></p><p><strong>作用：可能是做一些延时</strong></p></blockquote><h3 id="软件SPI读写W25Q64">软件SPI读写W25Q64</h3><h4 id="软件SPI底层代码">软件SPI底层代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MySPI.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSPI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSPI_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//void MySPI_W_SS(uint8_t BitVal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void MySPI_W_SCK(uint8_t BitVal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void MySPI_W_MOSI(uint8_t BitVal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//uint8_t MySPI_W_MISO()；</span></span><br><span class="line"><span class="comment">/*上面四个函数只有MySPI.c中会使用，所以我们不用放在头文件中，保持模块的独立，封装！！！！！！*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写SS</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SS</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写SCK</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SCK</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_5,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写MOSI</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_MOSI</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_7,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读MISO</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_R_MISO</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_6);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*由于SPI速度很快，操作引脚后就不用加延时了*/</span></span><br><span class="line"><span class="comment">/*上面这样单独对写入引脚的封装，有利于单片机移植或者添加延时*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//1.开启对应引脚RCC</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//2.配置GPIO</span></span><br><span class="line">  <span class="comment">/*三个推挽输出引脚*/</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*一个上拉/浮空输入引脚*/</span></span><br><span class="line">  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.配置默认电平：初始化SS引脚为高电平，由于使用模式0，所以初始化SCK引脚为低电平</span></span><br><span class="line">  MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI起始条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_W_SS(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI终止条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI字节交换,由于是交换1字节，所以需要有返回值得到从机发送的1字节</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> ByteReceive = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*1.依次1位，1位操作*/</span></span><br><span class="line"><span class="comment">//MySPI_W_MOSI(ByteSend &amp;= 0x80); //移出第一位数据</span></span><br><span class="line"><span class="comment">//  MySPI_W_SCK(1);</span></span><br><span class="line"><span class="comment">//if(MySPI_W_MISO() == 1)  //接收从机发送的第一位数据(最高位)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//ByteReceive |= 0x80;   </span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//MySPI_W_SCK(0);</span></span><br><span class="line"><span class="comment">///*一个时序的结束*/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//MySPI_W_MOSI(ByteSend &amp;= 0x40);//移出第二位数据</span></span><br><span class="line"><span class="comment">//MySPI_W_SCK(1);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//if(MySPI_W_MISO() == 1)  //接收从机发送的第二位数据(次高位)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//ByteReceive |= 0x40;   </span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//.....一位一位发送，可以简化为循环</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*2.通过掩码，依次挑出每一位进行操作*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">MySPI_W_MOSI(ByteSend &amp; (<span class="number">0x80</span> &gt;&gt; i)); <span class="comment">//移出第i位数据，每次只发送了1bit</span></span><br><span class="line">MySPI_W_SCK(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(MySPI_R_MISO() == <span class="number">1</span>)  <span class="comment">//接收从机发送的第i位数据(i=0时为最高位)，每次只接收了1bit</span></span><br><span class="line">&#123;</span><br><span class="line">ByteReceive |= (<span class="number">0x80</span> &gt;&gt; i);   </span><br><span class="line">&#125;</span><br><span class="line">MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3.通过SPI中主机和从机移位寄存器交换字节的方式，更加契合SPI的移位模型讲解*/</span></span><br><span class="line"><span class="comment">//for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//MySPI_W_MOSI(ByteSend &amp;= 0x80); //移出第i位数据，每次只发送了1bit</span></span><br><span class="line"><span class="comment">//ByteSend &lt;&lt;= 1 ; //最高位发送后，左移1位后最低位为0，空出最低为</span></span><br><span class="line"><span class="comment">//MySPI_W_SCK(1);</span></span><br><span class="line"><span class="comment">//if(MySPI_W_MISO() == 1)  //接收从机发送的第i位数据(i=0时为最高位)，每次只接收了1bit</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//ByteSend |= 0x01; //主机发送数据的移位寄存器最后1bit置为从机移位发送的1bit</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//MySPI_W_SCK(0);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////最终得到的ByteSend就是移位交换后的数据，就可以不用定义ByteReceive,提高效率</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ByteReceive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面演示的是SPI模式0的时序，如果需要修改模式，只需要对照时序图进行修改即可</p><p>比如修改为模式1，对照模式1的时序图只需要将for循环中的前两行代码交换顺序即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">         MySPI_W_SCK(<span class="number">1</span>);</span><br><span class="line">         <span class="comment">/*这两行*/</span></span><br><span class="line">MySPI_W_MOSI(ByteSend &amp;= (<span class="number">0x80</span> &gt;&gt; i)); </span><br><span class="line"><span class="keyword">if</span>(MySPI_W_MISO() == <span class="number">1</span>)  </span><br><span class="line">&#123;</span><br><span class="line">ByteReceive |= (<span class="number">0x80</span> &gt;&gt; i);   </span><br><span class="line">&#125;</span><br><span class="line">MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>这里的模式0和模式1的时钟极性相同，如果改为模式2或模式3时，只需要将所有出现SCK的地方电平全部翻转一下即可</code></p></blockquote><h4 id="W25Q64测试代码">W25Q64测试代码</h4><p><code>由于指令码直接书写不太美观，也不够清楚，所以我们可以对指令集进行宏定义。新建一个头文件，单独存放指令集的宏定义！！！</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64_Ins*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q64_INS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q64_INS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据W25Q64的手册将所有的指令码抄过来*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_ENABLE0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_DISABLE0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_STATUS_REGISTER_10x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_STATUS_REGISTER_20x35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_STATUS_REGISTER0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_PAGE_PROGRAM0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_QUAD_PAGE_PROGRAM0x32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_BLOCK_ERASE_64KB0xD8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_BLOCK_ERASE_32KB0x52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_SECTOR_ERASE_4KB0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_CHIP_ERASE0xC7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_ERASE_SUSPEND0x75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_ERASE_RESUME0x7A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_POWER_DOWN0xB9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_HIGH_PERFORMANCE_MODE0xA3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_CONTINUOUS_READ_MODE_RESET0xFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_RELEASE_POWER_DOWN_HPM_DEVICE_ID0xAB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_MANUFACTURER_DEVICE_ID0x90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_UNIQUE_ID0x4B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_JEDEC_ID0x9F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_DATA0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ0x0B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_DUAL_OUTPUT0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_DUAL_IO0xBB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_QUAD_OUTPUT0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_QUAD_IO0xEB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_OCTAL_WORD_READ_QUAD_IO0xE3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_DUMMY_BYTE0xFF</span></span><br><span class="line"><span class="comment">//用于表示接受时交换过去的无用数据</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q64_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q64_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySPI.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  MySPI_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看芯片手册对应指令集编写时序*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span></span><br><span class="line">&#123;</span><br><span class="line">  MySPI_Start();</span><br><span class="line"></span><br><span class="line">MySPI_SwapByte(<span class="number">0x9F</span>);<span class="comment">//发送读取厂商ID和设备ID的指令码</span></span><br><span class="line"></span><br><span class="line">*mId = MySPI_SwapByte(<span class="number">0xFF</span>);<span class="comment">//交换数据得到从机返回的第一个字节厂商ID，主机随便发送什么默认0xFF</span></span><br><span class="line"></span><br><span class="line">*dId = MySPI_SwapByte(<span class="number">0xFF</span>);<span class="comment">//交换数据得到从机返回的第二个字节设备ID(前8bit为存储器类型，后8bit为存储器大小)，主机随便发送什么默认0xFF</span></span><br><span class="line">*dId &lt;&lt;= <span class="number">8</span>; <span class="comment">//设置16bit高8位</span></span><br><span class="line"></span><br><span class="line">*dId |= MySPI_SwapByte(<span class="number">0xFF</span>);<span class="comment">//设置16bit低8位，不能直接等于，否则高八位会被置0</span></span><br><span class="line"></span><br><span class="line">  MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>测试代码：先使用该读取ID的代码测试是否能使用SPI</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c业务代码*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> mid=<span class="number">0x00</span>;</span><br><span class="line"><span class="type">uint16_t</span> did=<span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">  UsartInit();</span><br><span class="line"></span><br><span class="line">W25Q64_Init();</span><br><span class="line"></span><br><span class="line">W25Q64_ReadID(&amp;mid,&amp;did);</span><br><span class="line">  UsartSendNum(mid,<span class="number">2</span>);</span><br><span class="line">  UsartSendNum(did,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们读取的指令码为0x9F，对应手册上收到的应该是</p><p>厂商ID：0xEF</p><p>设备ID：0x4017</p><p>将OLED上显示或者串口发送的结果对比发现正确</p></blockquote><h4 id="W25Q64完整代码">W25Q64完整代码</h4><blockquote><p><strong>由于每次操作需要我们判断是否芯片是否处于BUSY，所有我们可以在每次写操作的时候进行等待BUSY位。等待分为事前等待和事后等待</strong></p><p><code>事前等待</code>：在写操作开始前调用W25Q64_WaitBusy等待BUSY位置0</p><p><code>事后等待</code>：在写操作结束后需要调用W25Q64_WaitBusy</p><p><strong>两者区别：</strong></p><ol><li><p><strong>事后等待比事前等待更保险，事后等待可以保证在进行写操作之外的地方芯片肯定不处于BUSY状态，保证安全。</strong></p></li><li><p><strong>事前等待效率比事后等待效率高，可以在执行完写操作后执行其他代码，刚好可以利用这段代码来消耗等待时间</strong></p></li><li><p><strong>事前等待需要在读取和写入前都要调用。因为读的时候也需要在BUSY位不为1的时候。而事后等待只需要在写入后调用</strong></p></li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q64_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q64_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_PageProgram</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint16_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_SectorErase</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadData</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint32_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void W25Q64_WriteEnble();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void W25Q64_WaitBusy();</span></span><br><span class="line"><span class="comment">/*这两个函数为了模块化，不用外部调用了*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySPI.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64_Ins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  MySPI_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看芯片手册对应指令集编写时序！！！*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span></span><br><span class="line">&#123;</span><br><span class="line">  MySPI_Start();</span><br><span class="line"></span><br><span class="line">MySPI_SwapByte(W25Q64_JEDEC_ID);<span class="comment">//发送读取厂商ID和设备ID的指令码</span></span><br><span class="line"></span><br><span class="line">*mId = MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//交换数据得到从机返回的第一个字节厂商ID，主机随便发送什么默认0xFF</span></span><br><span class="line"></span><br><span class="line">*dId = MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//交换数据得到从机返回的第二个字节设备ID(前8bit为存储器类型，后8bit为存储器大小)，主机随便发送什么默认0xFF</span></span><br><span class="line">*dId &lt;&lt;= <span class="number">8</span>; <span class="comment">//设置16bit高8位</span></span><br><span class="line"></span><br><span class="line">*dId |= MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//设置16bit低8位，不能直接等于，否则高八位会被置0</span></span><br><span class="line"></span><br><span class="line">  MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次写之前都要写使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WriteEnble</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_Start();</span><br><span class="line"></span><br><span class="line">MySPI_SwapByte(W25Q64_WRITE_ENABLE);</span><br><span class="line"></span><br><span class="line">MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待状态寄存器BUSY位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WaitBusy</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> Timeout=<span class="number">100000</span>;</span><br><span class="line">MySPI_Start();</span><br><span class="line"></span><br><span class="line">MySPI_SwapByte(W25Q64_READ_STATUS_REGISTER_1);</span><br><span class="line"><span class="keyword">while</span>((MySPI_SwapByte(W25Q64_DUMMY_BYTE) &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>) <span class="comment">//状态寄存器有8位，最低位代表BUSY位，读取判断BUSY位若为1就一直等待</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*状态寄存器可以被连续读取，如果不停止就会一直发送状态寄存器当前的值*/</span></span><br><span class="line">Timeout--;</span><br><span class="line"><span class="keyword">if</span>(Timeout == <span class="number">0</span>)<span class="comment">//超时退出避免程序卡死</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页编程，也就是写入数据到W25Q64。需要先写使能！！</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_PageProgram</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint16_t</span> count)</span><span class="comment">//读取最大值count为256，所以要定义为uint16，uint8=255</span></span><br><span class="line">&#123;</span><br><span class="line">W25Q64_WriteEnble();<span class="comment">//每次写入数据前都要进行写使能！！！，在这里可以方便我们避免每次都要手动写使能</span></span><br><span class="line">MySPI_Start();</span><br><span class="line">MySPI_SwapByte(W25Q64_PAGE_PROGRAM);</span><br><span class="line">  MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);<span class="comment">//取高8位</span></span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>); <span class="comment">//取中8位该函数只会发送8bit数据，高位会舍弃</span></span><br><span class="line">MySPI_SwapByte(Address);<span class="comment">//取低8位发送</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">&#123;</span><br><span class="line">MySPI_SwapByte(DataArray[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySPI_Stop();</span><br><span class="line"></span><br><span class="line">W25Q64_WaitBusy();<span class="comment">//写操作进行事后等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扇区擦除，其他擦除同理,Address为指定擦拭的4个字节，也就是1个扇区。需要先写使能！！</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_SectorErase</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">  W25Q64_WriteEnble(); <span class="comment">//每次写入数据前都要进行写使能！！！，在这里可以方便我们避免每次都要手动写使能</span></span><br><span class="line">MySPI_Start();</span><br><span class="line">MySPI_SwapByte(W25Q64_SECTOR_ERASE_4KB);</span><br><span class="line">  MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);<span class="comment">//取高8位</span></span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>); <span class="comment">//取中8位该函数只会发送8bit数据，高位会舍弃</span></span><br><span class="line">MySPI_SwapByte(Address);<span class="comment">//取低8位发送</span></span><br><span class="line">MySPI_Stop();</span><br><span class="line"></span><br><span class="line">W25Q64_WaitBusy();<span class="comment">//写操作进行事后等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadData</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint32_t</span> count)</span><span class="comment">//读取时数量没有限制</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_Start();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//1.发送读取数据指令码</span></span><br><span class="line">MySPI_SwapByte(W25Q64_READ_DATA);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//2.发送读取的24位地址</span></span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);<span class="comment">//取高8位</span></span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>); <span class="comment">//取中8位该函数只会发送8bit数据，高位会舍弃</span></span><br><span class="line">MySPI_SwapByte(Address);<span class="comment">//取低8位发送</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//3.置换得到数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">&#123;</span><br><span class="line">DataArray[i]= MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//发送0xFF将数据置换过来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> mid=<span class="number">0x00</span>;</span><br><span class="line"><span class="type">uint16_t</span> did=<span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> ArrayWrite[] = &#123;<span class="number">0xA1</span>,<span class="number">0xB2</span>,<span class="number">0xC3</span>,<span class="number">0xD4</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> ArrayRead[<span class="number">4</span>]; </span><br><span class="line"></span><br><span class="line">W25Q64_Init();</span><br><span class="line">  </span><br><span class="line">W25Q64_ReadID(&amp;mid,&amp;did);</span><br><span class="line">   </span><br><span class="line">W25Q64_SectorErase(<span class="number">0x000000</span>);<span class="comment">//指定擦除扇区起始地址，后3位代表一个扇区内地址，6位代表块地址</span></span><br><span class="line">W25Q64_PageProgram(<span class="number">0x000000</span>,ArrayWrite,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">W25Q64_ReadData(<span class="number">0x000000</span>,ArrayRead,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>1.每次写入数据前要先写使能!!!</code></p><p><code>2.每次写入前一定要记得擦除!!!</code></p><p><strong>最终OLED上显示发送和读取的数据相同，断电后不写入直接读取数据也不变</strong></p></blockquote><h3 id="硬件SPI外设-硬件读写">硬件SPI外设(硬件读写)</h3><p><img src="./image/image-20250105141343897.png" alt="image-20250105141343897"></p><blockquote><p>SPI最常用配置就是8位数据帧，高位先行。16位和低位先行用的很少</p><hr><p><code>时钟频率：</code><strong>SPI的时钟由PCLK(外设时钟)分频得来</strong>，可以2~256分频，时钟频率越快，对应传输速率越快。</p><p>频率不能任意指定，也就是说SPI的时钟频率只能是对面8种分频后对应的时钟频率，且对于SPI1和SPI2来说，PCLK也不相同，SPI1挂载在APB2，PCLK是72MHz，SPI2挂载在APB1，PCLK是36MHz</p><hr><p><code>多主机模型：</code>使用较少，可以看手册学习</p><p><code>主机或从机：</code>通常作为主机</p><hr><p><code>精简为半双工/单工通信：</code></p><p>可以节省一条数据线，半双工或单工通信。一般不适用</p><hr><p><code>DMA:</code>大量数据传输时使用</p><hr><p><code>兼容I2S协议：</code>数字音频传输专用协议，与SPI有一些共同特征</p><hr><p><code>以上所有内容都可以查看参考手册进行学习！！！</code></p></blockquote><h4 id="SPI框图">SPI框图</h4><p><img src="./image/image-20250108114540986.png" alt="image-20250108114540986"></p><blockquote><p>与对应寄存器描述结合理解</p><hr><p><code>左上角：</code>通过LSBFIRST控制位控制低位先行还是高位先行，移位寄存器通过MOSI和MISO，分别移动和接收一位位数据。SPI发送和接收可以同时进行</p><p>接收缓冲区：就是RDR寄存器</p><p>发送缓冲区：就是TDR寄存器</p><p>TDR和RDR占用同一个地址，统一叫作DR，写入经过RDR，发送数据经过TDR，对应也是TXE(发送寄存器空)和RXNE(接收寄存器非空)两个标志位</p><p><strong>移位寄存器配合数据寄存器实现连续数据流</strong>：</p><p>发送数据先写入TDR，再转到移位寄存器发送，发送的同时接收数据，接收的同时转到RDR，我们再从RDR读取数据</p><hr><p><code>左下角：</code></p><p>波特率发生器：内部有一个分频器，输入时钟为PCLK，72M或36M，经过分频器后输出到SCK，生成时钟与移位寄存器同步</p><hr><p><code>右下角:</code></p><p>LSBFIRST：用于控制高位先行还是低位先行</p><p>SPE：SPI使能位</p><p>BR2，BR1，BR0：用于控制分频系数</p><p>MSTR：配置主从模式</p><p>CPOL和CPHA：选择SPI四种模式</p><hr><p><code>右上角：</code></p><p>一些使能位与控制位，重要的是TXE和RXNE</p><hr><p><code>NSS引脚：</code>与多主机有关</p></blockquote><p><code>SPI外设基本结构:</code></p><p><img src="./image/image-20250108122752353.png" alt="image-20250108122752353"></p><blockquote><p><strong>TDR整体转入移位寄存器的时刻，置TXE标志位为1</strong></p><p><strong>移位寄存器数据整体转入RDR的时刻，置RXNE标志位为1</strong></p><hr><p><strong>图中没画出SS引脚，我们使用普通的GPIO口来模拟</strong></p></blockquote><h4 id="主模式全双工连续传输">主模式全双工连续传输</h4><p><img src="./image/image-20250108172721631.png" alt="image-20250108172721631"></p><blockquote><p>这里演示的是模式3，低位先行的模式：</p><p><strong>首先等待TXE=1后就软件写入数据到SPI_DR(TDR)，TXE也就变为0，转入完成后，立马将数据再移动到移位寄存器，转入到移位寄存器瞬间把TXE置为1，表示发送寄存器空，波形产生开始传输，但此时又要立马把下个数据写入到TDR中</strong></p><hr><p>流程简述下来就是：</p><p>发送数据1、发送数据2-- 接收数据1 --发送数据3 – 接收数据2 - 发送数据4 – 接收数据3</p><p>数据交换的流程是交叉的，要求很严格，对程序设计不太友好</p><p><strong>如果对效率要求很高，就可以研究这个</strong></p></blockquote><h4 id="非连续传输">非连续传输</h4><p><img src="./image/image-20250108174720946.png" alt="image-20250108174720946"></p><blockquote><p>这里演示的是模式3，低位先行的模式：</p><p><strong>接收时序与发送时序是同步的，具体见连续传输的图，因为是主机和从机交换字节发送所以发送的同时也在接收。但是必须先发送才会产生时序，然后才会有接收！！！</strong></p><p>首先等待TXE=1后就软件写入数据到SPI_DR(TDR)，TXE也就变为0，转入完成后，立马将数据再移动到移位寄存器，转入到移位寄存器瞬间把TXE置为1，表示发送寄存器空，一旦移位寄存器有数据了，<strong>时序波形会自动产生</strong>，开始交换数据</p><p><strong>此时不立马将下个数据写入TDR，而是等待第一个字节时序结束，意味着接收第一个字节也结束了，RXNE置1，先把第一个接收到的数据读出来，之后再写入数据2</strong></p><p><strong>流程即：四行代码完成任务</strong></p><p>第1步：等待TXE为1</p><p>第2步：写入发送的数据至TDR</p><p>第3步：等待RXNE为1</p><p>第4步：读取RDR接收的数据</p><p>然后重复第2、3、…字节</p><p>所以我们只需要将这四步封装到一个函数中就可以实现字节的交换，与软件SPI的流程基本上是一样的。</p><hr><p><code>非连续与连续传输的区别：</code>没有及时将数据送入TDR寄存器，等到第一个字节时序完成后，第二个字节还没有送过来，数据传输就会等候，所以时钟和数据的时序在字节与字节之间产生了间隙，拖慢了整体数据传输的速度。</p><p><img src="./image/image-20250108175801926.png" alt="image-20250108175801926"></p><p>间隙在SCK频率低时影响不大，但在非常高时就非常严重</p><p>频率在2分频下的波形：</p><p><img src="./image/image-20250108181920148.png" alt="image-20250108181920148"></p><p>可以看到等待时间都远大于数据交换时间了</p><p><code>所以我们要在想在极限频率下，进一步提高数据传输速率，我们需要使用连续传输模式，或者使用DMA</code></p></blockquote><h4 id="TXE和RXNE标志位清除问题">TXE和RXNE标志位清除问题</h4><p><img src="./image/image-20250108211408772.png" alt="image-20250108211408772"></p><blockquote><p><strong>手册上的描述，TXE和RXNE会在写入DR和读DR的时候由硬件清除</strong></p><p><strong>所以我们不需要手动调用ClearFlag清除标志位</strong></p></blockquote><h4 id="连续和非连续的优缺点">连续和非连续的优缺点</h4><blockquote><p><code>非连续传输：</code></p><p>好处：容易封装，好理解，好用</p><p>缺点：会损失一点点性能</p><hr><p><code>连续传输:对传输效率有要求的话可以使用</code></p><p>好处：传输更快</p><p>缺点：操作起来相对复杂，对软件的需求较高，每个标志位产生后数据都要及时处理</p></blockquote><h4 id="软件硬件波形对比">软件硬件波形对比</h4><p><img src="./image/image-20250108182601125.png" alt="image-20250108182601125"></p><blockquote><p><code>区别：</code></p><p>下降沿和低电平期间，都可以作为数据变化的时刻，只是硬件波形一般会紧贴边沿，软件波形，一般只能在电平期间，无论哪种方式都不会影响数据传输。</p><p>对于软件波形，尽量要贴近边沿，否则等待太久贴近下一个边沿了数据也会容易出错</p></blockquote><h4 id="SPI库函数">SPI库函数</h4><p><strong>标准库函数中包含的SPI很多名称中带有I2S相关的函数，因为I2S与SPI共用一套电路。直接使用即可</strong></p><ul><li><code>初始化：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_DeInit</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2S_Init</span><span class="params">(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2S_StructInit</span><span class="params">(I2S_InitTypeDef* I2S_InitStruct)</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_Init</span><span class="params">(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_StructInit</span><span class="params">(SPI_InitTypeDef* SPI_InitStruct)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>外设使能：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_Cmd</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2S_Cmd</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>中断配置：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_ITConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_I2S_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>DMA：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_DMACmd</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_I2S_DMAReq, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>发送和接收数据：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_SendData</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="comment">//数据到DR</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_I2S_ReceiveData</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br><span class="line"><span class="comment">//从DR读数据</span></span><br></pre></td></tr></table></figure><hr><p><code>不常用函数：</code></p><ul><li><code>NSS引脚配置：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_NSSInternalSoftwareConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_NSSInternalSoft)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_SSOutputCmd</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>数据帧位数配置：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_DataSizeConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_DataSize)</span>;</span><br><span class="line"><span class="comment">//8位或16为数据帧配置</span></span><br></pre></td></tr></table></figure><ul><li><code>CRC校验配置：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_TransmitCRC</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_CalculateCRC</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_GetCRC</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_CRC)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_GetCRCPolynomial</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>半双工时双向线的方向配置：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_BiDirectionalLineConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_Direction)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>标志位：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">SPI_I2S_GetFlagStatus</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_I2S_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_ClearFlag</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_I2S_FLAG)</span>;</span><br><span class="line">ITStatus <span class="title function_">SPI_I2S_GetITStatus</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_I2S_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_ClearITPendingBit</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_I2S_IT)</span>;</span><br></pre></td></tr></table></figure><h4 id="硬件SPI初始化流程">硬件SPI初始化流程</h4><blockquote><p>根据SPI框图：</p><ol><li>开启RCC对应SPI和GPIO口的时钟</li><li>初始化GPIO口，SCK和MOSI是硬件控制输出的信号，配置为<strong>复用推挽输出</strong>。MISO是，是硬件外设配置的输入信号，配置为<strong>上拉输入</strong>。还有一个SS引脚，使用软件模拟控制的输出信号，配置为<strong>通用推挽输出</strong>即可</li><li>配置SPI外设，调用SPI_Init配置各参数即可</li><li>使能，开关控制，调用SPI_Cmd即可</li><li>默认SS为高电平，不使用从机</li></ol></blockquote><h4 id="硬件SPI读写W25Q64">硬件SPI读写W25Q64</h4><blockquote><p>对于W25Q64Q驱动层的代码我们不需要修改，我们只需要修改底层SPI代码即可</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MySPI.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSPI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSPI_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MySPI.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写SS</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SS</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//1.开启对应引脚RCC</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.配置GPIO</span></span><br><span class="line"><span class="comment">/*SCK和MOSI复用推挽输出引脚*/</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_7;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*使用软件模拟SS，SS通用推挽输出引脚*/</span>  </span><br><span class="line">  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_4;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*MISO上拉输入引脚*/</span></span><br><span class="line">  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//3.配置SPI</span></span><br><span class="line">  SPI_InitTypeDef SPI_InitStruct;</span><br><span class="line">  SPI_InitStruct.SPI_Mode = SPI_Mode_Master;<span class="comment">//选择主机</span></span><br><span class="line">  SPI_InitStruct.SPI_Direction = SPI_Direction_2Lines_FullDuplex;<span class="comment">//选择全双工</span></span><br><span class="line">  SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b;</span><br><span class="line">  SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB;<span class="comment">//8位先行</span></span><br><span class="line">  SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;<span class="comment">//频率为72Mhz/128 = 500多khz</span></span><br><span class="line">  SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge;</span><br><span class="line">  SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low;</span><br><span class="line">  SPI_InitStruct.SPI_NSS = SPI_NSS_Soft;<span class="comment">//我们使用的GPIO引脚模拟，使用软件NSS</span></span><br><span class="line">  SPI_InitStruct.SPI_CRCPolynomial = <span class="number">7</span>;<span class="comment">//我们不使用CRC校验，只需要随便给个值即可</span></span><br><span class="line">  SPI_Init(SPI1,&amp;SPI_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.使能</span></span><br><span class="line">  SPI_Cmd(SPI1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.默认不选中从机</span></span><br><span class="line">  MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI起始条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_W_SS(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI终止条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI字节交换，硬件自动控制SCK、MOSI、MISO引脚</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="comment">/*对应非连续传输的四个步骤*/</span></span><br><span class="line"><span class="comment">//1.等待TXE为1，代表发送数据寄存器为空，可以写入数据了</span></span><br><span class="line"><span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) != SET)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写入发送数据到TDR(发送数据寄存器)，同时自动清除TXE</span></span><br><span class="line">SPI_I2S_SendData(SPI1,ByteSend);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.等待RXNE为1，接收数据寄存器非空，代表接收完成</span></span><br><span class="line"><span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE) != SET)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.从RDR(接收数据寄存器)读取接收到的数据，同时自动清除RXNE</span></span><br><span class="line"><span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>RTC</h1><h2 id="常识">常识</h2><h3 id="Unix时间戳">Unix时间戳</h3><p><img src="./image/image-20250109131815285.png" alt="image-20250109131815285"></p><blockquote><p><code>时间戳：</code>1970年1月1日0时0分0秒开始所经过的秒数，没有进位，不同时区通过对秒计数器添加偏移就可以得到当地时间</p><p>计算机底层使用时间戳会很方便，只需要一个很大的寄存器存储秒数即可</p><p>给人类观看的时候，只需要将时间戳转换为对应的日期即可</p><p>但是，时间戳比较占用软件资源，在每次进行秒计数器和日期时间转换时，软件都需要经过比较复杂的运算</p></blockquote><h3 id="RTC-GMT">RTC/GMT</h3><p><img src="./image/image-20250109133115489.png" alt="image-20250109133115489"></p><blockquote><p><code>闰秒：</code>由于地球自转会越转越慢，地球自转一周的时间会变化，当地球自转一周的时间与原子钟计时一天的时间相差超过0.9s时，UTC就会执行闰秒操作，即多走1s来等等地球，1分钟可能会出现61s。、</p><p>现在世界使用的就是UTC</p></blockquote><h3 id="时间戳转换">时间戳转换</h3><p><img src="./image/image-20250109134112560.png" alt="image-20250109134112560"></p><blockquote><p>localtime是在gmtime的基础上，加一个时区偏移得到</p></blockquote><p><img src="./image/image-20250109134249030.png" alt="image-20250109134249030"></p><h2 id="BKP简介">BKP简介</h2><p><img src="./image/image-20250109135916881.png" alt="image-20250109135916881"></p><blockquote><p>BKP其实就是一个存储器，只有当VDD和VBAT都断电了数据才会清零</p><hr><p>TAMPER引脚：侵入事件将所有备份寄存器内容清除，用于安全等</p><hr><p>RTC引脚：输出RTC校准时钟，或输出RTC闹钟脉冲</p><hr><p>BKP20字节：中容量和小容量</p><p>BKP84字节：大容量和互联型</p></blockquote><h3 id="基本结构">基本结构</h3><p><img src="./image/image-20250109142941243.png" alt="image-20250109142941243"></p><blockquote><p>橙色部分叫后备区域，BKP处于后备区域，但后备区域不只有BKP，还有RTC相关电路</p><p><code>后备区域特性：</code>当VDD主电源掉电时，后备区域仍可以由VBAT的备用电池供电，当VDD主电源上电时，后备区域供电会由VBAT切换到VDD，也就是在主电源有电时，VBAT不会用到，这样可以节省电池电量。</p><p>每个数据寄存器空间为2个字节</p><hr><p><code>BKP的几个功能：</code></p><ul><li><strong>侵入检测</strong>：可以从PC13位置的TAMPER引脚引入一个检测信号，当TAMPER产生上升沿或者下降沿时，清除BKP所有的内容，以保证安全</li><li><strong>时钟输出</strong>：可以从PC13位置的RTC引脚输出出去，供外部使用，其中输出RTC校准时钟时配合校准寄存器可以对RTC的误差进行校准</li></ul></blockquote><h3 id="BKP库函数">BKP库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BKP_DeInit</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//手动清空bkp所有寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_TamperPinLevelConfig</span><span class="params">(<span class="type">uint16_t</span> BKP_TamperPinLevel)</span>;</span><br><span class="line"><span class="comment">//配置tamper引脚有效电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_TamperPinCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//是否开启侵入检测功能</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_ITConfig</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//BKP中断配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_RTCOutputConfig</span><span class="params">(<span class="type">uint16_t</span> BKP_RTCOutputSource)</span>;</span><br><span class="line"><span class="comment">//BKP时钟输出配置，可选择输入RTC校准时钟，RTC闹钟脉冲或秒脉冲</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_SetRTCCalibrationValue</span><span class="params">(<span class="type">uint8_t</span> CalibrationValue)</span>;</span><br><span class="line"><span class="comment">//设置RTC校准值，写入RTC校准寄存器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_WriteBackupRegister</span><span class="params">(<span class="type">uint16_t</span> BKP_DR, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="comment">//写备份寄存器</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">BKP_ReadBackupRegister</span><span class="params">(<span class="type">uint16_t</span> BKP_DR)</span>;</span><br><span class="line"><span class="comment">//读备份寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关函数*/</span></span><br><span class="line">FlagStatus <span class="title function_">BKP_GetFlagStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ITStatus <span class="title function_">BKP_GetITStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_ClearITPendingBit</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="读写BKP">读写BKP</h3><blockquote><ul><li><code>使用BKP或RTC必须先执行前两步：</code></li></ul><ol><li>开启PWR和BKP时钟</li><li>设置PWR，使能BKP和RTC的访问</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> test = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.开启对应BKP和PWR时钟</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP,ENABLE);</span><br><span class="line"><span class="comment">//2.使能PWR，使能BKP和RTC的访问</span></span><br><span class="line">  PWR_BackupAccessCmd(ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.写bkp寄存器</span></span><br><span class="line">  BKP_WriteBackupRegister(BKP_DR1,<span class="number">0x1234</span>);<span class="comment">//写入DR1寄存器，uint16_t</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.读bkp寄存器</span></span><br><span class="line">  test = BKP_ReadBackupRegister(BKP_DR1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RTC外设">RTC外设</h2><h3 id="RTC简介">RTC简介</h3><p><img src="./image/image-20250109144513674.png" alt="image-20250109144513674"></p><blockquote><p>其中计数都是用一个秒计数器，对应Unix的时间戳，使用c库中的time.h库中localtime函数可以得到年月日时分秒信息了。</p><hr><p>RTC可选三种时钟源输入：HSE、LSE、LSI</p><p><strong>一般都使用LSE：32.768KHz 提供给RTC时钟</strong></p><p>特殊情况下，HSE和LSI为备选时钟</p><p><code>选择LSE原因：</code><strong>HSE和LSI都有自己的用途，而LSE是专用，同时只有LSE时钟可以通过VBAT备用电池供电，HSE和LSI在主电源掉电后是停止运行的。</strong></p><p><code>所以要想实现RTC主电源掉电继续走时的功能，必须选择RTC专用时钟LSE</code></p><hr><p><code>BKP和RTC内容都可以在参考手册中查看！！！</code></p></blockquote><h3 id="RTC框图">RTC框图</h3><p><img src="./image/image-20250109145649841.png" alt="image-20250109145649841"></p><blockquote><p><strong>图中灰色部分都处于后备区域，主电源掉电后，可以使用备用电池供电</strong></p><p><code>左边：核心的分频和计数计时部分</code></p><p><strong>RTCCLK</strong>：为时钟来源在RCC配置，主要选择LSE</p><p><strong>RTC预分频器</strong>：实际上就是一个计数器，计几个数就溢出1次就是几分频。由重装载寄存器RTC_PRL(相当于ARR)，和余数寄存器RTC_DIV(相当于CNT计数器，但是为自减计数器)。</p><p>若RTC_PRL=32768，来一个输入时钟RTC_DIV自减一次，直到变为0，然后再来一个输入时钟就会产生一个溢出信号，同时DIV变回32767。也就是每来32768个输入脉冲计数器就溢出一次，产生一个输出脉冲，也就是产生了32768分频，分频后输出的时钟频率为1Hz，也就是1s提供给后续</p><p><strong>RTC_CNT</strong>：就是Unix时间戳的秒计数器</p><p><code>RTC_ALR：</code>闹钟寄存器RTC_ALR，32位值，可以在其写入一个秒数，设定闹钟，当RTC_CNT == RTC_ALR，这时闹钟响了就会产生RTC_Alarm信号，通往右边的中断系统，执行对应操作，同时闹钟信号RTC_Alarm可以让STM32退出待机模式。</p><p><strong>可以实现定时唤醒待机芯片采集数据，完成后继续待机，以节省电源的作用</strong></p><hr><p><code>右边：中断使能和NVIC部分</code></p><p><strong>RTC_Second</strong>：秒信号，触发秒中断，每秒触发一次中断</p><p><strong>RTC_Overflow</strong>：溢出信号，触发溢出中断，计数值溢出触发一次中断，这个一般不会触发</p><p><strong>RTC_Alarm</strong>：闹钟信号，触发闹钟中断，可以设定闹钟或者唤醒待机设备</p><hr><p><code>上边：AP1总线相关部分</code></p><p>读写寄存器可以通过APB1总线完成，且RTC是APB1总线上的设备</p><hr><p><code>下边：PWR关联的部分</code></p></blockquote><h3 id="RTC基本结构">RTC基本结构</h3><p><img src="./image/image-20250109151703477.png" alt="image-20250109151703477"></p><h3 id="硬件电路-6">硬件电路</h3><p><img src="./image/image-20250109151911012.png" alt="image-20250109151911012"></p><blockquote><p>在最小系统的电路上需要额外添加两个部分：</p><ol><li><p>**备用电池电路：**根据数据手册得到简单连接，参考手册得到推荐连接</p><p>图右上角：使用3V纽扣电池充当备用电池，型号位CR2032/CR1220等，有字的那面为正极</p></li></ol><p><img src="../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/image/image-20250109152015914.png" alt="image-20250109152015914"></p><p><strong>画板子设计产品应该选择推荐连接方案更保险</strong></p><ol start="2"><li>**外部低速晶振：**根据参考手册设计</li></ol><p>图右下角：黑色的为外部低速晶振32.768khz，白色的为外部高速8Mhz晶振</p><p><img src="../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/image/image-20250109152430959.png" alt="image-20250109152430959"></p></blockquote><h3 id="RTC操作注意事项">RTC操作注意事项</h3><p><img src="./image/image-20250109152914363.png" alt="image-20250109152914363"></p><blockquote><ul><li><code>使用BKP或RTC必须先执行前两步：</code></li></ul><ol><li>开启PWR和BKP时钟</li><li>设置PWR，使能BKP和RTC的访问</li></ol><hr><ul><li>由于APB1和RTC_CRL使用的是不同时钟，面临着同步问题，所以需要在初始化时，调用一个等待同步的函数</li></ul><hr><ul><li>RTC有一个进入配置模式的标志位，必须先将RTC中的RTC_CRL中的CNF标志位置1才能进入配置模式。</li></ul><p>当然，在每个写入寄存器的库函数中都自动加上了这个操作，我们可以不用写</p><hr><ul><li>每次写入操作，都需要等待RTC_CR中的RTOFF标志位，只有为1时才能写入RTC寄存器。也就是调用一个等待上一个任务函数</li></ul><p>原因：因为PCLK1和RTCCLK时钟频率不一样，使用PCLK1的频率写入后，这个值不能直接更新到RTC寄存器中，因为RTC是由RTCCLK驱动，所以PCLK1写完后需要等一下RTCCLK时钟，RTCCLK来一个上升沿使值更新到RTC寄存器中</p></blockquote><h3 id="RCC库函数">RCC库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_LSEConfig</span><span class="params">(<span class="type">uint8_t</span> RCC_LSE)</span>;<span class="comment">//配置LSE外部低速时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_LSICmd</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//配置LSI内部低速时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_RTCCLKConfig</span><span class="params">(<span class="type">uint32_t</span> RCC_RTCCLKSource)</span>;<span class="comment">//RTCCLK配置，配置时钟源选择</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_RTCCLKCmd</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//在调用上面的RTCCLK配置函数后，需要再次调用该函数使能</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">RCC_GetFlagStatus</span><span class="params">(<span class="type">uint8_t</span> RCC_FLAG)</span>;<span class="comment">//调用时钟启动函数后需要该函数等待LSERDY标志位置1，时钟才算启动完成稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_GetClocksFreq</span><span class="params">(RCC_ClocksTypeDef* RCC_Clocks)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphResetCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphResetCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_BackupResetCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClockSecuritySystemCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_MCOConfig</span><span class="params">(<span class="type">uint8_t</span> RCC_MCO)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ITStatus <span class="title function_">RCC_GetITStatus</span><span class="params">(<span class="type">uint8_t</span> RCC_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClearITPendingBit</span><span class="params">(<span class="type">uint8_t</span> RCC_IT)</span>;</span><br></pre></td></tr></table></figure><h3 id="RTC库函数">RTC库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RTC_ITConfig</span><span class="params">(<span class="type">uint16_t</span> RTC_IT, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_EnterConfigMode</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//RTC进入配置模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ExitConfigMode</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//RTC退出配置模式</span></span><br><span class="line"><span class="type">uint32_t</span>  <span class="title function_">RTC_GetCounter</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//RTC获取CNT计数器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetCounter</span><span class="params">(<span class="type">uint32_t</span> CounterValue)</span>;<span class="comment">//写入CNT</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetPrescaler</span><span class="params">(<span class="type">uint32_t</span> PrescalerValue)</span>;<span class="comment">//写入预分频器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetAlarm</span><span class="params">(<span class="type">uint32_t</span> AlarmValue)</span>;<span class="comment">//RTC写入闹钟值,该该寄存器是只写的不可读</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span>  <span class="title function_">RTC_GetDivider</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//读取预分频器种的DIV余数寄存器，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意事项中的两个等待函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_WaitForLastTask</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//等待上次操作完成，循环直到RTOFF状态位为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_WaitForSynchro</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//等待同步，等待RSF置1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关函数*/</span></span><br><span class="line">FlagStatus <span class="title function_">RTC_GetFlagStatus</span><span class="params">(<span class="type">uint16_t</span> RTC_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearFlag</span><span class="params">(<span class="type">uint16_t</span> RTC_FLAG)</span>;</span><br><span class="line">ITStatus <span class="title function_">RTC_GetITStatus</span><span class="params">(<span class="type">uint16_t</span> RTC_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearITPendingBit</span><span class="params">(<span class="type">uint16_t</span> RTC_IT)</span>;</span><br></pre></td></tr></table></figure><h3 id="RTC配置">RTC配置</h3><ol><li><strong>开启PWR和BKP时钟，设置PWR，使能BKP和RTC的访问</strong></li><li><strong>使用RCC开启LSE时钟(LSE不行的话换成40khz的LSI)，且使用RCC开启LSE时钟(LSE省电默认关闭)，且等待LSERDY标志位为1</strong></li><li><strong>配置RTCCLK时钟源，指定LSE为RTCCLK时钟源，并且调用RTCCLK_Cmd使能</strong></li><li><strong>调用两个等待函数，注意事项中的等待同步与等待上一次操作完成</strong></li><li><strong>配置预分频器，RTC_SetPrescaler，并且再调用等待上一次操作完成函数</strong></li><li><strong>配置CNT,并且再调用等待上一次操作完成函数</strong></li><li>如果有闹钟值则配置闹钟</li><li>如果有中断就配置中断</li></ol><blockquote><p>RTC没有结构体进行配置，且没有Cmd函数，开启时钟后就会运行</p></blockquote><h3 id="RTC显示当前时间">RTC显示当前时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyRTC.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYRTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYRTC_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> MyRTC_Time[];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_SetTime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_ReadTime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyRTC.C*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> MyRTC_Time[] = &#123;<span class="number">2025</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.开启BKP和PWR时钟,设置PWR，使能BKP和RTC的访问</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP|RCC_APB1Periph_PWR,ENABLE);</span><br><span class="line">PWR_BackupAccessCmd(ENABLE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用RCC开启LSE时钟,等待LSERDY标志位为1</span></span><br><span class="line">RCC_LSEConfig(RCC_LSE_ON);<span class="comment">//使用LSI修改处1：RCC_LSICmd(ENABLE);</span></span><br><span class="line">  <span class="keyword">while</span>(RCC_GetFlagStatus(RCC_FLAG_LSERDY)!= SET)<span class="comment">//使用LSI修改处2：RCC_FLAG_LSIRDY</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.配置RTCCLK数据选择器，指定LSE为RTCCLK，并且调用RTCCLK_Cmd使能</span></span><br><span class="line">RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);<span class="comment">//使用LSI修改处3：RCC_FLAG_LSERDY</span></span><br><span class="line">RCC_RTCCLKCmd(ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.调用两个等待函数，注意事项中的等待同步与等待上一次操作完成</span></span><br><span class="line">RTC_WaitForSynchro();</span><br><span class="line">RTC_WaitForLastTask();</span><br><span class="line"><span class="comment">//这两行代码是安全保障措施，防止因为时钟不同步而出现bug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.配置预分频器，RTC_SetPrescaler，并且再调用等待上一次操作完成函数</span></span><br><span class="line">RTC_SetPrescaler(<span class="number">32768</span><span class="number">-1</span>);<span class="comment">//LSE频率为32768HZ，32768分频后可以使频率为1hz</span></span><br><span class="line"><span class="comment">//使用LSI修改处4：40KHz对应40000-1分频得到1hz</span></span><br><span class="line">RTC_WaitForLastTask();</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.配置CNT,并且再调用等待上一次操作完成函数</span></span><br><span class="line">RTC_SetCounter(<span class="number">1672588795</span>);</span><br><span class="line">RTC_WaitForLastTask();</span><br><span class="line">   </span><br><span class="line">MyRTC_SetTime();<span class="comment">//设置起始时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_SetTime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">time_t</span> time_cnt;<span class="comment">//unsigned int类型数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_date</span>;</span></span><br><span class="line"><span class="comment">//1.数组指定时间填充到struct tm结构体中</span></span><br><span class="line">  time_date.tm_year = MyRTC_Time[<span class="number">0</span>]<span class="number">-1900</span>;</span><br><span class="line">time_date.tm_mon = MyRTC_Time[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">time_date.tm_mday = MyRTC_Time[<span class="number">2</span>];</span><br><span class="line">time_date.tm_hour = MyRTC_Time[<span class="number">3</span>];</span><br><span class="line">time_date.tm_min = MyRTC_Time[<span class="number">4</span>];</span><br><span class="line">time_date.tm_sec = MyRTC_Time[<span class="number">5</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2.使用mktime得到秒数</span></span><br><span class="line">time_cnt = mktime(&amp;time_date) - <span class="number">8</span>*<span class="number">60</span>*<span class="number">60</span>;<span class="comment">//此处是北京时间转为伦敦时间，因为RTC中的秒数是以伦敦时间计算的，写入到CNT中也应该是伦敦时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.写入RTC的CNT中</span></span><br><span class="line">  RTC_SetCounter(time_cnt);</span><br><span class="line">  RTC_WaitForLastTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_ReadTime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">time_t</span> time_cnt;<span class="comment">//unsigned int类型数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_date</span>;</span></span><br><span class="line"></span><br><span class="line">  time_cnt = RTC_GetCounter()+ <span class="number">8</span>*<span class="number">60</span>*<span class="number">60</span>;<span class="comment">//此处是伦敦时间转换为北京时间，东8区，要多8个小时，对应8个小时的秒数</span></span><br><span class="line">    </span><br><span class="line">  time_date = *localtime(&amp;time_cnt);</span><br><span class="line">  </span><br><span class="line">  MyRTC_Time[<span class="number">0</span>] = time_date.tm_year+<span class="number">1900</span>;</span><br><span class="line">MyRTC_Time[<span class="number">1</span>] = time_date.tm_mon+<span class="number">1</span>;</span><br><span class="line">MyRTC_Time[<span class="number">2</span>] = time_date.tm_mday;</span><br><span class="line">MyRTC_Time[<span class="number">3</span>] = time_date.tm_hour ;</span><br><span class="line">MyRTC_Time[<span class="number">4</span>] = time_date.tm_min;</span><br><span class="line">MyRTC_Time[<span class="number">5</span>] = time_date.tm_sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>在程序中由于F103芯片等的BUG，可能使用LSE时不会起振，此时函数会卡死在初始化中，我们可以用示波器观察是否产生波形判断一下</strong></p><p><code>解决方案：</code></p><p><strong>此时我们可以使用LSI作为时钟源，但是就不能实现掉电时间不重置了因为LSI不像LSE一样可以由VBat备用电池供电</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*模块初始化*/</span></span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">MyRTC_Init();<span class="comment">//RTC初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示静态字符串*/</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Date:XXXX-XX-XX&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Time:XX:XX:XX&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;CNT :&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;DIV :&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">MyRTC_ReadTime();<span class="comment">//RTC读取时间，最新的时间存储到MyRTC_Time数组中</span></span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, MyRTC_Time[<span class="number">0</span>], <span class="number">4</span>);<span class="comment">//显示MyRTC_Time数组中的时间值，年</span></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">11</span>, MyRTC_Time[<span class="number">1</span>], <span class="number">2</span>);<span class="comment">//月</span></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">14</span>, MyRTC_Time[<span class="number">2</span>], <span class="number">2</span>);<span class="comment">//日</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, MyRTC_Time[<span class="number">3</span>], <span class="number">2</span>);<span class="comment">//时</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">9</span>, MyRTC_Time[<span class="number">4</span>], <span class="number">2</span>);<span class="comment">//分</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">12</span>, MyRTC_Time[<span class="number">5</span>], <span class="number">2</span>);<span class="comment">//秒</span></span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">3</span>, <span class="number">6</span>, RTC_GetCounter(), <span class="number">10</span>);<span class="comment">//显示32位的秒计数器</span></span><br><span class="line">OLED_ShowNum(<span class="number">4</span>, <span class="number">6</span>, RTC_GetDivider(), <span class="number">10</span>);<span class="comment">//显示余数寄存器</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BKP寄存器解决掉电时间不丢失问题">BKP寄存器解决掉电时间不丢失问题</h3><blockquote><p><strong>在对RTC的初始化中，我们要有判断的去执行</strong>：</p><ol><li><p>当系统完全断电了，备用电池也断电了，我们就执行初始化</p></li><li><p>当系统只是主电源断电，备用电池没断的话，LSE一直都在运行，就不用执行初始化</p></li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*我们只需要修改MyRTC_Init()的代码即可，为其添加一个BKP寄存器自定义标志位的判断*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);<span class="comment">//开启PWR的时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);<span class="comment">//开启BKP的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*备份寄存器访问使能*/</span></span><br><span class="line">PWR_BackupAccessCmd(ENABLE);<span class="comment">//使用PWR开启对备份寄存器的访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (BKP_ReadBackupRegister(BKP_DR1) != <span class="number">0xAAAA</span>)<span class="comment">//通过写入备份寄存器的标志位，判断RTC是否是第一次配置</span></span><br><span class="line"><span class="comment">//if成立则执行第一次的RTC配置</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_LSEConfig(RCC_LSE_ON);<span class="comment">//开启LSE时钟</span></span><br><span class="line"><span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSERDY) != SET);<span class="comment">//等待LSE准备就绪</span></span><br><span class="line"></span><br><span class="line">RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);<span class="comment">//选择RTCCLK来源为LSE</span></span><br><span class="line">RCC_RTCCLKCmd(ENABLE);<span class="comment">//RTCCLK使能</span></span><br><span class="line"></span><br><span class="line">RTC_WaitForSynchro();<span class="comment">//等待同步</span></span><br><span class="line">RTC_WaitForLastTask();<span class="comment">//等待上一次操作完成</span></span><br><span class="line"></span><br><span class="line">RTC_SetPrescaler(<span class="number">32768</span> - <span class="number">1</span>);<span class="comment">//设置RTC预分频器，预分频后的计数频率为1Hz</span></span><br><span class="line">RTC_WaitForLastTask();<span class="comment">//等待上一次操作完成</span></span><br><span class="line"></span><br><span class="line">MyRTC_SetTime();<span class="comment">//设置时间，调用此函数，全局数组里时间值刷新到RTC硬件电路</span></span><br><span class="line"></span><br><span class="line">BKP_WriteBackupRegister(BKP_DR1, <span class="number">0xAAAA</span>);<span class="comment">//在备份寄存器写入自己规定的标志位，用于判断RTC是不是第一次执行配置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//RTC不是第一次配置</span></span><br><span class="line">&#123;</span><br><span class="line">RTC_WaitForSynchro();<span class="comment">//等待同步</span></span><br><span class="line">RTC_WaitForLastTask();<span class="comment">//等待上一次操作完成</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果LSE无法起振导致程序卡死在初始化函数中,可将初始化函数替换为下述代码，使用LSI当作RTCCLK</strong></p><p><code>LSI无法由备用电源供电，故主电源掉电时，RTC走时会暂停</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);</span><br><span class="line">    </span><br><span class="line">    PWR_BackupAccessCmd(ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (BKP_ReadBackupRegister(BKP_DR1) != <span class="number">0xA5A5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       RCC_LSICmd(ENABLE);</span><br><span class="line">       <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET);</span><br><span class="line">       </span><br><span class="line">       RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);</span><br><span class="line">       RCC_RTCCLKCmd(ENABLE);</span><br><span class="line">       </span><br><span class="line">       RTC_WaitForSynchro();</span><br><span class="line">       RTC_WaitForLastTask();</span><br><span class="line">       </span><br><span class="line">       RTC_SetPrescaler(<span class="number">40000</span> - <span class="number">1</span>);</span><br><span class="line">       RTC_WaitForLastTask();</span><br><span class="line">       </span><br><span class="line">       MyRTC_SetTime();</span><br><span class="line">       </span><br><span class="line">       BKP_WriteBackupRegister(BKP_DR1, <span class="number">0xA5A5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       RCC_LSICmd(ENABLE);             <span class="comment">//即使不是第一次配置，也需要再次开启LSI时钟</span></span><br><span class="line">       <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET);</span><br><span class="line">       </span><br><span class="line">       RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);</span><br><span class="line">       RCC_RTCCLKCmd(ENABLE);</span><br><span class="line">       </span><br><span class="line">       RTC_WaitForSynchro();</span><br><span class="line">       RTC_WaitForLastTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>PWR电源控制</h1><h2 id="PWR简介">PWR简介</h2><p><img src="./image/image-20250110170201038.png" alt="image-20250110170201038"></p><blockquote><p>实现<code>可编程电压检测器</code>和<code>低功耗模式</code></p><p>**可编程电压检测器PVD：**监视VDD电压，在供电电压下降到PVD阀值以下时或上升到PVD阈值以上时，产生一个中断，通知软件做紧急处理</p><p>**低功耗模式：**睡眠模式Sleep、停机模式stop、待机模式standby。在空闲状态时关闭不必要的硬件，比如把CPU断电或关闭时钟，但需要保留必要的唤醒电路</p></blockquote><p><code>所有知识在手册上可以找到</code></p><h2 id="电源框图">电源框图</h2><p><img src="./image/image-20250110170713455.png" alt="image-20250110170713455"></p><blockquote><p>STM32内部供电方案图可分为三个部分：</p><p><code>模拟部分供电：</code>VDDA(VDD Analog)</p><p>包括A/D转换器、温度传感器、复位模块、PLL</p><p>供电正极为：VDDA</p><p>供电负极为：VSSA</p><p>其中还有两个参考电压供电脚：VREF- 和VREF+</p><p>在该芯片中直接接入了VSSA和VDDA，也可能会单独引出去</p><hr><p><code>数字部分供电：</code>VDD供电区域和1.8V供电区域</p><p><strong>VDD供电区域</strong>：I/O电路、待机电路、电压调节器(为1.8V区域供电)</p><p><strong>1.8V供电区域</strong>：CPU、存储器、外设</p><p>我们可以看到CPU、存储器和外设都是以1.8V的低电压运行的，当需要与外界交流时，才会通过I/O电路转换为3.3V</p><hr><p><code>后备供电区域：</code>VBAT为以下供电</p><p>LSE 32K晶体振荡器后备寄存器</p><p>RCC BDCR寄存器，即备份域控制寄存器</p><p>RTC</p><p>低电压检测器：控制开关，VDD有电时由VDD供电，VDD没电时由VBAT供电</p><p><img src="../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/image/image-20250110171925509.png" alt="image-20250110171925509"></p></blockquote><h2 id="上电复位和掉电复位-POR-PDR">上电复位和掉电复位(POR/PDR)</h2><p><img src="./image/image-20250110181242741.png" alt="image-20250110181242741"></p><blockquote><p>设置了阈值电压：40mV迟滞避免电压来回波动，造成输出也来回抖动</p><p>Reset：低电平有效</p><p>对应滞后时间在stm32数据手册可以找到</p><p><img src="./image/image-20250110181444794.png" alt="image-20250110181444794"></p></blockquote><h2 id="可编程电压检测器PVD">可编程电压检测器PVD</h2><p><img src="./image/image-20250110181535199.png" alt="image-20250110181535199"></p><blockquote><p><strong>PVD-(Programmable Votage Detector)作用</strong>：</p><p>监视VDD电压，在供电电压下降到PVD阀值以下时或上升到PVD阈值以上时，产生一个中断，通知软件做紧急处理。</p><p>PVD在电压过低时为1，正常时输出0</p><p>PVD在上升沿或下降沿时触发中断，通过<strong>外部中断</strong>实现，提醒用户处理。</p><hr><p>PVD的阈值电压可以使用程序指定，配置PLS寄存器3位，迟滞电压上限为100mV</p><p><img src="../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/image/image-20250110181653488.png" alt="image-20250110181653488"></p></blockquote><h2 id="低功耗模式介绍">低功耗模式介绍</h2><p><code>手册中的低功耗模式介绍：</code></p><p><img src="./image/image-20250110182653384.png" alt="image-20250110182653384"></p><blockquote><p>三种模式从上到下：<code>睡眠</code>、<code>停机(止)</code>、<code>待机</code></p><ol><li>关闭的电路越来越多</li><li>越来越省电</li><li>越来越难唤醒</li></ol><p>图中可以知道关闭电路通常由两个做法：<code>关闭时钟</code>或<code>关闭电源</code></p><p><strong>关闭时钟</strong>：所有的运算和涉及时序的操作都会暂停，寄存器和存储器保存的数据可以维持不会消失</p><p><strong>关闭电源</strong>：电路直接断电，电路操作和寄存器数据都丢失，比关闭时钟更省电</p><hr><p><code>睡眠模式：一般省电</code></p><p>**WFI(wait for interrupt)：**等待中断，对应唤醒条件为<code>中断唤醒</code>，意思就是处于睡眠状态，如果有中断发生再叫我起来。</p><p>调用WFI进入的睡眠模式，<strong>任何外设发生任何中断时</strong>，芯片都会立刻醒来，进入中断处理程序</p><p>**WFE(wait for event)：**等待事件，对应唤醒条件为<code>唤醒事件</code>，可以是外部中断配置为事件模式，也可以是使能了中断但没有配置NVIC</p><p>调用WFE进入的睡眠模式，产生唤醒事件时，会立刻醒来。一般不需要进中断函数</p><p><code>对电路影响：</code>只关闭了CPU时钟，其他电路没有影响。<strong>看上图中描述</strong></p><hr><p><code>停机模式：非常省电</code></p><p><strong>SLEEPDEEP位</strong>：置1进入深度睡眠</p><p><strong>PDDS位</strong>：区分停机和待机。PDDS=0，进入停机模式，PDDS=1，进入待机模式</p><p><strong>LPDS位</strong>：<strong>设置电压调节器</strong>，开启或进入低功耗模式。LPDS=0,电压调节器开启LPDS=1，电压调节器进入低功耗(更省电但唤醒延迟更高)。</p><p><strong>设置流程：SLEEPDEEP=1，PDDS=0，LPDS=0/1，再调用WFI或WFE，芯片就可以进入停止模式了</strong></p><p><strong>唤醒条件</strong>：只有任一的外部中断能唤醒，其他中断不能唤醒</p><p>WFI用外部中断中断模式唤醒，WFE用外部中断事件唤醒</p><p><code>对电路影响：</code>关闭所有1.8V区域的时钟(CPU、AD、外设)，以及HSI和HSE振荡器，但不会关闭LSI和LSE，电压调节器开启(1.8V区域电源仍开启)。<strong>看上图中描述</strong></p><hr><p><code>待机模式:极为省电</code></p><p><strong>设置流程：SLEEPDEEP=1，PDDS=1，再调用WFI或WFE，芯片就可以进入停止模式了</strong></p><p>**唤醒条件：**普通外设中断或外部中断都无法唤醒待机模式，只能由以下四个信号唤醒</p><ol><li>WKUP引脚上升沿(如PA0-Wakeup，即PA0)</li><li>RTC闹钟事件</li><li>NRST引脚的外部复位(Reset一下)</li><li>IWDG复位</li></ol><p><code>对电路影响：</code>关闭所有1.8V区域的时钟(CPU、AD、外设)，两个高速时钟关闭，两个低速时钟不会关闭，电压调节器关闭(即1.8V区域电源关闭)。<strong>看上图中描述</strong></p></blockquote><h2 id="模式选择的图">模式选择的图</h2><p><img src="./image/image-20250110195522341.png" alt="image-20250110195522341"></p><blockquote><p>配置其他寄存器在执行WFI或WFE之前。</p><p>图中最左边是执行WFI/WFE后，根据各个寄存器判断启动什么模式的流程</p></blockquote><h2 id="三种模式特性及注意事项">三种模式特性及注意事项</h2><p><img src="./image/image-20250110211426203.png" alt="image-20250110211426203"></p><blockquote><p><strong>GPIO高低电平保持睡眠前运行时的状态，唤醒后程序从暂停的地方继续运行</strong></p><p>手册对事件唤醒描述：</p><p><img src="../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/image/image-20250110211647415.png" alt="image-20250110211647415"></p><p>比较麻烦所以还是使用中断唤醒吧</p></blockquote><hr><p><img src="./image/image-20250110211742039.png" alt="image-20250110211742039"></p><blockquote><p><strong>GPIO高低电平保持睡眠前运行时的状态，唤醒后程序从暂停的地方继续运行</strong></p><p><strong>注意：</strong></p><p>停止模式唤醒时，因为HSI被选为了系统时钟，所以变成了8MHz的主频，<code>所以我们在停止模式唤醒后第一时间应该重新启动HSE，配置主频为72MHz(调用SystemInit即可)</code></p></blockquote><hr><p><img src="./image/image-20250110212325583.png" alt="image-20250110212325583"></p><blockquote><p><strong>待机模式下，GPIO输出引脚变为高阻态(浮空输入)，唤醒后程序从头开始运行</strong></p><p>仅备份寄存器和待机电路供电</p><p>仅四种方式退出待机模式</p></blockquote><h2 id="节电方法">节电方法</h2><p>在数据手册工作条件的供电电流特性测试电流部分可以得到省电方法</p><ol><li><strong>关闭不需要的外设对应时钟</strong></li><li><strong>降低主频，耗电电流下降，对于省电也挺划算的。设备需要连续运行，但是对于主频和性能没这么高要求的话，就可以选择降低主频</strong></li></ol><blockquote><p>产品使用电池的话低功耗模式也是很必要使用的</p></blockquote><h2 id="SLEEPDEEP和SLEEPONEXIT位配置">SLEEPDEEP和SLEEPONEXIT位配置</h2><blockquote><p>这两个位位于内核系统控制块，没有提供什么简单的配置方法，只能通过操作寄存器来配置，默认值为0</p><p>我们需要打开Cortex-M3编程手册，第4章内核外设的系统控制块SCB中找到寄存器介绍</p><p><img src="./image/image-20250111155405959.png" alt="image-20250111155405959"></p><p>对应SCB-&gt;SCR寄存器等按照配置编程手册上的位配置即可</p></blockquote><h2 id="修改主频">修改主频</h2><p>在system_stm32f10x.c文件中可以看到的描述是有两个函数和一个变量与系统主频有关</p><p>在system_stm32f10x.h文件中也可以找到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> SystemCoreClock;<span class="comment">//系统时钟</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//系统时钟初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">SystemCoreClockUpdate</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//系统时钟更新</span></span><br></pre></td></tr></table></figure><p>在system_stm32f10x.c文件中，对应部分找到自己的型号然后进行修改主频即可</p><p><img src="./image/image-20250111152640885.png" alt="image-20250111152640885"></p><blockquote><p>修改主频后，使用主频的地方需要修改，比如Delay函数</p><p><img src="./image/image-20250111152842134.png" alt="image-20250111152842134"></p><p>在72Mhz下是正确延时指定时间，但是变为36Mhz后，就会变为原来的1/2。所以最好将SystemCoreClock变量带入计算中做自适应</p><hr><p><code>所以一般条件下不推荐修改主频，除非有需求</code></p></blockquote><h2 id="睡眠模式实例">睡眠模式实例</h2><p>睡眠模式使用寄存器都是内核中的，与PWR没什么关系，所以没使用PWR库函数</p><h3 id="串口收发">串口收发</h3><blockquote><p><strong>对于这种靠任意中断触发，没中断就没什么事的，平时主循环会耗电</strong></p><p><strong>我们就可以给它加入低功耗模式</strong></p><p><code>根据分析，这种情况下串口只能使用睡眠模式</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Serial.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RxData;<span class="comment">//定义用于接收串口数据的变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;RxData:&quot;</span>);<span class="comment">//显示静态字符串</span></span><br><span class="line"></span><br><span class="line">Serial_Init();<span class="comment">//串口初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Serial_GetRxFlag() == <span class="number">1</span>)<span class="comment">//检查串口接收数据的标志位</span></span><br><span class="line">&#123;</span><br><span class="line">RxData = Serial_GetRxData();<span class="comment">//获取串口接收的数据</span></span><br><span class="line">Serial_SendByte(RxData);<span class="comment">//串口将收到的数据回传回去，用于测试</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, RxData, <span class="number">2</span>);<span class="comment">//显示串口接收的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);<span class="comment">//OLED闪烁Running，指示当前主循环正在运行</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">__WFI();<span class="comment">//执行WFI指令，CPU睡眠，并等待中断唤醒</span></span><br><span class="line">        <span class="comment">//__WFE();WFE,事件唤醒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>对于睡眠模式我们在while循环中加入WFI或WFE即可实现睡眠模式，唤醒后继续执行上一次执行的操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__WFI();<span class="comment">//执行WFI指令，CPU睡眠，并等待中断唤醒</span></span><br><span class="line">__WFE();<span class="comment">//WFE,事件唤醒</span></span><br></pre></td></tr></table></figure><p><code>现象：</code></p><p>OLED上不再持续显示Running，此时用串口助手发送信息，每发送一次，Running闪烁显示一次，说明只有接收中断后才会唤醒工作一次，然后立马睡眠</p></blockquote><h2 id="停机模式实例">停机模式实例</h2><h3 id="库函数-10">库函数</h3><p>停机模式涉及内核外的电路操作，需要使用库函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWR_DeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_BackupAccessCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//使能后备区域的访问，在RTC初始化时需要使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_PVDCmd</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//PVD使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_PVDLevelConfig</span><span class="params">(<span class="type">uint32_t</span> PWR_PVDLevel)</span>;<span class="comment">//PVD阈值电压配置</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_WakeUpPinCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//WKUP引脚唤醒功能使用需要调用此函数开启</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_EnterSTOPMode</span><span class="params">(<span class="type">uint32_t</span> PWR_Regulator, <span class="type">uint8_t</span> PWR_STOPEntry)</span>;</span><br><span class="line"><span class="comment">//停机模式：调用该函数就可以进入停止模式了</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_EnterSTANDBYMode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//待机模式：调用该函数就可以进入待机模式了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//PWR标志位相关函数</span></span><br><span class="line">FlagStatus <span class="title function_">PWR_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> PWR_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> PWR_FLAG)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="对射式红外传感器外部中断-停机模式">对射式红外传感器外部中断(停机模式)</h3><blockquote><p>使用<strong>外部中断触发</strong>的可以考虑使用<strong>更省电的停机模式</strong></p><p>虽然停机模式关闭了外设时钟，但是外部中断使用不需要时钟就能工作</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CountSensor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*模块初始化*/</span></span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">CountSensor_Init();<span class="comment">//红外计数传感器初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);<span class="comment">//开启PWR的时钟！！！</span></span><br><span class="line"><span class="comment">//停止模式和待机模式一定要记得开启</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示静态字符串*/</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Count:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">7</span>, CountSensor_Get(), <span class="number">5</span>);<span class="comment">//OLED不断刷新显示CountSensor_Get的返回值</span></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);<span class="comment">//OLED闪烁Running，指示当前主循环正在运行</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI);<span class="comment">//STM32WFI指令进入停止模式，并等待中断唤醒</span></span><br><span class="line">        </span><br><span class="line">SystemInit();<span class="comment">//唤醒后，要重新配置时钟</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI):</code></p><p>该函数最后调用了WFI或WFE指令之后就进入了静止模式</p><hr><p><code>SystemInit()：</code>唤醒后时钟变为了HSI的8M，需要我们重新启动HSE，配置72M的主频，调用该函数即可</p></blockquote><blockquote><p><code>现象：</code>红外传感器计数一次，Running闪烁一次，确实进入了停机模式</p></blockquote><h2 id="待机模式实例">待机模式实例</h2><h3 id="RTC闹钟-待机模式">RTC闹钟(待机模式)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*模块初始化*/</span></span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">MyRTC_Init();<span class="comment">//RTC初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);<span class="comment">//开启PWR的时钟</span></span><br><span class="line"><span class="comment">//停止模式和待机模式一定要记得开启时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示静态字符串*/</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;CNT :&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;ALR :&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;ALRF:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使能WKUP引脚*/</span></span><br><span class="line">PWR_WakeUpPinCmd(ENABLE);<span class="comment">//使能位于PA0的WKUP引脚，WKUP引脚上升沿唤醒待机模式,接上VCC即可唤醒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设定闹钟：由于该寄存器是只写的不可读，所以我们使用变量显示*/</span></span><br><span class="line"><span class="type">uint32_t</span> Alarm = RTC_GetCounter() + <span class="number">10</span>;<span class="comment">//闹钟为唤醒后当前时间的后10s</span></span><br><span class="line">RTC_SetAlarm(Alarm);<span class="comment">//写入闹钟值到RTC的ALR寄存器</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, Alarm, <span class="number">10</span>);<span class="comment">//显示闹钟值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, RTC_GetCounter(), <span class="number">10</span>);<span class="comment">//显示32位的秒计数器</span></span><br><span class="line">OLED_ShowNum(<span class="number">3</span>, <span class="number">6</span>, RTC_GetFlagStatus(RTC_FLAG_ALR), <span class="number">1</span>);<span class="comment">//显示闹钟标志位</span></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);<span class="comment">//OLED闪烁Running，指示当前主循环正在运行</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">9</span>, <span class="string">&quot;STANDBY&quot;</span>);<span class="comment">//OLED闪烁STANDBY，指示即将进入待机模式</span></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">9</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">OLED_Clear();<span class="comment">//OLED清屏，模拟关闭外部所有的耗电设备，以达到极度省电</span></span><br><span class="line"></span><br><span class="line">PWR_EnterSTANDBYMode();<span class="comment">//STM32进入停止模式，并等待指定的唤醒事件（WKUP上升沿或RTC闹钟）</span></span><br><span class="line"><span class="comment">/*待机模式唤醒后，程序会重头开始运行*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>PWR_EnterSTANDBYMode():</code></p><p>该函数最后统一调用WFI指令进入待机模式</p><hr><p><strong>待机模式下只有这四种可以唤醒</strong>：</p><ol><li>WKUP引脚上升沿(如PA0-Wakeup，即PA0)：手册中对应描述不需要GPIO初始化，被强制下拉，只需要接VCC即可唤醒</li><li>RTC闹钟事件</li><li>NRST引脚的外部复位(Reset一下)</li><li>IWDG复位</li></ol></blockquote><blockquote><p><code>现象：</code>等待10s后，Running闪烁一下后消失，CNT和ALR的值都更新，说明待机模式下唤醒后，程序从头开始运行，所以我们不用重新调用SystemInit了。</p></blockquote><p><code>最大化省电：</code><strong>进入待机模式前把外接的模块能关的全关，需要精心设计电路。否则待机模式无法做到真正的极度省电！！！</strong></p><h1>看门狗WDG</h1><h2 id="看门狗简介">看门狗简介</h2><p><img src="./image/image-20250111173313542.png" alt="image-20250111173313542"></p><blockquote><p><code>看门狗</code>：由于程序出现漏洞、硬件故障、电磁干扰等原因出现卡死或跑飞现象时可以及时复位程序。</p><p>本质是一个<strong>定时器</strong>，在指定时间范围内，程序没有执行<strong>喂狗</strong>(手动重装计数器)操作时，看门狗硬件电路就自动产生复位信号。</p><p><code>作用：</code>提高系统的可靠性和健壮性，避免程序陷入长时间罢工状态</p><p>可以预料的漏洞应该尽量解决，开门狗只是一个复位的作用，可能会出现复位也不能解决的问题</p><hr><p>STM32内置两个看门狗：独立看门狗(IWDG)和窗口看门狗(WWDG)</p><p><strong>独立看门狗(IWDG)</strong>：使用专门的LSI时钟，即使主时钟出现问题，独立看门狗也能正常工作，这就是<strong>独立的命名</strong>。对时间精度要求较低，只有一个喂狗最晚界限。</p><p><strong>窗口看门狗(WWDG)</strong>：使用APB1时钟，要求看门狗在精确的计时窗口作用，有喂狗最早界限和最晚界限，必须在这个界限窗口内喂狗，这就是窗口的命名。喂早和喂晚都会发生复位</p><p><code>对应更多内容请查看参考手册!!!</code></p></blockquote><h2 id="独立看门狗IWDG">独立看门狗IWDG</h2><h3 id="IWDG框图">IWDG框图</h3><p><img src="./image/image-20250112155237497.png" alt="image-20250112155237497"></p><blockquote><p>IWDG_PR：其实就是定时器中的预分频Prescaler缩写，8位，最大为256</p><p>IWDG_RLR：就是定时器中的ARR=Auto Reloader，RLR = Reloader，12位最大为4096</p><p>IWDG_SR：状态寄存器</p><p><strong>工作流程</strong>：计数器为递减计数器，自减到0之前执行喂狗操作，重置计数器为4096-1，当计数器自减到0时，就会进行复位</p><hr><p>上面寄存器处于1.8V供电区，而下面的电路处于VDD供电区，所以在停机和待机模式下只会关闭1.8V时钟，所以可以在停机和待机模式下可以运行。</p><p>待机模式下的唤醒条件之一就包含看门狗</p></blockquote><h3 id="IWDG键寄存器">IWDG键寄存器</h3><p><img src="./image/image-20250112160401346.png" alt="image-20250112160401346"></p><blockquote><p><strong>在多个位确定代替一位的情况下，该寄存器就算值变化，也很难恰巧出现以上的值，这样就更保险。</strong></p><p>同时对IWDG_PR、IWDG_RLR设计了写保护，只有写入键寄存器的值为0x5555时才会解除写保护，其他情况下都不允许写入</p><p>IWDG_SR由于是只读的就不用管</p></blockquote><h3 id="IWDG超时时间">IWDG超时时间</h3><p><img src="./image/image-20250112160724383.png" alt="image-20250112160724383"></p><blockquote><p>就是定时器溢出时间，和定时器溢出时间相同</p><p>最大值只能是</p><p>PR[2:0]：写入0~7，固定上面几个分频系数</p></blockquote><h2 id="窗口看门狗WWDG">窗口看门狗WWDG</h2><h3 id="WWDG框图">WWDG框图</h3><p><img src="./image/image-20250112161153418.png" alt="image-20250112161153418"></p><blockquote><p>**时钟源：**PCK1 = 36M，进入预分频器前还进行了4096分频，图中没画出</p><p>**看门狗的预分频器WDGTB：**与独立看门狗PR和定时器的PSC都是一样的道理</p><hr><p>**看门狗控制寄存器(WWDG_CR)：<strong>包</strong>WDGA(看门狗使能位)**和计数器，与计数器合二为一了。</p><p>**6/7位递减计数器CNT：**CNT的有效位为T0~T5，T6位用于判断是否溢出。<strong>启动时必须将此位写入1，值为1代表计数器没有溢出，值为0代表计数器溢出，产生看门狗复位</strong>。位于控制寄存器CR中，计数器和控制寄存器合二为一。</p><p>窗口看门狗没有重装寄存器，直接向CNT写数据。</p><p><strong>当T6~T0位为1 0 0 0 0 0 0 (<code>0x40</code>)，第1位为标志位T6为1，6位计数器的值为000000。再减一次后T6位变为0，计数器溢出，T6通过图中线路产生复位信号</strong>。</p><ul><li><p><strong>如果把T0~T5看成计数器，就是6位计数器，那么就是自减到0时溢出</strong></p></li><li><p><strong>如果把T0~T6为看成计数器，就是7位计数器，那么就是自减小于0x40时溢出</strong></p></li></ul><p><code>喂狗操作：</code>写入WWDG_CR寄存器，也就是写入CNT</p></blockquote><blockquote><hr><p><strong>看门狗配置寄存器WWDG_CFR：</strong></p><p>用于设置喂狗的<code>窗口值的最早界限</code>，写入W6~W0，7位数据，固定不变</p><hr><p>最左边是比较器逻辑，什么时候产生复位操作的逻辑</p><hr><p><code>工作流程：</code></p><p>首先时钟从PCLK1(36M时钟进入)，然后经过预分频器分频，驱动计数器进行计数，每来一个时钟自减一次。最终比较进行复位</p></blockquote><h3 id="WWDG工作特性">WWDG工作特性</h3><p><img src="./image/image-20250112163354916-17366708495051.png" alt="image-20250112163354916"></p><p><img src="./image/image-20250112182947095.png" alt="image-20250112182947095"></p><blockquote><p>定期写入WWDG_CR寄存器喂狗，避免WWDG复位</p><p><strong>W[6:0]</strong>：喂狗的最早界限，对应<code>窗口时间</code></p><p><strong>T[6:0]：</strong> 喂狗的计数器值，对应<code>超时时间</code></p><p><strong>0x3F</strong>：喂狗的最晚界限，由0x40-1得到，对应<code>超时时间的最大值</code></p><p><code>窗口时间~超时时间:</code>之间喂狗才不会复位</p><hr><p>递减计数器T[6:0] = 0X40 产生早期唤醒中断EWI</p></blockquote><h3 id="WWDG超时时间">WWDG超时时间</h3><p><img src="./image/image-20250112164040798.png" alt="image-20250112164040798"></p><h2 id="IWDG和WWDG对比">IWDG和WWDG对比</h2><p><img src="./image/image-20250112164553712.png" alt="image-20250112164553712"></p><blockquote><p><strong>窗口看门狗的精度比独立看门狗高</strong></p></blockquote><h2 id="独立看门狗代码">独立看门狗代码</h2><h3 id="相关库函数">相关库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*stm32f10x_iwdg.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_WriteAccessCmd</span><span class="params">(<span class="type">uint16_t</span> IWDG_WriteAccess)</span>;</span><br><span class="line"><span class="comment">//写使能控制，键寄存器写入ENABLE就是0x5555，Disable就是0x0000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_SetPrescaler</span><span class="params">(<span class="type">uint8_t</span> IWDG_Prescaler)</span>;</span><br><span class="line"><span class="comment">//设置预分频</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_SetReload</span><span class="params">(<span class="type">uint16_t</span> Reload)</span>;</span><br><span class="line"><span class="comment">//设置重装载值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_ReloadCounter</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//喂狗操作：重新装载寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_Enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//启用独立看门狗，键寄存器写入0xCCCC</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">IWDG_GetFlagStatus</span><span class="params">(<span class="type">uint16_t</span> IWDG_FLAG)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*RCC库函数，stm32f10x_rcc.c*/</span></span><br><span class="line">FlagStatus <span class="title function_">RCC_GetFlagStatus</span><span class="params">(<span class="type">uint8_t</span> RCC_FLAG)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* *   For @b other_STM32_devices, this parameter can be one of the following values:        </span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_PLLRDY: PLL clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_PINRST: Pin reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_PORRST: POR/PDR reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_SFTRST: Software reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_LPWRRST: Low Power reset</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">     </span><br></pre></td></tr></table></figure><blockquote><p>使用RCC中的获取标志位函数可以根据可选参数得到是什么造成的复位，这里用于判断复位是否由看门狗完成</p><p><code>同时我们的看门狗标志位必须手动清除，因为及时按下复位键也不会手动清0。如果不清零下次即使是复位键复位也会判断为看门狗复位</code></p></blockquote><h3 id="配置流程-2">配置流程</h3><ol><li>开启时钟LSI**(不需要我们写代码，开启看门狗时会自动强制开启LSI)**</li></ol><blockquote><p><strong>在手册的看门狗时钟部分可以看到，开启独立看门狗后LSI会被强制打开，等LSI稳定后，就可以自动为独立看门狗提供时钟</strong></p></blockquote><ol start="2"><li><p>写入键寄存器0x5555关闭写保护，再写入预分频值和重装值**(直接调用库函数，不需要我们寄存器操作)**</p></li><li><p>写入键寄存器0xCCCC启动看门狗**(直接调用库函数IWDG_Enable)**</p></li><li><p><strong>主循环执行喂狗操作</strong></p></li></ol><h3 id="按键触发独立看门狗">按键触发独立看门狗</h3><blockquote><p><img src="./image/image-20250112171912193.png" alt="image-20250112171912193"></p><p><code>设置1000ms超时：</code><strong>图中可以看到前两个分频系数最大超时时间&lt;1000ms不满足,所以选下面的,优先选择预分频系数小的最大化利用计数器值</strong></p><p><strong>LSI时钟</strong>：40kHz -&gt; 0.025ms</p><p><strong>计算预分频系数PR</strong>：16</p><p><strong>计算重载寄存器RL</strong>： 1000/(0.025*16) = 2499+1</p><p>重载寄存器RL值：2499</p><p>0.025ms * 16 * (2499+1) = 1000ms</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*模块初始化*/</span></span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">Key_Init();<span class="comment">//按键初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示静态字符串*/</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;IWDG TEST&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断复位信号来源*/</span></span><br><span class="line"><span class="keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) == SET)<span class="comment">//如果是独立看门狗复位</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;IWDGRST&quot;</span>);<span class="comment">//OLED闪烁IWDGRST字符串</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">RCC_ClearFlag();<span class="comment">//清除标志位!!!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//否则，即为其他复位</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;RST&quot;</span>);<span class="comment">//OLED闪烁RST字符串</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*IWDG初始化*/</span></span><br><span class="line">IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);<span class="comment">//1.独立看门狗写使能</span></span><br><span class="line">IWDG_SetPrescaler(IWDG_Prescaler_16);<span class="comment">//2.设置预分频为上面计算的16,</span></span><br><span class="line">IWDG_SetReload(<span class="number">2499</span>);<span class="comment">//2.设置重装值为双面计算的2499，独立看门狗的超时时间为1000ms</span></span><br><span class="line">IWDG_ReloadCounter();<span class="comment">//3.重装计数器，喂狗，这样更严谨一点使下个周期为1000ms</span></span><br><span class="line">IWDG_Enable();<span class="comment">//4.独立看门狗使能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Key_GetNum();<span class="comment">//调用阻塞式的按键扫描函数，模拟主循环卡死</span></span><br><span class="line"></span><br><span class="line">IWDG_ReloadCounter();<span class="comment">//重装计数器，喂狗，避免复位</span></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;FEED&quot;</span>);<span class="comment">//OLED闪烁FEED字符串</span></span><br><span class="line">Delay_ms(<span class="number">200</span>);<span class="comment">//喂狗间隔为200+600=800ms,没到1000ms不会重装</span></span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;    &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">600</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Delay_ms(1010);//模拟超时喂狗，多留一点冗余时间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>按键使用的是阻塞式消抖，其中包含while循环，一直按着不松就会卡死在while循环，这样就会造成超时主循环阻塞没喂狗，触发看门狗复位</p></blockquote><blockquote><p>现象：正常情况下屏幕间断显示FEED</p><p>正常按下Reset按键，屏幕显示&quot;RST&quot;复位。</p><p>按下按键不松手，屏幕显示&quot;IWDGRST&quot;</p></blockquote><h2 id="窗口看门狗代码">窗口看门狗代码</h2><h3 id="库函数-11">库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_DeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_SetPrescaler</span><span class="params">(<span class="type">uint32_t</span> WWDG_Prescaler)</span>;<span class="comment">//写入预分频器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_SetWindowValue</span><span class="params">(<span class="type">uint8_t</span> WindowValue)</span>;<span class="comment">//设置窗口最早界限</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_EnableIT</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//使能EWI中断</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_SetCounter</span><span class="params">(<span class="type">uint8_t</span> Counter)</span>;<span class="comment">//喂狗操作</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_Enable</span><span class="params">(<span class="type">uint8_t</span> Counter)</span>;<span class="comment">//使能看门狗,手册上说明了计数器时刻自减，所以可能是任何值，所以需要使能的时候喂一下狗</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">WWDG_GetFlagStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="配置流程-3">配置流程</h3><ol><li><p><strong>RCC开启APB1总线上的WWDG时钟。</strong></p></li><li><p><strong>设置预分频值，窗口值</strong></p></li><li><p><strong>使能看门狗(带有喂狗值，需要使能的时候喂一下狗)</strong></p></li><li><p><strong>主循环在窗口时间~超时时间内喂狗</strong></p></li></ol><h3 id="按键触发窗口看门狗">按键触发窗口看门狗</h3><blockquote><p><img src="./image/image-20250112174602385.png" alt="image-20250112174602385"></p><p><code>设定超时时间50ms</code>：图中看到只能选择最后一个分频系数</p><p>PCLK1的T：1/36M</p><p>4096是进入预分频前对PCLK1的一个分频</p><p>**计算预分频系数：**2的3次方 = 8</p><p><strong>计算T[5:0]写入计数器的值：</strong> 50ms /[(1/36M)*4096 *8] = 54.931640625  = 55(取整) = 54+1</p><p><code>喂狗值：</code>54</p><p><strong>超时时间</strong> = 1/36M * 4096 * 8 * (54+1) = 约为50ms</p><hr><p><img src="../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/image/image-20250112180841188.png" alt="image-20250112180841188"></p><p><code>设定窗口时间为30ms:</code></p><p>PCLK1的T：1/36M</p><p>4096是进入预分频前对PCLK1的一个分频</p><p>计算窗口值W[5:0]：54 - 30ms /[(1/36M)*4096 *8] = 54 - 33(取整) = 21</p><p><code>窗口值：</code> 21</p><p><strong>窗口时间</strong> = 1/36M * 4096 * 8 * (54-33) = 约为30ms</p><hr><p><code>最终我们主循环的喂狗周期为：</code><strong>30ms ~ 50ms</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*模块初始化*/</span></span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">Key_Init();<span class="comment">//按键初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示静态字符串*/</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;WWDG TEST&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断复位信号来源*/</span></span><br><span class="line"><span class="keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_WWDGRST) == SET)<span class="comment">//如果是窗口看门狗复位</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;WWDGRST&quot;</span>);<span class="comment">//OLED闪烁WWDGRST字符串</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">RCC_ClearFlag();<span class="comment">//清除标志位！！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//否则，即为其他复位</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;RST&quot;</span>);<span class="comment">//OLED闪烁RST字符串</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.开启时钟*/</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);<span class="comment">//开启WWDG的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*WWDG初始化*/</span></span><br><span class="line">WWDG_SetPrescaler(WWDG_Prescaler_8);<span class="comment">//设置预分频为8</span></span><br><span class="line">WWDG_SetWindowValue(<span class="number">21</span> | <span class="number">0x40</span>);<span class="comment">//设置窗口值，窗口时间为30ms</span></span><br><span class="line">WWDG_Enable(<span class="number">54</span> | <span class="number">0x40</span>);<span class="comment">//使能并第一次喂狗，超时时间为50ms</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Key_GetNum();<span class="comment">//调用阻塞式的按键扫描函数，模拟主循环卡死</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*如果把喂狗放在这里的话程序会一直触发看门狗复位，因为距离第一次喂狗时间&lt;30ms，就会触发看门狗复位*/</span></span><br><span class="line">        </span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;FEED&quot;</span>);<span class="comment">//OLED闪烁FEED字符串</span></span><br><span class="line">Delay_ms(<span class="number">20</span>);<span class="comment">//喂狗间隔为20+20=40ms</span></span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;    &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">WWDG_SetCounter(<span class="number">54</span> | <span class="number">0x40</span>);<span class="comment">//重装计数器，喂狗</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>代码中的或上0x40操作：</code></p><p>每次喂狗或上0x40是对计数器的T6位设置为1，避免每次喂狗后立即产生一个复位</p><p>而设置窗口时的或上0x40是为了使W6位也为1，这样才能将该窗口值与喂狗值比较，否则窗口值一直小于喂狗值</p></blockquote><h1>FLASH 闪存</h1><h2 id="FLASH简介">FLASH简介</h2><p><img src="./image/image-20250112184103510.png" alt="image-20250112184103510"></p><blockquote><p><img src="./image/image-20250113122739972.png" alt="image-20250113122739972"></p><p><code>FLASH：</code>程序存储器、系统存储器、选项字节三部分。</p><p>通过<code>闪存存储器接口(外设)：</code><strong>可以对程序存储器和选项字节进行擦除和编程</strong></p><hr><p><code>读写FLASH的用途：</code></p><ol><li><strong>利用程序存储器Flash的剩余空间来保存掉电不丢失的用户数据</strong></li><li><strong>通过在程序中编程IAP，实现程序的自我更新</strong></li></ol><hr><p><code>在线编程</code>(In-Circuit Programming-ICP)：用于更新程序存储器的全部内容，它通过JTAG、SWD协议或系统加载程序(Bootloader)下载程序</p><p><code>在程序中编程</code>(In-Application Programming-lAP)： 可以使用微制器支持的任一种通信接口下载程序</p><hr><p><code>下图各个流程都是闪存编程参考手册中的内容，可以观看闪存编程手册编程!!!</code></p></blockquote><blockquote><p>当有些参数数据需要掉电不丢失的时候，我们可以将其写入内部FLASH中，这样不用外挂存储器芯片，节省了资源</p></blockquote><h2 id="闪存模块组织">闪存模块组织</h2><p><img src="./image/image-20250113123459899.png" alt="image-20250113123459899"></p><blockquote><p><code>闪存三部分：</code></p><p><strong>主存储器</strong>对应：<code>1.程序存储器Flash</code>，起始地址0x0800 0000。也是我们平时说的闪存容量的部分，另外两部分也属于闪存，但不统计进入容量内。</p><p><strong>信息块</strong>：</p><ul><li><p><strong>启动程序代码</strong>对应：<code>2.系统存储器</code>，存放bootloader。起始地址0x1FFF F000</p></li><li><p><strong>用户选择字节</strong>对应：<code>3.选项字节</code>，起始地址0x1FFF F800</p></li></ul><p><strong>闪存存储器接口寄存器(外设)</strong>：从地址来看就是普通的外设寄存器，SRAM的内容</p><hr><p>与W25Q64分为块、扇区、页不同</p><p><strong>内部Flash只有页为基本单位，每页大小为</strong><code>1K</code></p><p>以000、400、800、C00结尾的都一定是页的起始地址。</p><hr><p><code>对于不同容量产品，闪存的分配方式有些区别，参考单独的闪存编程参考手册！！！</code></p></blockquote><h2 id="FLASH基本结构">FLASH基本结构</h2><p><img src="./image/image-20250113143613020.png" alt="image-20250113143613020"></p><blockquote><ol><li><p><strong>闪存存储器接口也叫闪存编程和擦除控制器FPEC</strong>。可以对程序存储器擦除和编程、选项字节擦除和编程</p></li><li><p>选项字节可以配置程序存储器的读写保护</p></li></ol></blockquote><h2 id="FLASH解锁">FLASH解锁</h2><p><img src="./image/image-20250113143920049.png" alt="image-20250113143920049"></p><blockquote><p><code>FPEC：</code>闪存存储器接口/闪存编程和擦除控制器，其中的键寄存器有三个键值</p><p><strong>通过向键寄存器写入指定值可以解锁FLASH的写操作，对于读操作不用执行解锁操作</strong></p><p><code>解锁方式：</code></p><ol><li>先向FLASH_KEYR写入KEY1</li><li>再向FLASH_KEYR写入KEY2</li></ol><p>保护机制：一旦没有先写入KEY1，再写入KEY2就会锁死，除非复位</p><p><code>加锁方式：</code></p><ol><li>设置FLASH_CR中给的LOCK位锁住FPEC和FLASH_CR</li></ol><p><code>操作闪存方式：</code>先解锁，操作完后，再加锁即可</p></blockquote><h2 id="使用指针访问存储器-指针写入操作">使用指针访问存储器(指针写入操作)</h2><p><img src="./image/image-20250113144515473.png" alt="image-20250113144515473"></p><blockquote><p>想以什么形式的方式读出数据，就把uint16_t* 改为对应类型即可，比如想以8位读取，将uint16_t*改为uint8_t*即可</p></blockquote><blockquote><p><code>使用 __IO原因：</code></p><p>当单片机通过指针访问外部硬件设备的寄存器时，<strong>由于这些寄存器的值可能会由硬件自动更新</strong>（例如，一个定时器寄存器的值会随时间变化），因此应该将这些寄存器对应的变量声明为volatile。 这样，每次访问这些变量时，都会直接从硬件寄存器中读取值，而不是使用可能已过时的缓存值。</p></blockquote><h2 id="程序存储器FLASH的擦除和编程">程序存储器FLASH的擦除和编程</h2><p>以下内容对应stm32闪存编写手册的2.3.4节和2.3.3节</p><p><img src="./image/image-20250113151653732.png" alt="image-20250113151653732"></p><p><img src="./image/image-20250113151600875.png" alt="image-20250113151600875"></p><h3 id="程序存储器FLASH的全擦除">程序存储器FLASH的全擦除</h3><p><img src="./image/image-20250113145605786.png" alt="image-20250113145605786"></p><blockquote><p><strong>程序的全擦除在库函数中使用了一个函数，我们可以直接使用，以下就是函数的底层寄存器操作步骤</strong></p><p><code>步骤如下：</code></p><ol><li>读取FLASH_CR的<code>LOCK位</code>，如果锁住了需要先解锁(库函数都是直接解锁)</li><li>置FLASH_CR的<code>MER = 1</code> (MER表示执行的是全擦除)，置FLASH_CR的<code>STRT = 1</code> (STRT为触发条件，置1后芯片开始干活)</li><li>检测FLASH_SR的<code>BSY位是否为1</code>，为1就一直等待，直到BSY位置0后全擦除结束</li></ol><p>读出并验证被擦除页的数据我们可以不管</p></blockquote><h3 id="程序存储器FLASH的页擦除">程序存储器FLASH的页擦除</h3><p><img src="./image/image-20250113172548064.png" alt="image-20250113172548064"></p><blockquote><p><strong>程序的页擦除在库函数中使用了一个函数，我们可以直接使用，以下就是函数的底层寄存器操作步骤</strong></p><p><code>步骤如下：</code></p><ol><li><p>读取FLASH_CR的<code>LOCK位</code>，如果锁住了需要先解锁(库函数都是直接解锁)</p></li><li><p>置FLASH_CR的<code>PER = 1</code> (PER表示执行的是页擦除)，</p><p>然后在FLASH_AR中选择要擦除的页，此地址提前写入</p><p>最后置FLASH_CR的<code>STRT = 1</code> (STRT为触发条件，置1后芯片开始干活)</p></li><li><p>检测FLASH_SR的<code>BSY位是否为1</code>，为1就一直等待，直到BSY位置0后全擦除结束</p></li></ol><p>读出并验证被擦除页的数据我们可以不管</p></blockquote><h3 id="程序存储器FLASH编程">程序存储器FLASH编程</h3><p><img src="./image/image-20250113145516235.png" alt="image-20250113145516235"></p><blockquote><p><code>注：STM32的闪存会在写入前检查指定地址有没有擦除，如果没有擦除，STM32不执行写入操作，除非写入的全为0!!!</code></p><p><strong>程序的全擦除在库函数中使用了一个函数，我们可以直接使用，以下就是函数的底层寄存器操作步骤</strong></p><p><code>步骤如下：</code></p><ol><li>读取FLASH_CR的<code>LOCK位</code>，如果锁住了需要先解锁(库函数都是直接解锁)</li><li>置FLASH_CR的<code>PG = 1</code> (PG表示执行的是编程操作)</li><li>在指定地址写入半字(16位)，只能以半字写入16位(使用指针写入操作)</li><li>检测FLASH_SR的<code>BSY位是否为1</code>，为1就一直等待，直到BSY位置0后全擦除结束</li></ol><p><code>每次流程只能写入半字，如果想要写入很多字节，只需循环调用上面的步骤即可</code></p><hr><p><code>字、半字、字节：</code></p><p>Word(字)：32位数据</p><p>HalfWord(半字)：16位数据</p><p>Byte(字节)：8位数据</p></blockquote><h2 id="选项字节">选项字节</h2><p><img src="./image/image-20250113151106010.png" alt="image-20250113151106010"></p><blockquote><p><code>选项字节：</code>存放独立于程序代码的配置参数</p></blockquote><p><strong>内容对应闪存编程手册2.5节</strong></p><p><img src="./image/image-20250113151906094.png" alt="image-20250113151906094"></p><h3 id="选项字节擦除">选项字节擦除</h3><p><img src="./image/image-20250113151712143.png" alt="image-20250113151712143"></p><blockquote><ol><li><p>先解锁闪存</p></li><li><p>检查FLASH SR的BSY位，以确认没有其他正在进行的闪存操作</p></li><li><p>解锁FLASH_CR的OPTWRE(Option Write Enable)位，即：对FLASH_OPTKEY写入类似对FLASH_KEYR解锁的两个KEY操作</p></li><li><p>设置FLASH CR的OPTER位为1，设置FLASH CR的STRT位为1</p></li><li><p>等待BSY位变为0，即擦除结束</p></li><li><p>读出被擦除的选择字节并做验证(不必要操作)</p></li></ol></blockquote><h3 id="选项字节的编程">选项字节的编程</h3><p><img src="./image/image-20250113151403201.png" alt="image-20250113151403201"></p><blockquote><ol><li><p>先解锁闪存</p></li><li><p>检查FLASH SR的BSY位，以确认没有其他正在进行的闪存操作</p></li><li><p>解锁FLASH_CR的OPTWRE(Option Write Enable)位，即：对FLASH_OPTKEY写入类似对FLASH_KEYR解锁的两个KEY操作</p></li><li><p>设置FLASH CR的OPTPG位为1</p></li><li><p>写入要编程的半字到指定地址</p></li><li><p>等待BSY位变为0，即写入结束</p></li><li><p>读出被擦除的选择字节并做验证(不必要操作)</p></li></ol></blockquote><h2 id="器件电子签名">器件电子签名</h2><p><img src="./image/image-20250113152633326.png" alt="image-20250113152633326"></p><blockquote><p><code>器件电子签名相关内容对应参考手册第28章的内容!!!</code></p><p><strong>电子签名其实就是芯片ID号</strong></p><p>**存放在系统存储器区域：**包含BootLoader和几个字节的电子签名</p><p><img src="./image/image-20250113152728389.png" alt="image-20250113152728389"></p></blockquote><h2 id="FLASH-库函数">FLASH 库函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*stm32f10x_flash.h*/</span></span><br><span class="line"><span class="comment">/*------------ Functions used for all STM32F10x devices -----*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_SetLatency</span><span class="params">(<span class="type">uint32_t</span> FLASH_Latency)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_HalfCycleAccessCmd</span><span class="params">(<span class="type">uint32_t</span> FLASH_HalfCycleAccess)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_PrefetchBufferCmd</span><span class="params">(<span class="type">uint32_t</span> FLASH_PrefetchBuffer)</span>;</span><br><span class="line">FlagStatus <span class="title function_">FLASH_GetPrefetchBufferStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*内核运行代码相关，我们不需要使用*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*加锁解锁：*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_Unlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_Lock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//芯片的加锁和解锁，KEY1,KEY2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*芯片擦除：*/</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ErasePage</span><span class="params">(<span class="type">uint32_t</span> Page_Address)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseAllPages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseOptionBytes</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//分别是页擦除、全擦除、选项字节擦除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*芯片写入(编程):*/</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ProgramWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint32_t</span> Data)</span>;<span class="comment">//指定地址写入字</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ProgramHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint16_t</span> Data)</span>;<span class="comment">////指定地址写入半字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*选项字节读写相关:*/</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ProgramOptionByteData</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint8_t</span> Data)</span>;<span class="comment">//选项字节写入Data</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EnableWriteProtection</span><span class="params">(<span class="type">uint32_t</span> FLASH_Pages)</span>;<span class="comment">//选项字节写保护使能</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ReadOutProtection</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//选项字节都保护</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_UserOptionByteConfig</span><span class="params">(<span class="type">uint16_t</span> OB_IWDG, <span class="type">uint16_t</span> OB_STOP, <span class="type">uint16_t</span> OB_STDBY)</span>;<span class="comment">//用户选项的三个配置位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*选项字节状态获取：*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">FLASH_GetUserOptionByte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">FLASH_GetWriteProtectionOptionByte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FlagStatus <span class="title function_">FLASH_GetReadOutProtectionStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_ITConfig</span><span class="params">(<span class="type">uint32_t</span> FLASH_IT, FunctionalState NewState)</span>;</span><br><span class="line">FlagStatus <span class="title function_">FLASH_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> FLASH_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> FLASH_FLAG)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_GetStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_WaitForLastOperation</span><span class="params">(<span class="type">uint32_t</span> Timeout)</span>;<span class="comment">//等待上一次操作，也就是等待BSY为0，在上面读写擦除的库函数内部已经调用了，我们不需要调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--我们这里用不到下面的函数</span><br><span class="line"><span class="comment">/*------------ New function used for all STM32F10x devices -----*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_UnlockBank1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_LockBank1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseAllBank1Pages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_GetBank1Status</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_WaitForLastBank1Operation</span><span class="params">(<span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> STM32F10X_XL</span></span><br><span class="line"><span class="comment">/*---- New Functions used only with STM32F10x_XL density devices -----*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_UnlockBank2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_LockBank2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseAllBank2Pages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_GetBank2Status</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_WaitForLastBank2Operation</span><span class="params">(<span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_BootConfig</span><span class="params">(<span class="type">uint16_t</span> FLASH_BOOT)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面三个库函数分为部分：<strong>通用函数、新加的通用函数、新加的只能被大容量XL系列使用的函数</strong></p><p>图中的Bank2是后面新推出加大容量XL系列新加的一块Flash</p></blockquote><h2 id="实验">实验</h2><h3 id="简单读写FLASH-FLASH底层代码实现">简单读写FLASH(FLASH底层代码实现)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取一个字32bit</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">MyFlash_ReadWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span>  *((__IO <span class="type">uint32_t</span>*)(Address));<span class="comment">////使用指针访问指定地址下的数据并返回</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取半字16bit</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">MyFlash_ReadHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span>  *((__IO <span class="type">uint16_t</span>*)(Address));<span class="comment">//使用指针访问指定地址下的数据并返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将32位地址强转为指向uint16_t数据的指针，Address值也就是该指针不会变，仅仅将这个指针(地址)指向的数据变为了uint16_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字节8bit</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyFlash_ReadByte</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span>  *((__IO <span class="type">uint8_t</span>*)(Address));<span class="comment">//使用指针访问指定地址下的数据并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_EraseAllPages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">FLASH_EraseAllPages();<span class="comment">//全擦除</span></span><br><span class="line">FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ErasePage</span><span class="params">(<span class="type">uint32_t</span> Page_Address)</span></span><br><span class="line">&#123;</span><br><span class="line">FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">FLASH_ErasePage(Page_Address);<span class="comment">//全擦除</span></span><br><span class="line">FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选项字节擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFLash_EraseOptionBytes</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">FLASH_EraseOptionBytes();<span class="comment">//全擦除</span></span><br><span class="line">  FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入字32bit</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint32_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">FLASH_ProgramWord(Address, Data);<span class="comment">//编程字</span></span><br><span class="line">FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入半字16bit</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint16_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">FLASH_ProgramHalfWord(Address, Data);<span class="comment">//编程半字</span></span><br><span class="line">FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyFlash.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYFLASH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYFLASH_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">MyFlash_ReadWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">MyFlash_ReadHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyFlash_ReadByte</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_EraseAllPages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ErasePage</span><span class="params">(<span class="type">uint32_t</span> Page_Address)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFLash_EraseOptionBytes</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint32_t</span> Data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyFlash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> data1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> data2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> data3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyFlash_ErasePage(<span class="number">0x0800FC00</span>);<span class="comment">//写入前要先擦除，写入区域</span></span><br><span class="line"></span><br><span class="line">MyFlash_ProgramWord(<span class="number">0x0800FC00</span>,<span class="number">0x12345678</span>);<span class="comment">//写入Flash最后的区域一个字,数据为0x12345678</span></span><br><span class="line">      MyFlash_ProgramHalfWord(<span class="number">0x0800FC10</span>,<span class="number">0xABCD</span>);<span class="comment">//写入半个字，数据为0xABCD</span></span><br><span class="line">      </span><br><span class="line">    data1 = MyFlash_ReadWord(<span class="number">0x0800FC00</span>);</span><br><span class="line">data2 = MyFlash_ReadHalfWord(<span class="number">0x0800FC00</span>);</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最终读取的结果如下keil变量的值，以及内存中的值如图</p><p><strong>我们也可以使用STM32 ST-LINK Utility软件直接观察</strong></p></blockquote><p><img src="./image/image-20250113194907167.png" alt="image-20250113194907167"></p><p><img src="../../../Notes/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/image/image-20250113194929798.png" alt="image-20250113194929798"></p><h3 id="在SRAM中定义数组和标志位对FLASH数据存储">在SRAM中定义数组和标志位对FLASH数据存储</h3><blockquote><p><strong>在SRAM定义数组写入数据到FLASH，并且实现上电FLASH数据读取到SRAM操作</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*store.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STORE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STORE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> Store_Data[]; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Save</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*store.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyFLASH.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对于这种在很多地方出现，对应不同芯片有不同值得数据我们使用宏定义，提高程序的复用*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORE_START_ADDRESS0x0800FC00<span class="comment">//存储的起始地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORE_COUNT512<span class="comment">//存储数据的个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> Store_Data[STORE_COUNT];<span class="comment">//定义SRAM数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块初始化</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*地址的第一个半字存储标志位以此判断是不是第一次使用,*/</span></span><br><span class="line"><span class="keyword">if</span> (MyFLASH_ReadHalfWord(STORE_START_ADDRESS) != <span class="number">0xA5A5</span>)<span class="comment">//读取第一个半字的标志位，if成立，则执行第一次使用的初始化</span></span><br><span class="line">&#123;</span><br><span class="line">MyFLASH_ErasePage(STORE_START_ADDRESS);<span class="comment">//擦除指定页</span></span><br><span class="line">MyFLASH_ProgramHalfWord(STORE_START_ADDRESS, <span class="number">0xA5A5</span>);<span class="comment">//在第一个半字写入自己规定的标志位，用于判断是不是第一次使用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">1</span>; i &lt; STORE_COUNT; i ++)<span class="comment">//循环STORE_COUNT次，除了第一个标志位</span></span><br><span class="line">&#123;</span><br><span class="line">MyFLASH_ProgramHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>, <span class="number">0x0000</span>);<span class="comment">//除了标志位的有效数据全部清0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上电时，将闪存数据加载回SRAM数组，实现SRAM数组的掉电不丢失*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; STORE_COUNT; i ++)<span class="comment">//循环STORE_COUNT次，包括第一个标志位</span></span><br><span class="line">&#123;</span><br><span class="line">Store_Data[i] = MyFLASH_ReadHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>);<span class="comment">//将闪存的数据加载回SRAM数组</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块保存数据到闪存</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Save</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MyFLASH_ErasePage(STORE_START_ADDRESS);<span class="comment">//擦除指定页</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; STORE_COUNT; i ++)<span class="comment">//循环STORE_COUNT次，包括第一个标志位</span></span><br><span class="line">&#123;</span><br><span class="line">MyFLASH_ProgramHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>, Store_Data[i]);<span class="comment">//将SRAM数组的数据备份保存到闪存</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块将所有有效数据清0</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Clear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">1</span>; i &lt; STORE_COUNT; i ++)<span class="comment">//循环STORE_COUNT次，除了第一个标志位</span></span><br><span class="line">&#123;</span><br><span class="line">Store_Data[i] = <span class="number">0x0000</span>;<span class="comment">//SRAM数组有效数据清0</span></span><br><span class="line">&#125;</span><br><span class="line">Store_Save();<span class="comment">//保存数据到闪存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Store.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> KeyNum;<span class="comment">//定义用于接收按键键码的变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*模块初始化*/</span></span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">Key_Init();<span class="comment">//按键初始化</span></span><br><span class="line">Store_Init();<span class="comment">//参数存储模块初始化，在上电的时候将闪存的数据加载回Store_Data，实现掉电不丢失</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示静态字符串*/</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Flag:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Data:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KeyNum = Key_GetNum();<span class="comment">//获取按键键码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (KeyNum == <span class="number">1</span>)<span class="comment">//按键1按下</span></span><br><span class="line">&#123;</span><br><span class="line">Store_Data[<span class="number">1</span>] ++;<span class="comment">//变换测试数据</span></span><br><span class="line">Store_Data[<span class="number">2</span>] += <span class="number">2</span>;</span><br><span class="line">Store_Data[<span class="number">3</span>] += <span class="number">3</span>;</span><br><span class="line">Store_Data[<span class="number">4</span>] += <span class="number">4</span>;</span><br><span class="line">Store_Save();<span class="comment">//将Store_Data的数据备份保存到闪存，实现掉电不丢失</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (KeyNum == <span class="number">2</span>)<span class="comment">//按键2按下</span></span><br><span class="line">&#123;</span><br><span class="line">Store_Clear();<span class="comment">//将Store_Data的数据全部清0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">6</span>, Store_Data[<span class="number">0</span>], <span class="number">4</span>);<span class="comment">//显示Store_Data的第一位标志位</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>, <span class="number">1</span>, Store_Data[<span class="number">1</span>], <span class="number">4</span>);<span class="comment">//显示Store_Data的有效存储数据</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>, <span class="number">6</span>, Store_Data[<span class="number">2</span>], <span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, Store_Data[<span class="number">3</span>], <span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">6</span>, Store_Data[<span class="number">4</span>], <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>实现按键1按下存入FLASH中，按键2按下清除数据</p></blockquote><h3 id="读取芯片ID-使用指针直接访问读取">读取芯片ID(使用指针直接访问读取)</h3><p><img src="./image/image-20250113152633326.png" alt="image-20250113152633326"></p><p><code>对应手册28章内容：</code></p><p><img src="./image/image-20250113204952775.png" alt="image-20250113204952775"></p><p><img src="./image/image-20250113205028352.png" alt="image-20250113205028352"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;F_SIZE:&quot;</span>);<span class="comment">//显示静态字符串</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, *((__IO <span class="type">uint16_t</span> *)(<span class="number">0x1FFFF7E0</span>)), <span class="number">4</span>);<span class="comment">//使用指针读取指定地址下的闪存容量寄存器</span></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;U_ID:&quot;</span>);<span class="comment">//显示静态字符串</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">6</span>, *((__IO <span class="type">uint16_t</span> *)(<span class="number">0x1FFFF7E8</span>)), <span class="number">4</span>);<span class="comment">//使用指针读取指定地址下的产品唯一身份标识寄存器</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">11</span>, *((__IO <span class="type">uint16_t</span> *)(<span class="number">0x1FFFF7E8</span> + <span class="number">0x02</span>)), <span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>, <span class="number">1</span>, *((__IO <span class="type">uint32_t</span> *)(<span class="number">0x1FFFF7E8</span> + <span class="number">0x04</span>)), <span class="number">8</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, *((__IO <span class="type">uint32_t</span> *)(<span class="number">0x1FFFF7E8</span> + <span class="number">0x08</span>)), <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>**闪存容量寄存器：**使用半字读取</p><p>**产品唯一身份标识寄存器：**2个半字和2个字读取</p><p>全部显示到OLED上去</p></blockquote><h2 id="存在的BUG-当程序很大时覆盖用户存储参数区">存在的BUG-当程序很大时覆盖用户存储参数区</h2><p><code>问题描述：</code></p><p><strong>我们上面由于程序较小，程序存储在Flash的靠前区域，我们使用最后一页存储用户数据，但是如果程序很大的时候，可能就会到最后一页，造成程序和用户数据存储的位置冲突。</strong></p><p><code>解决方法：</code>给程序文件限定一个存储范围，不让它分配到后面我们的用户数据空间来。</p><ol><li><strong>打开工程管理</strong></li></ol><p><img src="./image/image-20250113203529438.png" alt="image-20250113203529438"></p><ol start="2"><li><strong>目前使用的是起始地址为0x80000000，Size大小为0x10000(64KB)，刚好使用完了程序存储区</strong></li></ol><p><img src="./image/image-20250113203606973.png" alt="image-20250113203606973"></p><ol start="3"><li><strong>如果我们想把程序区的最后自己使用，修改Size为0xFC00，这样到FC00之前就是程序存储的地方，后面地址我们可以自己存放用户参数</strong></li></ol><p><img src="./image/image-20250113203950691.png" alt="image-20250113203950691"></p><blockquote><p>注意修改size大小不能太小，太小了也会报错</p></blockquote><h2 id="Flash写入之前的擦除必要性">Flash写入之前的擦除必要性</h2><p><strong>1.Flash 默认状态是“全 1”</strong>：</p><ul><li>Flash 存储器在擦除之前的默认值是“1”，即每个字节的每一位都设为 1。当你想要写入数据时，必须将目标区域从“1”改为“0”。但是 Flash 存储器并不支持直接将 “0” 恢复为 “1”，只能将其设置为“0”。</li></ul><p><strong>2.擦除是将区域复位为“全 1”</strong>：</p><ul><li>擦除操作是将整个存储单元（如页面或扇区）恢复为“全 1”状态，为后续的写入做好准备。只有当区域恢复为全 1 后，才能写入新的数据。</li></ul><p><strong>3.Flash 的写入操作是“增量”</strong>：</p><ul><li>你可以在一个已擦除区域中写入数据，但不能直接覆盖其中的</li></ul><h2 id="STM32-ST-LINK-Utility">STM32 ST-LINK Utility</h2><p><img src="./image/image-20250113171621586.png" alt="image-20250113171621586"></p><blockquote><p>我们可以使用STM32 ST-LINK Utility这个软件直接查看和修改我们芯片内部的各个地址的内容。</p><p>关于上方的内部FLASH和选项字节模块对应都可以查看和修改</p><p>使用代码配置读写保护时如果造成了芯片自锁，但程序里没有预留解除写保护的代码，造成没法下载程序了，我们可以使用这个这个软件直接去掉读写保护就可以解除芯片的自锁。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++学习笔记</title>
      <link href="/posts/ad4f1e09.html"/>
      <url>/posts/ad4f1e09.html</url>
      
        <content type="html"><![CDATA[<h1>C++学习笔记：</h1><h2 id="名称空间std">名称空间std</h2><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113132517924.png" alt="image-20221113132517924"></p><p>&lt;math.h&gt;新式为<cmath></p><p>&lt;string.h&gt;新式为<cstring></p><p>如果使用iostream，而不是iostream.h，即当头文件中没有扩展名h时，iostream中定义的用于输出的cout变量实际是<strong>std::cout</strong>,而endl实际上是<strong>std::endl</strong>.因此，可以省略编译指令using，用下述方式进行编码:</p><p>std::cout&lt;&lt;&quot; xxxxxx&quot;;</p><p>std::cout&lt;&lt;std::endl;</p><p>但如果使用using编译指令:<strong>using namespace std;</strong></p><p><strong>便可以直接使用cin和cout…，而不必加上std::前缀</strong></p><h2 id="控制符endl">控制符endl</h2><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113133422849.png" alt="image-20221113133422849"></p><p><strong>C++中的旧版换行采用的是&quot;\n</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113133633328.png" alt="image-20221113133633328"></p><h2 id="cin和cout">cin和cout</h2><p><strong>（1）.</strong><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113135231199.png" alt="image-20221113135231199"></p><p><strong>（2）.</strong></p><p><strong>输出可以拼接:</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113140118344.png" alt="image-20221113140118344">**</p><h2 id="每次读取一行字符串-string-输入">每次读取一行字符串(string)输入</h2><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113193250853.png" alt="image-20221113193250853"></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113194203451.png" alt="image-20221113194203451"></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113194311275.png" alt="image-20221113194311275"></p><h2 id="总结">总结:</h2><p><strong>1.cin(&gt;&gt;)</strong></p><p>虽然可以使用 cin 和 &gt;&gt; 来输入字符串，当 cin 读取数据时，<strong>一旦它接触到第一个非空格字符即开始阅读，当它读取到下一个空白字符时，它将停止读取。</strong></p><p>可以输入 “Mark” 或 “Twain”，但不能输入 “Mark (停止读取)  Twain”，<br><strong>因为 cin 不能输入包含嵌入空格的字符串。</strong></p><p><strong>2.cin.get(char ch)/(array_name,size)</strong></p><p>无参数时，读入一个字符，包括换行符，常用来处理输入缓冲区中的换行符。</p><p>有参数时，从缓冲区读取数据，到达行尾或size-1个字符**(剩下的空间储存在结尾添加的空字符)**后结束读取(超过规定字符数不会出现错误,会直接截断)，不会对换行符进行处理，将其留在缓冲区</p><p><strong>3.cin.getline(array_name,size)</strong></p><p>从缓冲区读取数据,到达行尾或size-1**(剩下的空间储存在结尾添加的空字符)**个字符结束读取(超过规定的字符数会出现错误,中断)，会读取换行符将其替换为空字符，并且丢弃。</p><p>**4.getline(cin,array_name） **/  <strong>std::getline(std::cin,array_name)</strong></p><p>例如：getline(cin,str);</p><p>从缓冲区中读取数据，遇到换行符时将其替换为空字符，并且丢弃。</p><h2 id="补">补:</h2><p><strong>(1)cin.getline(char*s,streamsize n,char delim)</strong></p><p>所需的头文件为<iostream>(这里的参数char s是输入的字符串变量， n是输入字符串的字符个数（第n个补’\0’）， delim是输入终止条件，即遇到delim所代表的字符就终止输入,正常使用时 char delim可以省略，c++语言默认为’\0’)   例 :   cin.getline(name,20,‘C’)或cin.getline(name,20)</p><p><strong>(2)getline(istream&amp; is, string&amp; str, char delim)</strong></p><p>所需的头文件为<string>(s是标准输入流函数， str是用来存字符的变量名， delim是结束标志,作用与cin.getline()里的相同）例: getline(cin,str,‘A’)</p><p>==<strong>注:</strong> <strong>getline()是string流的函数，只能用于string类型(不能用于输入char*类型)的输入操作.</strong>==</p><p>==<strong>cin.getline()是std流的函数，只能用于char*类型的输入操作（不能用于string类型输入）</strong>。==       <strong>char*为数组</strong></p><p><strong>当你定义了一个char*类型变量，只能用cin/cin.getline()输入。！！！！！</strong></p><p>**(3).**在使用getline读入一整行时，<br>若是前面是使用getchar()、cin这类读入了一个字母，<br>但是不会读入后续换行\n符号或者空格的输入时，再接getline()就容易出现问题。</p><p>这是因为输入数字之后，敲回车，产生的换行符仍然滞留在输入流了，<br>接着就被getline(cin,s)给读进去了，<br>此时的s=“\n”,所以实际上s只是读入了一个换行符\n。</p><p>而若是前面使用getline()，再又用getline()进行读入，此时不会发生问题。<br><strong>getline()中读入结束的回车后，结束符不放入缓存区，会将读入的\n直接去除，</strong><br><strong>下一个输入前，缓冲区为空，并不会因为回车留下\n。</strong></p><p>而cin的结束后，以及getchar()此类的读入结束后,按下回车或者使用空格读入下一个，<br>此时按下的回车或空格会还在缓存区,继续用getline()就会出现前面所提到的情况。<br>那么如何解决前面用了cin、getchar()后的输入呢？<br><strong>可以直接在cin和getchar()后使用一个getchar()吃掉接下来的换行.</strong></p><h1>string类(头文件&quot;string&quot;)</h1><p><strong>1.</strong><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202153066.png" alt="image-20221113202153066"></p><p><strong>2.</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202108337.png" alt="image-20221113202108337"></p><p><strong>3.数组和string类的不同点:</strong></p><p>**(1)**在数组中，不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象。</p><p>**(2)**可以使用+让两个string对象合并起来，还可以使用+=将字符串附加到string对象的末尾。</p><p>同时可以对字符串实现运算符（==，=），可以直接比较</p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202543882.png" alt="image-20221113202543882"></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202618980.png" alt=""></p><p><strong>4.用getline将输入读取到string对象</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202709793.png" alt="image-20221113202709793"></p><h2 id="补：获取字符串长度">补：获取字符串长度</h2><p><strong>1.length()函数</strong><br>直接获取字符串长度，包括空格在内</p><p>表示方法:    **str.length()**即可表示str字符串的长度</p><p><strong>2.strlen()函数</strong><br>需要添加头文件&lt;string.h&gt;,而且<strong>参数只能是char数组</strong>（不能是string类）<br>而且结尾必须是\0(即字符数组不能满，因为满了结尾就不是\0，会接着向下检索到\0为止)<br>啊哦char c[6]{“kunkun”}; 这样是错误的嗷 直接没法进行编译，编译器直接帮我们解决问题2。</p><p>表示方法：  <strong>strlen(数组名)</strong></p><p><strong>3.size()</strong></p><p>需要添加&lt;string.h&gt;头文件，用法类似于length()。<br>size()表示的是string这个容器中的元素个数。（还可以获取vector类型的长度）<br>如果使用过std::vector之类的容器的话，可以把string看做是一个vector(这里只是举例，并不能等价)， char就是这个容器的元素类型。那么size()表示的就是这个vector(容器)中char的个数。<br>表示方法:</p><p>**str.size()**即可表示str字符串的长度（不包含’\0’）</p><h1>数组的替代品</h1><p><strong>具体见CSDN</strong></p><h2 id="模板类vector">模板类vector</h2><ul><li><p>vector是向量类型，可以容纳许多类型的数据，因此也被称为容器</p></li><li><p>(可以理解为<strong>动态数组</strong>，是封装好了的类）</p></li><li><p>进行<code>vector</code>操作前应添加头文件<code>#include &lt;vector&gt;</code></p></li><li><p>.2 vector初始化：<br>方式1.</p><p>定义具有10个整型元素的向量（尖括号为元素类型名，它可以是任何合法的数据类型），不具有初值，其值不确定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>方式2.</p><p>定义具有10个整型元素的向量，且给出的每个元素初值为1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>方式3.</p><p>用向量b给向量a赋值，a的值完全等价于b的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b);</span><br></pre></td></tr></table></figure><p>方式4.</p><p>将向量b中从0-2（共三个）的元素赋值给a，a的类型为int型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b.<span class="built_in">begin</span>(),b.begin+<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>方式5.</p><p>//从数组中获得初值<br>int b[7]={1,2,3,4,5,6,7};</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>）;</span></span></span><br></pre></td></tr></table></figure><h4 id="1-3-vector对象的常用内置函数使用（举例说明）">1.3 vector对象的常用内置函数使用（举例说明）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a,b;</span><br><span class="line"><span class="comment">//b为向量，将b的0-2个元素赋值给向量a</span></span><br><span class="line">a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//a含有4个值为2的元素</span></span><br><span class="line">a.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//返回a的最后一个元素</span></span><br><span class="line">a.<span class="built_in">back</span>();</span><br><span class="line"><span class="comment">//返回a的第一个元素</span></span><br><span class="line">a.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//返回a的第i元素,当且仅当a存在</span></span><br><span class="line">a[i];</span><br><span class="line"><span class="comment">//清空a中的元素</span></span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//判断a是否为空，空则返回true，非空则返回false</span></span><br><span class="line">a.<span class="built_in">empty</span>();</span><br><span class="line"><span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入数值5,</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入3个数，其值都为5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//b为数组，在a的第一个元素（从第0个元素算起）的位置插入b的第三个元素到第5个元素（不包括b+6）</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>);</span><br><span class="line"><span class="comment">//返回a中元素的个数</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">a.<span class="built_in">capacity</span>();</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值随机</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值为2</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//将a的容量扩充至100，</span></span><br><span class="line">a.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//b为向量，将a中的元素和b中的元素整体交换</span></span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">//b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt;</span></span><br><span class="line">a==b;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="size">size()</h2><p>C++中，在获取<strong>字符串长度</strong>时，size()函数与length()函数作用相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">length</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><strong>size()函数以及length()函数</strong>都用于计算字符串（string）长度，不能用char*作为参数。除此之外，size()函数还可以获取vector类型的长度。</p><p>size()函数返回值为unsigned int 类型为正数</p><p>注意 让其作为返回值赋给变量时，变量类型要为<br>unsigned int 或 size_t型</p><p>补:<strong>size_t</strong></p><p><strong>size_t</strong> 是一些C/C++标准在stddef.h中定义的，size_t 类型表示C中任何对象所能达到的最大长度，它是无符号整数。</p><p>32位上的定义:  等价于 unsigned int</p><p>64位上的定义:  等价于 unsigned long</p><h2 id="empty">empty()</h2><p>C++中empty()作为判断容器是否为空的函数</p><p>用法为 <strong>对象名.empty()</strong>    例: <strong>s.empty()</strong></p><p><strong>如果对象为空就返回1(ture)，</strong></p><p><strong>不为空返回0(false)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;&quot;</span>；</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; “字符串为空”;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串不为空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="swap-swap-交换">swap()         swap(交换)</h2><p><strong>具体见CSDN</strong></p><p>标准库的<strong>C ++中</strong>的<code>swap()</code>函数是一个在两个<strong>相同类型</strong>的给定变量之间直接交换值的函数。<strong>元素个数不相等也可以进行交换</strong></p><p>用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">swap</span>(a,b);</span><br></pre></td></tr></table></figure><h2 id="insert-insert-插入">insert()      insert(插入)</h2><p><strong>对象.insert()</strong></p><p><strong>几种用法:</strong>         <strong>下标（索引）都是默认从第0个位置开始（第0个位置，第1个位置）</strong></p><p><strong>1、在第index位置插入count个字符c----&gt;str.insert(index,count,c);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;012356789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;<span class="number">012356789</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="number">1</span>,<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串----&gt;&quot;</span>  &lt;&lt; str &lt;&lt; endl;  <span class="number">0123456789</span></span><br></pre></td></tr></table></figure><p><strong>2、在第index位置插入一个常量字符串----&gt;str.insert(index,str);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;0156789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;  <span class="number">0156789</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">2</span>,<span class="string">&quot;234&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;   <span class="number">0123456789</span></span><br></pre></td></tr></table></figure><p><strong>3、第index位置插入常量字符串str中的count个字符----&gt;str.insert(index,str,count);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;456789&quot;</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl; <span class="number">0123456789</span></span><br></pre></td></tr></table></figure><p>4、<strong>第index位置插入常量str----&gt;str.insert(index,str);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;45&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl; <span class="number">0123456789</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5、第index位置插入常量str的从index_str开始的count个字符----&gt;str.insert(index,str,index_str,count);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;2345678&quot;</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;   <span class="number">0123456789</span></span><br></pre></td></tr></table></figure><p><strong>6、index位置插入常量str从index_str开始以后的字符串----&gt;str.insert(index,str,index_str,string::npos);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;012345&quot;</span>,<span class="number">4</span>,string::npos);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;  <span class="number">0123456789</span></span><br></pre></td></tr></table></figure><h1>NULL和nullptr</h1><p>c中用NULL表示空指针</p><p>但在c++中用nullptr表示空指针，把NULL当作0来使用</p><p><strong>具体的见CSDN</strong></p><h2 id="对类的定义：">对类的定义：</h2><p><strong>首先用class+标记名对类进行定义</strong>：<strong>1.private部分，2.public部分</strong></p><p><strong>(1)private</strong>中的数据为隐藏数据（通常是变量），只能通过public中的成员函数对其进行访问，外部没有访问权力。</p><p><strong>(2)public</strong>中通常是成员函数，可以在成员函数中访问该类的private中的数据，<strong>通常只在里面声明函数原型,在其他地方定义</strong>（此处用的链表，链表的下一个结点）</p><p>**注：**访问成员函数要作用域解析符 <strong>: :</strong>  ，格式为 : <strong>类标记名+ : : + 函数名</strong>   <strong>尤其是在定义时</strong> 例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Input</span><span class="params">()</span></span>&#123;<span class="comment">//定义一个全新的函数Input,不是成员函数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Classroom::Input</span><span class="params">()</span></span>&#123;<span class="comment">//对成员函数进行定义</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处用了友元类，具体见笔记</p><h2 id="类对象（变量）的创建">类对象（变量）的创建</h2><p><strong>标记名 + 对象名</strong> 例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classroom</span>&#123;</span></span><br><span class="line">    private：</span><br><span class="line">        </span><br><span class="line">    public：</span><br><span class="line">        <span class="type">void</span> <span class="title function_">Input</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br><span class="line">Classroom a<span class="comment">//创建一个Classroom类的对象a</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Classroom::Input();<span class="comment">//错误写法</span></span><br><span class="line">    a.Input()<span class="comment">//正确写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重点！！   注意：在调用成员函数之前，必须创建对象,不能直接像定义成员函数那样调用成员函数.   如上方</strong></p><p><strong>调用成员函数的方式是通过 点关系符 ”  .  “</strong></p><p>！！！！ <strong>类访问==成员函数==时用&quot;.&quot;访问,并且如果没有参数访问的时候必须带上后面的括号，否则认为访问的是变量；</strong></p><p>格式为：   <strong>对象名 . 函数名()</strong></p><p><strong>例如:       a.Input();</strong></p><p><strong>下为类对象（变量）在学生管理程序中使用：</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221120220212245.png" alt="image-20221120220212245"></p><h2 id="new和delete">new和delete</h2><p><strong>该处以链表+类为例：</strong></p><p>![image-20221120200903909](E:\！！！！Markdown\C++.assets\image-20221120200903909.png![image-20221120202508583](E:\！！！！Markdown\C++.assets\image-20221120202508583.png<img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221120202614633.png" alt="image-20221120202614633"></p><h3 id="1-New">1.New</h3><p>（1）用malloc分配内存时需要头文件cstdlib,但是new 不需要引用新的头文件。</p><p>（2）new为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配的内存</p><p>通用格式如下：<strong>typename * pointer_name = new typeName</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);<span class="comment">//申请了一个初值为10的整型数据,括号中为初始化的值</span></span><br><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//申请了能存放10个整型数据元素的数组，其首地址为arr</span></span><br></pre></td></tr></table></figure><p>注意:</p><p>*<em>int <em>p=new int 此时解引用p的值将会是一个随机值，未初始化。</em></em></p><p>*<em>int <em>p=new int() 此时括号里为空，解引用p的值将自动初始化为0</em></em></p><p>此处文件中<strong>current</strong> 是一个指针 ，<strong>Student</strong>是类标记，<strong>new + 类型名 返回的值是一个地址</strong></p><p>（3）new 从被称为<strong>堆</strong>或<strong>自由储存区</strong>的内存区域分配内存，除了主动释放外不会被回收。而局部变量通常储存在<strong>栈</strong>的内存区域中</p><h3 id="2-Delete">2.Delete</h3><p><strong>delete 用来释放new分配的内存</strong></p><p>通常    delete + 指针名    即可（注意:delete不一定使用用于new的指针，而是用于new的地址）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p；</span><br><span class="line"><span class="keyword">delete</span>[] arr;<span class="comment">//注意要删除数组时，需要加[]，以表示arr为数组。</span></span><br></pre></td></tr></table></figure><p><strong>使用new 和 delete 应该遵守以下规则：</strong></p><p>1.不要使用delete来释放不是new分配的内存。</p><p>2.不要使用delete来释放同一个内存块两次。</p><p>3.如果使用new [ ]为数组分配内存，则应该使用delete [ ]来释放</p><p>4.如果使用new为一个实体分配内存，则应该使用delete（没有方括号）来释放。</p><p>5.对空指针使用delete是安全的。</p><h2 id="C-中文件的输入输出">C++中文件的输入输出</h2><h3 id="写入到文本文件中">写入到文本文件中</h3><p>==要求==：</p><p><strong>1.包含头文件iostream，</strong></p><p><strong>包含头文件fstream</strong></p><p><strong>iostream: 头文件中定义了一个处理输出的ostream类</strong></p><p><strong>fstream：头文件定义了一个用于处理输出的ofstream类</strong></p><p><strong>2.<strong>声明一个或多个</strong>ofstream</strong>（<strong>output fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为outFile</strong></p><p>**3.**必须指明名称空间std，为引用ofstream，必须使用编译指令using或者前缀的std：：</p><p>**4.**将ofstream对象与文件关联起来。为此，方法之一是使用open()方法</p><p>**5.**使用完文件后，应使用close()将其关闭</p><p>**6.**可结合ofstream对象 和运算符&lt;&lt;来输出各种类型的数据。</p><p>**总结：**文件的输出主要步骤如下:</p><p>1.包含头文件fstream</p><p>2.创建一个ofstream（output fstream）对象（<strong>通常取名为outFile</strong>）</p><p>3.将该ofstream 对象同一个文件关联起来。</p><p>**4.向cout那样使用ofstream对象（通常outFile）**重点：<strong>cout在屏幕上输出，而outFile是在文件中输出（写入）</strong></p><p><strong>例子见下方</strong></p><h3 id="从文本文件中读取数据">从文本文件中读取数据</h3><p>==要求==：</p><p><strong>1.包含头文件iostream，包含头文件fstream</strong></p><p><strong>iostream: 头文件中定义了一个处理输出的istream类</strong></p><p><strong>fstream：头文件定义了一个用于处理输入的ifstream类</strong></p><p><strong>2.<strong>声明一个或多个</strong>ifstream</strong>（<strong>input fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为inFile</strong></p><p>**3.**必须指明名称空间std，为引用ifstream，必须使用编译指令using或者前缀的std：：</p><p>**4.**将ifstream对象与文件关联起来。为此，方法之一是使用open()方法</p><p>**5.**使用完文件后，应使用close()将其关闭</p><p>**6.**可结合ifstream对象 和运算符&lt;&lt;来输出各种类型的数据。</p><h4 id="检查文件">检查文件</h4><p>格式为: 对象名.isopen()  例:    <strong>inFile.is_open()</strong></p><p>如果文件成功被打开，返回<strong>true</strong>；如果文件没有被打开，<strong>因此表达式   !inFile.is_open()  将为true</strong></p><p>通常使用下方代码判断是否打开成功</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exit(0)程序正常结束</strong></p><p><strong>exit(1)程序异常结束</strong></p><p><strong>exit()使用需要用到头文件==cstdlib==</strong></p><h4 id="文件读取结尾">文件读取结尾</h4><p><strong>eof在遇到EOF（文件结束标志）时返回ture ，否则返回false</strong></p><p>通常和while循环一起用作文件读取结束，<strong>!inFile.eof</strong>在文件结束前为真，结束为假（退出循环）</p><p>具体格式为：   <strong>while(  !inFile.eof（）)</strong></p><h4 id="文件的打开和关闭">文件的打开和关闭</h4><p>**1.对象名.open(“文件名”) **（一个参数）例：<strong>outFile.open(“student.txt”)</strong> 如果文件不存在，将会自动创建一个相同名字的文件,如果文件存在，将会打开该文件，首先截断该文件，将其长度截短到0，丢弃原有的内容，然后将新的输入加入到该文件中</p><p><strong>2.对象名.open(“文件名”，打开方式)</strong> （两个参数）例如 : **outFile.open(“student.txt”,std::ios::in)**只读模式  见下方</p><p>格式：对象名.close()  例: <strong>outFile.close()</strong></p><p>注意方法close()，不需要使用文件名作为参数，因为outFile已经同特定的文件关联起来，如果忘记关闭文件，程序正常终止的时候将自动关闭它。</p><p><strong>下面时学生管理程序中的例子:</strong></p><p><strong>读取数据到文件中（output输出数据到文件）：</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221120212115308.png" alt="image-20221120212115308"></p><p><strong>从该文件中读取数据（input从文件中输入数据到外）：</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221120212136110.png" alt="image-20221120212136110"></p><p><strong>从文件中读取数据时，也需要用到new分配新的内存，与Input（）函数在输入数据时相同</strong></p><p><strong>inFile 对应的c中的fscanf（从文件中读取数据）</strong></p><p><strong>outFile对应的时c中的fprintf（写入数据到文件）</strong></p><h1>构造函数和析构函数</h1><h2 id="构造函数">构造函数</h2><ul><li>按参数种类分：无参构造函数、有参构造函数、有默认参构造函数</li><li>按类型分为：普通构造函数、拷贝构造函数(赋值构造函数)</li></ul><p><a href="https://blog.csdn.net/Viewinfinitely/article/details/115017678?ops_request_misc=%7B%22request%5Fid%22%3A%22170626893616800185850269%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170626893616800185850269&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115017678-null-null.142%5Ev99%5Epc_search_result_base4&amp;utm_term=C%2B%2B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">C++构造函数的各种用法全面解析（C++初学面向对象编程）_c++ 构造函数-CSDN博客</a></p><h1>运算符重载</h1><h2 id="运算符重载的概念和原理">运算符重载的概念和原理</h2><p>如果不做特殊处理，C++ 的 +、-、*、/ 等运算符只能用于对基本类型的常量或变量进行运算，不能用于对象之间的运算。</p><p>有时希望对象之间也能用这些运算符进行运算，以达到使程序更简洁、易懂的目的。例如，复数是可以进行四则运算的，两个复数对象相加如果能直接用+运算符完成，不是很直观和简洁吗？</p><p>利用 C++ 提供的“运算符重载”机制，赋予运算符新的功能，就能解决用+将两个复数对象相加这样的问题。</p><p>运算符重载，就是对已有的运算符赋予多重含义，使同一运算符作用于不同类型的数据时产生不同的行为。运算符重载的目的是使得 C++ 中的运算符也能够用来操作对象。</p><p>运算符重载的实质是编写以运算符作为名称的函数。不妨把这样的函数称为运算符函数。运算符函数的格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">返回值类型  <span class="keyword">operator</span>  运算符(形参表)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符可以是+、-、*、/等，必须是有效的C++运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值可以是一个引用，也可以是一个对象，但一定注意！！！，不要返回一个指向局部变量或临时对象的引用，因为函数执行完毕后，局部变量和临时对象将消失，引用将指向一个不存在的数据</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一个简单的重载+运算符*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="type">int</span> testData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> testData;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;testData = data;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Test <span class="keyword">operator</span>+(<span class="type">const</span> Test&amp; t)</span><br><span class="line">     &#123;</span><br><span class="line">         Test test;</span><br><span class="line">         test.testData = testData+t.testData;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> test;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Test t1,t2;</span><br><span class="line">    Test t3,t4;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">setData</span>(<span class="number">5</span>);</span><br><span class="line">    t2.<span class="built_in">setData</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    t3 = t1+t2;</span><br><span class="line"></span><br><span class="line">    t4 = t1.<span class="keyword">operator</span>+(t3);</span><br><span class="line">    <span class="comment">//t4 = t1+t2+t3 这是允许的，得出的结果相同</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t1:&quot;</span> &lt;&lt; t1.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t2:&quot;</span> &lt;&lt; t2.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t3:&quot;</span> &lt;&lt; t3.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t4:&quot;</span> &lt;&lt; t4.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：重载后的+号允许大于两个对象相加，如t4 = t1+ t2 + t3</span></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>该函数有两种调用方式</strong>：</p><ul><li>通过对象调用方法来调用，如上边的t4</li><li>直接通过重载的符号调用，如上方t1+t2</li></ul></div><h2 id="运算符重载限制">运算符重载限制:</h2><p>运算符重载规则，即允许重载的运算符，不允许重载的运算符见：</p><p><a href="https://blog.csdn.net/qq_72157449/article/details/128664136?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=c++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E9%99%90%E5%88%B6&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128664136.142%5Ev96%5Epc_search_result_base1&amp;spm=1018.2226.3001.4187">【⑤C++ | 运算符重载】意义 | 限制 | 方法 | 规则 | 特殊运算符重载 | 应用场景-CSDN博客</a></p><p>注：在 <strong>C++ 中，类型的名字（包括类的名字）本身也是一种运算符</strong>，即类型强制转换运算符。 类型强制转换运算符是单目运算符，也可以被重载，但只能重载为成员函数，不能重载为全局函数。</p><h1>类的继承</h1><h2 id="继承的定义">继承的定义</h2><p>定义：</p><p>继承(inheritance)机制是面向对象程序设计中使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能。这样产生的新类，称派生类（或子类），被继承的类称基类（或父类）。</p><p>继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。之前接触的复用都是函数复用，继承是类设计层次的复用。</p><h2 id="继承：is-a-关系">继承：is-a 关系</h2><p>因为派生类可以在基类上添加新特性，所以这种关系成为is-a-kind-of(是一种)关系更加准确，通常术语是is-a关系。例如：香蕉是一种水果</p><p>同时在指针指向的对象上面也有讲究：</p><ul><li>可以将基类指针指向派生类对象(多态性体现)</li><li>不能将派生类指针指向基类对象(不允许这样做)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span>:<span class="keyword">public</span> Fruit</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fruit *pFruit1 = <span class="keyword">new</span> <span class="built_in">Fruit</span>();<span class="comment">//正确</span></span><br><span class="line">    Fruit *pBanana = <span class="keyword">new</span> <span class="built_in">Banana</span>();<span class="comment">//正确，满足香蕉一种水果，水果包含香蕉的关系</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用基类指针引用派生类对象的能力允许多态性。在这种情况下，你可以通过基类指针调用基类的函数或访问基类的成员，而在运行时，将调用正确的派生类方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    Banana* pFruit2 = <span class="keyword">new</span> <span class="built_in">Fruit</span>();<span class="comment">//错误，水果不是一种香蕉，香蕉不包含水果，不允许这样做</span></span><br><span class="line">    Banana* pBanana1 =<span class="keyword">new</span> <span class="built_in">Banana</span>();<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承的格式">继承的格式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 新类的名字: 继承方式 继承类的名字</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一个简单的例子*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">people</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">people</span>(string name,<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:<span class="keyword">public</span> people</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> schoolnum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">student</span>(string name,<span class="type">int</span> age,<span class="type">int</span> schoolNum):<span class="built_in">people</span>(name,age)<span class="comment">//使用成员初始化列表语法,会先调用基类的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;schoolnum = schoolNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*上面的构造函数等价于</span></span><br><span class="line"><span class="comment">    student(string name,int age,int schoolnum)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        this-&gt;name = name;</span></span><br><span class="line"><span class="comment">        this-&gt;age = age;</span></span><br><span class="line"><span class="comment">        this-&gt;schoolnum = schoolnum;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    这两种方法都可以</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; endl &lt;&lt; age &lt;&lt; endl &lt;&lt; schoolnum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">student <span class="title">s</span><span class="params">(<span class="string">&quot;keqiudi&quot;</span>,<span class="number">18</span>,<span class="number">2022124018</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>在继承的时候可以使用类名加上作用域解析符(:)来调用基类的方法，通常在私有继承中使用，第二种便是使用this指针调用继承过来的基类的方法</strong></p></div><p>更多详细内容学习：</p><p><a href="https://blog.csdn.net/qq_62718027/article/details/125922249?ops_request_misc=%7B%22request%5Fid%22%3A%22170126212316800222846414%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170126212316800222846414&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-125922249-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=C%2B%2B%E7%B1%BB%E7%BB%A7%E6%89%BF&amp;spm=1018.2226.3001.4187">c++：继承（超详解）</a></p><h2 id="继承的总结：">继承的总结：</h2><ol><li>基类private成员无论以什么方式继承到派生类中都是不可见的。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它。</li><li>基类private成员在派生类中不能被访问，如果基类成员不想在派生类外直接被访问，但需要在派生类中访问，就定义为protected。可以看出保护成员限定符是因继承才出现的。</li><li>基类的私有成员在子类都是不可见；基类的其他成员在子类的访问方式就是访问限定符和继承方式中权限更小的那个（权限排序：public&gt;protected&gt;private）。</li><li>使用关键字class时<strong>默认的继承方式是private</strong>，使用struct时默认的继承方式是public，但最好显式地写出继承方式。</li></ol><h2 id="多态公有继承">多态公有继承</h2><p>简单来说就是一个方法的行文随上下文而异，有两种重要机制可用于实现多态的公有继承</p><ol><li>在派生类中重新定义基类的方法</li><li>使用虚方法</li></ol><h3 id="虚方法">虚方法</h3><ul><li>关键词：virtual</li><li>在基类中将<strong>派生类会重新定义的方法</strong>声明为虚方法。使用了virtual，程序将根据<strong>引用或指针指向的对象</strong>的类型来选择方法，而未使用时程序将仅仅根据<strong>引用或指针的类型</strong>来选择方法，与<strong>多态性</strong>紧密相关。</li><li>virtual关键词只用于类声明的方法原型中，而不用于类方法实现中</li><li>派生类中覆盖的方法后要加上override标注</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//brass.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BRASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BRASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string fullName; <span class="comment">//客户姓名</span></span><br><span class="line"><span class="type">long</span> acctNum; <span class="comment">//账号</span></span><br><span class="line"><span class="type">double</span> balance; <span class="comment">//当前结余</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Brass</span>(<span class="type">const</span> string &amp;s = <span class="string">&quot;Nullbody&quot;</span>, <span class="type">long</span> an = <span class="number">-1</span>, <span class="type">double</span> bal = <span class="number">0.0</span>); <span class="comment">//创建账户</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Deposit</span><span class="params">(<span class="type">double</span> amt)</span></span>; <span class="comment">//存款</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span>; <span class="comment">//取款</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Balance</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//显示账户信息</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//显示</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Brass</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrassPlus</span> : <span class="keyword">public</span> Brass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> maxLoan; <span class="comment">//透支上限</span></span><br><span class="line"><span class="type">double</span> rate; <span class="comment">//透支贷款利率</span></span><br><span class="line"><span class="type">double</span> owesBank; <span class="comment">//当前的透支总额</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BrassPlus</span>(<span class="type">const</span> string &amp;s = <span class="string">&quot;Nullbody&quot;</span>, <span class="type">long</span> an = <span class="number">-1</span>, <span class="type">double</span> bal = <span class="number">0.0</span>, <span class="type">double</span> m1 = <span class="number">500</span>, <span class="type">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line"><span class="built_in">BrassPlus</span>(<span class="type">const</span> Brass &amp;ba, <span class="type">double</span> m1 = <span class="number">500</span>, <span class="type">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//覆盖基类实现，函数重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span> <span class="keyword">override</span></span>; <span class="comment">//覆盖基类实现，函数重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResetMax</span><span class="params">(<span class="type">double</span> m)</span> </span>&#123; maxLoan = m; &#125; <span class="comment">//透支上限</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResetRate</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123; rate = r; &#125; <span class="comment">//透支贷款利率</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResetOwes</span><span class="params">()</span> </span>&#123; owesBank = <span class="number">0</span>; &#125; <span class="comment">//当前透支总额</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设计的Brass基类指针既可以指向Brass对象，也可以指向BrassPlus对象，因此可以使用一个数组来表示多种类型的对象，这就是多态性。下面在一个数组中可以很清楚的看清virtual的作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> CLIENTS = <span class="number">2</span>;</span><br><span class="line">Brass *clients[CLIENTS];<span class="comment">//Brass类型的指针</span></span><br><span class="line">clients[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">Brass</span>(<span class="string">&quot;Test0&quot;</span>, <span class="number">1234</span>, <span class="number">1234.56</span>);<span class="comment">//指向Brass类型对象</span></span><br><span class="line">clients[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">BrassPlus</span>(<span class="string">&quot;Test1&quot;</span>, <span class="number">5678</span>, <span class="number">5678.91</span>);<span class="comment">//指向BrassPlus类型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; CLIENTS;++i)</span><br><span class="line">&#123;</span><br><span class="line">    clients[i]-&gt;<span class="built_in">ViewAcct</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>多态性说明</strong>：</p><ul><li>假如ViewAcct()是使用关键字virtual声明</li></ul><p>如果数组成员(指针)指向的是Brass对象，则调用的是Brass::ViewAcct()。<br>如果数组成员(指针)指向的是BrassPlus对象，则调用的是BrassPlus::ViewAcct()。</p><ul><li>假如ViewAcct()不是虚方法</li></ul><p>则在任何情况下都将调用Brass::ViewAcct()。</p><h3 id="虚析构函数">虚析构函数</h3><p>基类要声明一个虚析构函数，为了确保释放派生类对象时，按正确的顺序调用析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string fullName; <span class="comment">//客户姓名</span></span><br><span class="line"><span class="type">long</span> acctNum; <span class="comment">//账号</span></span><br><span class="line"><span class="type">double</span> balance; <span class="comment">//当前结余</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Brass</span>() &#123;&#125; <span class="comment">//这是虚析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>为何使用虚析构函数</strong>：</p><ul><li>如果析构函数不是虚方法，则将只调用对应于指针类型的析构函数。对于Brass * 指针将只调用Brass基类的析构函数，即使Brass * 指针指向的是BrassPlus对象。</li><li>如果析构函数是虚方法，将调用相应的指向对象类型的析构函数。即如果指针指向的是Brass对象，将调用Brass对象的析构函数，如果指针指向的是BrassPlus对象，将调用BrassPlus的析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以确保正确的析构函数序列被调用。</li><li>如果BrassPlus包含一个执行某些操作的析构函数，则Brass必须有一个虚析构函数，即使Brass的析构函数不执行任何操作。</li></ul></div><h2 id="静态联编和动态联编">静态联编和动态联编</h2><p><strong>静态联编</strong>：静态联编是指联编工作在<strong>编译阶段完成的</strong>，联编过程是在程序运行之前完成。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，静态联编对函数的选择是<strong>基于指向对象的指针或者引用的类型</strong>。其优点是<strong>效率高，但灵活性差</strong>，也因此作为C++默认联编选择。</p><p><strong>动态联编</strong>：动态联编是指联编在<strong>程序运行时动态地进行</strong>，根据当时的情况来确定调用哪个同名函数，实际上是在运行时是<strong>虚函数的实现</strong>。动态联编对成员函数的选择是基于<strong>对象的类型</strong>，针对不同的对象类型将做出不同的编译结果。C++中一般情况下的联编是静态联编，但是当涉及到<strong>多态性和虚函数时应该使用动态联编</strong>。动态联编的优点是<strong>灵活性强，但效率低</strong>。</p><p>动态联编规定：只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式为：指向基类的指针变量名-&gt;虚函数名（实参表）或基类对象的引用名.虚函数名（实参表）</p><ul><li>编译器对<strong>非虚方法</strong>使用<strong>静态联编</strong></li><li>编译器对<strong>虚方法</strong>使用<strong>动态联编</strong></li></ul><hr><p><strong>实现动态联编需要同时满足以下三个条件：</strong></p><p>①  必须把动态联编的行为定义为类的虚函数。</p><p>②  类之间应满足子类型关系，通常表现为一个类从另一个类公有派生而来。</p><p>③  必须先使用基类指针指向子类型的对象，然后直接或者间接使用基类指针调用虚函数</p><p><strong>总结</strong>：</p><p>大多数情况下，动态联编很好，因为他让程序能够选择特定类型设计的方法。<strong>虚函数是实现多态的基础，是实现动态联编的必要条件之一</strong>。动态联编要靠虚函数来实现，虚函数要靠动态联编的支持。两者相辅相成，缺一不可。</p><h2 id="初始化列表">初始化列表</h2><h3 id="概念">概念</h3><p>当在C++中定义类的构造函数时，可以使用初始化列表来初始化类的成员变量。初始化列表是在构造函数的参数列表后面使用冒号(:)分隔开来的一组初始化语句,多个参数初始化使用逗号隔开，用于初始化类的成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*初始化列表写法*/</span></span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> value,<span class="type">double</span> values):<span class="built_in">data</span>(value),<span class="built_in">datas</span>(values)<span class="comment">//这里的冒号及冒号右边的部分就是构造函数的初始化列表,逗号隔开</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*函数体内写法*/</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value,<span class="type">double</span> values)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;</span><br><span class="line">        <span class="type">double</span> = datas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">    <span class="type">double</span> datas;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意</strong>：</p><ul><li>对于<strong>继承的对象</strong>，构造函数在成员初始化列表中使用基类名来调用特定的基类构造函数。</li><li>对于<strong>成员对象</strong>，构造函数则使用成员名。</li></ul></div><h3 id="什么时候必须使用">什么时候必须使用</h3><ol><li><strong>在成员变量为引用类型时</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> &amp;data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value):<span class="built_in">data</span>(value)<span class="comment">//正确</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;<span class="comment">//会报错引用类型不允许这样做,只能使用初始化列表(上面的方式初始化)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>在成员变量为const时</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value):<span class="built_in">data</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="built_in">A</span>(<span class="type">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;<span class="comment">//会报错const类型不允许这样做,只能使用初始化列表(上面的方式初始化)</span></span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="建议使用的地方">建议使用的地方</h3><ul><li>初始化基类部分</li></ul><p>在派生类构造函数中使用初始化列表法初始基类的变量，可以避免在函数体中进行额外的赋值操作提高效率，同时提高可读性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*对于成员对象使用成员名初始化列表*/</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> value)</span>:data(value)//这里的冒号及冒号右边的部分就是构造函数的初始化列表,逗号隔开</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> datas;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*对于继承的对象，使用基类名初始化列表，调用基类构造函数初始化基类部分*/</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> value,<span class="type">double</span> values):<span class="built_in">A</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        datas = values; <span class="comment">//正常的在函数体内初始化派生类部分,更清晰表明继承关系，这个地方也可以在上面使用初始化列表方式为datas赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><p>建议尽可能使用初始化列表法来初始化构造函数中的成员变量，但并非所有情况都必须使用初始化列表。</p><p>一般来说，以下情况建议使用初始化列表法：</p><ol><li><strong>初始化成员变量</strong>：如果构造函数需要初始化类的成员变量,但此时类的结构和逻辑不是很复杂时，使用初始化列表是最清晰和高效的方式。</li><li><strong>初始化基类部分</strong>：在派生类的构造函数中调用基类的构造函数时，应该使用初始化列表来确保基类部分被正确地初始化。</li><li><strong>初始化const和引用类型成员变量</strong>：const和引用类型的成员变量只能在初始化列表中进行初始化，无法在构造函数体内进行赋值。</li><li><strong>初始化具有复杂初始化逻辑的成员变量</strong>：如果某个成员变量的初始化逻辑比较复杂，使用初始化列表可以将初始化逻辑集中在一起，提高代码的可读性。</li></ol><p>但也有一些情况可以在构造函数体内进行初始化，例如：</p><ol><li><strong>运行时条件决定的初始化</strong>：如果某些成员变量的初始化取决于运行时条件，可能需要在构造函数体内进行初始化。</li><li><strong>需要在构造函数体内执行额外逻辑</strong>：如果构造函数需要执行一些额外的逻辑操作，可以在构造函数体内进行初始化。</li></ol><h3 id="优点和缺点">优点和缺点</h3><p><strong>优点</strong>:</p><ol><li>(涉及含有类成员时)<strong>效率高</strong>: 使用初始化列表可以直接对成员变量进行初始化，而不需要先调用默认构造函数再进行赋值操作，从而提高了代码的执行效率。基本类型时效率与在函数体中差不多</li><li><strong>确保成员变量的初始化</strong>: 使用初始化列表可以确保所有成员变量在对象构造时立即得到正确的初始化，避免了可能出现的未初始化的情况。</li><li><strong>处理const和引用类型成员变量</strong>: 对于const成员变量和引用类型成员变量，只能在初始化列表中进行初始化，因为它们不能在构造函数体内被赋值。</li><li><strong>清晰明了</strong>: 初始化列表将所有初始化操作集中在一起，使代码更加清晰易读，便于理解和维护</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>可读性差</strong>: 对于复杂的类结构和初始化逻辑，初始化列表可能会使代码变得复杂和难以理解，降低了可读性。</li><li><strong>限制较多</strong>: 有些情况下，无法在初始化列表中初始化所有的成员变量，例如需要在构造函数体内进行逻辑判断后再进行初始化的情况。</li><li><strong>容易遗忘</strong>: 在添加新成员变量时，容易忘记在初始化列表中添加相应的初始化操作，导致未初始化的错误。</li></ol><h2 id="使用using-重新定义访问权限">使用using 重新定义访问权限</h2><p>使用<strong>保护派生或私有派生</strong>时，基类的公有成员将成为保护成员或私有成员。假设要让基类的方法在派生类外面可用，可以在派生类的public成员中使用using声明指出派生类可以使用特定的基类成员，就像using指定的成员或函数是派生类的公有方法一样，即使采用的是私有派生。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一个简单的例子*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">people</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">people</span>(string name,<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>: <span class="keyword">private</span> people<span class="comment">//私有派生</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> schoolnum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> people::showName;<span class="comment">//使用using定义重新定义访问权限</span></span><br><span class="line">    <span class="keyword">using</span> people::name;<span class="comment">//使用using定义重新定义访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">student</span>(string name,<span class="type">int</span> age,<span class="type">int</span> schoolNum):<span class="built_in">people</span>(name,age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;schoolnum = schoolNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">student <span class="title">s</span><span class="params">(<span class="string">&quot;keqiudi&quot;</span>,<span class="number">18</span>,<span class="number">2022124018</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">showName</span>();<span class="comment">//正确，使用了using可以在派生类外调用</span></span><br><span class="line">    cout &lt;&lt; s.name &lt;&lt; endl;<span class="comment">//正确，使用了using可以在派生类外调用</span></span><br><span class="line">    cout &lt;&lt; s.age &lt;&lt; endl;<span class="comment">//报错，未使用using，继承后为派生类private成员不可以直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多重继承">多重继承</h2><h3 id="定义">定义</h3><p>派生类都只有一个基类，称为单继承。除此之外，C++也支持多继承，即一个派生类可以有两个或多个基类。<br>多继承的语法也很简单，将多个基类用逗号隔开。</p><p>如已声明了类A、类B和类C，那么可以这样来声明派生类D：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A, <span class="keyword">private</span> B, <span class="keyword">protected</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//类D新增加的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数-2">构造函数</h3><p>与单继承形式基本相同，只是在派生类的构造函数中调用多个基类的构造函数。<br>以上面的 A、B、C、D 类为例，D 类构造函数的写法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">D</span>(形参列表): <span class="built_in">A</span>(实参列表), <span class="built_in">B</span>(实参列表), <span class="built_in">C</span>(实参列表)<span class="comment">//使用初始化列表写法调用基类构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二义性">二义性</h3><p>当两个或多个基类有同名成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员。这个时候需要在<strong>名字前面加上类名和域解析符::</strong>，以显示地指明到底使用哪个类的成员，消除二义性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseA</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">BaseA</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BaseA</span>(<span class="type">int</span> value):_value(value)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseA::_value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseB</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">BaseB</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BaseB</span>(<span class="type">int</span> value):_value(value)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseB::_value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> BaseA, <span class="keyword">public</span> BaseB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Derived</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> valueA, <span class="type">int</span> valueB):<span class="built_in">BaseA</span>(valueA), <span class="built_in">BaseB</span>(valueB)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseA::_value: &quot;</span> &lt;&lt; BaseA::_value &lt;&lt; endl;<span class="comment">//使用::指明基类BaseA的value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseB::_value: &quot;</span> &lt;&lt; BaseB::_value &lt;&lt; endl;<span class="comment">//使用::指明基类BaseB的value</span></span><br><span class="line">        BaseA::<span class="built_in">showValue</span>();<span class="comment">//使用::指明调用基类BaseA的方法</span></span><br><span class="line">        BaseB::<span class="built_in">showValue</span>();<span class="comment">//使用::指明调用基类BaseB的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    d.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>模板</h1><h2 id="类模板">类模板</h2><p>在C++中，<strong>模板类</strong>是一种用于创建通用数据结构或算法的强大工具。模板类允许您编写一次代码，然后在不同数据类型上重复使用它，例如有两个或多个类，其功能是相同的，仅仅是数据类型不同时使用，<strong>以提高代码的可重用性和灵活性</strong>。</p><p>模板类允许您定义一种通用的类模板，其中某些成员或函数可以根据不同进行参数化。它们使用template关键字定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,....&gt;</span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;</span><br><span class="line">类的定义;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>typename</code>表明其后面的符号是一种数据类型，可以用<code>class</code>代替</li><li><code>T</code>是通用的数据类型，名称可以替换，通常为大写字母</li><li>函数模板建议用 <code>typename</code> 描述通用数据类型，类模板建议用 <code>class</code></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">nameType</span>,<span class="keyword">class</span> <span class="title class_">ageType</span>&gt;<span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    nameType name;</span><br><span class="line">    ageType age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(nameType name,ageType age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">student</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    student.<span class="built_in">showPerson</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数模板">函数模板</h2><p>函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能，提高了程序的可重用性。</p><p>C++ 语言支持模板。有了模板，例如可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。</p><p><strong>写法</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span>,<span class="keyword">typename</span> 类型参数<span class="number">2</span>, ...&gt;</span><br><span class="line">返回值类型  模板名(形参表)</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*typename可以使用class替换*/</span></span><br></pre></td></tr></table></figure><p><strong>一个简单的示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp; x, T &amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>, m = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(n, m);  <span class="comment">//编译器自动生成 void Swap (int &amp;, int &amp;)函数</span></span><br><span class="line">    <span class="type">double</span> f = <span class="number">1.2</span>, g = <span class="number">2.3</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(f, g);  <span class="comment">//编译器自动生成 void Swap (double &amp;, double &amp;)函数</span></span><br><span class="line">    string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(s1, s2);  <span class="comment">//编译器自动生成 void Swap (string &amp;, string &amp;)函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类模板与函数模板区别">类模板与函数模板区别</h2><ol><li><strong>应用对象</strong>：<ul><li><strong>函数模板</strong>主要用于生成通用函数，可以用于不同类型的参数。它通过在函数定义中使用模板来实现，允许编写一次通用的函数代码，用于多种数据类型。</li><li><strong>类模板</strong>主要用于生成通用类，可以包含不同类型的成员变量或成员函数。它通过在类定义中使用模板来实现，允许创建一种通用的类形式，适用于多种数据类型。</li></ul></li><li><strong>自动类型推导的使用方式</strong>：<ul><li><strong>函数模板</strong>在调用时支持自动类型推导，允许省略模板参数，由编译器根据实参类型自动推导出模板参数的类型。</li><li><strong>类模板</strong>在实例化时需要显式指定模板参数，没有像函数模板那样的自动类型推导。每次实例化都需要<strong>明确指定模板参数</strong>。</li></ul></li><li><strong>默认参数</strong>：<ul><li><strong>函数模板</strong>和<strong>类模板</strong>都支持默认参数。在模板参数列表中可以为某些模板参数设置默认值，使得在使用时可以不必每次都指定这些参数。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板与函数模板的区别</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; <span class="comment">//指定默认参数</span></span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NameType m_Name;</span><br><span class="line">AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Person p(&quot;孙悟空&quot;, 1000);错误的，类模板无法用自动类型推导</span></span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;keqiudi&quot;</span>, <span class="number">19</span>);<span class="comment">//正确，只能用显式指定类型推导</span></span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string&gt;<span class="built_in">p</span>(<span class="string">&quot;keqiudi&quot;</span>, <span class="number">19</span>); <span class="comment">//类模板在参数列表中有默认参数</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类模板成员函数实现">类模板成员函数实现</h2><p>在类<strong>内部定义成员函数</strong>可以更简洁，因为不需<strong>要再次指定模板参数</strong>。类内部的成员函数定义可以直接使用类模板的模板参数，而在<strong>外部定义时需要重新指定一次</strong>。</p><p>总体来说，选择在类内部还是类外部定义成员函数取决于项目的需求和组织代码的风格。一般而言，对于简单、短小的成员函数，可以选择在类内部定义；而对于复杂或长的成员函数，以及避免头文件的多次包含导致的重定义错误，通常建议在类外部定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板成员类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"><span class="comment">/*内部定义&#123;</span></span><br><span class="line"><span class="comment">this-&gt;m_Name = name;</span></span><br><span class="line"><span class="comment">this-&gt;m_Age = age;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*内部定义&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造函数的类外实现，每个函数都要重新指定模板参数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="comment">//要点1：每个函数前加上template&lt;&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)<span class="comment">//要点2:类名指出模板参数再进行解析(::)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*成员函数的类外实现，每个函数都要重新指定模板参数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">30</span>);</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="成员模板">成员模板</h2><p>模板可用作结构、类或模板类的成员。要完全实现STL(标准模板库)，必须使用这个特性</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">beta</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;<span class="comment">//模板成员</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">hold</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">         V val;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">hold</span>(V v=<span class="number">0</span>):<span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>&#123;cout &lt;&lt; val &lt;&lt; endl;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">V <span class="title">Value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    hold&lt;T&gt; q; <span class="comment">//模板类中的模板对象,传入的模板参数为T，即外部模板类想通过的模板参数</span></span><br><span class="line">    hold&lt;<span class="type">int</span>&gt; n;<span class="comment">//模板对象</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">beta</span>(T t,<span class="type">int</span> i):<span class="built_in">q</span>(t),<span class="built_in">n</span>(i)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;<span class="comment">//模板函数做成员</span></span><br><span class="line">    <span class="function">U <span class="title">blab</span><span class="params">(U u,T t)</span></span>&#123;<span class="keyword">return</span> (n.<span class="built_in">Value</span>()+q.<span class="built_in">Value</span>()*u/t);&#125; </span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span>&#123; q.<span class="built_in">show</span>(); n.<span class="built_in">show</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">beta&lt;<span class="type">double</span>&gt; <span class="title">guy</span><span class="params">(<span class="number">3.5</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T被设置为double\n&quot;</span>;</span><br><span class="line">    guy.<span class="built_in">Show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;V被设置为T,即double，第二个V被设置为int\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; guy.<span class="built_in">blab</span>(<span class="number">10</span>,<span class="number">2.3</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;U被设置为int\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; guy.<span class="built_in">blab</span>(<span class="number">10.0</span>,<span class="number">2.3</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;U被设置为double\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类模板对象做函数参数">类模板对象做函数参数</h2><p>一共有三种传入方式：</p><ol><li>指定传入的类型：直接显示对象的数据类型，此时模板对象必须含有模板类的参数</li><li>参数模板化：将对象中的参数变为模板进行传递</li><li>整个类模板化：将这个对象类型模板化进行传递</li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板对象做函数参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(T1 name,T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">199</span>);</span><br><span class="line"><span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 2、参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T1的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T2的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line"><span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">60</span>);</span><br><span class="line"><span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="将模板做模板类参数">将模板做模板类参数</h2><p>模板可以包含类型参数(如typename T)和非类型参数(如 int n)。模板还可以本身就是模板的参数，这种参数是模板类新增的特性，用于实现STL。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Thing</span>&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *模板参数是template &lt;typename T&gt; class Thing，其中template &lt;typename T&gt; class 是类型，Thing是参数。</span></span><br><span class="line"><span class="comment"> 假设有Crab&lt;King&gt; legs;</span></span><br><span class="line"><span class="comment"> 那么King必须是一个模板类，其声明与模板参数Thing的声明匹配；</span></span><br><span class="line"><span class="comment"> 即：</span></span><br><span class="line"><span class="comment"> template&lt;class T&gt;</span></span><br><span class="line"><span class="comment"> class King&#123;...&#125;</span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Crab</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Thing&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    Thing&lt;<span class="type">double</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设有如下声明</span></span><br><span class="line">Crab&lt;Stack&gt;stack;</span><br><span class="line"><span class="comment">//成员函数Thing&lt;int&gt;就被替换为Stack&lt;int&gt;,Thing&lt;double&gt;替换为Stack&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *总之模板参数Thing将被替换为声明Crab对象时被用作模板参数的模板类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="类模板与继承">类模板与继承</h2><p>当类模板碰到继承时，需要注意以下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中<code>T</code>的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中<code>T</code>的类型，子类也需为类模板</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板与继承</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son: public Base //错误，必须要知道父类中的T类型，才能继承给子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想灵活指定父类中T的类型，子类也需要变成类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son2</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T1的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T2的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">T1 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2&lt;<span class="type">int</span>,<span class="type">char</span>&gt; s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模板类和友元">模板类和友元</h2><p>模板类声明也可以有友元。模板的友元分为3类：</p><ol><li><p>非模板友元</p></li><li><p>约束(bound)模板友元，即友元的类型取决于类被实例化时的类型；</p></li><li><p>非约束(unbound)模板友元，即友元的所有具体化都是类的每一个具体化的友元</p></li></ol><ul><li><p>非模板友元</p><p>在模板类中将一个常规函数声明为友元</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasFriend</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">int</span>&gt;&amp; hf)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">double</span>&gt;&amp; hf)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *上述声明使counts()函数成为模板所有实例化的友元,例如是HasFriend&lt;int&gt;和HasFriend&lt;string&gt;的友元</span></span><br><span class="line"><span class="comment"> *report()函数也是，只不过接受一个模板类参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">int</span>&gt;&amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">double</span>&gt;&amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>约束模板友元</li></ul><p>​修改前一个示例，使友元函数本身成为模板，即使类的每一个具体化都获得与友元匹配的具体化，一共包含3步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一步，在类定义前面声明每个模板函数*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(T&amp; t)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*第二步，在类中将模板声明为友元，这些语句根据类模板参数的类型声明具体化*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">class</span> TT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> HasFriendT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">counts</span>&lt;TT&gt;();</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> report&lt;&gt;(HasFriendT&lt;TT&gt; &amp; tt);</span><br><span class="line">        <span class="comment">//或使用friend void report&lt;HasFriendT&lt;TT&gt;&gt;(HasFriendT&lt;TT&gt; &amp; tt);</span></span><br><span class="line">    <span class="comment">//声明中的&lt;&gt;指出这是模板具体化，&lt;&gt;可以为空，因为可以从函数参数推断出模板类型参数</span></span><br><span class="line">    <span class="comment">//但counts()没有参数，因此必须使用模板参数语法(&lt;TT&gt;)来指明其具体化,TT为HasFriendT类的类模板参数类型</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三步，为友元函数提供定义*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(T &amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非约束模板友元</li></ul><p>每个函数<strong>具体化</strong>都是每个类<strong>具体化</strong>的友元，<strong>友元模板类型参数与模板类类型参数不同</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ManyFriend</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T item</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">ManyFriend</span>(<span class="type">const</span> T&amp; i):<span class="built_in">item</span>(i)&#123;&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C,<span class="keyword">typename</span> D&gt;</span><br><span class="line">      <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show2</span><span class="params">(C&amp; c,D&amp; d)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C,<span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show2</span><span class="params">(C&amp; c,D&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; c.item &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; d.item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类模板成员函数创建时机">类模板成员函数创建时机</h2><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>对于类模板的成员函数在使用时进行实例化。当你使用特定类型实例化类模板对象时，编译器会生成该类型的成员函数实现。</li><li>对于普通类，所有的成员函数都在编译时就被实例化了。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*故可以做到以下的操作*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数的创建时机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中的成员函数在调用的时候才创建，所以不会报错</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">obj.<span class="built_in">showPerson1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">obj.<span class="built_in">showPerson2</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Myclass&lt;Person1&gt;m;</span><br><span class="line">m.<span class="built_in">func1</span>();</span><br><span class="line"><span class="comment">//m.func2(); 此时模板参数传递为Person1故无法调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类模板分文件编写-重要">类模板分文件编写(重要)</h2><p>如果工程中需要利用多个类模板，那么将这些类模板都写在同一个文件中将会导致代码可读性变差，所以有必要对类模板进行分文件编写，但是类模板的分文件编写面临着一些问题，以下是类模板分文件编写面临的问题及解决方法。</p><p><strong>问题</strong>：模板的特性导致了编译器对模板的实例化是在链接阶段进行的，而编译器需要在链接时找到模板的定义，当模板类的定义放在.h文件模板类实现放在.cpp文件，会出现链接失败情况，找不到定义。</p><p><strong>解决方法</strong>：</p><ul><li>直接包含<code>.cpp</code>源文件（不常用因为.cpp风格不好一般用.hpp文件）</li><li>将声明和实现写到同一个文件中，并更改后缀名为<code>.hpp</code></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>.hpp</code> 文件通常用来包含 C++ 的头文件，其中包含类声明、函数原型、模板定义等。这种文件扩展名的选择<strong>是一种约定</strong>，用于表示这个头文件中包含一些声明与实现在一起，比如模板类</p><p>一般来说，<code>.hpp</code> 文件和 <code>.h</code> 文件在功能上是相似的，都用于包含头文件，但 <code>.hpp</code> 文件更常见于 C++ 项目中，尤其是涉及到类和模板的情况。</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编写的templatePerson.hpp文件，模板类的定义和实现放在一个文件中*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.cpp文件内容*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;templatePerson.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模板别名-C-11">模板别名(C++11)</h2><p>如果能为类型指定别名，将很方便，在模板设计中尤其如此，可以使用typedef为模板具体化指定别名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">double</span>,12&gt;arrd;</span><br><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">int</span>,12&gt;arri;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>C++11新增了一项功能——使用(using)为模板提供一系列别名，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> arrtype = std::array&lt;T,<span class="number">12</span>&gt;;</span><br><span class="line"><span class="comment">//使用using将arrtype定义为一个模板别名，arrtype&lt;T&gt;表示类型std::array&lt;T,12&gt;。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arrtype&lt;<span class="type">double</span>&gt; gallons;<span class="comment">//等价于 std::array&lt;double,12&gt;</span></span><br><span class="line">arrtype&lt;<span class="type">int</span>&gt; days;<span class="comment">//与上面相同</span></span><br><span class="line">arrtype&lt;std::string&gt; months</span><br></pre></td></tr></table></figure><p>C++11 允许将语法using = 用于非模板。用于非模板时语法与常规typedef等价：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span>* pc1;</span><br><span class="line"><span class="keyword">using</span> pc2 = <span class="type">const</span> <span class="type">char</span>*;<span class="comment">//与上方等价</span></span><br></pre></td></tr></table></figure><p><strong>好处</strong>：</p><ul><li>使用模板别名可以提高代码的可读性，特别是在涉及复杂模板或需要引入特定模板类型时。</li><li>模板别名还可以使代码更易于维护，因为你只需要在一个地方修改模板类型或表达式，而无需修改多处使用的地方。</li></ul><h1>友元</h1><p>在C++中，友元类和友元函数是用来在类之间建立友好关系的机制，允许一个类的成员访问另一个类的私有成员。这样可以增加程序的灵活性和封装性。</p><p>虽然友元提供了灵活性，但过度使用友元可能会破坏封装性，因此应该谨慎使用。友元应该只在确实需要访问私有成员的情况下使用，以保持代码的清晰性和可维护性。</p><h2 id="友元函数">友元函数</h2><ul><li><strong>作用</strong>： <strong>允许一个非成员函数访问类的私有成员。</strong></li><li><strong>用法</strong>： 可以在类的声明中使用<code>friend</code>关键字声明友元函数，然后在类外定义这个函数。</li><li><strong>示例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span>:myData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">showMyData</span><span class="params">(<span class="type">const</span> Myclass&amp; myclass)</span></span>;<span class="comment">//友元函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元函数类外定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMyData</span><span class="params">(<span class="type">const</span> Myclass&amp; myclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myData = &quot;</span> &lt;&lt; myclass.myData &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//友元函数可以访问私有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showMyData</span>(myclass);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元类">友元类</h2><ul><li><strong>作用</strong>： <strong>允许一个类的所有成员函数访问另一个类的私有成员</strong>。</li><li><strong>用法</strong>：在类的声明中使用<code>friend</code>关键字声明<strong>友元类</strong>。</li><li><strong>示例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> friendData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FriendClass</span><span class="params">(<span class="type">int</span> data)</span>:friendData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">FriendClass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Myclass</span>;<span class="comment">//指定Myclass为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span>:myData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;FriendClass data is: &quot;</span> &lt;&lt; friendclass.friendData &lt;&lt; endl;<span class="comment">//友元类的成员函数直接访问另一个类的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">FriendClass <span class="title">friendclass</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">   <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   myclass.<span class="built_in">showFriendData</span>(friendclass);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元成员函数">友元成员函数</h2><ul><li><strong>作用</strong>： <strong>允许一个类的某一个成员函数访问另一个类的私有成员</strong>。</li><li><strong>用法</strong>：在类的声明中使用<code>friend</code>关键字声明<strong>友元</strong>。</li><li><strong>示例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明FriendClass，以便在Myclass中声明友元关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span> : myData(data) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明Myclass的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> friendData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FriendClass</span><span class="params">(<span class="type">int</span> data)</span> : friendData(data) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">FriendClass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数的声明，在FriendClass中声明，使Myclass的showFriendData作为FriendClass类的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Myclass::showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Myclass的成员函数因为是FriendClass的友元，所以定义必须在类外，用于访问FriendClass的私有成员，</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myclass::showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FriendClass data is: &quot;</span> &lt;&lt; friendclass.friendData &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Myclass data is: &quot;</span> &lt;&lt; myData &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FriendClass <span class="title">friendclass</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    myclass.<span class="built_in">showFriendData</span>(friendclass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="友元的优缺点">友元的优缺点</h2><p><strong>优点：</strong></p><ol><li><strong>灵活性：</strong> 友元机制允许在类之间建立友好关系，使得某个函数或类可以访问其他类的私有成员，提高了灵活性。</li><li><strong>特定需求的访问权限：</strong> 有时候，为了实现特定的功能，需要某些函数或类能够直接访问其他类的私有成员，友元机制提供了一种选择。</li><li><strong>效率：</strong> 有时候使用友元可以避免通过公有接口的方式(比如get方法等等)进行多次函数调用，提高代码执行效率。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>破坏封装性：</strong> 友元可以直接访问类的私有成员，这可能破坏类的封装性，增加了代码的耦合性，增加了维护的难度。</li><li><strong>复杂性增加：</strong> 过度使用友元可能导致代码更加复杂，使得程序难以理解和维护。</li><li><strong>设计问题：</strong> 有时候需要重新考虑设计，以避免对友元的过度依赖。可能存在更好的设计模式或方法，不需要使用友元。</li></ol><h1>嵌套类</h1><h2 id="概念-2">概念</h2><p>在C++中，嵌套类是一个类被定义在另一个类的内部的情况。被嵌套的类称为内部类或嵌套类，而包含这个内部类的类称为外部类。嵌套类可以具有私有、受保护或公有的访问权限，这取决于它在外部类中的声明方式。包含类的成员函数可以创建和使用被嵌套类的对象；而仅当声明位于公有部分时，才能在包含类的外面使用嵌套类，而且必须使用作用域解析运算符(旧版本的C++不允许嵌套类或无法完全实现这种概念)</p><p><strong>一个示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内部类 Point 表示二维平面上的点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Point</span>(<span class="type">int</span> xCoord, <span class="type">int</span> yCoord) : <span class="built_in">x</span>(xCoord), <span class="built_in">y</span>(yCoord) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部类的成员函数</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Point: (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Point center; <span class="comment">// Shape 类包含 Point 类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Shape 类的构造函数</span></span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">int</span> centerX, <span class="type">int</span> centerY) : <span class="built_in">center</span>(centerX, centerY) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shape 类的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayShape</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shape with center at &quot;</span>;</span><br><span class="line">        center.<span class="built_in">display</span>(); <span class="comment">// 调用内部类的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Shape 类对象</span></span><br><span class="line">    <span class="function">Shape <span class="title">myShape</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Shape 类的成员函数</span></span><br><span class="line">    myShape.<span class="built_in">displayShape</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作用">作用</h2><p>嵌套类的主要作用之一是组织和封装代码，使代码更为模块化、清晰和可读。以下是嵌套类的一些主要作用：</p><ol><li><strong>封装实现细节：</strong> 嵌套类允许将一个类的一部分实现细节封装在另一个类中，从而隐藏一些具体的实现细节，提高封装性。外部类可以更专注于公共接口，而具体的实现则留给内部类。</li><li><strong>组织相关的类：</strong> 当两个类有密切关联时，将它们组织在一起可以形成更清晰的结构。嵌套类可以在逻辑上将这些关联的类放在同一个地方，方便代码的组织和维护。</li><li><strong>限制访问权限：</strong> 内部类可以访问外部类的私有成员，但外部类不能直接访问内部类的私有成员。这种特性可以用于在设计中划分不同层次的访问权限，使得代码更安全。</li><li><strong>实现接口与实现分离：</strong> 将接口和实现分离，可以通过内部类隐藏一些实现细节。外部类可以专注于公共接口，而具体的实现细节则留给内部类。</li><li><strong>增加代码的模块化：</strong> 将相关的类组织在一起可以使代码更模块化。每个嵌套类可以有自己的职责，这样代码更易于理解和维护。</li></ol><h2 id="访问控制">访问控制</h2><ol><li><p><strong>公有嵌套类</strong>： 如果内部类声明为<code>public</code>，则外部类的任何成员函数、友元或其他类都可以访问内部类。这使得内部类对外可见，允许外部代码直接访问它。</p></li><li><p><strong>私有嵌套类</strong>：如果内部类声明为<code>private</code>，则只有外部类的成员函数和友元可以访问内部类。外部类的客户端无法直接访问或创建内部类的对象。</p></li><li><p><strong>保护嵌套类</strong>： 如果内部类声明为<code>protected</code>，则外部类的成员函数、友元以及继承了外部类的派生类都可以访问内部类</p></li></ol><h1>异常</h1><h2 id="异常概念">异常概念</h2><p>C语言异常处理机制是：</p><ol><li>终止程序。缺陷：用户难以接受。如发生内存错误，除0错误时就会终止</li><li>返回错误码。缺陷：需要程序员自己去查对应的错误</li></ol><p>在C++中，异常是一种在程序执行过程中发生的错误或者意外状况。异常提供了一种机制，允许程序员在代码中识别和处理错误，以及在出现错误时进行适当的响应。异常处理是C++中一个重要的编程概念，它使得程序更健壮，更容易维护。</p><p>C++中异常处理有三个关键字：<strong>throw、catch、try</strong></p><ul><li>throw：当问题出现，程序抛出一个异常。抛异常使用throw关键字完成。</li><li>catch：用于捕捉异常。**catch(…)**可以捕获任意类型的异常，主要时用来捕获没有显示捕获类型的异常。相当于条件判断中的else。</li><li>try：try中包含会出现异常的代码或者函数。后面通常会跟一个或者多个catch块。</li></ul><p><strong>注意：可以抛出任意类型的对象。抛出的异常必须捕获。try要和catch匹配使用，catch里的内容抛出异常时才执行，没有异常，不执行。</strong></p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入被除数和除数:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;除0错误&quot;</span>;<span class="comment">//抛出异常,这里抛出的是字符串类型异常，也可以是对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">test</span>() &lt;&lt; endl;<span class="comment">//会出现异常的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//捕获字符串类型的异常，a即 &quot;除0错误&quot;。</span></span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* a)&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//捕获任意类型的异常，通常未知异常</span></span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unknow exception&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常的抛出和匹配规则">异常的抛出和匹配规则</h2><h3 id="异常的抛出">异常的抛出</h3><ol><li><p>异常时通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码。</p></li><li><p>被选中的处理代码的调用链是，找到于该类型匹配且离抛出异常位置最近的那一个catch。</p></li><li><p>抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象。</p></li><li><p>catch(…)可以捕获任意类型的对象，主要是用来捕获没有显示捕获类型的异常，因为如果没有匹配的catch会终止程序。相当于条件判断中的else。问题是不知道异常错误是什么。</p></li><li><p>实际中抛出和捕获的类型不一定类型完全匹配，可以抛出派生类对象，使用基类来捕获，这个在实际生活中很实用。主要原因是：派生类可以赋值给基类。</p></li></ol><h3 id="匹配规则">匹配规则</h3><ul><li>首先检查throw本身是否在try块内部，如果是，再在当前函数栈中查找匹配的catch语句。如果有匹配的直接跳到catch的地方执行。</li><li>如果没有匹配的catch块，则退出当前函数栈，在调用函数的栈中查找匹配的catch。</li><li>如果到达main函数的栈，都没有匹配的catch，就会终止程序。</li><li>上述沿着调用链查找匹配的catch块的过程叫栈展开。所以实际要最后要加一个catch(…)来捕获任意类型的异常，防止程序终止。</li><li>找到匹配的catch会直接跳到catch语句执行，执行完后，会继续沿着catch语句后面执行。</li></ul><h2 id="异常的重新抛出">异常的重新抛出</h2><p>有可能单个的catch不能完全处理一个异常，**在进行一些矫正处理后，需要交给更外层的调用链函数来处理。**catch可以做完矫正操作，再将异常重新抛出，交给更上层的函数进行处理。</p><h2 id="异常安全问题">异常安全问题</h2><p>由于抛异常只要找到匹配的catch就直接跳到catch块执行，没有找到对应catch的函数就不会继续执行。这样导致函数的执行流回很乱。可能会导致一些问题。</p><ul><li><p>构造函数完成对象的构造和初始化，最好不要再构造函数中抛出异常，否则可能导致对象不完整或者没有完全初始化</p></li><li><p>析构函数主要完成资源的清理，最好不要在析构函数中抛异常，否则可能导致内存泄漏。</p></li><li><p>C++异常经常会导致资源泄漏问题。比如：在new和delete中抛出异常，导致new出来的资源没有释放，导致内存泄漏。在lock和unlock中抛出异常，导致锁没有释放，导致死锁。</p></li></ul><p>有两种解决办法：</p><ul><li>将异常捕获，释放资源后，将锁重新抛出。</li><li>使用RAII的思想解决。定义一个类封装，管理资源。当要使用时实例化一个类对象，将资源传入，当退出函数，调用对象析构函数，释放资源。</li></ul><h2 id="异常规范说明">异常规范说明</h2><ul><li><strong>noexcept</strong>：表示函数不抛出异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>noexcept(expression)</strong>： 表示如果 <code>expression</code> 求值结果为 <code>true</code>，则函数不抛出异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(someExpression())</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>早期的异常规范：</strong> 在早期的C++标准中，可以使用 <code>throw()</code> 表示函数不抛出异常，或者使用 <code>throw(type1, type2, ...)</code> 来指定函数可能抛出的异常类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// 函数不抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">anotherFunction</span><span class="params">()</span> <span class="title">throw</span><span class="params">(std::exception, MyException)</span></span>; <span class="comment">// 函数可能抛出 std::exception 或 MyException</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>现代C++中的 noexcept</strong>： 推荐使用 <code>noexcept</code> 关键字来表示函数是否抛出异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 函数不抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">anotherFunction</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(someExpression())</span></span>; <span class="comment">// 函数在 someExpression() 为 true 时不抛出异常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>异常规范的问题：</strong> 早期的异常规范在实践中并没有提供太多的好处，而且容易导致问题。因此，自C++11开始，异常规范已经被弃用，而 <code>noexcept</code> 关键字更灵活且更安全。</p><h2 id="自定义异常体系">自定义异常体系</h2><p>在实际中，并不是我们想抛什么异常就抛什么异常，这样会导致捕捉的时候不好捕捉。而是，会建立一个继承体系，<strong>建立一个异常类，派生类继承这个类，来定义出不同的异常。</strong></p><ul><li>到时候抛出异常**，只需要用基类进行捕捉即可**</li><li>基类可以相当于是一个框架，派生类是具体的异常。然后去具体实现异常的内容，然后<strong>抛异常只需要抛派生类，捕捉异常只需要捕捉基类即可。</strong> ‘</li></ul><p>下列使用一个简单实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="comment">//异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Exception</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">0</span>):_errmsg(str), _id(id)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>;<span class="comment">//派生类中输出的指定异常信息</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _errmsg;<span class="comment">//错误信息</span></span><br><span class="line">    <span class="type">int</span> _id;<span class="comment">//错误码</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="comment">//数据库异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SqlException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">1</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//网络异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">2</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//缓存异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CacheException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">3</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当网络连接失败，抛出这个异常即可</span></span><br><span class="line">    <span class="comment">//throw HttpException(&quot;Http fail&quot;, 2);</span></span><br><span class="line">    <span class="comment">//当缓存错误,抛出这个异常</span></span><br><span class="line">    <span class="comment">//throw CacheException(&quot;Cache error&quot;, 3);</span></span><br><span class="line">    <span class="comment">//当数据库错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">SqlException</span>(<span class="string">&quot;Sql error&quot;</span>, <span class="number">4</span>);<span class="comment">//抛出派生类异常对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//捕获基类异常，</span></span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> Exception&amp; a)&#123;</span><br><span class="line">        a.<span class="built_in">what</span>();<span class="comment">//输出错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unknow exception&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-标准库的异常体系">C++标准库的异常体系</h2><p>在C++库中也建立了一个异常体系。也给我们提供了一些异常类。我们可以在程序中使用这些标准异常，它们也是以父子类层次结构组织起来的。</p><ul><li>基类：std::exception</li><li>派生类：std::runtime_error等</li></ul><h2 id="异常优缺点">异常优缺点</h2><p><strong>优点</strong>：</p><ul><li>异常对象定义好了，相比较于错误码，可以清晰准确的展示出错误的各种信息，甚至包含堆栈调用信息，可以帮我们很好的定位程序的bug。</li><li>在函数调用链中，深层函数返回错误，我们得层层返回，需要不断的判断是什么错误，再返回给最外层。异常直接会找到对应的catch执行，不需要判断是什么错误。</li><li>部分函数更好处理，比如没有返回值的函数或者返回值为自身的T&amp; operator，不好返回错误码。并且pos越界了，内存错误等不需要终止程序。</li><li>更好的进行测试代码</li></ul><p><strong>缺点</strong>：</p><ul><li>异常导致执行流乱跳，运行混乱。导致我们调试和分析程序时，比较困难。</li><li>C++没有垃圾回收机制，可能会导致异常安全问题。开辟的资源和打开的流，由于执行流乱跳，导致没有释放和关闭等。导致内存泄漏。打开的锁为关闭，导致死锁。</li><li>C++标准库的异常体系定义不好，导致我们需要各自定义各自的体系，非常混乱。</li><li>随意抛异常，外层不好捕获，所以尽量按找异常规范使用。</li></ul><h2 id="RTTI">RTTI</h2><p>在C++中，RTTI是<strong>运行阶段类型识别</strong>的简称（Runtime Type Identification）。它允许在程序运行时获取对象的类型信息。是新添加到C++中的特性之一，很多老式实现不支持。主要用途包括：</p><ol><li><strong>识别对象类型：</strong> RTTI允许在程序运行时确定对象的类型。这对于处理多态性和动态多态性（dynamic polymorphism）非常有用。例如，在一个基类的指针或引用指向派生类对象时，你可以使用RTTI来确定实际派生类的类型。</li><li><strong>安全的类型转换：</strong> 在某些情况下，你可能需要将基类指针或引用安全地转换为派生类指针或引用。RTTI的<code>dynamic_cast</code>运算符可用于执行这种安全的转换，它会在转换之前检查类型信息，如果转换不安全，<strong>它会返回空指针或引发异常</strong>，而不是导致未定义行为。</li><li><strong>类型检查：</strong> RTTI允许你在运行时检查对象的类型信息，从而采取相应的措施。这对于实现一些通用的算法或框架，需要根据对象的类型来执行不同的操作，非常有用。</li><li><strong>异常处理：</strong> 在一些情况下，RTTI可用于处理异常。当在基类指针或引用上使用<code>dynamic_cast</code>时，如果转换失败，会返回空指针或引发<code>std::bad_cast</code>异常，可以在异常处理中捕获。</li></ol><p>C++中有三个支持RTTI的元素</p><ul><li>dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针，否则，该运算符返回空指针-0</li><li>typeid运算符返回一个指出对象的类型的值</li><li>type_info结构储存了有关特定类型的信息</li></ul><h3 id="dynamic-cast">dynamic_cast</h3><p><strong>dynamic_cast 操作符</strong>：<code>dynamic_cast</code> 用于在运行时执行安全的类型转换，主要用于处理继承关系。它可以将指向基类的指针或引用转换为派生类的指针或引用，同时执行类型检查。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">   Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (derivedPtr != <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Successfully casted to Derived.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Failed to cast to Derived.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> basePtr;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Derived&amp; derivedRef = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(*basePtr);</span><br><span class="line">    <span class="comment">// 成功转换</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_cast&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在一些情况下，RTTI可用于处理异常。当在基类指针或引用上使用dynamic_cast时，如果转换失败，会返回空指针或引发std::bad_cast异常，可以在异常处理中捕获。*/</span></span><br></pre></td></tr></table></figure><h3 id="typeid和type-info">typeid和type_info</h3><p><strong>typeid运算符</strong>：</p><ul><li><strong>用途：</strong> <code>typeid</code>运算符用于在运行时获取对象的类型信息。它返回一个<code>const std::type_info&amp;</code> 对象，该对象包含有关实际类型的信息，其中type_info是在头文件typeinfo(以前是typeInfo.h)中定义的一个类。。</li><li><strong>语法：</strong> <code>typeid(expression)</code>，其中<code>expression</code>是一个表达式，通常是<strong>一个对象或一个类型</strong>。</li></ul><p><strong>type_info类</strong>：</p><ul><li><strong>用途：</strong> <code>type_info</code>是一个类，表示类型信息。它包含有关类型的信息，例如类型的名称。</li><li><strong>成员函数：</strong><ul><li><strong><code>name()</code>：</strong> 返回一个指向包含类型名称的C字符串的指针。请注意，这个名称的格式是实现定义的，可能在不同编译器和平台上有所不同。</li><li><strong>其他成员函数：</strong> 可能会有其他一些实现特定的成员函数，但标准并没有规定。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="type">const</span> std::type_info&amp; typeInfo = <span class="built_in">typeid</span>(*basePtr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object type: &quot;</span> &lt;&lt; typeInfo.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>typeid运算符使得能够确定两个对象是否为同种类型。type_info类重载了==和!运算符，可以使用这些运算符来对类型比较。</strong></p><p><strong>例如</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> Base;</span><br><span class="line">    Derived* derivedPtr = <span class="keyword">new</span> Derived;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Base) == <span class="built_in">typeid</span>(*basePtr)) &lt;&lt; std::endl;<span class="comment">//(*basePtr表示指向的对象)相同,返回值1</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Base) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//返回值0</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Derived) == <span class="built_in">typeid</span>(*basePtr)) &lt;&lt; std::endl;<span class="comment">//返回值0</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Derived) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//返回值1</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(*basePtr) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//,对象不同返回值0</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">delete</span> derivedPtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>智能指针模板类</h1><p>当谈到C++中的智能指针时，通常会涉及到 <code>std::shared_ptr</code> 和 <code>std::unique_ptr</code> 这两个模板类。还有一个<code>std::auto_ptr</code>已经被摒弃，但在C++11以前使用了多年，如果编译器不支持其他两种，则auto_ptr是唯一选择。<strong>这些智能指针类旨在管理动态分配的内存，并在对象不再需要时自动释放该内存，从而避免内存泄漏和悬挂指针的问题。</strong></p><p>要创建智能指针对象，必须包含头文件<strong>memory</strong>，该文件模板定义。然后使用通常的模板语法来实例化所需类型的指针。</p><h2 id="auto-ptr模板类">auto_ptr模板类</h2><p><code>std::auto_ptr</code> 是 C++98 标准中引入的智能指针，用于管理动态分配的内存。然而，它在 C++11 标准中已被弃用，并且在 C++17 标准中已经被移除。主要原因是 <code>std::auto_ptr</code> 存在一些问题，特别是在资源所有权转移方面存在潜在的危险。</p><p>一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">autoPtr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    *autoPtr1 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// autoPtr2 现在拥有 autoPtr1 的内存所有权</span></span><br><span class="line">    std::auto_ptr&lt;<span class="type">int</span>&gt; autoPtr2 = autoPtr1;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; *autoPtr1 &lt;&lt; std::endl;<span class="comment">//输出1</span></span><br><span class="line">    <span class="comment">// 这里autoPtr1不再拥有资源，会导致运行时错误</span></span><br><span class="line">    <span class="comment">// 使用 autoPtr1 时可能会出现未定义的行为</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">double</span>&gt; <span class="title">autoPtr3</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>;</span><br><span class="line">    *autoPtr3 = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; *autoPtr3 &lt;&lt; std::endl;<span class="comment">//输出3.14</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::auto_ptr&lt;string&gt; <span class="title">autoPtr4</span><span class="params">(<span class="keyword">new</span> string)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>std::auto_ptr</strong>具有独占所有权的特性，但其所有权转移的方式可能导致一些问题，因为它采用了移动语义而非拷贝语义。这意味着当一个 <strong>std::auto_ptr</strong>所有权转移给另一个时，原始的 <strong>std::auto_ptr</strong> 将不再拥有对资源的所有权。</p></div><h2 id="shared-ptr模板类">shared_ptr模板类</h2><p><code>std::shared_ptr</code> 是一种共享所有权的智能指针，多个 <code>shared_ptr</code> 实例可以共享对同一块内存的所有权。它使用引用计数来追踪有多少个 <code>shared_ptr</code> 共享相同的资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 创建一个shared_ptr并分配内存</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  等价于std::shared_ptr&lt;int&gt; sharedPtr(new int(42));</span></span><br><span class="line"><span class="comment">         *  但是std::make_shared&lt;int&gt;(42)更加安全，因为它有性能优势和异常安全性</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 共享所有权</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; anotherSharedPtr = sharedPtr;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;sharedPtr: &quot;</span> &lt;&lt; *sharedPtr &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;anotherSharedPtr: &quot;</span> &lt;&lt; *anotherSharedPtr &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 使用sharedPtr和anotherSharedPtr</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当最后一个shared_ptr离开作用域时，内存会被自动释放</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="unique-ptr模板类">unique_ptr模板类</h2><p><code>std::unique_ptr</code> 是一种独占所有权的智能指针，一个 <code>unique_ptr</code> 实例独立拥有对其指向的资源的所有权，不能共享。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建一个unique_ptr并分配内存</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::cout &lt;&lt; *uniquePtr &lt;&lt; std::endl;<span class="comment">//输出42</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  等价于std::unique_ptr&lt;int&gt; sharedPtr(new int(42));</span></span><br><span class="line"><span class="comment">         *  但是std::make_unique&lt;int&gt;(42)更加安全，因为它有性能优势和异常安全性</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// unique_ptr不能直接赋值给另一个unique_ptr（会发生所有权转移）</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; anotherUniquePtr = uniquePtr;  // 错误，编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过std::move进行所有权转移</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; anotherUniquePtr = std::<span class="built_in">move</span>(uniquePtr);</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt; *anotherUniquePtr &lt;&lt; std::endl;<span class="comment">//输出42</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用anotherUniquePtr</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当anotherUniquePtr离开作用域时，内存会被自动释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="unique-ptr为何优于auto-ptr">unique_ptr为何优于auto_ptr</h2><ol><li><p><strong>更安全的所有权转移：</strong> <code>std::unique_ptr</code> 使用移动语义进行所有权转移，而 <code>std::auto_ptr</code> 使用复制语义。由于 <code>std::auto_ptr</code> 的复制语义可能导致不明确的行为，因此在 C++11 引入 <code>std::unique_ptr</code> 时，<code>std::auto_ptr</code> 被标记为已弃用。使用 <code>std::unique_ptr</code> 更容易理解和更安全。</p></li><li><p><strong>支持数组和自定义删除器：</strong> <code>std::unique_ptr</code> 可以用于管理数组（<code>std::unique_ptr&lt;T[]&gt;</code>），而 <code>std::auto_ptr</code> 不支持这种用法。此外，<code>std::unique_ptr</code> 还支持通过自定义删除器来管理非默认方式分配的资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arrayPtr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">arrayPtr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arrayPtr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">arrayPtr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p><strong>更灵活的模板参数：</strong> <code>std::unique_ptr</code> 具有更灵活的模板参数，可以轻松地与自定义删除器和分配器一起使用。这提供了更多的灵活性，以适应各种资源管理需求。</p></li><li><p><strong>更严格的所有权管理：</strong> <code>std::unique_ptr</code> 严格实现了独占所有权的概念，一个 <code>std::unique_ptr</code> 实例独立拥有对其指向的资源的所有权。这使得代码更加明确，减少了潜在的错误。</p></li></ol><p><strong>警告</strong>：</p><p><strong>只有使用new分配内存时</strong>，才能使用auto_ptr和shared_ptr，<strong>使用new[] 分配内存时</strong>，不能使用它们，只能使用unique_ptr。<strong>不使用new或new[]分配内存时</strong>，也不能使用unique_ptr。</p><h1>标准模板库STL</h1><h2 id="模板类vector-2">模板类vector</h2><p><strong>vector又名动态数组</strong></p><p><a href="https://blog.csdn.net/qq_52324409/article/details/121000029?ops_request_misc=%7B%22request%5Fid%22%3A%22170903352516800180642186%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170903352516800180642186&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121000029-null-null.142%5Ev99%5Epc_search_result_base1&amp;utm_term=vector%E5%AE%B9%E5%99%A8&amp;spm=1018.2226.3001.4187">C++ vector容器详解_c++容器vector-CSDN博客</a></p><h2 id="基于范围的for循环">基于范围的for循环</h2><p>基于范围的for循环是为用于STL而设计的。在这种for循环中，括号中的代码<strong>声明一个类型(通常用auto)与容器储存的内容相同的变量</strong>，然后指出了容器的名称。接下来，循环体使用指定的变量依次访问容器的每个元素。若<strong>使用引用参数，则可修改容器内容</strong>。</p><p>一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> price[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; price2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*未使用引用参数，不能修改容器内容*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: price) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*使用引用可以修改容器内容*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x: price2) &#123;</span><br><span class="line">        x=<span class="number">10</span>;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="泛型编程">泛型编程</h2><p>STL是一种泛型编程。面向对象编程关注的是编程的数据方面，而泛型编程关注的则是算法。他们之间的共同点是抽象和创建可重用代码，但他们的理念绝然不同。</p><p>泛型编程旨在编写独立于数据类型的代码。在C++中，完成通用程序的工具是模板。模板使得能够按泛型定义函数或类，而STL通过通用算法更近了一步。为了解模板和设计是如何协同工作的，我们需要先了解一下迭代器。</p><h3 id="迭代器">迭代器</h3><p>在C++中，模板使得<strong>算法独立于储存的数据类型</strong>，而迭代器使<strong>算法独立于使用的容器类型</strong>，迭代器（Iterator）是一种用于遍历容器（如数组、向量、链表等）中元素的对象。迭代器提供了一种统一的方式来访问容器中的元素，而不必关心容器的具体类型或实现细节。C++标准库提供了多种类型的迭代器，<strong>主要分为五种</strong>：</p><ol><li><strong>Input Iterator（输入迭代器）</strong>：<ul><li>只允许从容器中读取元素，但不能修改元素。</li><li>支持逐个递增，只能用于单向遍历。</li></ul></li><li><strong>Output Iterator（输出迭代器）</strong>：<ul><li>只允许往容器中写入元素，但不能读取元素。</li><li>支持逐个递增，也只能用于单向遍历。</li></ul></li><li><strong>Forward Iterator（前向迭代器）</strong>：<ul><li>具有Input Iterator和Output Iterator的功能，支持读写操作。</li><li>支持逐个递增，可用于单向遍历。</li></ul></li><li><strong>Bidirectional Iterator（双向迭代器）</strong>：<ul><li>具有Forward Iterator的功能，同时支持逐个递减。</li><li>支持双向遍历，即可以前进也可以后退。</li></ul></li><li><strong>Random Access Iterator（随机访问迭代器）</strong>：<ul><li>具有Bidirectional Iterator的功能，同时支持随机访问元素。</li><li>支持通过指针算术运算（如 +、-）直接跳跃访问容器中的元素。</li></ul></li></ol><p>在C++标准库中，不同的容器提供不同类型的迭代器，例如，<code>std::vector</code>和<code>std::list</code>提供了双向迭代器，而<code>std::array</code>和<code>std::deque</code>提供了随机访问迭代器。在使用迭代器时，要注意选择适当的类型以满足操作的需求。。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义一个迭代器...*/</span></span><br><span class="line">vector&lt;type&gt;::iterator it;</span><br><span class="line">list&lt;type&gt;::iterator it2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*一个简单的示例*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; price= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">list&lt;<span class="type">double</span>&gt;::iterator it2;<span class="comment">//定义的一个遍历list容器的迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = price2.<span class="built_in">begin</span>();<span class="comment">//定义的一个遍历vector容器的迭代器</span></span><br><span class="line"><span class="keyword">for</span>(; it != price2.<span class="built_in">end</span>(); it++)<span class="comment">//迭代器支持前缀++和后缀++，遍历容器</span></span><br><span class="line">&#123;</span><br><span class="line">   std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上作为一种编程风格，最好避免直接使用迭代器，而应尽可能使用STL函数(for_each())来处理细节。也可以使用C++11新增的基于范围的for循环。</p><h3 id="容器">容器</h3><p>STL具有容器概念和容器类型。概念是具有名称(容器、序列容器、关联容器)的通用类别，容器类型是可用于创建具体容器对象的模板。</p><p>主要的容器分类包括：</p><ol><li><strong>序列容器（Sequence Containers）</strong>：<ul><li>顺序存储元素，元素的顺序与它们被插入的顺序相同。</li><li>包括：<ul><li><strong>std::vector：</strong> 动态数组，支持快速随机访问。</li><li><strong>std::list：</strong> 双向链表，支持在任意位置快速插入和删除元素。</li><li><strong>std::deque：</strong> 双端队列，支持在两端快速插入和删除元素。</li><li><strong>std::array：</strong> 固定大小的数组，支持快速随机访问。</li></ul></li></ul></li><li><strong>关联容器（Associative Containers）</strong>：<ul><li>基于键值对（Key-Value）的存储方式，通过键值来快速查找元素。</li><li>包括：<ul><li><strong>std::set：</strong> 有序集合，不允许重复元素。</li><li><strong>std::map：</strong> 有序映射，存储键值对，不允许重复的键。</li><li><strong>std::multiset：</strong> 有序集合，允许重复元素。</li><li><strong>std::multimap：</strong> 有序映射，允许重复的键。</li></ul></li></ul></li><li><strong>无序容器（Unordered Containers）</strong>：<ul><li>使用哈希表实现，元素的存储顺序不固定。</li><li>包括：<ul><li><strong>std::unordered_set：</strong> 无序集合，不允许重复元素。</li><li><strong>std::unordered_map：</strong> 无序映射，存储键值对，不允许重复的键。</li><li><strong>std::unordered_multiset：</strong> 无序集合，允许重复元素。</li><li><strong>std::unordered_multimap：</strong> 无序映射，允许重复的键。</li></ul></li></ul></li><li><strong>容器适配器（Container Adapters）</strong>：<ul><li>提供特定接口的封装，简化了底层容器的使用。</li><li>包括：<ul><li><strong>std::stack：</strong> 栈，后进先出（LIFO）。</li><li><strong>std::queue：</strong> 队列，先进先出（FIFO）。</li><li><strong>std::priority_queue：</strong> 优先队列，按照优先级排序。</li></ul></li></ul></li></ol><p><strong>用法见</strong>：<a href="https://blog.csdn.net/qq_45524532/article/details/115386824?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=C++%E5%AE%B9%E5%99%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-115386824.142%5Ev99%5Epc_search_result_base9&amp;spm=1018.2226.3001.4187">C++常用容器-CSDN博客</a></p><h2 id="函数对象">函数对象</h2><p>在C++中，函数对象（Function Objects），也称为函数符或仿函数（Functor），函数符是可以以函数方式与()结合使用的任意对象。这包括函数名的指针和重载了()运算符对象的类(即定义了函数operator()()的类)。是一种可调用对象，可以像函数一样被调用。函数对象通常是类对象，但不像普通函数，它们可以携带状态信息，并可以通过成员函数实现自定义行为。函数对象可用于算法、STL容器等各种场景中。</p><p><strong>函数对象类</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数符类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddFunctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用方式</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddFunctor addFunctor;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">addFunctor</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 结果为7</span></span><br></pre></td></tr></table></figure><h3 id="应用">应用</h3><ol><li><strong>函数对象作为算法的参数</strong>：</li></ol><p>函数对象可以作为算法的参数，提供一种灵活的方式来定制算法的行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SquareFunctor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    SquareFunctor squareFunctor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象对容器中的每个元素进行平方操作</span></span><br><span class="line">    std::<span class="built_in">transform</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), numbers.<span class="built_in">begin</span>(), squareFunctor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在numbers为 &#123;1, 4, 9, 16, 25&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>函数对象与STL</strong>：</li></ol><p>函数对象在STL（标准模板库）中广泛应用，例如在排序、查找等算法中可以通过函数对象来指定比较的规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DescendingOrder</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    DescendingOrder descendingOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象进行降序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), descendingOrder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在numbers为 &#123;8, 5, 3, 2, 1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法">算法</h2><p><strong>STL的算法</strong>：</p><ul><li><strong>作用范围</strong>：STL的算法是独立于容器的通用算法。它们被设计为能够在不同类型的容器上进行操作，而不依赖于具体容器的实现。这种独立性使得同一个算法可以用于不同的数据结构，例如，可以使用<code>std::sort</code>在不同类型的容器上进行排序。</li><li><strong>参数类型</strong>：STL的算法通常接受迭代器（iterator）作为参数，因此可以用于各种容器，如数组、向量、链表等。它们不直接与容器关联，而是通过迭代器与容器交互。</li><li><strong>功能丰富</strong>：STL的算法涵盖了广泛的应用场景，包括排序、查找、数学运算、变换等。这些算法是为了提供通用且高效的数据处理工具。</li></ul><p>以下是一些常用的STL算法及其简要介绍：</p><ol><li><strong>排序算法</strong>：<ul><li><code>std::sort</code>：对容器进行排序，默认是升序排序。可以传递自定义的比较函数或Lambda表达式来实现不同的排序规则。</li><li><code>std::stable_sort</code>：稳定排序，保持相等元素的相对顺序。</li><li><code>std::partial_sort</code>：部分排序，将容器中的一部分元素排序，其余元素不变。</li></ul></li><li><strong>查找算法</strong>：<ul><li><code>std::find</code>：在容器中查找指定值的第一个出现位置。</li><li><code>std::binary_search</code>：在已排序的容器中进行二分查找。</li><li><code>std::count</code>：统计容器中指定值的出现次数。</li></ul></li><li><strong>变换算法</strong>：<ul><li><code>std::transform</code>：将一个范围的元素转换为另一个范围，可以结合函数对象或Lambda表达式进行元素的变换操作。</li><li><code>std::copy</code>：将一个范围的元素复制到另一个范围。</li><li><code>std::replace</code>：替换容器中指定值的所有出现。</li></ul></li><li><strong>删除和修改算法</strong>：<ul><li><code>std::remove</code>：在容器中移除指定值的所有元素，不改变容器大小，返回一个新的结束迭代器。</li><li><code>std::remove_if</code>：根据谓词条件移除满足条件的元素。</li><li><code>std::unique</code>：移除容器中相邻的重复元素，仅保留一个。</li></ul></li><li><strong>数值算法</strong>：<ul><li><code>std::accumulate</code>：对范围内的元素进行累积操作，可以用于计算总和、平均值等。</li><li><code>std::inner_product</code>：计算两个范围的内积。</li><li><code>std::iota</code>：用给定的值填充一个范围。</li></ul></li><li><strong>其他算法</strong>：<ul><li><code>std::min</code>、<code>std::max</code>：找到范围内的最小值和最大值。</li><li><code>std::reverse</code>：将容器中的元素进行反转。</li><li><code>std::rotate</code>：将容器中的元素进行旋转。</li></ul></li></ol><p>C++标准库中还有很多其他有用的算法。使用STL算法，可以编写更简洁、可读性更好的代码，并且由于这些算法经过优化，通常具有较好的性能</p><h2 id="STL总结">STL总结</h2><p>STL（Standard Template Library）是C++标准库的一部分，提供了一套通用的模板类和函数，用于处理常见的数据结构和算法。STL的设计目标是提供高效、灵活、可复用的代码，以便开发者能够更加专注于解决问题而不必重复实现基础数据结构和算法。<strong>STL主要包括以下三个组件</strong>：</p><ol><li>容器：序列容器、关联容器等等</li><li>算法：提供了一系列通用的算法，如排序、查找、变换、合并等。这些算法可以用于不同类型的容器，通过迭代器进行操作，实现了数据结构和算法的分离，增强了代码的可复用性和通用性。算法通过函数对象或函数指针支持用户自定义的操作和比较规则。</li><li>迭代器：迭代器是STL中用于遍历容器元素的通用接口，为算法和容器提供了统一的访问机制。不同类型的容器支持不同类型的迭代器，包括输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器，提供了不同程度的功能和效率。</li></ol><h2 id="其他库">其他库</h2><h3 id="vector、valarray、array">vector、valarray、array</h3><p>C++标准库提供了多个数组模板（<code>std::vector</code>、<code>std::valarray</code>、<code>std::array</code>），每个模板都有其特定的用途和优势。这样设计的目的是为了满足不同的编程需求，提供更丰富、更灵活的选择。以下是这三个数组模板的主要区别和适用场景：</p><ol><li><strong><code>std::vector</code></strong>：</li></ol><ul><li><strong>动态大小</strong>：<code>std::vector</code>是一个动态数组，其大小可以在运行时动态调整。这使得它非常适用于需要动态增减大小的场景，例如在运行时读取不确定数量的数据。</li><li><strong>内存管理</strong>：<code>std::vector</code>会自动处理内存的分配和释放，使得在动态数组的使用上更加方便。</li></ul><ol start="2"><li><strong><code>std::valarray</code></strong>：</li></ol><ul><li><strong>数值运算</strong>：<code>std::valarray</code>设计用于面向数值计算，提供了一些成员函数和操作符用于逐元素进行数学运算。它的目标是提高数值计算的效率。</li><li><strong>元素级别的操作</strong>：<code>std::valarray</code>更适用于执行逐元素的数学运算，如数组的逐元素加法、乘法等。</li></ul><ol start="3"><li><strong><code>std::array</code></strong>：</li></ol><ul><li><strong>固定大小</strong>：<code>std::array</code>是一个静态数组，其大小在编译时就确定了，不能动态改变。这使得它适用于固定大小的场景，例如需要在编译时确定数组大小的情况。</li><li><strong>栈上分配</strong>：<code>std::array</code>通常在栈上分配内存，因此相较于动态数组，它的内存访问更加高效。</li></ul><h3 id="模板initializer-list">模板initializer_list</h3><p>在C++中，<code>initializer_list</code> 是一个标准库中的类模板，用于方便地<strong>初始化容器或其他类的对象</strong>。它允许在对象的构造函数中传递一个初始化列表，类似于数组的初始化方式。<code>initializer_list</code> 的定义位于头文件 <code>&lt;initializer_list&gt;</code> 中。</p><ul><li><strong>用于容器的构造函数</strong>：使得容器类如 <code>std::vector</code>、<code>std::initializer_list</code> 等能够通过初始化列表进行构造。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vector类构造函数中参数使用了initializer_list</span></span><br></pre></td></tr></table></figure><ul><li><strong>容器和类的构造函数重载</strong>：类可以同时提供接受 <code>initializer_list</code> 和其他参数的构造函数，以便支持不同的初始化方式。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">double</span> b) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(std::initializer_list&lt;<span class="type">int</span>&gt; values) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;<span class="comment">//使传递一个初始化列表</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>输入、输出和文件</h1><h2 id="流和缓冲区">流和缓冲区</h2><p>在C++中，流（stream）和缓冲区（buffer）是与输入和输出相关的概念，用于处理数据的流动和存储。流提供了一个抽象层，使得输入和输出可以以统一的方式进行处理，而缓冲区则用于临时存储数据，以提高性能和效率。</p><h3 id="流（Stream）">流（Stream）</h3><p>流是一个抽象的概念，表示数据在程序和外部设备（如文件、屏幕、键盘等）之间的传输。在C++中，标准库提供了一些流类（如iostream、fstream、stringstream等），用于实现输入和输出的操作。流可以分为输入流和输出流，分别用于读取和写入数据。</p><p>常见的流类包括：</p><ol><li><p><strong><code>iostream</code>：</strong> 提供了<code>cin</code>（标准输入流）和<code>cout</code>（标准输出流），用于从键盘读取输入和向屏幕输出数据。</p></li><li><p><strong><code>fstream</code>：</strong> 用于文件输入和输出，包括<code>ifstream</code>（文件输入流）和<code>ofstream</code>（文件输出流）。</p></li><li><p><strong><code>stringstream</code>：</strong> 用于在内存中操作字符串，可以将字符串作为输入或输出流处理。</p></li></ol><h3 id="缓冲区（Buffer）">缓冲区（Buffer）</h3><p>缓冲区是用于暂时存储数据的区域，它可以提高输入输出的效率。标准库中的流都具有与之关联的缓冲区，用于暂时存储数据，然后一次性地进行读取或写入，而不是每次都直接与外部设备进行通信。</p><p>流的缓冲区可以分为两种：</p><ol><li><strong>输入缓冲区：</strong> 存储从外部设备（如键盘或文件）读取的数据，以便程序可以逐一处理。</li><li><strong>输出缓冲区：</strong> 存储要写入外部设备的数据，以提高写入效率。</li></ol><p>在一些情况下，你可能需要手动刷新缓冲区，以确保数据被及时处理。使用<code>flush()</code>函数可以强制将输出缓冲区的内容写入外部设备。</p><h2 id="iostream文件">iostream文件</h2><p><code>iostream</code>是C++标准库中的头文件之一，它包含了对输入和输出流的支持。具体而言，<code>iostream</code>是由两个基本的头文件合并而成，分别是：</p><ul><li><strong><code>istream</code>（Input Stream）：</strong> 用于输入流，提供了从输入设备（如键盘）读取数据的功能。主要的类包括<code>istream</code>和<code>ifstream</code>。</li><li><strong><code>ostream</code>（Output Stream）：</strong> 用于输出流，提供了向输出设备（如屏幕或文件）写入数据的功能。主要的类包括<code>ostream</code>和<code>ofstream</code>。</li></ul><p>通过合并这两个头文件，得到了<code>iostream</code>，其中包括了<code>cin</code>、<code>cout</code>、<code>cerr</code>、<code>clog</code>等标准流对象，以及相关的功能和操作符重载，使得输入输出操作变得简便和灵活。</p><p>C++的iostream库管理了很多细节。例如在程序中包换iostream文件将自动创建8个流对象(4个用于窄字符流，4个用于宽字符流)</p><p>常见的8个流对象及其用途包括：</p><ul><li><strong><code>cin</code>：</strong> 标准输入流，用于从用户输入中读取数据，wcin对象于此类似但处理的是wchar_t(宽字符类型)类型。</li><li><strong><code>cout</code>：</strong> 标准输出流，用于将数据输出到控制台。wcout对象于此类似但处理的是wchar_t(宽字符类型)类型。</li><li><strong><code>cerr</code>：</strong> 标准错误流，没有被缓冲，用于输出错误信息到控制台。wcerr对象于此类似但处理的是wchar_t(宽字符类型)类型。</li><li><strong><code>clog</code>：</strong> 标准日志流，用于输出程序运行时的一般信息。wclog对象于此类似但处理的是wchar_t(宽字符类型)类型。</li></ul><h3 id="cerr和clog">cerr和clog</h3><p>在C++中，<code>cerr</code>和<code>clog</code>都是标准错误流，用于输出错误信息到控制台。它们是<code>ostream</code>类的实例，提供了与<code>cout</code>相似的输出功能，但通常用于不同的目的。</p><ol><li><p><strong><code>cerr</code>（标准错误流）：</strong></p><ul><li><code>cerr</code>是一个标准错误流对象，用于输出程序的错误信息。</li><li>与<code>cout</code>不同，<code>cerr</code>的<strong>输出默认不被缓冲</strong>，意味着错误消息会立即显示在控制台上，而<strong>不受缓冲机制的影响</strong>。</li><li>通常用于输出紧急的错误信息，以便及时发现问题。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;This is an error message.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>clog</code>（标准日志流）：</strong></p><ul><li><code>clog</code>也是一个标准错误流对象，用于输出程序运行时的一般信息，类似于日志。</li><li>与<code>cerr</code>不同，<code>clog</code>的输出默认是被缓冲的，可以通过<code>std::flush</code>强制刷新输出，或者等到缓冲区满时才刷新。</li><li><strong>通常用于输出程序的运行时信息，方便调试和了解程序执行的进展</strong>。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::clog &lt;&lt; <span class="string">&quot;This is a log message.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总体而言，<code>cerr</code>和<code>clog</code>都是用于输出程序的诊断信息的标准错误流，它们与<code>cout</code>一起构成了C++中的标准流。选择使用哪一个取决于你的需求，如果你需要及时看到错误信息，可以使用<code>cerr</code>，如果你希望输出日志信息，并允许一定程度的缓冲，可以使用<code>clog</code>。</p><h2 id="使用cout进行输出">使用cout进行输出</h2><h3 id="重载的-运算符">重载的&lt;&lt;运算符</h3><p>在C++中，&lt;&lt;运算符的默认含义是按位左移运算符，但ostream类重新定义了&lt;&lt;运算符，将其重载为输出。在这种情况下&lt;&lt;能识别C++中的所有的基本类型(int、double、string…)</p><p>对于上述每种类型，ostream类提供了operator&lt;&lt;()函数的定义。</p><p>&lt;&lt;运算符的所有化身返回类型都是ostream&amp;，格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(type);</span><br></pre></td></tr></table></figure><p>意味着该运算符将返回一个指向ostream对象的引用，该引用指向用于调用该运算符的对象。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">// &lt;&lt;运算符返回的是cout对象</span></span><br></pre></td></tr></table></figure><p>这种特性使得cout能串联输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;oh&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="其他osteam方法">其他osteam方法</h3><p>ostream还提供了put()方法和write()方法</p><p>put：用于显示字符</p><p>write：用于显示字符串</p><ul><li>put原型：将一个字符插入到输出流中。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">put</span><span class="params">(<span class="type">char</span>)</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;W&#x27;</span>);</span><br><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;I&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;t&#x27;</span>);<span class="comment">//可进行拼接输出</span></span><br><span class="line">cout.<span class="built_in">put</span>(<span class="number">65</span>) <span class="comment">//输出A</span></span><br><span class="line">cout.<span class="built_in">put</span>(<span class="number">66.3</span>) <span class="comment">//自动将double值66.3转换为char值66，输出B</span></span><br></pre></td></tr></table></figure><ul><li><p>write模板原型： 将指定数量的字符从指定位置的字符串插入到输出流中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">basic_ostream&lt;<span class="type">char</span>, Traits&gt;&amp; <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, streamsize n)</span></span>;</span><br><span class="line"></span><br><span class="line">-第一个参数为指定字符串</span><br><span class="line">-第二个参数为指定长度</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello, C++!&quot;</span>;</span><br><span class="line">    cout.<span class="built_in">write</span>(message, <span class="number">6</span>); <span class="comment">// 将 &quot;Hello&quot; 写入输出流</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="刷新输出缓冲区">刷新输出缓冲区</h3><ul><li><p>在C++中，刷新输出缓冲区是指将缓冲区中的数据强制写入输出设备。默认情况下，输出流（如<code>cout</code>、<code>cerr</code>等）会将数据存储在内部缓冲区中，而不是每次写入一个字符就立即刷新到输出设备。刷新输出缓冲区的操作可以通过 <code>flush</code> 方法或 <code>flush</code> 操纵符来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一种*/</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is some text.&quot;</span> &lt;&lt; flush; <span class="comment">// 刷新输出缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第二种*/</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is some text.&quot;</span> &lt;&lt; endl;   <span class="comment">// endl 操纵符会输出一个换行符并刷新输出缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三种*/</span></span><br><span class="line"><span class="built_in">flush</span>(cout);</span><br></pre></td></tr></table></figure></li></ul><h3 id="用cout进行格式化">用cout进行格式化</h3><ol><li><strong>控制输出的进制</strong>：在下一次将格式状态修改为其他进制时才会输出其他进制，否则一直按照设置进制之后进行输出</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 十六进制输出</span></span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; <span class="string">&quot;Hexadecimal: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*或者使用hex(cout)、oct(cout)*/</span></span><br><span class="line">    <span class="comment">// 八进制输出</span></span><br><span class="line">    cout &lt;&lt; oct &lt;&lt; <span class="string">&quot;Octal: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hex,oct都是控制符</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>调整字段宽度和对齐方式</strong>：width()方法只影响接下来显示的一个项目，然后字段宽度将恢复为默认值</li></ol><p>使用width()进行设置字段宽度，left左对齐，right右对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> num2 = <span class="number">45.6789</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制输出宽度和对齐方式</span></span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; left &lt;&lt; num1;</span><br><span class="line">    </span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; right &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>填充字符</strong>：</li></ol><p>在默认情况下，cout用空格填充字段中未被使用的部分，可以使用fill()成员函数来改变填充字符。<strong>在下次修改之前将一直使用之前修改的字符填充</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> num2 = <span class="number">45.6789</span>;</span><br><span class="line">    cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">// 控制输出宽度和对齐方式</span></span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);<span class="comment">//宽度为10，前7位用*填充</span></span><br><span class="line">    cout &lt;&lt; right &lt;&lt; num1;</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; right &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>设置浮点数的显示精度</strong>：</li></ol><p>浮点数精度的含义取决于输出模式。在<strong>默认情况</strong>下，指的是显示的总位数，在<strong>定点模式和科学模式</strong>下，精度指的是小数点后面的位数。c++默认精度位6位(末尾的0不显示)。precision()成员函数使得能选择其他值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cout精度设置为2</span></span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>打印末尾的0和小数点</strong>：</li></ol><p>对于有些输出(比如价格栏中的数字)，保留末尾的0将更为美观。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.setf(ios_base::showpoint);</span><br></pre></td></tr></table></figure><p><strong>上面的dec、hex、oct、left、right等都是标准控制符能够调用setf()，并且自动提供正确的参数，工作方式都相似。</strong></p><h3 id="头文件iomanip">头文件iomanip</h3><p>使用iostream工具来设置一些格式值有时不太方便。为简化工作，C++在头文件iomanip中提供了一些控制符，作用类似，表示更方便。常用的有三个：setprecision()、setfill()和setw()，表示设置精度、填充字符、字段宽度。</p><p>setprecision()：接受一个指定精度的整数参数</p><p>setfill()：接受一个指定字段宽度的整数参数</p><p>setw()：接受一个指定填充字符的char参数</p><p>因为他们都是控制符，故可以使用cout将语句连接起来。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> root = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">10</span>;n&lt;=<span class="number">100</span>; n+=<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;.&#x27;</span>) &lt;&lt; n &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; root &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用cin进行输入">使用cin进行输入</h2><h3 id="cin如何检查输入">cin如何检查输入</h3><p>不同版本的抽取运算符查看输入流的方法是相同的。<strong>他们跳过空白（空格、换行符、制表符），直到遇到非空白字符</strong>。即使对于单字符模式（char、unsigned char）也是如此。在其他模式下，&gt;&gt;运算符将读取一个指定类型的数据。<strong>将从非空白字符开始，到与目标类型不匹配的第一个字符的全部内容</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"><span class="comment">//假设输入12348z</span></span><br><span class="line">cout &lt;&lt; num;<span class="comment">//输出12348，剩下的留在输入缓冲区</span></span><br></pre></td></tr></table></figure><h3 id="流状态">流状态</h3><p>在C++中，<code>cin</code> 对象的流状态会受到输入的影响。<code>cin</code> 是C++标准库中的标准输入流对象，用于从标准输入设备（通常是键盘）获取用户输入。流状态的不同值反映了输入的有效性和状态。以下是一些关于 <code>cin</code> 流状态的详细介绍：</p><ol><li><strong>流状态位</strong>：</li></ol><p><code>cin</code> 有一系列的流状态位，主要的有：</p><ul><li><strong><code>failbit</code>：</strong> 当输入的数据类型不匹配或输入格式错误时，<code>failbit</code> 会被设置。例如，用户输入了非整数字符而 <code>cin</code> 期望输入整数。</li><li><strong><code>badbit</code>：</strong> 当输入流发生严重错误时，如IO错误或设备故障，<code>badbit</code> 会被设置。</li><li><strong><code>eofbit</code>：</strong> 当遇到文件末尾时，<code>eofbit</code> 会被设置。</li><li><strong><code>goodbit</code>：</strong> 表示没有错误发生。</li></ul><ol start="2"><li><strong>流状态查询</strong>：</li></ol><p>可以通过 <code>cin</code> 对象的成员函数 <code>fail()</code>、<code>bad()</code>、<code>eof()</code> 和 <code>good()</code> 来查询流的状态。</p><ul><li><strong><code>fail()</code>：</strong> 返回 <code>true</code> 表示 <code>failbit</code> 或 <code>badbit</code> 被设置。</li><li><strong><code>bad()</code>：</strong> 返回 <code>true</code> 表示 <code>badbit</code> 被设置。</li><li><strong><code>eof()</code>：</strong> 返回 <code>true</code> 表示 <code>eofbit</code> 被设置。</li><li><strong><code>good()</code>：</strong> 返回 <code>true</code> 表示没有任何错误位被设置，即 <code>goodbit</code> 被设置。</li></ul><ol start="3"><li><strong>流状态的影响</strong>：</li></ol><p>在使用 <code>cin</code> 进行输入时，输入的有效性和格式与流状态密切相关。如果输入不符合预期，流状态位将被设置，进而影响程序的行为。例如：</p><h3 id="使用cin错误处理">使用cin错误处理</h3><p>在使用 <code>cin</code> 进行输入时，最好进行错误处理，以确保用户输入的数据是有效的。例如，如果用户输入了非整数的字符，<code>cin</code> 将进入错误状态。可以通过检查 <code>cin.fail()</code> 来检测错误，并通过 <code>cin.clear()</code> 来清除错误状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter an integer: &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!(cin &gt;&gt; num)) &#123;</span><br><span class="line">        <span class="comment">/*输入有效返回true，无效返回false*/</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid input. Please enter an integer: &quot;</span>;</span><br><span class="line">        cin.<span class="built_in">clear</span>(); <span class="comment">// 清除错误状态</span></span><br><span class="line">      cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 忽略缓冲区中的无效字符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- cin.clear() 的作用是清除 cin 对象的错误状态，以便能够继续尝试接收输入。如果不清除错误状态，cin 会一直保持在错误状态，导致后续的输入操作无法正常进行。</span><br><span class="line"></span><br><span class="line">- cin.ignore(numeric_limits&lt;streamsize&gt;<span class="punctuation">:</span><span class="punctuation">:</span>max()<span class="punctuation">,</span> &#x27;\n&#x27;) 的作用是清除输入缓冲区中的无效字符，直到遇到换行符为止。这通常用于处理用户输入错误时，清除缓冲区中的残留字符，以便下一次输入操作不受之前错误的影响。</span><br><span class="line"></span><br><span class="line">- cin.fail() 是 cin 流的一个成员函数，用于检查最近一次的输入操作是否成功。它返回一个布尔值，如果最近的输入操作失败，则返回 <span class="literal"><span class="keyword">true</span></span>，否则返回 <span class="literal"><span class="keyword">false</span></span>。</span><br></pre></td></tr></table></figure><h3 id="其他istream类方法">其他istream类方法</h3><ol><li><strong>单字符输入</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(<span class="type">char</span>&amp; )</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在使用char参数或没有参数的情况下，get()方法读取下一个字符，即使该字符是空格、制表符或换行符。get(char&amp; ch)版本将输入字符赋给其参数，而get(void)版本将输入字符转换为整型并将其返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">cin.<span class="built_in">get</span>(c1);</span><br><span class="line"></span><br><span class="line">c1 = cin.<span class="built_in">get</span>();<span class="comment">//返回值为整型</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">cin.<span class="built_in">get</span>(c1).<span class="built_in">get</span>(c2) &gt;&gt; c3;</span><br><span class="line"><span class="comment">//可以进行拼接get，代表先赋值给c1返回调用对象cin，再赋值给c2，返回cin，最后把下一个非空白字符赋值给c3</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ct=<span class="number">0</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cin.<span class="built_in">get</span>(ch);<span class="comment">//如果这里替换位&gt;&gt;下面将不会退出循环</span></span><br><span class="line"><span class="keyword">while</span>(ch!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; ch;</span><br><span class="line">    ct++;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设输入 I C++ clearly.&lt;Enter&gt;</span></span><br><span class="line"><span class="comment">//最终输出会跳过空格，输出IC++clearly.</span></span><br></pre></td></tr></table></figure><p>2.<strong>字符串输入</strong>：get()、getline()和ignore()</p><ul><li><strong>cin.get()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">get</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>,<span class="type">char</span>)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">get</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">- <span class="type">char</span>*:放置输入字符串的内存单元的地址</span><br><span class="line">- <span class="type">int</span>:比读取的最大字符大<span class="number">1</span>，额外的一个字符用于存储结果为空字符</span><br><span class="line">- <span class="type">char</span>:指定用作分界符的字符，只有两个参数时将使用换行符用作分界符</span><br><span class="line">    </span><br><span class="line">cin.<span class="built_in">get</span>(array,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>无参数时，读入一个字符，包括换行符，常用来处理输入缓冲区中的换行符。</p><p>有参数时，从缓冲区读取数据，到达行尾或size-1个字符**(剩下的空间储存在结尾添加的空字符)<strong>后结束读取(超过规定字符数不会出现错误,会直接截断)，不会对换行符进行处理，将</strong>其留在输入流**。</p><ul><li><strong>cin.getline()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>,<span class="type">char</span>)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">- <span class="type">char</span>*:放置输入字符串的内存单元的地址</span><br><span class="line">- <span class="type">int</span>:比读取的最大字符大<span class="number">1</span>，额外的一个字符用于存储结果为空字符</span><br><span class="line">- <span class="type">char</span>:指定用作分界符的字符，只有两个参数时将使用换行符用作分界符</span><br><span class="line">    </span><br><span class="line">cin.<span class="built_in">getline</span>(array,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>从缓冲区读取数据,到达行尾或size-1**(剩下的空间储存在结尾添加的空字符)**个字符结束读取(超过规定的字符数会出现错误,中断)，会读取并丢弃输入流中的换行符。</p><ul><li><strong>ignore()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">ignore</span><span class="params">(<span class="type">int</span> =<span class="number">1</span>,<span class="type">int</span>= EOF)</span></span>;</span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">255</span>,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">255</span>,<span class="string">&#x27;\n&#x27;</span>).<span class="built_in">ignore</span>(<span class="number">255</span>,<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//可拼接</span></span><br></pre></td></tr></table></figure><p>原型为两个参数提供的默认值为1和EOF，EOF导致读取指定数目的字符或读取到文件结尾</p><p><code>cin.ignore</code> 是 C++ 中用于忽略输入流中一定数量字符或特定字符的函数。这个函数通常用于清除输入缓冲区中的不需要的字符，以便在后续的输入操作中不受其影响。</p><h2 id="文件输入输出">文件输入输出</h2><h3 id="文件输入输出-2">文件输入输出</h3><p><strong>iostream: 头文件中定义了一个处理输出的ostream类</strong></p><p><strong>fstream：头文件定义了一个用于处理输出的ofstream类</strong></p><p><strong>文件的输出主要步骤如下</strong>:</p><ol><li><p>包含头文件fstream，iostream</p></li><li><p>创建一个ofstream（output fstream）对象（<strong>通常取名为outFile</strong>）</p></li><li><p>将该ofstream 对象同一个文件关联起来(使用open方法)。</p></li><li><p>向cout那样使用ofstream对象（通常outFile）</p><p><strong>重点</strong>：cout在屏幕上输出，而outFile是在文件中输出（写入）</p></li><li><p>outFile.close()关闭文件流</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span><span class="comment">//步骤1</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">ofstream outFile;<span class="comment">//步骤2</span></span><br><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>,std::ios::out);<span class="comment">//步骤3以写入的方式打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!outFile.<span class="built_in">is_open</span>()) </span><br><span class="line">&#123;<span class="comment">//判断文件是否打开成功，打开成功返回true</span></span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>()</span><br><span class="line">&#123;</span><br><span class="line">    outFile &lt;&lt; data &lt;&lt; endl;<span class="comment">//步骤4，输入文件中</span></span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">    outFile.<span class="built_in">close</span>();<span class="comment">//步骤5，关闭文件流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>文件的输入包括以下步骤</strong>：</p><ol><li><p>包含头文件iostream，包含头文件fstream</p></li><li><p>声明一个或多个<strong>ifstream</strong>（<strong>input fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为inFile</strong></p></li><li><p>将ifstream对象与文件关联起来。为此，方法之一是使用open()方法</p></li><li><p>可结合ifstream对象 和运算符&gt;&gt;来输入各种类型的数据。</p></li><li><p>使用inFile.close()关闭文件流</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">255</span>];</span><br><span class="line">    ifstream inFile;<span class="comment">//步骤2</span></span><br><span class="line">    inFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,std::ios::in);<span class="comment">//步骤3</span></span><br><span class="line">    <span class="keyword">if</span> (!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!inFile.<span class="built_in">eof</span>())<span class="comment">//判断是否读取到文件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        inFile &gt;&gt; data;<span class="comment">//步骤4</span></span><br><span class="line">        inFile.<span class="built_in">getline</span>(str,<span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">close</span>();<span class="comment">//步骤5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查文件-2">检查文件</h3><p>格式为: 对象名.isopen()  例：   <strong>inFile.is_open()</strong></p><p>如果文件成功被打开，返回<strong>true</strong>；如果文件没有被打开，<strong>因此表达式   !inFile.is_open()  将为true</strong></p><p><strong>通常使用下方代码判断是否打开成功</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//exit(0)程序正常结束</span></span><br><span class="line"><span class="comment">//exit(1)程序异常结束</span></span><br><span class="line"><span class="comment">//exit()使用需要用到头文件cstdlib</span></span><br></pre></td></tr></table></figure><h3 id="判断文件结尾">判断文件结尾</h3><p>格式为：对象名.eof()  例:   <strong>inFile.eof()</strong></p><p><strong>eof在遇到EOF（文件结束标志）时返回ture ，否则返回false</strong></p><p>通常和while循环一起用作文件读取结束，<strong>!inFile.eof</strong>在文件结束前为真，结束为假（退出循环）</p><p>具体格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!inFile.<span class="built_in">eof</span>())<span class="comment">//判断是否读取到文件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        inFile &gt;&gt; data;<span class="comment">//步骤4</span></span><br><span class="line">        inFile.<span class="built_in">getline</span>(str,<span class="number">255</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="文件打开关闭">文件打开关闭</h3><ul><li><strong>文件打开</strong>：</li></ul><p>**1.对象名.open(“文件名”) **（一个参数）例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果文件不存在，将会自动创建一个相同名字的文件,如果文件存在，将会打开该文件，首先截断该文件，将其长度截短到0，丢弃原有的内容，然后将新的输入加入到该文件中</p><p><strong>2.对象名.open(“文件名”，打开方式)</strong> （两个参数）例如 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,std::ios::in)</span><br></pre></td></tr></table></figure><p>只读模式以只读模式打开</p><ul><li><strong>文件关闭</strong>：</li></ul><p>格式：对象名.close()  例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>注意方法close()，不需要使用文件名作为参数，因为outFile已经同特定的文件关联起来，如果忘记关闭文件，程序正常终止的时候将自动关闭它。</p><h3 id="打开多个文件">打开多个文件</h3><p>打开多个文件时可以同时打开多个文件流：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">std::ifstream userInFile,managerInFile;</span><br><span class="line">    userInFile.<span class="built_in">open</span>(<span class="string">&quot;user_data.txt&quot;</span>, std::ios::in);</span><br><span class="line">    managerInFile.<span class="built_in">open</span>(<span class="string">&quot;manager_data.txt&quot;</span>, std::ios::in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!userInFile.<span class="built_in">is_open</span>()||!managerInFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(!userInFile.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">while</span>(!managerInFile.<span class="built_in">eof</span>())</span><br><span class="line"> &#123;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">    userInFile.<span class="built_in">close</span>();</span><br><span class="line">    managerInFile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件打开模式">文件打开模式</h3><p><a href="https://blog.csdn.net/digitalkee/article/details/105799054?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=c++%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%A8%A1%E5%BC%8F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105799054.142%5Ev99%5Epc_search_result_base1&amp;spm=1018.2226.3001.4187">C++ open 打开文件（含打开模式一览表）_c++ open函数-CSDN博客</a></p><h1>c++新标准</h1><p><strong>更多内容见C++ primer plus 18章</strong></p><h2 id="统一的初始化">统一的初始化</h2><p>C++11扩大了大括号扩起的列表，即初始化列表的使用范围，使其可用于所有内置类型和用户定义的类对象。使用初始化列表时，可添加等号，也可不添加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">double</span> y&#123;<span class="number">2.75</span>&#125;;</span><br><span class="line"><span class="type">short</span> quar[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">76</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>另外初始化列表可用于new表达式中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ar = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>] &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;<span class="comment">//c++11</span></span><br></pre></td></tr></table></figure><h2 id="右值引用">右值引用</h2><h3 id="左值和右值：">左值和右值：</h3><ul><li><p><strong>左值（lvalue）：</strong> <strong>左值是可以标识内存位置的表达式</strong>。通常，左值是具有名称的变量、对象或表达式的结果，它们可以出现在等号的左边，可以被取地址。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;  <span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span>* ptr = &amp;x;  <span class="comment">// &amp;x 是左值，因为它是地址</span></span><br></pre></td></tr></table></figure></li><li><p><strong>右值（rvalue）：</strong> <strong>右值是不能标识内存位置的表达式</strong>。右值通常是临时的、<strong>无法取地址的值</strong>，出现在等号的右边。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">10</span> + <span class="number">5</span>;  <span class="comment">// 10 + 5 是右值</span></span><br><span class="line"><span class="type">int</span> z = x + y;   <span class="comment">// x + y 是右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z = x;<span class="comment">//x不是右值，可以取地址</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="左值引用和右值引用：">左值引用和右值引用：</h3><ul><li><p><strong>左值引用（lvalue reference）：</strong> 左值引用是用于引用左值的引用类型。它使用 <code>&amp;</code> 符号声明。<strong>左值引用主要用于在函数中传递参数或作为函数的返回类型，以及在赋值操作中</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = x;  <span class="comment">// ref 是对 x 的左值引用</span></span><br></pre></td></tr></table></figure></li><li><p><strong>右值引用（rvalue reference）：</strong> <strong>右值引用是用于引用右值的引用类型</strong>。它使用 <code>&amp;&amp;</code> 符号声明。<strong>右值引用通常与移动语义一起使用，允许有效地将资源从一个对象移动到另一个对象，而不进行深层复制</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">10</span> + <span class="number">5</span>;  <span class="comment">// rref 是对右值的引用</span></span><br><span class="line"><span class="comment">//无法对rref取地址</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>右值引用通常与移动语义结合，例如在移动构造函数和移动赋值运算符中使用，提高了对动态分配资源的效率。左值引用用于传递可修改的参数，而右值引用用于支持移动操作。</strong></p><h2 id="Lambda函数">Lambda函数</h2><p>在C++中，lambda 表达式是一种方便的方式，允许你在函数内部定义匿名函数。它的语法形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// lambda body</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>capture</code> 是捕获列表，用于指定在 lambda 表达式中可以访问的外部变量。</li><li><code>parameters</code> 是 lambda 函数的参数列表。</li><li><code>return_type</code> 是返回类型。</li><li><code>lambda body</code> 包含实际的函数体。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operateWithLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 表达式，接受两个参数，返回它们的和</span></span><br><span class="line">    <span class="keyword">auto</span> add1 = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式计算并输出结果</span></span><br><span class="line">    <span class="type">int</span> result1 = <span class="built_in">add1</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum1 is: &quot;</span> &lt;&lt; result1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 表达式也可以访问外部变量</span></span><br><span class="line">    <span class="keyword">auto</span> add2 = [x,y]() -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> result2 = <span class="built_in">add2</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum2 is: &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> addWithExternal = [x](<span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式计算并输出结果</span></span><br><span class="line">    <span class="type">int</span> resultWithExternal = <span class="built_in">addWithExternal</span>(y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum with external variable is: &quot;</span> &lt;&lt; resultWithExternal &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">operateWithLambda</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的关键字用法</title>
      <link href="/posts/d29d5856.html"/>
      <url>/posts/d29d5856.html</url>
      
        <content type="html"><![CDATA[<h1>类型转换运算符</h1><p>C++中，类型转换运算符允许你在不同类型之间执行转换。这些运算符允许你显式地将一个类型转换为另一个类型。C++中有四种类型转换运算符：</p><h2 id="static-cast">static_cast</h2><p><strong>用途</strong>： 主要用于进行静态类型转换，例如将指针或引用从一种类型转换为另一种类型，但在转换时<strong>没有运行时检查</strong>。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> doubleValue = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> intValue = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(doubleValue);</span><br></pre></td></tr></table></figure><h2 id="dynamic-cast">dynamic_cast</h2><ul><li><strong>用途</strong>： 主要用于进行安全的动态类型转换，只能在<strong>指针或引用</strong>之间转换，<strong>通常在基类指针或引用和派生类之间进行类型转换</strong>。在运行时，<code>dynamic_cast</code>会检查转换的合法性，成功转换返回新指针，否则返回空指针。</li><li><strong>示例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Base* basePtr = <span class="keyword">new</span> Derived  <span class="comment">/* 指向派生类对象的基类指针 */</span>;</span><br><span class="line">Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (derivedPtr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 转换成功,非空指针</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 转换失败，空指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*有效性检验*/</span></span><br></pre></td></tr></table></figure><h2 id="const-cast">const_cast</h2><ul><li><strong>用途</strong>：主要用于添加或移除<code>const</code>性质。它可以用于去除<strong>指针或引用</strong>的<code>const</code>限定，也可以用于在必要时添加<code>const</code>限定。</li><li><strong>示例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> constValue = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* nonConstPtr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;constValue);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="reinterpret-cast">reinterpret_cast</h2><ul><li><strong>用途</strong>： 执行低级别的类型转换，例如将<strong>指针转换为整数或整数转换为指针</strong>。它是一种较为危险的转换，因为它不进行类型检查。</li><li><strong>示例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intValue = <span class="number">42</span>;</span><br><span class="line"><span class="type">double</span>* doublePtr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">double</span>*&gt;(&amp;intValue);</span><br></pre></td></tr></table></figure><h2 id="注意事项和使用推荐">注意事项和使用推荐</h2><p><strong>static_cast</strong>：</p><ul><li><p>注意事项：</p><ul><li><code>static_cast</code> 在大多数情况下是相对安全的，但它不能执行运行时检查。</li><li>避免进行不安全或不明确的类型转换，以免引起问题。</li></ul></li><li><p>推荐用途：</p><ul><li>用于执行基本的类型转换，如数值之间的转换，非多态类之间的指针或引用转换。</li><li>在继承层次结构中进行上行转换（基类指针或引用到派生类）。</li></ul></li></ul><p><strong>dynamic_cast</strong>：</p><ul><li>注意事项：<ul><li>仅在存在虚函数的类层次结构中使用 <code>dynamic_cast</code>。</li><li>它会进行运行时类型检查，但只适用于多态类型。</li><li>在使用时要注意返回的指针可能为空，因此需要进行有效性检查。</li></ul></li><li>推荐用途：<ul><li>用于在运行时执行安全的下行转换（派生类指针或引用到基类）。</li><li>用于判断对象的实际类型。</li></ul></li></ul><p><strong>const_cast</strong>：</p><ul><li>注意事项：<ul><li>避免使用 <code>const_cast</code> 去除真正的 <code>const</code> 修饰符，因为这可能导致未定义行为。</li><li>可以用于去除指针或引用上的 <code>const</code> 修饰，但确保不修改原始对象。</li></ul></li><li>推荐用途：<ul><li>用于在函数调用或某些特殊情况下去除指针或引用的 <code>const</code> 限定。</li></ul></li></ul><p><strong>reinterpret_cast</strong>：</p><ul><li>注意事项：<ul><li>非常危险，可能导致未定义行为。</li><li>通常用于底层的硬件交互或者特殊的内存布局情况。</li></ul></li><li>推荐用途：<ul><li>尽量避免使用 <code>reinterpret_cast</code>，除非你确切地了解底层的内存表示和硬件特性。</li></ul></li></ul><h1>explicit</h1><p>C++中的explicit关键字<strong>通常</strong>用于修饰<strong>只有一个参数</strong>的类构造函数, 以指定该构造函数不会被用于隐式类型转换。当构造函数被标记为<strong>explicit</strong>时，它只能被显式调用，而不能隐式地将其参数转换为相应的类类型。跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).</p><p><strong>explicit关键字的作用</strong>：避免类构造函数的隐式自动转换.</p><h2 id="使用说明">使用说明</h2><ul><li><strong>使用了explicit关键字后</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span> : data(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1 = <span class="number">10</span>;  <span class="comment">// 会报错！不能进行隐式类型转换，10不允许被转换为MyClass类型</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;   <span class="comment">// 正确！显式调用构造函数</span></span><br><span class="line">    std::cout &lt;&lt; obj2.<span class="built_in">getData</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>未使用explicit</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">data</span>(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1 = <span class="number">10</span>;  <span class="comment">// 正确！隐式类型转换</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;   <span class="comment">// 正确！显式调用构造函数</span></span><br><span class="line">    std::cout &lt;&lt; obj2.<span class="built_in">getData</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类型转换">类型转换</h2><ol><li><strong>隐式类型转换</strong>：</li></ol><p>在第一个例子中，当我们尝试将一个整数直接赋值给<code>MyClass</code>对象时，发生了隐式类型转换。具体来说，整数<code>10</code>被隐式地转换为<code>MyClass</code>类型的对象。这是因为构造函数没有被声明为<code>explicit</code>，因此编译器可以自动执行类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj1 = <span class="number">10</span>;  <span class="comment">// 隐式类型转换</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>显式类型转换</strong>：</li></ol><p>在两个示例中，都使用了显式类型转换，即通过构造函数来显式创建对象。在第一个例子中，由于构造函数被声明为<code>explicit</code>，因此必须显式调用构造函数来创建对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;  <span class="comment">// 显式类型转换，调用构造函数</span></span><br><span class="line">MyClass obj2 = <span class="built_in">MyClass</span>(<span class="number">20</span>);<span class="comment">//上面等价于这个,但某种情况下可能会增加开销，建议使用上面的更简洁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*在这个语句中，整数 20 被显式地转换为 MyClass 类型的对象，而转换的具体过程是通过调用构造函数来实现的。*/</span></span><br></pre></td></tr></table></figure><p>总之，隐式类型转换是指在不显式指定类型转换的情况下，由编译器自动执行的类型转换。而显式类型转换则是通过显式调用构造函数或其他类型转换操作符来指定类型转换的过程。在使用<code>explicit</code>关键字时，它会禁止隐式类型转换，要求显式地调用构造函数来执行类型转换。</p><h2 id="优点和缺点">优点和缺点</h2><p><strong>优点</strong>：</p><ol><li><strong>明确转换意图：</strong> 明确指定了构造函数的调用方式，防止了隐式类型转换，使代码更加清晰易懂，降低了代码的误解和错误发生的概率。</li><li><strong>增强类型安全性：</strong> 显式指定构造函数调用可以减少类型转换的不确定性，使代码更加健壮，减少了潜在的类型错误。</li><li><strong>减少不必要的转换：</strong> 防止了不必要的自动类型转换，避免了一些不必要的中间步骤和临时对象的创建，提高了程序的性能和效率。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>冗长繁琐：</strong> 使用<code>explicit</code>关键字会使代码变得更加冗长和繁琐，因为在每次创建对象时都需要显式地调用构造函数，增加了代码的复杂度和书写量。</li><li><strong>限制灵活性：</strong> 在某些情况下，隐式类型转换可能会使代码更加简洁和灵活，而使用<code>explicit</code>关键字会限制这种灵活性，使代码的编写和使用更加受限。</li><li><strong>破坏现有代码：</strong> 在现有的代码库中添加<code>explicit</code>关键字可能会破坏原有的隐式类型转换逻辑，导致代码无法编译或者行为发生改变，增加了代码修改和维护的成本。</li></ol><p>综上所述，虽然<code>explicit</code>关键字可以提高代码的安全性和清晰度，但在使用时需要权衡其带来的好处和坏处，根据具体情况来决定是否使用。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Clion上愉快的写Qt</title>
      <link href="/posts/36b81ed7.html"/>
      <url>/posts/36b81ed7.html</url>
      
        <content type="html"><![CDATA[<h1>Clion配置Qt工具链</h1><p><a href="https://blog.csdn.net/Dusk_Clouds/article/details/120791223?spm=1001.2014.3001.5506">CLion配置qt环境-CSDN</a></p><h1>Clion配置外部工具</h1><h2 id="配置外部工具Qt-Creator和UIC等">配置外部工具Qt Creator和UIC等</h2><ul><li><strong>在Clion的设置中打开外部工具</strong></li><li><strong>名称填QT Creator</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">工具设置<span class="punctuation">:</span></span><br><span class="line"> 程序<span class="punctuation">:</span> qtcreator.exe的根路径</span><br><span class="line"> 实参： $FileName$</span><br><span class="line"> 工作目录<span class="punctuation">:</span> $FileDir$</span><br><span class="line"></span><br><span class="line">其他外部工具同理</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>可通过Qt creator外部工具打开.ui文件实现拖动部件设计UI，在Clion直接编译会自动将.ui文件转化为C++对应的头文件，不需要UIC转换</strong></p></div><h2 id="分块查找">分块查找</h2><h1>配置 Qt creator</h1><p><strong>写Qt有两种方法</strong>：</p><ul><li>直接在Qt creator 中创建项目，Build system选择qmake，Kits选择Qt minGW 64-bit/32-bit即可开始</li><li>将Clion与Qt creator联合使用来写Qt，下面介绍如何配置</li></ul><p>为了使Clion和Qt creator 同时使用来完成UI的设计</p><ul><li><p>首先需要在Qt中先创建项目选择Qt Widgets Application,取名并选择路径</p></li><li><p>在Build System 中选择Cmake</p></li><li><p>在Class information 中选择基类一共有三种(QMainWindow,QWidget,QDialog),任意选择一种即可，一般选择前面的，类名可随便定义你自己喜欢的(下面默认为widget)</p></li><li><p>Kits 中选择Kits选择Qt minGW 64-bit/32-bit即可</p></li><li><p>创建项目成功</p></li><li><p>用Clion打开对应项目文件夹</p></li><li><p>在Clion中用外部工具打开widget.ui，在其中拖动部件即可</p></li><li><p>可在widget的构造函数中添加代码实现与拖动部件相同功能</p></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>在创建项目时，若提示no suitable kits，即没有kits可以使用时，可能是没有下载cmake或cmake没有添加到环境变量，此时去官网下载cmake或创建环境变量即可</p></div><h1>配置Qt Resource File</h1><p>当要使用图片，动态图片等资源设置背景时，需要在项目根目录下创建Qt Resource File 文件</p><h2 id="只使用Qt-Creator">只使用Qt Creator</h2><ul><li><p>当使用的时qmake时，直接在项目根目录右键Add New然后创建Qt Resource File</p></li><li><p>随便取名称(以下用resource),路径为默认路径(项目根目录)</p></li><li><p>此时Qt creator会在项目根目录下创建一个Resources文件夹，里面有个文件resource.qrc</p></li><li><p>先点击Add Prefix，然后在下面将前缀改为单独一个&quot;/“即可，此时创建出一个”/&quot;的根目录</p></li><li><p>接下来再点击Add Files，选择你要添加的图片或动态图(注意要把图片放在项目根目录下)，Ctrl+S保存</p></li><li><p>然后在改变样式表中添加资源即可看见添加的资源</p></li></ul><h2 id="使用Clion">使用Clion</h2><ul><li><p>在Qt Creator中打开用cmake配置的项目，在根目录直接在项目根目录右键Add New然后创建Qt Resource File</p></li><li><p>随便取名称(以下用resource),路径为默认路径(项目根目录)</p></li><li><p>接下来在Clion中打开该项目，即可看到一个resource.qrc文件</p></li><li><p>然后用外部工具Qt creator打开resource.qrc文件，在里面进行Add Prefix,和Add Files(见上方)，Ctrl+S保存(一定要保存否则不会生效)</p></li><li><p>创建完之后在CMakeLists.txt中将resource.qrc添加进add_executable中</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ANDROID)</span><br><span class="line">  <span class="built_in">add_library</span>(qt_pj_stylesheet SHARED</span><br><span class="line">    main.cpp</span><br><span class="line">    widget.cpp</span><br><span class="line">    widget.h</span><br><span class="line">    widget.ui</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="built_in">add_executable</span>(qt_pj_stylesheet</span><br><span class="line">    main.cpp</span><br><span class="line">    widget.cpp</span><br><span class="line">    widget.h</span><br><span class="line">    widget.ui</span><br><span class="line">    resource.qrc<span class="comment">//只需要添加这一个地方即可</span></span><br><span class="line">  )</span><br><span class="line"><span class="built_in">endif</span>()</span><br></pre></td></tr></table></figure><p>然后直接编译即可</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt</title>
      <link href="/posts/b511cbcf.html"/>
      <url>/posts/b511cbcf.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://note.youdao.com/web/#/file/recent/note/09695FF39793403CAF4C924E2E5E55B4/">笔记 (youdao.com)</a></p><p>视频等详细资料在U盘中</p><img src="/assets/2.webp" alt="示例图片" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/posts/735e5788.html"/>
      <url>/posts/735e5788.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法概述</title>
      <link href="/posts/1ce63292.html"/>
      <url>/posts/1ce63292.html</url>
      
        <content type="html"><![CDATA[<h1>算法的概念</h1><p>算法（algorithm）是解决一系列问题的<strong>清晰指令</strong>，也就是，能对一定规范的输入，在有限的时间内获得所要求的输出。</p><p>​    简单来说，算法就是解决一个问题的具体方法和步骤。算法是<strong>程序的灵魂</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序 = 算法+数据结构</span><br></pre></td></tr></table></figure><h1>算法的特征</h1><h2 id="可行性">可行性</h2><p>​        算法中执行的任何计算步骤都可以分解为基本可执行的操作步，即每个计算步都可以在有限时间里完成（也称之为有效性）</p><h2 id="确定性">确定性</h2><p>​        算法的每一步都要有确切的意义，不能有二义性。例如“增加x的值”，并没有说增加多少，计算机就无法执行明确的运算。</p><h2 id="有穷性">有穷性</h2><p>​        算法的有穷性是指算法必须在执行有限个步骤后终止。操作次数不宜过大，不能超过人们事先设定的时间限制。</p><h2 id="输入">输入</h2><p>算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法已经给出了初始条件。</p><h2 id="输出">输出</h2><p>一个算法可能有1个或多个输出，以反映输入数据加工后的代码，没有输出的算法是没有意义的！</p><h1>算法的评价</h1><p>通常一个好算法应该达到如下目标：</p><h2 id="正确性">正确性</h2><p>算法应该正确的解决问题。</p><h2 id="可读性">可读性</h2><p>算法应该具有较好的可读性，让人们理解算法的作用。</p><h2 id="健壮性">健壮性</h2><p>输入非法数据时，算法也可以做出适当的反应，而不会产生奇奇怪怪的输出。</p><h1>算法的复杂度</h1><p><strong>算法复杂度</strong>是指算法在变为可执行程序后所耗费的时间资源和内存,一般分为两种。</p><ul><li><p><strong>时间复杂度</strong>：评估程序所需要的时间。</p></li><li><p><strong>空间复杂度</strong>：评估程序所需要的储存空间。</p></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>空间复杂度一般不作考虑，一般都优先考虑时间复杂度。</p></div><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">常见时间复杂度</span><br><span class="line"></span><br><span class="line">复杂度标记符号          说明</span><br><span class="line">常量 O(<span class="number">1</span>)   操作数量为常数，与输入数据的规模无关</span><br><span class="line">对数 O(log2n)    与输入数据的比例是 log2（n）</span><br><span class="line">线性 O(n)        与输入数据成正比</span><br><span class="line">平方 O(n²)        与输入数据规模的比例为平方</span><br><span class="line">立方 O(n³)        与输入数据规模的比例为立方</span><br><span class="line"></span><br><span class="line">      O(<span class="number">2</span>ⁿ)</span><br><span class="line">指数   O(kⁿ)           快速增长，应该尽量减少这种代码</span><br><span class="line">      O(n!)</span><br><span class="line">   </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法</title>
      <link href="/posts/e2adee35.html"/>
      <url>/posts/e2adee35.html</url>
      
        <content type="html"><![CDATA[<h1>线性表查找</h1><h2 id="顺序查找">顺序查找</h2><h3 id="算法介绍">算法介绍</h3><p>顺序查找算法又称<strong>顺序搜索算法</strong>或者<strong>线性搜索算法</strong>，是所有查找算法中最基本、最简单的，对应的时间复杂度为<strong>O(n)</strong>。</p><p>顺序查找算法适用于绝大多数场景，既可以在有序序列中查找目标元素，也可以在无序序列中查找目标元素。</p><p>顺序查找的特点：</p><ul><li>方法简单</li><li>对表的结构无要求</li><li>查找效率低，当n较大时不宜采用</li></ul><h3 id="算法实现">算法实现</h3><p>实现思路：所谓顺序查找，指的是从待查找序列中的第一个元素开始，查看各个元素是否为要找的目标元素。若相同则查找成功返回对应数组下标；若遍历完整个数组也没有找到待查找元素，则说明查找失败，返回-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一个简单的顺序查找，其实就是一个<span class="keyword">for</span>循环</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> arr[N],<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==value)</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//匹配失败，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="效率分析">效率分析</h3><p><strong>时间复杂度：</strong></p><ul><li>最坏情况：若相同则查找成功返回对应数组下标；若遍历完整个数组也没有找到待查找元素，则说明查找失败，返回-1。</li><li>最好情况：最理想的情况就是待查找元素位于集合的第一个位置，程序只需执行一次循环和比较就成功找到待查找元素并返回退出，所以时间复杂度为O(1)。</li><li>平均情况：综合两种，顺序查找的时间复杂度为O(n)。</li></ul><p><strong>空间复杂度：</strong></p><ul><li>算法中只需设置一个临时变量用于控制循环次数和数组下标变化，没有借助额外的辅助空间，所以空间复杂度为O(1)。</li></ul><h2 id="二分查找">二分查找</h2><h3 id="算法介绍-2">算法介绍</h3><p>二分查找，又叫<strong>折半查找</strong>，通过找到数据二段性每次都能将原来的数据筛选掉一半，通过这个算法我们能够将一个一个查找的 O(n) 的时间复杂度优化到 O(log2n) ，极大地提升了查找的效率。</p><p>但使用二分进行查找必须要有一个前提，那就是查找的区间必须是<strong>有序的</strong>。如数组并非有序，则找不到该数组的的二段性。</p><p>二分查找的特点：</p><ul><li>效率较高</li><li>要求查找表有序</li><li>只适合顺序查找和建立后很少改动而只需要查找的表</li></ul><h3 id="算法实现-2">算法实现</h3><p>实现思路：</p><p>二分法的思想很简单，因为整个数组是有序的，数组默认是递增的。</p><ul><li>首先选择数组中间的数字mid和需要查找的目标值比较</li><li>如果相等最好，就可以直接返回答案了</li><li>如果不相等<ul><li>如果中间的数字大于目标值，则中间数字向右的所有数字都大于目标值，全部排除，再移动right到mid-1的位置</li><li>如果中间的数字小于目标值，则中间数字向左的所有数字都小于目标值，全部排除，再移动left到mid+1的位置</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">searchKey</span><span class="params">(KeyType key,SSTable ST)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right = ST.length;</span><br><span class="line">    <span class="comment">/*区间初值*/</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)<span class="comment">//一定要取等，最后left和right相等时为最后一种情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left+right)/<span class="number">2</span> <span class="comment">//找到中间元素</span></span><br><span class="line">        <span class="keyword">if</span>(key == ST.elem[mid].key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; ST.elem[mid].key)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid<span class="number">-1</span>;<span class="comment">//key在middle左边，将right移过来</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;<span class="comment">//key在middle右边，将left移动过来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效率分析-2">效率分析</h3><ul><li><p>时间复杂度：O(log2n)</p></li><li><p>空间复杂度：O(1) 或 O(log2n)，取决于二分查找的实现方式。如果使用迭代的方式，只需要一个变量来存储中间元素的下标，所以空间复杂度为 O(1)。如果使用递归的方式，每次递归调用都需要额外的栈空间，所以空间复杂度为 O(log2n)。</p></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>二分查找的优点和缺点分别是：</p><ul><li>优点：比较次数少，查找速度快，平均性能好。</li><li>缺点：要求待查表为有序表，且插入删除困难。</li></ul></div><h2 id="分块查找">分块查找</h2><h3 id="算法介绍-3">算法介绍</h3><p>分块查找也称为索引查找，分块查找是一种结合了二分查找和顺序查找的查找方法，它将数据分为若干个块，在索引查找法中，除表本身之外还需要建立一个索引表。由分块查找可知，它要分开进行，块内元素之间无大小关系，块与块之间有大小关系（比如说：第二块中的元素肯定要比第一块中大，第三块中元素肯定要比前两块中的元素大）所以索引表是有序的，但每一块中的元素无序，可以进行二分查找进行查找由于要有索引所以要用到结构体。</p><h3 id="算法实现-3">算法实现</h3><p>索引查找是在一定条件下使用（给索引表开值为3，代表查找表中元素个数要是3的倍数），则每个块中的元素个数为n/3,则在每个块中找出块中最大值，赋值给索引表，在对索引表的关键字进行比较排序</p><p>索引查找是先找到确定的块（这个过程可以进行二分也可以进行顺序查找（下边代码实现的是顺序查找））</p><p>确定块之后在块中进行顺序查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">分块查找代码示例:</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义块的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">index</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key; <span class="comment">// 块的最大值</span></span><br><span class="line">    <span class="type">int</span> start; <span class="comment">// 块的起始位置</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*索引表中的每个元素包括该块中的最大值和块的起始位置*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量，存储索引表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">index</span> <span class="title">newIndex</span>[3];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义分块查找函数，参数为待查元素和数据数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">blockSearch</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义变量，存储左右边界和中间位置</span></span><br><span class="line">    <span class="type">int</span> left, right, mid;</span><br><span class="line">    <span class="comment">// 初始化左右边界(索引表的)</span></span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    right = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 1.二分查找：在索引表中用二分查找确定待查元素所在的块</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 计算中间位置</span></span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 如果找到了所在的块，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt;= newIndex[mid].key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果待查元素大于中间位置的最大值，由于是有序的，索引说明只能在在右半部分，更新左边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有找到所在的块，返回-1表示查找失败</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在确定的块中用顺序查找找到待查元素</span></span><br><span class="line">    <span class="comment">// 获取块的起始位置和结束位置</span></span><br><span class="line">    <span class="type">int</span> start = newIndex[mid].start;</span><br><span class="line">    <span class="type">int</span> end = start + <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 2.顺序查找：遍历块中的元素，如果找到了待查元素，返回其位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有找到待查元素，返回-1表示查找失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义数据数组</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">33</span>, <span class="number">42</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">24</span>, <span class="number">48</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">74</span>, <span class="number">49</span>, <span class="number">86</span>, <span class="number">53</span>&#125;;</span><br><span class="line">    <span class="comment">// 定义变量，存储块的数量和数据的总个数</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">18</span>;</span><br><span class="line">    <span class="comment">// 定义变量，为每个块内的元素个数</span></span><br><span class="line">    <span class="type">int</span> size = n / m;</span><br><span class="line">    <span class="comment">// 定义变量，存储待查元素</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="comment">// 确定每个块的最大值和起始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化每个块的起始位置</span></span><br><span class="line">        newIndex[i].start = i * size;</span><br><span class="line">        <span class="comment">// 初始化每个块的最大值为第一个元素的值</span></span><br><span class="line">        newIndex[i].key = arr[i * size];</span><br><span class="line">        <span class="comment">// 遍历每个块中的元素，更新每个块的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * size; j &lt; (i + <span class="number">1</span>) * size; j++)</span><br><span class="line">        &#123;        <span class="comment">/*条件为下个块之前*/</span></span><br><span class="line">            <span class="keyword">if</span> (newIndex[i].key &lt; arr[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                newIndex[i].key = arr[j];<span class="comment">//更新每个块的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输入待查元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要查找的元素：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line">    <span class="comment">// 调用分块查找函数，获取结果</span></span><br><span class="line">    <span class="type">int</span> result = blockSearch(key, arr);</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败，没有找到该元素。\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找成功，该元素在数组中的位置是：%d\n&quot;</span>, result + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效率分析-3">效率分析</h3><ul><li>时间复杂度：O(log2m + n/m)，其中 m 是块的数量，n 是数据的总个数，n/m为每个块元素个数。这是因为在分块查找过程中，需要先在索引表中用二分查找或顺序查找确定待查元素所在的块，这一步的时间复杂度为 O(log2m) 或 O(m)；然后在已确定的块中用顺序查找找到待查元素，这一步的时间复杂度为 O(n/m)。因此，分块查找的总时间复杂度为 O(log2m + n/m) 或 O(m + n/m)。</li><li>空间复杂度：O(m)，这是因为分块查找需要额外的空间来存储索引表，索引表的大小为 m。</li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li>优点：插入删除比较容易，无需进行大量移动。如果线性表既要快速查找又经常动态变化，则可采用分块查找。</li><li>缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算。如果分块过于稀疏或过于密集，都会影响查找效率。</li></ul></div><h1>树表的查找</h1><h2 id="二叉排序树">二叉排序树</h2><h3 id="二叉排序树-介绍">二叉排序树-介绍</h3><p><strong>二叉排序树</strong>又称为二叉搜索树、二叉查找树。二叉排序树或是空树，或是满足如下性质的二叉树：</p><ul><li>若它的<strong>左子树</strong>非空，则左子树上所有结点的值均<strong>小于它根结点的值</strong>。</li><li>若它的<strong>右子树</strong>非空，则右子树上所有结点的值均<strong>大于它根结点的值</strong>。</li><li>它的左、右树又本身是一颗⼆叉排序树</li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>二叉排序树性质</strong>：</p><p><strong>中序遍历</strong>非空的二叉排序树所得到的数据元素序列是一个按关键字排列的<strong>递增有序</strong>序列，即结点的从小到大顺序。</p></div><h3 id="二叉排序树-查找">二叉排序树-查找</h3><p><strong>查找思路：</strong></p><ul><li>若查找的关键字等于根节点，查找成功</li><li>若查找的关键字不等于根节点<ul><li>小于根节点，查找其左子树</li><li>若大于根节点，查找其右子树</li></ul></li><li>再左右子树上的查找与其类似</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    KeyType key; <span class="comment">//关键字项</span></span><br><span class="line">    infoType otherinfo;<span class="comment">//其他数据域</span></span><br><span class="line">&#125;ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>* <span class="title">lchild</span>;</span><span class="comment">//左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>* <span class="title">rchild</span>;</span><span class="comment">//右孩子</span></span><br><span class="line">&#125;BSTNode,*BSTree;</span><br><span class="line"></span><br><span class="line">BSTree T;<span class="comment">//定义二叉排序树T</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>二叉排序树的递归查找算法思想：</strong></p><ol><li>若二叉排序树为空，则查找失败，直接返回空指针。</li><li>若二叉排序树非空，将给定值key与根结点的关键字进行比较如果成功返回根结点地址，若小于data.key则查找左子树，若data.key则查找右子树。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉排序树递归查找函数*/</span></span><br><span class="line"></span><br><span class="line">BSTree <span class="title function_">searchBST</span><span class="params">(BSTree T,KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(key==T-&gt;data.key||T==<span class="literal">NULL</span>)<span class="comment">//树为空或找到了直接返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data.key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> searchBST(T-&gt;lchild,key);<span class="comment">//在左子树中继续寻找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span> searchBST(T-&gt;rchild,key); <span class="comment">//在右子树中继续寻找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉排序树的平均查找长度(ASL)和树的形态有关，一般来说树的高度越高，平均查找长度越大</strong></p><p>时间复杂度最好情况为O(log2n)，树的深度为：[log2n]+1，此时与折半查找中的判定树相同.</p><p>时间复杂度最坏为O(n)，树的深度为n，插入的元素变成了单支树的形态</p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>问题: 如何提高形态不均衡的二叉排序树的查找效率？</strong></p><p><strong>解决方法</strong>：做“平衡化”处理，尽量让二叉树的形状均衡。即实现平衡二叉树</p></div><h3 id="二叉排序树-插入">二叉排序树-插入</h3><p><strong>生成二叉排序树的过程就是插入的过程</strong></p><p><strong>插入思路：</strong></p><ul><li><p>若二叉排序树为空，则插入结点作为根节点插入到空树中</p></li><li><p>若二叉排序树为非空，则在其左右子树上查找</p><ul><li>树中已有，不再插入，直接返回</li><li>树中没有，查找直到某个叶子结点的左子树或右子树为空位置，再将该节点插入为该叶子结点的左孩子或右孩子</li></ul><p><strong>插入的结点一定是叶子结点上</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//定义一个临时指针 用于移动</span></span><br><span class="line">tNode* temp = root;<span class="comment">//temp为插入位置的结点</span></span><br><span class="line">tNode* prev = <span class="literal">NULL</span>;<span class="comment">//定位到待插入位置的前一个结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = (tNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tNode));</span><br><span class="line">root-&gt;data = key; </span><br><span class="line">root-&gt;left = <span class="literal">NULL</span>; </span><br><span class="line">root-&gt;right = <span class="literal">NULL</span>; </span><br><span class="line">    &#125;<span class="comment">//若根节点为NULL，直接插入</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/*第一部分：找到要插入的位置*/</span></span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prev = temp; <span class="comment">//保存插入结点的双亲的位置</span></span><br><span class="line"><span class="keyword">if</span> (key &lt; temp-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;left;<span class="comment">//找左边子树，若移动后为空则代表找到了插入的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(key &gt; temp-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;right;<span class="comment">//找右边子树，移动后为空则代表找到了插入位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;已存在该结点&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//存在该结点直接返回插入失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*第二部分：插入结点*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*当结点左子树为空时*/</span></span><br><span class="line"><span class="keyword">if</span> (key &lt; prev-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">prev-&gt;left = (tNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tNode));</span><br><span class="line">prev-&gt;left-&gt;data = key; <span class="comment">//插入结点数据域</span></span><br><span class="line">prev-&gt;left-&gt;left = <span class="literal">NULL</span>; <span class="comment">//设置左孩子为空</span></span><br><span class="line">prev-&gt;left-&gt;right = <span class="literal">NULL</span>; <span class="comment">//设置右孩子为空</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*当结点右子树为空时*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">prev-&gt;right = (tNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tNode));</span><br><span class="line">prev-&gt;right-&gt;data = key;</span><br><span class="line">prev-&gt;right-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">prev-&gt;right-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意：</strong></p><p>不同插入次序的序列生成不同形态的二叉排序树。</p></div><h3 id="二叉排序树-删除">二叉排序树-删除</h3><p>在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下来，将因删除结点而断开的二叉链表重新链接起来，同时**确保二叉排序树的性质（左子树结点值＜根结点值＜右子树结点值）**不会丢失。</p><p><strong>删除操作一般会出现三种情况</strong>：</p><ol><li>若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。</li><li>若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。</li><li>若结点z有左、右两棵子树，有两种方法：</li></ol><ul><li>令z的直接前驱（或直接后继）替代z，然后从二叉排序树中删除这个直接后继或直接前驱，这样就转换成了第一或第二种情况，按照第一种或第二种情况再删除直接前驱或后继(常使用这种方法)。</li><li>先用z结点的左子树替代该结点，再将z结点的右子树作为z节点直接前驱的右子树（这种方法会可能会增加树的深度，常使用第一种方法处理）</li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注</strong>：</p><p>已知二叉排序树经过中序遍历可以得到一个递增的有序序列，这里的<strong>直接后继（或直接前驱）<strong>应该是指被删除结点在这个</strong>中序遍历序列中的直接后继（或直接前驱）。</strong><br> <br>体现在二叉排序树的图中:<br> 某个结点的直接后继为以该结点为根的<strong>右子树中最左下位置的结点</strong>，即右子树的<strong>最小值</strong>；<br> 某个结点的直接前驱为以该结点为根的<strong>左子树中最右下位置的结点</strong>，即左子树的<strong>最大值</strong>。</p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从二叉树中删除值为key的结点*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">deleteNode</span><span class="params">(BSTree &amp;T,KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTree p = T，temp = <span class="literal">NULL</span>, prior = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*先查找值为key的结点*/</span></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data.key == key)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//查找成功</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;data.key &lt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rchild;<span class="comment">//在右子树中寻找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;lchild;<span class="comment">//在左子树中寻找</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//找不到结点p为NULL，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; p-&gt;rchild==<span class="literal">NULL</span>)<span class="comment">//p为叶子结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>) <span class="comment">//p左子树为空，删p后重接右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;rchild==<span class="literal">NULL</span>)<span class="comment">//p右子树为空，删p后重接左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span><span class="comment">//左右子树均不为空,先找前驱结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        temp = temp-&gt;lchild;<span class="comment">//在左子树中寻找最大值，即删除结点的直接前驱</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;rchild)<span class="comment">//右子树为空时，找到结点退出循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            prior = temp;</span><br><span class="line">            temp = temp-&gt;rchild;<span class="comment">//继续寻找</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//while循环结果后：temp为直接前驱，prior为temp的双亲</span></span><br><span class="line">        p-&gt;data.key = temp-&gt;data.key;</span><br><span class="line">        <span class="comment">//将删除的结点替换为直接前驱</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prior!=p)<span class="comment">//直接前驱的双亲不为删除的结点时,前驱右孩子为NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*将直接前驱的左孩子重挂到双亲的右孩子上去，替代直接前驱的位置*/</span></span><br><span class="line">            prior-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span><span class="comment">//直接前驱的双亲为删除结点时,前驱右孩子为NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*直接将前驱的左子树(右子树为空)重挂到双亲的左子树上去替代直接前驱的位置*/</span></span><br><span class="line">            prior-&gt;lchild = temp-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">free</span>(temp);<span class="comment">//删除直接前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡二叉树">平衡二叉树</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL通用语法及操作</title>
      <link href="/posts/f2e69609.html"/>
      <url>/posts/f2e69609.html</url>
      
        <content type="html"><![CDATA[<h1>基础篇</h1><h2 id="SQL通用语法">SQL通用语法</h2><ul><li>SQL语句可以单行或多行书写，使用回车可换行继续书写<strong>最后以分号结尾</strong>。</li><li>SQL语句可以使用空格/缩进来增加语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>注释：</li><li>单行注释：-- 注释内容 或 # 注释内容（MySQL特有）</li><li>多行注释：/*注释内容*/</li></ul><h2 id="SQL分类">SQL分类</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DDL<span class="punctuation">:</span> 数据定义语言，用来定义数据库对象（数据库，表，字段）</span><br><span class="line">DML<span class="punctuation">:</span> 数据操作语言，用来对数据库表中的数据进行增删改</span><br><span class="line">DQL<span class="punctuation">:</span> 数据查询语言，用来查询数据库中表的记录</span><br><span class="line">DCL<span class="punctuation">:</span> 数据控制语言，用来创建数据库的用户、控制数据库的访问权限</span><br></pre></td></tr></table></figure><h2 id="SQL数据类型">SQL数据类型</h2><p>见这篇blog-&gt;<a href="https://blog.csdn.net/wangkun_j/article/details/113500282?ops_request_misc=%7B%22request%5Fid%22%3A%22169493216516800197069763%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169493216516800197069763&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-113500282-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=mysql%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B&amp;spm=1018.2226.3001.4187">MySQL字段类型最全解析_kun_行者的博客-CSDN博客</a></p><h2 id="SQL运算符">SQL运算符</h2><p><a href="https://blog.csdn.net/heart2070292037/article/details/122562132?ops_request_misc=%7B%22request%5Fid%22%3A%22169522393616800180688568%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169522393616800180688568&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-122562132-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=sql%E8%BF%90%E7%AE%97%E7%AC%A6&amp;spm=1018.2226.3001.4187">SQL学习之运算符_sql运算符有哪些_heart-szu的博客-CSDN博客</a></p><h2 id="SQL七大约束">SQL七大约束</h2><p><strong>约束条件用法参考这篇blog</strong><a href="https://blog.csdn.net/m0_64338546/article/details/128547998?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mysql%E7%BA%A6%E6%9D%9F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-128547998.nonecase&amp;spm=1018.2226.3001.4187">【MySQL基础】MySQL表的七大约束_mysql 表级约束_小杨MiManchi的博客-CSDN博客</a></p><h2 id="DDL-数据库操作和表操作">DDL(数据库操作和表操作)</h2><h3 id="数据库操作">数据库操作</h3><h4 id="查询">查询</h4><p><strong>查看所有数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure><p><strong>查询当前数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure><h4 id="创建">创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE<span class="operator">|</span>SCHEMA [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [<span class="keyword">DEFAULT</span> (CHARSET)<span class="operator">|</span>(<span class="type">CHARACTER</span> <span class="keyword">SET</span>) 字符集] [<span class="keyword">COLLATE</span> 排序规则];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">DEFAULT</span>这个单词在写代码的时候可以加也可以不加,最好加上</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> ETISTS teaching</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="删除">删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] 数据库名;</span><br></pre></td></tr></table></figure><h4 id="使用">使用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure><h4 id="查看">查看</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>结果会显示出创建命令和各参数设置(字符集，校对规则)</span><br></pre></td></tr></table></figure><h4 id="修改">修改</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE<span class="operator">|</span>SCHEMA [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [<span class="keyword">DEFAULT</span> (CHARSET)<span class="operator">|</span>(<span class="type">CHARACTER</span> <span class="keyword">SET</span>) 字符集] [<span class="keyword">COLLATE</span> 排序规则];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>注意：用户必须有数据库的修改权限才能使用该命令修改数据库</span><br></pre></td></tr></table></figure><h3 id="表操作">表操作</h3><h4 id="查询-2">查询</h4><p>查询当前数据库所有表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><p>查询表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 表明;</span><br></pre></td></tr></table></figure><p>查询指定表的建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>会显示出详细注释，引擎，字符集，校对规则</span><br></pre></td></tr></table></figure><h4 id="创建-2">创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型 [约束条件] [COMMENT <span class="string">&#x27;字段1注释&#x27;</span>],</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型 [约束条件] [COMMENT <span class="string">&#x27;字段2注释&#x27;</span>],</span><br><span class="line">    字段<span class="number">3</span> 字段<span class="number">3</span>类型 [约束条件] [COMMENT <span class="string">&#x27;字段3注释&#x27;</span>],</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[COMMENT 表注释];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例子:</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">    id <span class="type">int</span> comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;姓名&#x27;</span></span><br><span class="line">    ) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li>表名和字段只能用反引号或不用符号，<strong>不能用单引号</strong></li><li>最后一个字段结尾不要有逗号</li><li>comment后的字段注释或表注释必须使用引号，而且<strong>是单引号</strong>而不是反引号</li></ul></div><h4 id="修改-2">修改</h4><p><strong>添加字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型(长度) [COMMENT 注释] [约束];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">alter</span>: 修改</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">add</span>: 添加</span><br></pre></td></tr></table></figure><p><strong>修改指定字段数据类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型(长度);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>modify: 修改</span><br></pre></td></tr></table></figure><p><strong>修改字段数据名和字段类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>change: 修改</span><br></pre></td></tr></table></figure><p><strong>删除字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br></pre></td></tr></table></figure><p><strong>修改表名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新表名;</span><br></pre></td></tr></table></figure><h4 id="删除-2">删除</h4><p><strong>删除表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 表名;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>数据全部删除</span><br></pre></td></tr></table></figure><p><strong>删除指定表，并重新创建该表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>数据全部删除，结构不变</span><br></pre></td></tr></table></figure><h2 id="DML-数据操作">DML(数据操作)</h2><h3 id="添加">添加</h3><ul><li><strong>给指定字段添加一条数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span><span class="operator">|</span>REPLACE <span class="keyword">INTO</span> 表名(字段名<span class="number">1</span>，字段名<span class="number">2</span>，字段名<span class="number">3</span>,..) <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..);</span><br></pre></td></tr></table></figure><ul><li><strong>给全部字段添加一条数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span><span class="operator">|</span>REPLACE <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，...);</span><br></pre></td></tr></table></figure><ul><li><strong>批量添加多条数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span><span class="operator">|</span>REPLACE <span class="keyword">INTO</span> 表名(字段名<span class="number">1</span>，字段名<span class="number">2</span>，字段名<span class="number">3</span>,..) <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>指定字段添加多份数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>所有字段添加多份数据</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意：</p><ul><li><strong>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</strong></li><li><strong>字符串和日期型(date型)数据应该包含在引号中</strong></li><li><strong>插入的数据大小应该在字段的规定范围内</strong></li></ul></div><h3 id="修改数据">修改数据</h3><p><strong>修改</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>, 字段名<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,...[<span class="keyword">WHERE</span> 条件]；</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;kqd&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>将id为<span class="number">1</span>的字段name数据修改为kqd</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意：</p><ul><li>修改语句的条件可以有，也可以没有，<strong>如果没有条件，则会修改整张表的所有数据。</strong></li></ul></div><p><strong>删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件]</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除gender为女的员工</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employee <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除所有员工</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意：</p><ul><li><strong>DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。</strong></li><li><strong>DELETE语句不能删除某一个字段的值(但可以使用UPDATE)。</strong></li></ul></div><h2 id="DQL-查询">DQL(查询)</h2><h3 id="基础查询">基础查询</h3><p>1.查询多个字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>，字段<span class="number">2.</span>.. <span class="keyword">FROM</span> 表名；</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 ; </span><br><span class="line"></span><br><span class="line"><span class="operator">*</span>代表查询所有的字段</span><br></pre></td></tr></table></figure><p>2.设置别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span> [<span class="keyword">AS</span> 别名<span class="number">1</span>]，字段<span class="number">2</span> [<span class="keyword">AS</span> 别名<span class="number">2</span>]... <span class="keyword">FROM</span> 表名；</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">AS</span> 可省略</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对字段起别名 </span></span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> <span class="keyword">as</span> <span class="string">&#x27;别名&#x27;</span>,...</span><br><span class="line">为字段<span class="number">1</span>取别名</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对表取别名</span></span><br><span class="line"><span class="keyword">select</span> a.name</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> a</span><br><span class="line">为student表取别名a</span><br></pre></td></tr></table></figure><p>3.去除重复记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><h3 id="条件查询">条件查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件列表;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">条件:</span><br><span class="line">运算符</span><br><span class="line"><span class="number">1.</span>算数</span><br><span class="line"><span class="operator">+</span>, <span class="operator">-</span>, <span class="operator">*</span>, <span class="operator">/</span></span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"><span class="number">2.</span>判断</span><br><span class="line"><span class="operator">&gt;</span>, <span class="operator">&lt;</span>, <span class="operator">&gt;=</span>, <span class="operator">&lt;=</span>, <span class="operator">!=</span>, <span class="operator">&lt;&gt;</span>(不等于) </span><br><span class="line"><span class="keyword">IS</span> <span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>(判断是否为<span class="keyword">NULL</span>)</span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"><span class="number">3.</span>逻辑 </span><br><span class="line"><span class="keyword">AND</span>(<span class="operator">&amp;&amp;</span>), <span class="keyword">OR</span>(<span class="operator">||</span>),<span class="keyword">NOT</span><span class="operator">||</span><span class="operator">!</span></span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"><span class="number">4.</span>范围 </span><br><span class="line"><span class="keyword">BETWEEN</span> 最小值 <span class="keyword">AND</span> 最大值,</span><br><span class="line"><span class="keyword">IN</span>(值<span class="number">1</span>，值<span class="number">2</span>，...)  <span class="operator">/</span><span class="operator">/</span><span class="keyword">IN</span>之后的列表的值为范围</span><br><span class="line"><span class="number">5.</span>模糊匹配 </span><br><span class="line"><span class="keyword">LIKE</span> <span class="string">&#x27;_||%||&#x27;</span></span><br><span class="line"><span class="string">&#x27;_&#x27;</span> 表示代表一个字符</span><br><span class="line"><span class="string">&#x27;%&#x27;</span> 表示<span class="number">0</span>各或多个字符</span><br><span class="line"><span class="string">&#x27;[]&#x27;</span> 表示某一范围的字符,例如[<span class="number">0</span><span class="number">-9</span>],<span class="number">0</span><span class="operator">~</span><span class="number">9</span>之间的字符</span><br><span class="line"><span class="string">&#x27;[^]&#x27;</span> 表示不再某一范围的字符</span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="聚合函数">聚合函数</h3><p><strong>介绍:</strong></p><p>将一列数据作为一个整体，进行纵向计算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">聚合函数：</span><br><span class="line"><span class="built_in">count</span>() 统计元组数量（行数）</span><br><span class="line"><span class="built_in">max</span>() 最大值</span><br><span class="line"><span class="built_in">min</span>() 最小值</span><br><span class="line"><span class="built_in">avg</span>() 平均值</span><br><span class="line"><span class="built_in">sum</span>() 求和</span><br></pre></td></tr></table></figure><p><strong>语法:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数(字段列表),聚合函数,... <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li><strong>所有的NULL值不参与所有聚合函数运算，对某个字段中有NULL在使用count时将不会计算数据条数。</strong></li><li><strong>count(*)统计的是表中所有的行数,count(字段)是统计该字段非NULL的行数,一般使用前者较多</strong></li></ul></div><h3 id="分组查询">分组查询</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件] GEOUP <span class="keyword">BY</span> 分组字段名 [<span class="keyword">HAVING</span> 分组后过滤条件]</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>where和having的区别:</strong></p><p>执行时机不同: where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果的过滤。</p><p>判断条件不同：where不能对聚合函数进行判断，而having可以。</p></div><p>注意：</p><ul><li>执行顺序：where &gt; 聚合函数 &gt; having.</li><li>分组之后，<strong>查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</strong></li></ul><h3 id="排序查询">排序查询</h3><p><strong>语法:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>，字段二 排序方式</span><br><span class="line"></span><br><span class="line">排序方式:</span><br><span class="line"><span class="keyword">ASC</span>: 升序（默认值）</span><br><span class="line"><span class="keyword">DESC</span>: 降序</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</p><h3 id="分页查询">分页查询</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT 起始索引(偏移量)，查询记录数</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一般LIMIT加在所有代码的最后</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p><strong>起始索引从0开始，起始索引 = (查询页码-1) * 每页显示记录数，起始索引也叫偏移量，表示从起始索引所在行数的下一行开始查询</strong></p></li><li><p><strong>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT</strong></p></li><li><p><strong>如果查询的是第一页数据，起始索引可以省略，直接简写为LIMIT 10。</strong></p></li></ul><h3 id="DQL执行顺序">DQL执行顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">执行顺序:了解了执行顺序后我们就可以知道哪些部分可以使用别名来访问数据，哪些不能使用</span><br><span class="line"><span class="number">1.</span><span class="keyword">FROM</span></span><br><span class="line"><span class="number">2.</span><span class="keyword">WHERE</span></span><br><span class="line"><span class="number">3.</span><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="number">4.</span><span class="keyword">HAVING</span></span><br><span class="line"><span class="number">5.</span><span class="keyword">SELECT</span></span><br><span class="line"><span class="number">6.</span><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line"><span class="number">7.</span>LIMIT</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> emp <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">若取别名 <span class="keyword">select</span> e.name,e.age <span class="keyword">from</span> emp <span class="keyword">as</span> e age <span class="keyword">where</span> e.age<span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">ASC</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>执行成功，先执行<span class="keyword">from</span>为emp取别名e，再执行<span class="keyword">where</span>,<span class="keyword">select</span></span><br><span class="line"></span><br><span class="line">若取别名<span class="keyword">select</span> e.name <span class="keyword">AS</span> ename, e.age <span class="keyword">AS</span> eage <span class="keyword">from</span> emp <span class="keyword">AS</span> e age <span class="keyword">where</span> eage<span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">ASC</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>错误，<span class="keyword">select</span>语句在<span class="keyword">where</span>之后执行，在执行<span class="keyword">select</span>之前没有eage这个别名</span><br></pre></td></tr></table></figure><h2 id="DCL-管理">DCL(管理)</h2><h3 id="用户管理">用户管理</h3><h4 id="查询用户">查询用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h4 id="创建用户">创建用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>设置任意主机访问该数据库</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;#&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>设置只能在本机访问数据库</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="修改用户密码">修改用户密码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="删除用户">删除用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意：</strong></p><ul><li><strong>主机名可以使用%通配</strong></li><li><strong>这类SQL开发人员操作的比较少，主要是DBA （数据库管理员)使用</strong></li></ul></div><h3 id="权限控制">权限控制</h3><h4 id="查询权限">查询权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="授予权限">授予权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALL</span><span class="operator">/</span><span class="keyword">all</span> 代表所有的权限</span><br><span class="line">数据库.<span class="operator">*</span> 代表所有的表</span><br><span class="line"><span class="operator">*</span>.<span class="operator">*</span> 代表所有数据库的所有表</span><br></pre></td></tr></table></figure><h4 id="撤销权限">撤销权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALL</span><span class="operator">/</span><span class="keyword">all</span> 代表所有的权限</span><br><span class="line"><span class="operator">*</span> 代表所有的表</span><br><span class="line"><span class="operator">*</span>.<span class="operator">*</span> 代表所有数据库的所有表</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意：</strong></p><ul><li><strong>多个权限之间，使用逗号分隔</strong></li><li><strong>授权时，数据库名和表名可以使用*进行通配，代表所有</strong>,</li></ul></div><h2 id="函数">函数</h2><p><a href="https://blog.csdn.net/hzbooks/article/details/118561808?ops_request_misc=%7B%22request%5Fid%22%3A%22169564664916800227428260%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169564664916800227428260&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-118561808-null-null.142%5Ev94%5Einsert_down1&amp;utm_term=mysql%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">MySQL 十大常用字符串函数_hzbooks的博客-CSDN博客</a></p><h3 id="字符串函数">字符串函数</h3><p>常用的函数:</p><h4 id="CONCAT">CONCAT</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(s1,s2,..sn)</span><br><span class="line">将字符串拼接，S1,S2,...Sn拼接成一个字符串，返回该字符串</span><br></pre></td></tr></table></figure><h4 id="LOWER">LOWER</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LOWER</span>(str) </span><br><span class="line">将字符串str全部转换为小写,返回该函数</span><br></pre></td></tr></table></figure><h4 id="UPPER">UPPER</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPPER</span>(str)</span><br><span class="line">将字符串str全部转换为大写,返回该函数</span><br></pre></td></tr></table></figure><h4 id="LPAD">LPAD</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LPAD(str,n,pad)</span><br><span class="line">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</span><br><span class="line"></span><br><span class="line">lpad(<span class="string">&#x27;01&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">代表用<span class="string">&#x27;-&#x27;</span>填充左边的得到<span class="string">&#x27;---01&#x27;</span>,一共五个字符，下面的rpad同理</span><br></pre></td></tr></table></figure><h4 id="RPAD">RPAD</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RPAD(str,n,pad)</span><br><span class="line">右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</span><br></pre></td></tr></table></figure><h4 id="TRIM">TRIM</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TRIM</span>(str)</span><br><span class="line">去掉字符串头部和尾部的空格(不除去中间)</span><br></pre></td></tr></table></figure><h4 id="SUBSTRING">SUBSTRING</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUBSTRING</span>(str,<span class="keyword">start</span>,len)</span><br><span class="line">返回从字符串str从<span class="keyword">start</span>位置起的len个长度的字符串</span><br></pre></td></tr></table></figure><h3 id="数值函数">数值函数</h3><h4 id="CEIL">CEIL</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CEIL</span>()</span><br><span class="line">向上取整</span><br></pre></td></tr></table></figure><h4 id="FLOOR">FLOOR</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FLOOR</span>()</span><br><span class="line">向下取整</span><br></pre></td></tr></table></figure><h4 id="MOD">MOD</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MOD</span>(x,y)</span><br><span class="line">返回x<span class="operator">/</span>y的模</span><br></pre></td></tr></table></figure><h4 id="RAND">RAND</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAND()</span><br><span class="line">返回<span class="number">0</span><span class="operator">~</span><span class="number">1</span>内的随机数</span><br></pre></td></tr></table></figure><h4 id="ROUND">ROUND</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ROUND(x,y)</span><br><span class="line">求参数x的四舍五入的值，保留y位小数</span><br></pre></td></tr></table></figure><h3 id="日期函数">日期函数</h3><h4 id="CURDATE">CURDATE</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curdate()</span><br><span class="line">返回当前日期,年<span class="operator">-</span>月<span class="operator">-</span>日</span><br></pre></td></tr></table></figure><h3 id="CURTIME">CURTIME</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curtime()</span><br><span class="line">返回当前时间</span><br></pre></td></tr></table></figure><h4 id="NOW">NOW</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">now()</span><br><span class="line">返回当前日期和时间</span><br></pre></td></tr></table></figure><h4 id="YEAR">YEAR</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">year</span>(<span class="type">date</span>)</span><br><span class="line">获取指定<span class="type">date</span>的年份</span><br></pre></td></tr></table></figure><h4 id="MONTH">MONTH</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">month</span>(<span class="type">date</span>)</span><br><span class="line">获取指定<span class="type">date</span>的月份</span><br></pre></td></tr></table></figure><h4 id="DAY">DAY</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">day</span>(<span class="type">date</span>)</span><br><span class="line">获取指定<span class="type">date</span>的日期</span><br></pre></td></tr></table></figure><h4 id="DATE-ADD">DATE_ADD</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DATE_ADD(<span class="type">date</span>,<span class="type">INTERVAL</span> expr type)</span><br><span class="line">返回一个日期<span class="operator">/</span>时间值加上一个时间间隔expr后的时间值</span><br><span class="line"></span><br><span class="line">expr 指定数字</span><br><span class="line">type 指定类型:年<span class="operator">/</span>月<span class="operator">/</span>日(<span class="keyword">DAY</span><span class="operator">/</span><span class="keyword">MONTH</span><span class="operator">/</span><span class="keyword">YEAR</span>)</span><br><span class="line">例：</span><br><span class="line">DATE_ADD(now(),<span class="type">INTERVAL</span> <span class="number">70</span> <span class="keyword">day</span>)<span class="comment">-- 70天之后的时间</span></span><br><span class="line">DATE_ADD(now(),<span class="type">INTERVAL</span> <span class="number">70</span> <span class="keyword">month</span>)<span class="comment">-- 70个月之后的时间</span></span><br></pre></td></tr></table></figure><h4 id="DATEDIFF">DATEDIFF</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DATEDIFF(date1,date2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回起始时间date1和结束时间date2</span></span><br><span class="line">之间的天数</span><br><span class="line"><span class="comment">-- 一般用于求入职，入学时间等</span></span><br></pre></td></tr></table></figure><h3 id="流程函数">流程函数</h3><h4 id="IF">IF</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF(<span class="keyword">value</span>,t,f)</span><br><span class="line">如果<span class="keyword">value</span>为<span class="literal">true</span>，则返回t，否则返回f</span><br><span class="line"><span class="comment">-- 类似三目运算符</span></span><br></pre></td></tr></table></figure><h4 id="IFNULL">IFNULL</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(value1,value2)</span><br><span class="line">如果value1不为<span class="keyword">null</span>，返回value1，否则返回value2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用于聚合函数的筛选</span></span><br><span class="line"><span class="comment">-- 例： 求成绩大于60分才有学分，求同学的总学分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sno <span class="keyword">as</span> <span class="string">&#x27;学号&#x27;</span>,sn <span class="keyword">as</span> <span class="string">&#x27;姓名&#x27;</span>,<span class="built_in">sum</span>(IF(score<span class="operator">&gt;=</span><span class="number">60</span>,credit,<span class="keyword">NULL</span>)) <span class="keyword">from</span> s;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这里的if会判断，如果score&gt;=60分就会返回credit，即sum(credit)计算学分和,如果不满足则会返回NULL，就不会计算该值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CASE-WHEN">CASE WHEN</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> [expr] <span class="keyword">WHEN</span> [val1] <span class="keyword">THEN</span> [res1] ...<span class="keyword">ELSE</span>[<span class="keyword">default</span>] <span class="keyword">END</span></span><br><span class="line">如果expr(表达式<span class="operator">/</span>字段)的值等于val1，返回res1，...否则返回<span class="keyword">default</span>默认值</span><br><span class="line"><span class="comment">-- 一般用于给出具体的条件的值</span></span><br><span class="line"></span><br><span class="line">例：查询emp表的员工姓名和工作地址，如果工作地址在北京<span class="operator">/</span>上海，则标明一线城市，其他则为二线城市</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">name,</span><br><span class="line">(<span class="keyword">case</span> workaddress <span class="keyword">when</span> <span class="string">&#x27;北京&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">when</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;二线城市&#x27;</span> <span class="keyword">end</span> ) <span class="keyword">as</span> <span class="string">&#x27;工作地址&#x27;</span></span><br><span class="line"><span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> [val <span class="number">1</span>] <span class="keyword">THEN</span> [RES1] ... <span class="keyword">ELSE</span> [<span class="keyword">default</span>] <span class="keyword">END</span></span><br><span class="line">如果val1为<span class="literal">true</span>，返回res1，...否则返回<span class="keyword">default</span>默认值</span><br><span class="line"><span class="comment">-- 一般用于范围</span></span><br><span class="line"></span><br><span class="line">例如：统计成绩，<span class="number">85</span>分以上为优秀，<span class="number">60</span>分以上为及格，<span class="number">60</span>分以下为不及格</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">id,</span><br><span class="line">name,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> math<span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span> ) <span class="keyword">as</span> <span class="string">&#x27;数学&#x27;</span>,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> english<span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span> ) <span class="keyword">as</span> <span class="string">&#x27;英语&#x27;</span>,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> chinese<span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span> ) <span class="keyword">as</span> <span class="string">&#x27;语文&#x27;</span>,</span><br><span class="line"><span class="keyword">from</span> score;</span><br><span class="line"></span><br><span class="line">其中math，english，chinese 三个字段使用了流程函数,使<span class="keyword">select</span>出来的值进行了指定</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多表关系">多表关系</h2><p>项目开发中，在进行数据库表结构设计师，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所有各个表结构之间也存在着各种联系，基本分为三种:</p><ul><li><p>一对多(多对一)</p><p>案例：部门与 员工的关系</p><p>关系：一个部门对应多个员工，一个员工对应多个部门</p></li></ul><p>​     实现：<strong>在多的一方建立外键，指向一的一方主键</strong></p><ul><li>多对多</li></ul><p>​案例：学生与课程的关系</p><p>​关系：一个学生可以选修多么课程，一门课程也可以供多个学生选择</p><p>​实现：<strong>建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</strong></p><ul><li><p>一对一</p><p>案例：用户与用户详情的关系</p><p>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详细字段放在另一张表中,以提升操作效率</p><p>实现：<strong>在任意一方加入外键，关联另一方的主键，并设置外键为唯一的UNIQUE</strong></p></li></ul><p>多表查询</p><h3 id="概述">概述</h3><p>概述：指从多张表中查询数据</p><p>笛卡尔积：笛卡尔乘积是指在数学中，两个集合A集合和B集合的所有组合情况。(<strong>在多表查询时，需要消除无效的笛卡尔积</strong>)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 后面这个where就可以保证出来的两个id对应</span></span><br><span class="line">连接条件为: emp.dept_id <span class="operator">=</span> dept.id</span><br></pre></td></tr></table></figure><h3 id="内连接">内连接</h3><p><strong>内连接将两张表连接起来，内连接查询的是两张表的交集的部分</strong></p><p>隐式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>，表<span class="number">2</span> <span class="keyword">WHERE</span> 条件 ...;</span><br><span class="line"><span class="comment">-- 不使用内连接实现方式</span></span><br></pre></td></tr></table></figure><p>显示内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 写法一</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 连接条件...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 写法二</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 连接条件 <span class="keyword">and</span> 连接条件 ...;</span><br></pre></td></tr></table></figure><h3 id="外连接">外连接</h3><h4 id="左外连接">左外连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> (<span class="keyword">OUTER</span>) <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 <span class="keyword">LEFT</span> (<span class="keyword">OUTER</span>) <span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 连接条件...;</span><br></pre></td></tr></table></figure><p><strong>注：相当于查询左表(表1)的所有数据包含表1和表2交集部分的数据</strong></p><h4 id="右外连接">右外连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> (<span class="keyword">OUTER</span>) <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 <span class="keyword">RIGHT</span> (<span class="keyword">OUTER</span>) <span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 连接条件...;</span><br></pre></td></tr></table></figure><p><strong>注：相当于查询右表(表2)的所有数据包含表1和表2交集部分的数据</strong></p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意:</strong></p><ul><li><strong>左外连接可以和右外连接互相转换，只需要交换字段位置</strong></li><li>外连接和内连接的区别:<strong>内连接只会展示两张表的交集部分当连接的部分中没有原表中的某条数据，即为NULL时，就不会显示出来，而外连接可以将某一张表的所有数据和交集部分显示出来，即可以显示想要知道的NULL</strong></li></ul></div><h3 id="自连接">自连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A <span class="keyword">AS</span> 别名A <span class="keyword">JOIN</span> 表A <span class="keyword">AS</span> 别名B <span class="keyword">ON</span> 条件 ...;</span><br><span class="line"></span><br><span class="line">一定要将该表取两个别名，看成两张表</span><br></pre></td></tr></table></figure><p><strong>自连接查询，可以是内连接查询，也可以是外连接查询</strong></p><h3 id="联合查询">联合查询</h3><p>把多次查询的结果合并起来，形成一个新的查询结果集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A ...</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B ...;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">50</span> </span><br><span class="line"></span><br><span class="line">有<span class="keyword">ALL</span>可能会导致有重复，但去掉<span class="keyword">ALL</span>只用<span class="keyword">union</span>则会去除相同的</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意:</strong></p><ul><li><strong>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</strong></li><li><strong>union all 会将全部的数据直接合并在一起，union会对合并之后的数据去重</strong></li><li><strong>or只能单表查询，而union可以多表查询</strong></li></ul></div><h3 id="子查询">子查询</h3><ul><li>概念：SQL语句中嵌套SELECT语句，成为<strong>嵌套查询</strong>，又称<strong>子查询</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> column1 <span class="operator">=</span> (<span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> t2);</span><br><span class="line"></span><br><span class="line">子查询外部的语句可以是：<span class="keyword">INSERT</span><span class="operator">/</span><span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span><span class="operator">/</span><span class="keyword">SELECT</span>的任何一个。</span><br></pre></td></tr></table></figure><ul><li><p>根据子查询结果不同，分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询 （子查询结果为多行多列）</li></ul></li><li><p>根据子查询位置,分为：WHERE之后、FROM之后、SELECT之后。</p></li></ul><h4 id="标量子查询">标量子查询</h4><p>子查询返回的结果是单个值(数字、字符串、日期等), 是最简单的形式，这种子查询称为<strong>标量子查询</strong></p><p>常用的操作符：<strong>= ，&lt;&gt; ，&gt;， &gt;=， &lt;， &lt;=</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例如:</span></span><br><span class="line"><span class="comment">-- 查询&#x27;销售部&#x27;的所有员工信息(id和名称在两张表)</span></span><br><span class="line"><span class="comment">-- 我们分为两步</span></span><br><span class="line"><span class="comment">-- 1.查询&#x27;销售部&#x27;部门ID</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.根据销售部的部门ID，查询员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.使用标量子查询合并之后就是</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="列子查询">列子查询</h4><p>子查询返回的结果是一列(可以是多行), 这种子查询成为列子查询。</p><p>常用的操作符： <strong>IN 、NOT IN 、ANY 、SOME 、ALL、EXISTS</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IN</span> ：在指定的集合范围之内  ，多选一</span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">IN</span> ： 不在指定的集合范围之内</span><br><span class="line"><span class="keyword">ANY</span> ：子查询返回列表中，有任意一个满足即可</span><br><span class="line"><span class="keyword">SOME</span> ： 与<span class="keyword">ANY</span>等同，使用<span class="keyword">SOME</span>的地方都可以使用<span class="keyword">ANY</span></span><br><span class="line"><span class="keyword">ALL</span> : 子查询返回列表的所有值都必须满足</span><br><span class="line"><span class="keyword">EXISTS</span>: 也可进行相关子查询，但不返回任何实际数据，只得到真或假</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="comment">-- 列子查询</span></span><br><span class="line"><span class="comment">-- 1.查询&#x27;销售部&#x27;和&#x27;市场部&#x27;的所有员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询比财务部所有人工资都高的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询所有财务部人员工资</span></span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b. 比财务部所有人工资都高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">ALL</span>(<span class="keyword">select</span>  salary <span class="keyword">from</span> <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>)salary )</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.查询比研发部任意一人工资高的员工该信息</span></span><br><span class="line"><span class="comment">-- a. 查询研发部所有人工资</span></span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b. 比研发部其中任意一人工资高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">ANY</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- exist 表示存在的量词，带有exists的子查询不返回任何实际数据，它只得到逻辑值&quot;真&quot;或&quot;假&quot;。当子查询的查询结果集合为非空时，外层的WHERE子句返回真值，否则返回假值。NOT EXISTS与此相反。</span></span><br><span class="line"><span class="comment">-- 查询学生的学号和姓名，查询条件是学生没有选修课程号为&quot;c1&quot;的课程（使用exist）</span></span><br><span class="line"><span class="keyword">select</span> sno,sn <span class="keyword">from</span> s <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sc <span class="keyword">where</span> sno <span class="operator">=</span> s.sno <span class="keyword">AND</span> cno <span class="operator">=</span> <span class="string">&#x27;C1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上述语句的执行过程是，对于父查询中的每一位学生，在子查询中查询是否选修了课程号为C1的课程，如果没有选课记录，说明子查询的结果集合为空，则父查询中WHERE子句中的not exists的返回逻辑值&quot;真&quot;,从而该学生的信息会被被选取到父查询的结果集合中,集合不为空，则not exists的返回逻辑值为&quot;假&quot;，则该学生信息丢弃。对父查询表s中的每一位学生重复上述过程，即可完成查询任务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="行子查询">行子查询</h4><p>子查询返回的结果是一行（可以是多列），这种子查询成为<strong>行子查询</strong></p><p>常用的操作符：<strong>= ，&lt;&gt; ，IN、NOT IN</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 行子查询</span></span><br><span class="line"><span class="comment">-- 1.查询与&#x27;张无忌&#x27;的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询张无忌的薪资及直属领导</span></span><br><span class="line"><span class="keyword">select</span> salary,managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b. 查询与&#x27;张无忌&#x27;的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">=</span> <span class="number">12500</span> <span class="keyword">and</span> managerid <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 组合作为条件</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="number">12500</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 表示salary =12500，managerid = 1 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 行子查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="keyword">select</span> salary,managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>);</span><br><span class="line"><span class="comment">-- 刚好是两条数据两两对应，等号的组合写法</span></span><br></pre></td></tr></table></figure><h4 id="表子查询">表子查询</h4><p>子查询返回的结果是多行多列，这种子查询称为<strong>表子查询</strong></p><p>常用操作符: <strong>IN</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表子查询</span></span><br><span class="line"><span class="comment">-- 1. 查询与 &#x27;lzk&#x27; ,&#x27;syq&#x27; 的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询 lzk，syq的职位和薪资</span></span><br><span class="line"><span class="keyword">select</span> job,salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;lzk&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;lyq&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b.查询与lzk，syq的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="comment">-- 组合写法</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (job,salary) <span class="keyword">in</span> (<span class="keyword">select</span> job,salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;lzk&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;lyq&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="事务简介">事务简介</h2><p><strong>事务（transaction）<strong>是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作</strong>要么同时成功，要么同时失败</strong></p><h3 id="事务操作">事务操作</h3><h4 id="方式一">方式一</h4><ul><li>查看/设置事务提交方式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="comment">-- 查看事务的自动提交方式：1为自动，0为手动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 设置系统变量的提交方式：1为自动，0为手动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这种方法可作用于全局</span></span><br></pre></td></tr></table></figure><ul><li>提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 在设置了手动提交后，任意的sql语句，只有在sql语句之后使用了commit才会提交修改数据库，否则不会修改</span></span><br></pre></td></tr></table></figure><ul><li>回滚事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="comment">-- 遇到异常时可以回滚已经执行的sql语句</span></span><br><span class="line"><span class="comment">-- 提交之后不能回滚</span></span><br></pre></td></tr></table></figure><h4 id="方式二">方式二</h4><ul><li>开启事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION 或 <span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 这句话执行后代表开启事务，代表我们要手动控制事务，只要没有commit数据库就不会改变、</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这种方法可作用于某些语句,执行完成后事务自动关闭</span></span><br></pre></td></tr></table></figure><ul><li>提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- commit事务后代表事务完成了</span></span><br></pre></td></tr></table></figure><ul><li>回滚事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h3 id="事务的四大特性-ACID">事务的四大特性(ACID)</h3><ul><li>原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态(合理加减)。</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变使永久的。</li></ul><h3 id="并发事务问题">并发事务问题</h3><ul><li><p><strong>丢失更新</strong>：两个事务读入同一数据，并发执行修改操作时，一个事务将另一个事务的修改覆盖，导致这些修改好像丢失了一样</p></li><li><p><strong>读取脏数据(脏读)：<strong>一个事务读到另外一个事务</strong>还没有提交</strong>的数据(未commit)</p></li><li><p>**不可重复读：**在一个事务中先后读取同一条数据，但两次读取的数据不同，称为不可重复读。</p></li><li><p>**幻象读(幻读)：**一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在了，好像出现了&quot;幻影&quot;</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- (查询)不可重复读：现在分别开启A,B两个事务，A第一次读取数据，在A第二次读取前，B事务修改了该数据，导致该事务再次读取数据时数据与第一次读取不同(A事务始终没有结束)</span></span><br><span class="line"><span class="comment">-- 如果解决了不可重复读，在一个事务中，两次读取同一个数据，数据相同，但在该事务结束后，再读取，数据就会更新了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- (增删)幻读: 在解决了不可重复读之后才会出现，A事务查询数据时，没有对应的数据行，A准备插入，但是在A插入前，B插入了数据,A就会得到数据已经存在，但是之后第二次查询，又发现没有该数据行。</span></span><br><span class="line"><span class="comment">-- 因为设置了可重复读（解决不可重复读），所以才会满足在同一个事务中两次读取到的数据应该是相同的，但是实际数据确实存在</span></span><br></pre></td></tr></table></figure><h3 id="事务隔离级别">事务隔离级别</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 四种事务隔离级别，从上到下性能降低，安全升高</span></span><br><span class="line"><span class="comment">-- 通常要综合性能和安全选择隔离级别</span></span><br><span class="line"></span><br><span class="line">脏读      不可重复读     幻读</span><br><span class="line">Read uncommitted:  会出现       会出现      会出现</span><br><span class="line">Read committed:     不会会  会</span><br><span class="line">Repeatable Read:不会不会 会</span><br><span class="line">Serializable:不会不会不会</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Mysql默认：Repeatable Read 可重复读</span></span><br><span class="line"><span class="comment">-- Oracle默认: Read committed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Read uncommitted：未提交读</span></span><br><span class="line"><span class="comment">-- Read committed：提交读</span></span><br><span class="line"><span class="comment">-- Repeatable Read：可重复读</span></span><br><span class="line"><span class="comment">-- Serializable：序列化(串行化)，代表在进行并发事务操作时，同一时间只能执行一个事务，只有在该事务提交之后，才能执行其他事务，其他事务在这之前会被阻塞,避免所有的并发问题</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看事务隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@TRANSACTION_ISOLATION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED<span class="operator">|</span> READ COMMITTED<span class="operator">|</span> REPEATABLE READ<span class="operator">|</span> SERIALIZABLE]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SESSION：会话级别,代表针对当前客户端窗口有效,某一个console控制台</span></span><br><span class="line"><span class="comment">-- GLOBAL：代表所有客户端有效</span></span><br></pre></td></tr></table></figure><ul><li><strong>注意事务隔离级别越高，数据越安全，但是性能越低</strong></li></ul><h1>进阶篇</h1><h2 id="索引">索引</h2><p>索引(index) 是帮助MySQL<strong>高效获取数据</strong>的<strong>数据结构(有序)</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p><strong>优点：</strong></p><ul><li><strong>提高数据检索的效率，降低数据库的IO成本</strong></li><li><strong>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</strong></li></ul><p><strong>缺点：</strong></p><ul><li><strong>索引列需要占用空间</strong></li><li><strong>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低</strong></li></ul><h3 id="索引结构">索引结构</h3><p>MySQL的索引是在储存引擎层实现的，不同的储存引擎有不同的结构，主要包含以下几种：</p><ul><li><strong>B+Tree索引：最常见的索引类型，大部分引擎都支持B+树索引</strong></li><li><strong>Hash索引：底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</strong></li><li><strong>R-tree：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</strong></li><li><strong>Full-text：是一种通过建立倒排索引，快速匹配文档的方式，类似于Lucene，Solr，ES</strong></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</strong></p></div><ul><li>二叉树</li></ul><p><strong>二叉树缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量的情况下，层级较深，检索速度慢。</strong></p><p><strong>红黑树：大数据量的情况下，层级较深，检索速度慢。</strong></p><ul><li>B-Tree(<strong>多路</strong>平衡查找树)</li></ul><p>以一颗最大度数为5(5个子节点)的b-tree为例(每个节点最多储存四个key，5个指针)，指针数 = key + 1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插入 <span class="number">100</span> <span class="number">65</span> <span class="number">169</span> <span class="number">368</span> <span class="number">900</span> <span class="number">556</span> <span class="number">780</span> <span class="number">35</span> <span class="number">215</span> <span class="number">1200</span> <span class="number">234</span> <span class="number">888</span> <span class="number">158</span> <span class="number">90</span> <span class="number">1000</span> <span class="number">88</span> <span class="number">120</span> <span class="number">268</span> <span class="number">250</span>  为例</span><br></pre></td></tr></table></figure><p>B-Tree 动态变化的过程可以参考网站：</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-Tree Visualization (usfca.edu)</a></p><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization (usfca.edu)</a></p><h3 id="索引分类">索引分类</h3><ul><li><strong>主键索引</strong>：针对于表中主键创建的索引，建表时默认自动创建，只能有一个，关键字是PRIMARY。</li><li><strong>唯一索引</strong>：避免同一个表中某数据列中的值重复，可以有多个，关键字UNIQUE。</li><li><strong>常规索引</strong>：快速定位特定的数据，可以有多个。</li><li><strong>全文索引</strong>：全文索引查找的是文本中的关键词，而不是比较索引中的值，可以有多个，关键字FULLTEXT。</li><li><strong>空间索引：</strong> 使用了SPATIAL关键字的索引，适用于GEOMETRY ,POINT,POLYGON等空间类型数据的列</li></ul><p>在InnoDB储存引擎中，根据索引的存储形式，又可以分为以下两种：</p><ul><li>聚集索引(Clustered Index)：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据(记录)，<strong>必须有，而且只有一个</strong></li><li>二级索引(Secondary Index)：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键，<strong>可以存在多个</strong></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>聚集索引的选取规则：</strong></p><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表中没有主键，或没有适合的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ul></div><p>回表查询：先根据字段对应的二级索引去查对应的主键值，在根据主键对应的聚集索引去查行数据。</p><h3 id="索引语法">索引语法</h3><h4 id="创建索引">创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name <span class="keyword">ON</span> table_name(字段名[(索引字符长度) [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]],...);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一个索引可关联多个字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不加可选项UNIQUE或FULLTEXT代表默认创建常规索引</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">--  以name字段为姓名字段，该字段的值可能会重复，且索引针对name的前3个字符以降序排序,为该字段创建索引。</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name(<span class="number">3</span>) <span class="keyword">desc</span>);</span><br><span class="line"><span class="comment">-- phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">UNIQUE</span> index idx_user_phone <span class="keyword">on</span> tb_user(phone);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为profession、age、status创建联合索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_status <span class="keyword">on</span> tb_user(profession、age、status);</span><br><span class="line">联合索引中字段索引是有讲究的</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为email建立合适的索引来提升查询效率</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_email <span class="keyword">on</span> tb_user(email);</span><br></pre></td></tr></table></figure><ul><li><strong>可以在建表时创建索引</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 数据类型 列约束 comment <span class="string">&#x27;注释&#x27;</span>,</span><br><span class="line">    字段<span class="number">2</span> 数据类型 列约束 comment <span class="string">&#x27;注释&#x27;</span>，</span><br><span class="line">    ...</span><br><span class="line">    [表约束]，</span><br><span class="line">    [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name(字段名[(索引字符长度) [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]],...),</span><br><span class="line">    ...</span><br><span class="line">     [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name(字段名[(索引字符长度) [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]],...),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例:</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> classroom(</span><br><span class="line">cid <span class="type">int</span> auto_increment,</span><br><span class="line">    crno <span class="type">varchar</span>(<span class="number">13</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    cbn <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(cid),</span><br><span class="line">    <span class="keyword">unique</span> index cn_cb_index(crno,cbn)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在表约束后，可以使用index关键字为表创建索引，与<span class="keyword">create</span> index用法相同。</span><br><span class="line"><span class="number">2.</span><span class="keyword">create</span> <span class="keyword">table</span>语句可以一次附带多个索引，不同索引间使用逗号分隔</span><br><span class="line"><span class="number">3.</span><span class="keyword">create</span> <span class="keyword">table</span>创建索引时无需提供表名，而是使用<span class="keyword">create</span> index语句创建索引时要指明表名</span><br></pre></td></tr></table></figure><h4 id="查看索引">查看索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看tb_user表的索引</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure><h4 id="修改索引">修改索引</h4><p><a href="https://blog.csdn.net/challenglistic/article/details/129166717">Mysql 索引（三）—— 不同索引的创建方式（主键索引、普通索引、唯一键索引）-CSDN博客</a></p><h4 id="删除索引">删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例：删除email的索引</span></span><br><span class="line"><span class="keyword">drop</span> index idx_user_email <span class="keyword">on</span> tb_user;</span><br></pre></td></tr></table></figure><h2 id="视图">视图</h2><ul><li>介绍</li></ul><p>视图(view)是一种<strong>虚拟存在的表</strong>。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p><p>通俗的讲，<strong>视图只保存了查询的SQL逻辑，不保存查询结果</strong>。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><h3 id="视图语法">视图语法</h3><ul><li><strong>创建</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- OR REPLACE &#x27;或替代&#x27; , 可选项</span></span><br><span class="line"><span class="comment">-- </span></span><br></pre></td></tr></table></figure><ul><li><strong>查询</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看创建视图的语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称；</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看视图数据(把视图当作表来查，可以像操作表一样来操作视图)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 视图名称 WHERE...;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> stu_v_1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1 <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>修改视图</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式一：关键在or replace上，修改必须加</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span>[<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure><ul><li><strong>删除视图</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] 视图名称，... ;</span><br></pre></td></tr></table></figure><h3 id="视图的检查选项">视图的检查选项</h3><p>当使用with check option子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使符合视图的定义。<strong>MySQL允许基于另一个视图创建视图</strong>，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：cascaded 和 local，<strong>默认值为cascaded(级联)</strong>。</p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意：</strong></p><ul><li><p><strong>只有添加了with check option的视图才会在插入时进行where条件的检查，没有检查时直接会添加成功到表</strong></p></li><li><p><strong>插入的数据是存放到基表中的，视图中不存放数据</strong></p></li></ul></div><h4 id="CASCADED-级联">CASCADED(级联)</h4><p><strong>cascade 会去递归检查当前视图以及创建时依赖的视图，并且看是否加了检查选项，如果其依赖的视图中没有加入检查选项，则会将cascaded向下传递，使其向下的视图都加上检查选项使其都能检查</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_1 <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;TOM&#x27;</span>)</span><br><span class="line"><span class="comment">-- 成功添加到student中</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_1 <span class="keyword">values</span>(<span class="number">30</span>,<span class="string">&#x27;TOM&#x27;</span>)</span><br><span class="line"><span class="comment">-- 添加成功到student中，用select搜索该视图中找不到该数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加cascaded选项后</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_1 <span class="keyword">values</span>(<span class="number">30</span>,<span class="string">&#x27;TOM&#x27;</span>)</span><br><span class="line"><span class="comment">-- 添加失败，因为id&gt;20，故会阻止该数据的添加</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span>  </span><br><span class="line"><span class="comment">-- 由于stu_2使用cascaded检查选项，则stu_1也会继承到该检查选项</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_3 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_3 <span class="keyword">values</span>(<span class="number">11</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入成功</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_3 <span class="keyword">values</span>(<span class="number">17</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入成功，stu_3没有检查选项，不会检查</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_3 <span class="keyword">values</span>(<span class="number">28</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入失败，stu_3没有检查选项，直接到依赖视图stu_2中，stu_2中有检查选项并且是cascaded，满足id&gt;=10,递归进入stu_1中，由于stu_1继承到了cascaded, 会进行判断,不满足id&lt;=20，阻止该数据插入.</span></span><br></pre></td></tr></table></figure><h4 id="LOCAL">LOCAL</h4><p><strong>local 会去递归检查当前视图以及创建时依赖的视图，并且看是否加了检查选项，如果有，则进行条件的检查看是否满足条件，如果没有则不进行检查继续递归</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图1,没有依赖视图，没有检查选项</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span>  student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">15</span>;</span><br><span class="line"><span class="comment">-- 创建视图2，依赖于视图1,没有检查选项</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_1 <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">10</span> ;</span><br><span class="line"><span class="comment">-- 创建视图3，依赖于视图2,设置local检查选项</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_3 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_2 <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">with</span> <span class="keyword">local</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_3 <span class="keyword">values</span>(<span class="number">13</span>,<span class="string">&#x27;TOM&#x27;</span>);</span><br><span class="line"><span class="comment">-- 由于stu_3设置了检查选项,该语句会先判断id&lt;20(如果没设置就不会判断而是会直接进入stu_2中),然后递归到stu_2发现stu_2没有添加检查选项，则不进行判断id&gt;=10，如果添加了，则会判断id&gt;=10，再依次递归到stu_1，直到没有依赖其他视图建立的视图为止</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果任意一次条件判断不满足则会插入失败</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQl安装</title>
      <link href="/posts/4484a8c6.html"/>
      <url>/posts/4484a8c6.html</url>
      
        <content type="html"><![CDATA[<h1>MySQL安装</h1><p><a href="https://www.mysql.com/downloads/">MySQL :: MySQL Downloads</a></p><h1>MySQL启动与停止</h1><p><strong>启动</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql80</span><br></pre></td></tr></table></figure><p><strong>停止</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql80</span><br></pre></td></tr></table></figure><h1>MySQL的客户端连接</h1><p>**方法一：**通过直接提供的MySQL 8.0 Command Line Client输入密码连接</p><p>**方法二：**系统的cmd连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql [-h 127.0.0.1] [-p 3306] -u root -p</span><br><span class="line"></span><br><span class="line">可选项1：指定连接ip，不填默认本机</span><br><span class="line">可选项2：指定端口号，不填默认3306</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意：要想在任意目录使用这种方式执行mysql指令就必须配置系统环境变量</p><p>系统环境变量path中添加：C:\Program Files\MySQL\MySQL Server 8.0\bin(mysql的路径)</p></div>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验室管理系统</title>
      <link href="/posts/b088c444.html"/>
      <url>/posts/b088c444.html</url>
      
        <content type="html"><![CDATA[<h1>题目及源码</h1><p>相关题目以及源码放在github仓库</p><p><a href="https://github.com/keqiudi/Cpp_internal_exam">keqiudi/Cpp_internal_exam (github.com)</a></p><h1>相关知识点</h1><h2 id="线程池的实现">线程池的实现</h2><p>见线程池篇</p><p><a href="https://keqiudi.github.io/posts/aa76cb12.html">线程池C++版 | Walnut🍭 (keqiudi.github.io)</a></p><h2 id="线程池下的socket">线程池下的socket</h2><p><code>分为两个部分</code>:</p><ul><li>主线程中添加一个任务，单独让一个线程，进行一个任务，该任务处于循环中，一直检测是否有客户端连接。(该线程始终存在)</li><li>如果连接成功，则每一次循环添加所需要工作的任务进线程池中，让其它线程进行处理。(可能管理者被销毁)</li></ul><h2 id="vector">vector</h2><p>此项目中，利用封装后的用户类放入vector容器中，用于保存数据。</p><ul><li>以下只有本项目中使用的函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>()<span class="comment">//尾部插入元素</span></span><br><span class="line"><span class="built_in">emplace_back</span>()<span class="comment">//尾部插入元素</span></span><br><span class="line">userList.<span class="built_in">emplace_back</span>(userName,password,userType,realName);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">pop_back</span>()<span class="comment">//删除最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>()<span class="comment">//删除元素，允许使用迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(userList.<span class="built_in">begin</span>()+i<span class="number">-1</span>)<span class="comment">//删除第i个元素    </span></span><br></pre></td></tr></table></figure>  <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li><p><code>emplace_back()</code> 可以允许直接传入构造函数参数，直接在容器内部创建一个对象，示例见上方。</p></li><li><p><code>push_back()</code>则是需要先用构造函数创建一个对象，再使用拷贝(复制)构造函数插入集合。</p></li></ul><p>即：使用<code>emplace_back()</code>比常规的<code>push_back()</code>少调用了一次复制构造函数，<strong>可提高代码的效率</strong>。</p></div><p><strong>以下为vector详细用法：</strong></p><ul><li><a href="https://blog.csdn.net/qq_52324409/article/details/121000029?spm=1001.2014.3001.5506">C++ vector容器详解_c++容器vector_＆不逝的博客-CSDN博客</a></li></ul><h2 id="运算符重载">运算符重载</h2><p>需要的到一个全新对象对=进行重载时，返回值最好为引用类型</p><p>返回值不是引用的话有以下几个坏处:</p><ul><li>不能实现链式赋值，例如m1 = m2 = m3 = u这样的语句就会报错，因为m2 = m3 = u返回的是一个临时对象，不能再赋值给m1。</li><li>会造成额外的拷贝开销，因为每次赋值都要创建一个新的对象，并调用拷贝构造函数和析构函数，这会降低程序的效率。</li><li>会导致对象的一致性问题，因为赋值后的对象和原对象不是同一个对象，它们的地址不同，如果对其中一个对象进行修改，另一个对象不会受到影响。</li></ul><p><code>例</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Manager&amp; <span class="keyword">operator</span>=(User&amp; user)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserName</span>(user.<span class="built_in">getUserName</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserPassword</span>(user.<span class="built_in">getUserPassword</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserRealName</span>(user.<span class="built_in">getUserRealName</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserType</span>(user.<span class="built_in">getUserType</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserSeatNumber</span>(user.<span class="built_in">getUserSeatNumber</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserSeatStatus</span>(user.<span class="built_in">getUserSeatStatus</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserGarbageTime</span>(user.<span class="built_in">getUserGarbageTime</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserActivityNumber</span>(user.<span class="built_in">getUserActivityNumber</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//User对象赋值给一个Manager对象。这个运算符的返回值是一个Manager的引用，也就是*this</span></span><br></pre></td></tr></table></figure><p><code>附上常用重载：</code></p><p><a href="https://blog.csdn.net/qq_27278957/article/details/85269245?ops_request_misc=%7B%22request%5Fid%22%3A%22169081199116800222867695%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169081199116800222867695&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-85269245-null-null.142%5Ev91%5Econtrol_2,239%5Ev12%5Einsert_chatgpt&amp;utm_term=%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD&amp;spm=1018.2226.3001.4187"> C++ 运算符重载_c++ 重载=_高祥xiang的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 多线程 </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git使用</title>
      <link href="/posts/ad18462f.html"/>
      <url>/posts/ad18462f.html</url>
      
        <content type="html"><![CDATA[<h1>基础篇</h1><h2 id="github术语">github术语</h2><p><strong>Repository</strong>：简称Repo，可以理解为“仓库”，我们的项目就存放在仓库之中。也就是说，如果我们想要建立项目，就得先建立仓库；有多个项目，就建立多个仓库。</p><p><strong>Issues</strong>：可以理解为“问题”，举一个简单的例子，如果我们开源一个项目，如果别人看了我们的项目，并且发现了bug，或者感觉那个地方有待改进，他就可以给我们提出Issue，等我们把Issues解决之后，就可以把这些Issues关闭；反之，我们也可以给他人提出Issue。</p><p><strong>Star</strong>：可以理解为“点赞”，当我们感觉某一个项目做的比较好之后，就可以为这个项目点赞，而且我们点赞过的项目，都会保存到我们的Star之中，方便我们随时查看。在 GitHub 之中，如果一个项目的点星数能够超百，那么说明这个项目已经很不错了。</p><p><strong>Fork</strong>：可以理解为“拉分支”，如果我们对某一个项目比较感兴趣，并且想在此基础之上开发新的功能，这时我们就可以Fork这个项目，这表示复制一个完成相同的项目到我们的 GitHub 账号之中，而且独立于原项目。之后，我们就可以在自己复制的项目中进行开发了。</p><p><strong>Pull Request</strong>：可以理解为“提交请求”，此功能是建立在Fork之上的，如果我们Fork了一个项目，对其进行了修改，而且感觉修改的还不错，我们就可以对原项目的拥有者提出一个Pull请求，等其对我们的请求审核，并且通过审核之后，就可以把我们修改过的内容合并到原项目之中，这时我们就成了该项目的贡献者。</p><p><strong>Merge</strong>：可以理解为“合并”，如果别人Fork了我们的项目，对其进行了修改，并且提出了Pull请求，这时我们就可以对这个Pull请求进行审核。如果这个Pull请求的内容满足我们的要求，并且跟我们原有的项目没有冲突的话，就可以将其合并到我们的项目之中。当然，是否进行合并，由我们决定。</p><p><strong>Watch</strong>：可以理解为“观察”，如果我们Watch了一个项目，之后，如果这个项目有了任何更新，我们都会在第一时候收到该项目的更新通知。</p><p><strong>Gist</strong>：如果我们没有项目可以开源或者只是单纯的想分享一些代码片段的话，我们就可以选择Gist。不过说心里话，如果不翻墙的话，Gist并不好用。</p><h2 id="配置用户名和邮箱">配置用户名和邮箱</h2><p>使用git前配置<strong>用户名和邮箱</strong>，这样才能够识别出来是谁提交的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;keqiudi&quot; #配置用户名</span><br><span class="line">git config --global user.email &quot;1244381125@qq.com&quot; #配置邮箱</span><br><span class="line"></span><br><span class="line">git config --global --list #查看配置</span><br><span class="line">参数：</span><br><span class="line">--global：全局配置，对所有仓库生效，一般使用</span><br><span class="line">--system：系统配置，对所有用户生效，一般不适用</span><br></pre></td></tr></table></figure><h2 id="创建仓库">创建仓库</h2><h3 id="方式一：git-init">方式一：git init</h3><p>先找到找到合适位置的目录，进入该仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init #初始化该仓库</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">成功会提示初始化了一个空的仓库，并且出现分支</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在该文件夹内出现隐藏文件夹.git</span></span><br><span class="line"></span><br><span class="line">git init my-repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加了一个参数后，将指定my-repo为git仓库，而不是该目录</span></span><br></pre></td></tr></table></figure><h3 id="方式二：git-clone">方式二：git clone</h3><p>先在github上常见仓库，再使用git clone</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/keqiudi/keqiudi.github.io</span><br></pre></td></tr></table></figure><h2 id="工作区域和文件状态">工作区域和文件状态</h2><p>git本地数据管理分为三个区域：</p><ul><li><strong>工作区</strong>：英文名working directory，即资源管理器中看到的文件夹，实际操作的目录</li><li><strong>暂存区</strong>：英文名staging area/index，用于保存即将提交到git仓库的修改内容，git版本控制中重要区域</li><li><strong>本地仓库</strong>：英文local repository，通过git init创建的本地仓库，包含完整的项目历史和源数据</li></ul><p><strong>流程</strong>：</p><ul><li>修改工作区文件后，需要将他们添加到暂存区</li><li>再将暂存区中的修改提交到本地仓库中</li></ul><p>git文件状态分为四种：</p><ul><li><p><strong>未跟踪</strong>：新创建没有被git管理起来的文件</p></li><li><p><strong>未修改</strong>：已经被git管理的文件但文件内容没有被修改过</p></li><li><p><strong>已修改</strong>：已经被git管理的文件但文件内容被修改过，没有添加到暂存区的文件</p></li><li><p><strong>已暂存</strong>：已经被git管理的文件但文件内容被修改过，已经添加到暂存区的文件</p></li></ul><h2 id="添加提交文件">添加提交文件</h2><ul><li>查看当前仓库状态，查看分支、文件等等</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">红色文件代表未被跟踪状态，未进入暂存区</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绿色文件代表已经被添加到了暂存区</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意git不会将空文件夹纳入版本控制中，如果创建一个空文件夹再使用git status将不会有区别</span></span><br></pre></td></tr></table></figure><ul><li>添加文件到暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git add fileName</span><br><span class="line"></span><br><span class="line">git add *.txt # 所有以.txt结尾的文件</span><br><span class="line">git add . # 将所有未被跟踪的文件加入暂存区，根据.gitignore做过滤</span><br><span class="line">git add * # 将所有未被跟踪的文件加入暂存区，不根据.gitignore做过滤</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git ls-files # 查看暂存区中的文件内容</span><br><span class="line">git rm --cached &lt;file&gt;...# 将添加到暂存区的文件取消</span><br></pre></td></tr></table></figure><ul><li>提交文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交信息&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意git commit只会提交暂存区中的文件，不会提交工作区中的文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不加上-m参数将会进入交互式状态，默认使用vim编辑提交信息</span></span><br><span class="line"></span><br><span class="line">git commit -a -m &quot;提交信息&quot;</span><br><span class="line">git commit -am &quot;提交信息&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加上-a参数可以同时完成添加暂存和提交两个动作</span></span><br></pre></td></tr></table></figure><ul><li>查看提交记录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示ID,日期，提交者和邮箱</span></span><br><span class="line"></span><br><span class="line">git log --oneline # 查看简介的提交记录，只会显示版本ID和提交信息</span><br></pre></td></tr></table></figure><h2 id="回退版本">回退版本</h2><p>git reset命令用于回退版本,可以退回到之前某一个提交状态，有三种模式</p><ul><li>表示回退到某一个版本，并且保留工作区和暂存区的所有修改内容,即所有工作区和暂存区在回退版本之后的修改都会保留</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft 版本ID</span><br></pre></td></tr></table></figure><ul><li>表示回退到某一个版本，并且丢弃工作区和暂存区的所有修改内容，即所有在工作区和暂存区在回退版本之后的修改都不会保留，完全回到当时版本的工作区和暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">版本ID中 代表上一个版本</span></span><br><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><ul><li>表示回退到某一个版本，并且只保留工作区修改的内容，丢弃暂存区修改的内容，即暂存区在回退版本之后的修改都不会保留，而工作区会保留到最新版本的工作区内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed 版本ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不加参数时默认为mixed</span></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>一般只使用soft和mixed，谨慎使用hard，但若误操作也没关系，git中的命令是可以回溯的，当我们误操作的时候只需要使用git reflog命令查看操作历史记录，找到误操作之前的版本号，再使用git reset回退到这个版本就可以了</strong></p></div><h2 id="查看文件差异">查看文件差异</h2><p>git diff命令可以用于查看文件在工作区、暂存区、本地仓库之间的差异，也可以查看不同版本，不同分支中文件的差异。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">红色代表删除的内容，绿色是添加的内容</span></span><br><span class="line"></span><br><span class="line">git diff </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">无参数默认比较工作区和暂存区之间的差异内容</span></span><br><span class="line"></span><br><span class="line">git diff HEAD </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HEAD参数表示工作区和版本库之间的差异</span></span><br><span class="line"></span><br><span class="line">git diff --cached</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cached比较暂存区和版本库的差异</span></span><br><span class="line"></span><br><span class="line">git diff ID1 ID2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较不同版本的差异时，只需要在后面加上比较的两次版本ID，就可以比较两次版本的差异内容</span></span><br><span class="line"></span><br><span class="line">git diff HEAD~ HEAD</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较当前版本和上一个版本的区别</span></span><br><span class="line"></span><br><span class="line">git diff HEAD~2 HEAD</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较当前版本和最新提交前2个版本的区别</span></span><br><span class="line"></span><br><span class="line">git diff HEAD~ HEAD file3.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只比较file3文件最新版本和上一个版本区别，没有则不显示</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>HEAD是Git中的一个非常重要的概念，指向分支最新提交结点，而HEAD~/HEAD^可以表示上一个版本，通常用于比较当前版本和上一个版本区别。我们还可以在HEAD波浪线后加上数字代表提交之前的几个版本</strong></p></div><h2 id="删除文件">删除文件</h2><p>从版本库中删除文件一共有两种方法:</p><ul><li>直接删除文件后提交</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm file1.txt # 只删除了工作区文件，未更新暂存区文件</span><br><span class="line"></span><br><span class="line">git add . #更新暂存区</span><br><span class="line">git ls-files #查看暂存区文件</span><br><span class="line"></span><br><span class="line">git commit -m &quot;commit&quot; #再次提交</span><br></pre></td></tr></table></figure><ul><li>使用git rm删除(更简单)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git rm file2.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将工作区和暂存区文件同时删除</span></span><br><span class="line"></span><br><span class="line">git rm --cached &lt;file&gt; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--cached参数，将文件从暂存区删除，但保留在当前工作区中</span></span><br><span class="line"></span><br><span class="line">git rm -r *</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">递归删除某个目录下的所有子目录和文件</span></span><br><span class="line"></span><br><span class="line">git commit -m &quot;commit&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意删除后不要忘记提交</span></span><br></pre></td></tr></table></figure><h2 id="gitignore文件">.gitignore文件</h2><p>在git中有个特殊文件，叫忽略文件，可以忽略掉一些不应该加入版本库中的文件，可以让我们的版本库体积更小，更干净</p><p>一般来说遵循下面的原则</p><ul><li>系统或者软件自动生成的文件</li><li>编译产生的中间文件和结果文件</li><li>运行时产生的日志文件、缓存文件、临时文件</li><li>涉及身份、密码、口令、密钥等敏感信息文件</li></ul><p>先创建.gitignore文件，在通过vim对.gitignore文件进行设置过滤文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore</span><br><span class="line"></span><br><span class="line">vim .gitignore</span><br></pre></td></tr></table></figure><p>假设下方为.gitignore文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">access.log #代表忽略access.log文件</span><br><span class="line"></span><br><span class="line">*.log # 代表忽略所有.log文件</span><br></pre></td></tr></table></figure><p>.gitignore文件还可以忽略文件夹内容，注意文件夹格式是以/结尾，才能正常忽略文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.log # 代表忽略所有.log文件</span><br><span class="line"></span><br><span class="line">temp/ # 代表忽略temp文件夹内容</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意.gitignore文件生效有一个前提，就是这个文件不能先添加到版本库中，若已经添加到版本库中.gitignore文件将不会生效</p></div><p><strong>.gitignore文件的匹配规则</strong>：</p><p><strong>从上到下逐行匹配，每行表示一个忽略模式</strong></p><p><a href="https://git-scm.com/docs/gitignore">Git - gitignore 文档 (git-scm.com)</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>空行或者以#开头的行会被git忽略。一般空行用于可读性分隔，#一般用于注释</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>使用标准的Blob模式匹配，例如：</span><br><span class="line">*通配任意个字符</span><br><span class="line">?匹配单个字符</span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">]</span>表示匹配列表中的单个字符<span class="punctuation">,</span>例如<span class="punctuation">:</span><span class="punctuation">[</span>abc<span class="punctuation">]</span> 表示a/b/c</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>两个星号**表示匹配任意的中间目录</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>中括号可以使用短中线链接<span class="punctuation">,</span>比如<span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">0</span><span class="number">-9</span><span class="punctuation">]</span>表示任意一位数字<span class="punctuation">,</span><span class="punctuation">[</span>a-z<span class="punctuation">]</span>表示任意一位小写字母</span><br><span class="line"><span class="number">5.</span>!表示取反</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略所有的.a文件</span></span><br><span class="line">*.a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在第一条的基础上除去lib.a文件</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只忽略当前目录下的TODO文件，而不忽略且文件夹的TODO，因为有/表示当前目录</span></span><br><span class="line">/TODO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略任意目录下名为TODO的文件夹</span></span><br><span class="line">TODO/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略 doc/hello.txt,但不忽略doc/temp/test.txt,因为指定的是doc/目录下的，而不是doc/temp/下的</span></span><br><span class="line">doc/*.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略所有doc/目录及其所有子目录下的/pdf文件</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><p>github上提供了各种常用语言的忽略文件的模板，在新建仓库时可以直接使用，也可以根据需要自己修改</p><p>以下为链接：</p><p><a href="https://github.com/github/gitignore">GitHub - github/gitignore: A collection of useful .gitignore templates</a></p><h2 id="SSH绑定git与github">SSH绑定git与github</h2><p>我们就一起完成 Git 和 GitHub 的绑定，体验通过 Git 向 GitHub 提交代码的能力。不过在这之前，我们需要先了解 SSh（安全外壳协议），因为在 GitHub 上，一般都是通过 SSH 来授权的，而且大多数 Git 服务器也会选择使用 SSH 公钥来进行授权，所以想要向 GitHub 提交代码，首先就得在 GitHub 上添加 SSH key配置。</p><h3 id="生成SSH-key">生成SSH key</h3><ol><li><p>输入ssh 查看本机是否安装ssh</p></li><li><p>输入ssh-keygen -t rsa -C “your_email”</p></li></ol><ul><li>表示我们指定 RSA 算法生成密钥，然后敲三次回车键，期间不需要输入密码，之后就就会生成两个文件，分别为id_rsa和id_rsa.pub，即密钥id_rsa和公钥id_rsa.pub. 对于这两个文件，其都为隐藏文件，默认生成在以下目录：<ul><li>Linux 系统：~/.ssh</li><li>Mac 系统：~/.ssh</li><li>Windows 系统：C:\Documents and Settings\username\.ssh</li><li>Windows 10 ThinkPad：C:\Users\think.ssh</li></ul></li></ul><p>密钥和公钥生成之后，我们要做的事情就是把公钥id_rsa.pub的内容添加到 GitHub，这样我们本地的密钥id_rsa和 GitHub 上的公钥id_rsa.pub才可以进行匹配，授权成功后，就可以向 GitHub 提交代码啦！</p><ol start="3"><li>添加 SSH key</li></ol><ul><li>进入github中的settings，再点击SSH and GPG Keys进入此子界面，然后点击New SSH key按钮：</li><li>将公钥id_rsa.pub的内容粘贴到Key处的位置（Titles的内容不填写也没事），然后点击Add SSH key 即可。</li></ul><ol start="4"><li>验证绑定是否成功</li></ol><p>在 Git Bash 中输入ssh -T git@github.com进行测试：</p><p><img src="https://pic4.zhimg.com/80/v2-aa1938b4970cd5ccddd82406f58aee83_720w.webp" alt="img"></p><p>结果即为Git 与 GitHub 绑定成功的标志。</p><h2 id="通过git将代码提交到github">通过git将代码提交到github</h2><h3 id="pull与push">pull与push</h3><p>push：该单词直译过来就是“推”的意思，如果我们本地的代码有了更新，为了保持本地与远程的代码同步，我们就需要把本地的代码推到远程的仓库，代码示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git push origin master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</span></span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此时指定默认主机后才能不加参数使用</span></span><br></pre></td></tr></table></figure><p>pull：该单词直译过来就是“拉”的意思，如果我们远程仓库的代码有了更新，同样为了保持本地与远程的代码同步，我们就需要把远程的代码拉到本地，代码示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里的仓库名称和分支名称可以省略，默认拉去别名为origin的main分支即</span></span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">git pull -u origin master</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>pull request它表示：如果我们fork了别人的项目（或者说代码），并对其进行了修改，想要把我们的代码合并到原始项目（或者说原始代码）中，我们就需要提交一个pull request，让原作者把我们的代码拉到 ta 的项目中，至少对于 ta 来说，我们都是属于远程端的。</p>   <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>一般情况下，我们在push操作之前都会先进行pull操作，这样不容易造成冲突。</p></div><h3 id="提交代码">提交代码</h3><p>对于向远处仓库（GitHub）提交代码分为两种情况：</p><p><code>第一种：</code></p><ol><li>本地没有 Git 仓库，这时我们就可以直接将远程仓库clone到本地。通过clone命令创建的本地仓库，其本身就是一个 Git 仓库了，不用我们再进行init初始化操作啦，而且自动关联远程仓库。我们只需要在这个仓库进行修改或者添加等操作，然后commit即可。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/guobinhit/mybatis-tutorial.git (仓库链接)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>将需要提交的文件复制到该仓库中</p></li><li><p>使用git status、git add、git commit -m &quot; &quot;、git log、git status</p></li><li><p>将本地仓库的内容push到远程仓库，输入git push origin master</p></li><li></li></ol> <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>在第一次向远程仓库提交代码的时候，需要输入账号及密码进行验证，验证成功后即可。</p></div><p><code>第二种</code></p><p>有本地Git 仓库，并且我们已经进行了多次commit操作。</p><ol><li>进入该仓库，git init初始化操作：</li><li>命令，关联远程仓库（在此，默认大家都知道如何获取远程仓库的地址），其中origin为远程仓库的名字：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/guobinhit/springmvc-tutorial.git</span><br><span class="line"></span><br><span class="line">git remote -v </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以查看关联分支和地址</span></span><br></pre></td></tr></table></figure><ol start="3"><li>输入git pull origin master命令，同步远程仓库和本地仓库：</li><li>再回到本地springmvc-tutorial仓库，看看我们是否已经把远程仓库的内容同步到了本地：</li><li>输入git add和git commit命令，将文件添加并提交到springmvc-tutorial仓库：</li><li>git push origin master命令，将本地仓库修改（或者添加）的内容提交到远程仓库：</li></ol><p>在这个例子中，我们将远程仓库命名为origin，本地仓库名为springmvc-tutorial，其实两者的名字咱们可以随意取，一般来说，我们习惯性将远程仓库命名为origin，不过在需要关联多个远程仓库的时候，就需要我们再取别的名字啦！</p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>在我们向远程仓库提交代码的时候，一定要先进行pull操作，再进行push操作，防止本地仓库与远程仓库不同步导致冲突的问题，尤其是第二种提交代码的情况，很容易就出现问题。</p></div><h2 id="GUI工具">GUI工具</h2><p>常用的</p><ul><li>github Desktop</li><li>GitKraken</li><li>Sourcetree</li></ul><h2 id="分支简介和基本操作">分支简介和基本操作</h2><p>我们可以将分支branch看做代码库中的不同版本，可以独立存在并且有自己的提交记录，分支非常适合团队协作和开发管理，比如多个程序员可以在自己的分支上进行开发工作，我们可以在分支上建立一个新问题的开发或者建立一个问题修复的分支来处理一些bug和缺陷，这样就可以让主线代码仓库处于稳定可用状态。而不会影响到其他功能的开发和测试，能够提高团队开发效率</p><ul><li>创建新分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;新分支名&gt;</span><br></pre></td></tr></table></figure><ul><li>删除分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;已经完成合并的分支&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">小d参数只能删除已经完成合并的分支</span></span><br><span class="line"></span><br><span class="line">git branch -D &lt;未合并的分支&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要删除未合并分支，需要用大D来强制删除分支</span></span><br></pre></td></tr></table></figure><ul><li>查看有哪些分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以查看到有哪些分支</span></span><br></pre></td></tr></table></figure><ul><li>切换到指定分支/恢复文件或目录状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;切换的分支名&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意git checkout可以在意外修改文件后，将文件恢复到修改之前的状态，这个时候分支名称和文件名称相同的就会出现歧义，git checkout命令会默认切换分支而不是恢复文件，下面是官网提供的命令用于专门切换分支</span></span><br><span class="line">git switch &lt;切换的分支名&gt;</span><br></pre></td></tr></table></figure><ul><li>合并分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;需要合并的分支名&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令将不同的分支合并到当前的分支中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">即合并到的目标分支为当前分支</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>查看分支图</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --oneline --decorate --all</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在命令行中可以用以上命令查看分支图，但是没有在git GUI中看着美观</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常使用<span class="built_in">alias</span>为该命令取别名来简化操作</span></span><br><span class="line">alias graph=&quot;git log --graph --oneline --decorate --all&quot;</span><br></pre></td></tr></table></figure><h2 id="解决分支合并冲突">解决分支合并冲突</h2><p>一般情况，**如果两个分支的修改内容没有冲突，git会自动完成合并。**但如果两个分支修改同一文件的同一行代码，那么git就不知道该保留哪个，所以需要我们手动来解决冲突。</p><p>当我们和并分支，输入git merge之后，提示存在合并冲突之后，会自动进入处理合并冲突状态，此时如果想<strong>取消该次合并</strong>只需要输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">即可打断本次合并</span></span><br></pre></td></tr></table></figure><p><strong>如果想继续合并，现在需要解决冲突</strong></p><ul><li><ol><li>我们先输入git status或git diff 来查看冲突位置</li></ol></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br><span class="line"></span><br><span class="line">--- a/main1.txt</span><br><span class="line">+++ b/main1.txt</span><br><span class="line">++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line"> +main</span><br><span class="line"> +这是在master中修改的内容</span><br><span class="line">++=======</span><br><span class="line">+ main1</span><br><span class="line">+ 这是在test中修改的内容</span><br><span class="line">++&gt;&gt;&gt;&gt;&gt;&gt;&gt; test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面中HEAD代表当前分支,<span class="built_in">test</span>代表想合并的分支，+代表添加的内容，main1.txt代表冲突的文件</span></span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>此时我们只需要再进入冲突的文件删除不想要的地方和保留想要的地方即可，同时把提示内容一并删除(+和&lt;和==等)</li></ol></li><li><ol start="3"><li>再git add . 和git commit 即可</li></ol></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>切记在每个分支修改内容后一定要记得add和commit，否则就会出现修改一同带入到切换到的分支的后果，导致两个分支中同一个文件内容出现同步修改</p></div><h2 id="回退和rebase">回退和rebase</h2><p>我们在删除了分支之后可以用命令将已经删除了的分支恢复到指定版本，命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;恢复的分支名称&gt; &lt;恢复版本的提交ID&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令可以恢复已经合并后删除的分支，只需要-b参数，版本ID可以通过来查看</span></span><br><span class="line">git log --graph --oneline --decorate --all</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一般主分支用git reset恢复</span></span><br></pre></td></tr></table></figure><p>rebase叫做&quot;变基&quot;，会将当前所处分支变基到目标分支上，会将两分支<strong>共同祖先</strong>之后的内容变基到目标分支上，类似嫁接移植，故<strong>在不同分支用rebase会产生不同的变基结果</strong>，最终都会是一条分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;目标分支&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下是一个示例</span></span><br><span class="line">----------------</span><br><span class="line">rebase前</span><br><span class="line">----------------</span><br><span class="line">* 941b6c7 (HEAD -&gt; master) main:4</span><br><span class="line">| * bd5a88d (test) test:1</span><br><span class="line">|/</span><br><span class="line">* 51f1666 main:3</span><br><span class="line">* 0e7b89e main:2</span><br><span class="line">* 85c4410 main:1</span><br><span class="line">----------------</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">处于main分支下时执行</span></span><br><span class="line">git rebase test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这将会使main与<span class="built_in">test</span>分支共同祖先之后的内容全部移动到<span class="built_in">test</span>最新分支之后再合并成一条分支</span></span><br><span class="line">在rebase test之后变为</span><br><span class="line">----------------</span><br><span class="line">* 941b6c7 (HEAD -&gt; master) main:4</span><br><span class="line">* bd5a88d (test) test:1</span><br><span class="line">* 51f1666 main:3</span><br><span class="line">* 0e7b89e main:2</span><br><span class="line">* 85c4410 main:1</span><br><span class="line">----------------</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">处于<span class="built_in">test</span>分支下执行</span></span><br><span class="line">git rebase main</span><br><span class="line"></span><br><span class="line">在rebase test之后变为</span><br><span class="line">----------------</span><br><span class="line">* 1d1fee5 (HEAD -&gt; test) test:1</span><br><span class="line">* 941b6c7 (master) main:4</span><br><span class="line">* 51f1666 main:3</span><br><span class="line">* 0e7b89e main:2</span><br><span class="line">* 85c4410 main:1</span><br><span class="line">----------------</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>Merge</strong></p><p><strong>优点</strong>：不会破坏原来分支的提交历史，方便回溯和查看</p><p><strong>缺点</strong>：会产生额外提交结点，分支图较复杂</p><p><strong>Rebase</strong></p><p><strong>优点</strong>：不会新增额外提交记录(合并)，形成线性历史，比较直观和干净；</p><p><strong>缺点</strong>：会改变提交历史，改变了当前分支branch out的节点，<strong>应当避免在共享分支中使用，一般不会和共同开发的分支中使用</strong>，当确定只有自己在该分支开发时且希望提交历史更加清晰明了则推荐使用。</p></div><h2 id="标签">标签</h2><p>tag用于在开发阶段创建标签，某个阶段完成了创建一个版本，在开发中可以使用tag来指定软件的一个重要时期，比如版本号更新的时候可以创建一个v1.0，这样回顾的时候比较简单</p><ul><li>查看tag</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这样列出的tag是按照字母排序的，和创建时间没有关系，如果只是想查看某些tag的话可以加一些限定：</span></span><br><span class="line"></span><br><span class="line">git tag -l version1.*</span><br></pre></td></tr></table></figure><ul><li>创建tag</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git tag version 1.0  #也可以 git tag 1.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">带有信息的tag:</span></span><br><span class="line">git tag -a version1.0 -m &quot;first version&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用 -a （译注：取 annotated 的首字母）指定标签名字即可,而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明</span></span><br></pre></td></tr></table></figure><ul><li>删除tag</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;标签名字&gt;</span><br></pre></td></tr></table></figure><h2 id="分支命名和管理">分支命名和管理</h2><p><strong>分支命名</strong>：</p><ul><li>推荐使用带有意义的描述性名称来命名分支<ul><li>版本发布分支/tag示例：v1.0.0</li><li>功能分支示例：feature-login-page</li><li>修复分支示例：hotfix-#issueid-desc</li></ul></li></ul><p><strong>分支管理</strong>：</p><ul><li>定期合并已经成功验证的分支，及时删除已经合并的分支</li><li>保持合适的分支数量</li><li>为分支设置合适的管理权限</li></ul>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器并发</title>
      <link href="/posts/11572ff3.html"/>
      <url>/posts/11572ff3.html</url>
      
        <content type="html"><![CDATA[<h1>1.单线程/进程</h1><p>在TCP通信过程中，服务器端启动之后可以同时和多个客户端建立连接，并进行网络通信，但是在介绍TCP通信流程的时候，提供的服务器代码却不能完成这样的需求，先简单的看一下之前的服务器代码的处理思路，再来分析代码中的弊端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            write(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中用到了三个会引起程序阻塞的函数，分别是：</p><ul><li><p>accept()：如果服务器端没有新客户端连接，阻塞当前进程/线程，如果检测到新连接解除阻塞，建立连接</p></li><li><p>read()：如果通信的套接字对应的读缓冲区没有数据，阻塞当前进程/线程，检测到数据解除阻塞，接收数据</p></li><li><p>write()：如果通信的套接字写缓冲区被写满了，阻塞当前进程/线程（这种情况比较少见）</p></li></ul><p>如果需要和发起新的连接请求的客户端建立连接，那么就必须在服务器端通过一个循环调用accept()函数，另外已经和服务器建立连接的客户端需要和服务器通信，发送数据时的阻塞可以忽略，当接收不到数据时程序也会被阻塞，这时候就会非常矛盾，被accept()阻塞就无法通信，被read()阻塞就无法和客户端建立新连接。因此得出一个结论，基于上述处理方式，在单线程/单进程场景下，服务器是无法处理多连接的，解决方案也有很多，常用的有三种：</p><ol><li>使用多线程实现</li><li>使用多进程实现</li><li>使用IO多路转接（复用）实现</li><li>使用IO多路转接 + 多线程实现</li></ol><h1>2.多线程并发</h1><p>多线程中的线程有两大类：主线程（父线程）和子线程，他们分别要在服务器端处理监听和通信流程。根据多进程的处理思路，就可以这样设计了：</p><ul><li>主线程<ul><li>负责监听，处理客户端的连接请求，也就是在父进程中循环调用accept()函数</li><li>创建子线程：建立一个新的连接，就创建一个新的子进程，让这个子进程和对应的客户端通信</li><li>回收子线程资源：由于回收需要调用阻塞函数，这样就会影响accept()，直接做<strong>线程分离</strong>即可。</li></ul></li><li>子线程：负责通信，基于主线程建立新连接之后得到的文件描述符，和对应的客户端完成数据的接收和发送。<ul><li>发送数据：send() / write()</li><li>发送数据：recv() / read()</li></ul></li></ul><p>在多线程版的服务器端程序中，多个线程共用同一个地址空间，有些数据是共享的，有些数据的独占的，下面来分析一些其中的一些细节：</p>   <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li><p>同一地址空间中的多个线程的栈空间是独占的</p></li><li><p>多个线程共享全局数据区，堆区，以及内核区的文件描述符等资源，因此需要注意数据覆盖问题，并且在多个线程访问共享资源的时候，还需要进行线程同步。</p></li></ul></div><p>多线程版TCP服务器示例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;                      <span class="comment">// 通信</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;               <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span>     <span class="comment">// 地址信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span> <span class="title">infos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">info</span> =</span> (<span class="keyword">struct</span> SockInfo*)arg;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> ret = read(info-&gt;fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端已经关闭连接...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;接收数据失败...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            write(info-&gt;fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于监听的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;          <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">8989</span>);        <span class="comment">// 字节序应该是网络字节序</span></span><br><span class="line">    addr.sin_addr.s_addr =  INADDR_ANY; <span class="comment">// == 0, 获取IP的操作交给了内核</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.设置监听</span></span><br><span class="line">    ret = listen(fd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 等待, 接受连接请求</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据初始化</span></span><br><span class="line">    <span class="type">int</span> max = <span class="keyword">sizeof</span>(infos) / <span class="keyword">sizeof</span>(infos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(&amp;infos[i], <span class="keyword">sizeof</span>(infos[i]));</span><br><span class="line">        infos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        infos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程监听, 子进程通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(infos[i].fd == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pinfo = &amp;infos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> connfd = accept(fd, (<span class="keyword">struct</span> sockaddr*)&amp;pinfo-&gt;addr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent thread, connfd: %d\n&quot;</span>, connfd);</span><br><span class="line">        <span class="keyword">if</span>(connfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pinfo-&gt;fd = connfd;</span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);  <span class="comment">// 监听</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ol><li><p>在编写多线程版并发服务器代码的时候，需要注意父子线程共用同一个地址空间中的文件描述符，因此每当在主线程中建立一个新的连接，都需要将得到文件描述符值保存起来，不能在同一变量上进行覆盖，这样做丢失了之前的文件描述符值也就不知道怎么和客户端通信了。</p></li><li><p>在上面示例代码中是将成功建立连接之后得到的用于通信的文件描述符值保存到了一个全局数组中，每个子线程需要和不同的客户端通信，需要的文件描述符值也就不一样，只要保证存储每个有效文件描述符值的变量对应不同的内存地址，在使用的时候就不会发生数据覆盖的现象，造成通信数据的混乱了。</p></li></ol></div><h1>3.多进程并发</h1>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池C++版</title>
      <link href="/posts/aa76cb12.html"/>
      <url>/posts/aa76cb12.html</url>
      
        <content type="html"><![CDATA[<h1>1.任务队列</h1><h2 id="类声明-Task-TaskQueue">类声明(Task,TaskQueue)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> C___PRACTICE_TASKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C___PRACTICE_TASKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> function = <span class="built_in">void</span>(*)(<span class="type">void</span>* arg);<span class="comment">//为一个函数指针类型取别名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>()&#123;</span><br><span class="line">        working = <span class="literal">nullptr</span>;</span><br><span class="line">        arg = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*无参构造*/</span></span><br><span class="line">    <span class="built_in">Task</span>(function working, <span class="type">void</span>* arg)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;working = working;</span><br><span class="line">        <span class="keyword">this</span>-&gt;arg = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*有参构造*/</span></span><br><span class="line">    function working;</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;Task&gt; taskQueue;<span class="comment">//任务队列,用容器实现</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span>  QueueLock;<span class="comment">//互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task&amp; task)</span></span>;</span><br><span class="line">    <span class="comment">/*添加任务*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(function working, <span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">/*addTask重载函数*/</span></span><br><span class="line">    <span class="function">Task <span class="title">takeTask</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*取出任务*/</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">getTaskSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> taskQueue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取任务队列大小*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//C___PRACTICE_TASKQUEUE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<span class='p red'>Task</span> 是任务类，里边有两个成员，分别是两个指针 <span class='p red'>void(*)(void*)</span>和 <span class='p red'>void*</span></p><p>另外一个类<span class='p red'>TaskQueue</span>是任务队列，提供了添加任务、取出任务、存储任务、获取任务个数、线程同步的功能。</p><h2 id="类定义">类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskQueue::<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;QueueLock, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">TaskQueue::~<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;QueueLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(Task&amp; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);<span class="comment">//此处如果资源已经被释放，就会发生段错误</span></span><br><span class="line">    taskQueue.<span class="built_in">push</span>(task);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(function working, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);</span><br><span class="line">    taskQueue.<span class="built_in">push</span>(<span class="built_in">Task</span>(working, arg));</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">TaskQueue::takeTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);</span><br><span class="line">    Task t;</span><br><span class="line">    <span class="keyword">if</span>(!taskQueue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        t = taskQueue.<span class="built_in">front</span>();<span class="comment">//取出队列头部元素</span></span><br><span class="line">        taskQueue.<span class="built_in">pop</span>();<span class="comment">//删除队列头部元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2.线程池</h1><h2 id="类声明-ThreadPool">类声明(ThreadPool)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> C___PRACTICE_THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C___PRACTICE_THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaskQueue* taskQueue = <span class="literal">nullptr</span>;<span class="comment">//任务队列</span></span><br><span class="line">    <span class="type">pthread_t</span> managerID;<span class="comment">//管理者线程id</span></span><br><span class="line">    <span class="type">pthread_t</span>* threadIDs;</span><br><span class="line">    <span class="type">int</span> minNum;<span class="comment">//最小线程数</span></span><br><span class="line">    <span class="type">int</span> maxNum;<span class="comment">//最大线程数</span></span><br><span class="line">    <span class="type">int</span> busyNum;<span class="comment">//忙线程数</span></span><br><span class="line">    <span class="type">int</span> liveNum;<span class="comment">//活着的线程数</span></span><br><span class="line">    <span class="type">int</span> exitNum;<span class="comment">//要销毁的线程数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> threadLock;<span class="comment">//锁住整个线程池</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> busyLock;<span class="comment">//单独锁住busyNum，提高效率</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;<span class="comment">//任务队列为空时阻塞，不为空时唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> shutdown;<span class="comment">//是否要销毁线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//工作线程函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//管理者线程函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadExit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> min,<span class="type">int</span> max);</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task task)</span></span>;</span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getBusyNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取忙线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getAliveNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取活着的线程数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//C___PRACTICE_THREADPOOL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类定义-2">类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_TIME 5<span class="comment">//默认管理者线程检测时间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_NUM 2<span class="comment">//一次添加3个线程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_NUM 2<span class="comment">//一次销毁3个线程</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">safe_delete_void_ptr</span><span class="params">(<span class="type">void</span>* &amp;target)</span></span>;</span><br><span class="line"></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> min, <span class="type">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">        taskQueue = <span class="built_in">new</span> (std::nothrow)TaskQueue;</span><br><span class="line">          <span class="comment">/*没有std::nothrow则if条件始终为false*/</span></span><br><span class="line">        <span class="keyword">if</span>(taskQueue == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;new taskQueue error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        threadIDs = <span class="built_in">new</span> (std::nothrow)<span class="type">pthread_t</span>[max];<span class="comment">//分配动态数组</span></span><br><span class="line"><span class="comment">/*没有std::nothrow则if条件始终为false*/</span></span><br><span class="line">        <span class="keyword">if</span>(threadIDs == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new threadIDs error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(threadIDs, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        minNum = min;</span><br><span class="line">        maxNum = max;</span><br><span class="line">        busyNum = <span class="number">0</span>;</span><br><span class="line">        liveNum = min;</span><br><span class="line">        exitNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;threadLock, <span class="literal">nullptr</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_mutex_init</span>(&amp;busyLock, <span class="literal">nullptr</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_cond_init</span>(&amp;notEmpty, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;init the lock or cond error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shutdown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 类的成员函数传递地址时失败报错:Reference to non-static member function must be called</span></span><br><span class="line"><span class="comment">         * 原因:类的成员函数不是静态时，函数没有地址，只有实例化之后才会有地址，所以不能传递地址</span></span><br><span class="line"><span class="comment">         * 两种解决方案:</span></span><br><span class="line"><span class="comment">         * 1.将成员函数改为静态函数</span></span><br><span class="line"><span class="comment">         * 2.将成员函数改为全局函数，独立于类之外（想要访问成员变量就必须加上友元函数）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;managerID, <span class="literal">nullptr</span>, manager, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;threadIDs[i], <span class="literal">nullptr</span>, worker, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//此处不返回将会导致之后的释放资源</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] threadIDs;</span><br><span class="line">        threadIDs = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="comment">//如果threadIDs不为空，释放内存</span></span><br><span class="line">    <span class="keyword">if</span>(taskQueue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> taskQueue;</span><br><span class="line">        taskQueue = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="comment">//如果taskQueue不为空，释放内存</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadPool::worker</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);<span class="comment">//传递的是(void*)this,所以要强制类型转换</span></span><br><span class="line">    <span class="comment">/*此处static_cast为C++的强制类型转换，也可用C中的(ThreadPool*)形式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 静态函数不能访问成员变量，所以必须传入该类的实例化对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        <span class="keyword">while</span>(pool-&gt;taskQueue-&gt;<span class="built_in">getTaskSize</span>()==<span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;thread &quot;</span>&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot; is waiting&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notEmpty, &amp;pool-&gt;threadLock);</span><br><span class="line">            <span class="comment">//如果任务队列为空，且线程池没有关闭，则等待</span></span><br><span class="line">            <span class="comment">//等待条件变量，会先解锁，等待被唤醒，再次拿到了这把锁</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*管理者销毁线程逻辑</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 唤醒后判断是否要销毁线程</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;exitNum &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pool-&gt;exitNum--;<span class="comment">//不能放在if里面，否则可能在产生新线程时，Num&gt;0,直接就被销毁了，不符合期望，故保证每次循环都减一</span></span><br><span class="line">                <span class="comment">/*限定当存活的线程个数大于最小个数时才销毁*/</span></span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum) &#123;</span><br><span class="line">                    pool-&gt;liveNum--;</span><br><span class="line">                    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//解锁</span></span><br><span class="line">                    pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;shutdown)<span class="comment">//如果线程池关闭，则线程全部退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//避免死锁</span></span><br><span class="line">            pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出任务工作</span></span><br><span class="line">        Task task = pool-&gt;taskQueue-&gt;<span class="built_in">takeTask</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处生产者不需要被唤醒了，任务队列可以无限大,即可以无限量的任务</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">        pool-&gt;busyNum++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; start working&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        task.<span class="built_in">working</span>(task.arg);<span class="comment">//执行任务</span></span><br><span class="line">        <span class="built_in">safe_delete_void_ptr</span>&lt;<span class="type">int</span>&gt;(task.arg);<span class="comment">//直接delete task.arg 有危险</span></span><br><span class="line">        task.arg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; end working&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">        pool-&gt;busyNum--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadPool::manager</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(CHECK_TIME);<span class="comment">//每隔3秒检测一次</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        <span class="type">size_t</span> queueSize = pool-&gt;taskQueue-&gt;<span class="built_in">getTaskSize</span>();<span class="comment">//取出任务个数</span></span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;<span class="comment">//取出存活线程个数</span></span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加线程规则</span></span><br><span class="line">        <span class="comment">//1.任务个数&gt;存活线程个数&amp;&amp;存活线程个数&lt;最大线程个数时，创建线程</span></span><br><span class="line">        <span class="keyword">if</span>(queueSize&gt;liveNum&amp;&amp;liveNum&lt;pool-&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*for循环三个条件</span></span><br><span class="line"><span class="comment">             * 1.遍历线程id</span></span><br><span class="line"><span class="comment">             * 2.counter&lt;ADD_NUM</span></span><br><span class="line"><span class="comment">             * 3.在存活线程个数小于最大线程个数时才添加*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pool-&gt;maxNum&amp;&amp;counter&lt;ADD_NUM&amp;&amp;pool-&gt;liveNum&lt;pool-&gt;maxNum;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到空闲的线程id，创建线程</span></span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threadIDs[i]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">pthread_create</span>(&amp;pool-&gt;threadIDs[i],<span class="literal">nullptr</span>,worker,pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//销毁线程规则</span></span><br><span class="line">        <span class="comment">//1.忙线程*2&lt;存活线程&amp;&amp;存活线程&gt;最小线程个数时，销毁线程</span></span><br><span class="line">        <span class="keyword">if</span>(busyNum*<span class="number">2</span>&lt;liveNum&amp;&amp;liveNum&gt;pool-&gt;minNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">            pool-&gt;exitNum = EXIT_NUM;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">            <span class="comment">//唤醒线程池中所有的线程，让他们自己执行，判断是否退出</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;EXIT_NUM;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadExit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*使线程退出时线程id归0*/</span></span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="built_in">pthread_self</span>();<span class="comment">//获取当前线程的id</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(threadIDs[i] == tid)</span><br><span class="line">        &#123;</span><br><span class="line">            threadIDs[i] = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;threadExit() called, threadID: &quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot; exiting...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);<span class="comment">//C的函数，此处不用nullptr，而是用NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::addTask</span><span class="params">(Task task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处不用判断任务队列是否满，因为任务队列可以无限大</span></span><br><span class="line">    <span class="keyword">if</span>(shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="comment">//如果线程池关闭，则不添加任务</span></span><br><span class="line"></span><br><span class="line">    taskQueue-&gt;<span class="built_in">addTask</span>(task);<span class="comment">//添加任务,此时不用上锁原因，因为addTask中已经上锁了</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);<span class="comment">//唤醒线程池中的消费者线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ThreadPool::getBusyNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用busyNum自己的锁，提高效率</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;busyLock);</span><br><span class="line">    <span class="type">int</span> busyNum = <span class="keyword">this</span>-&gt;busyNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;busyLock);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ThreadPool::getAliveNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用线程池的锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;threadLock);</span><br><span class="line">    <span class="type">int</span> liveNum = <span class="keyword">this</span>-&gt;liveNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;threadLock);</span><br><span class="line">    <span class="keyword">return</span> liveNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shutdown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(<span class="keyword">this</span>-&gt;managerID, <span class="literal">nullptr</span>);<span class="comment">//等待管理者线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;liveNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);<span class="comment">//唤醒所有线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;threadLock);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;busyLock);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;notEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(taskQueue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> taskQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] threadIDs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_delete_void_ptr</span><span class="params">(<span class="type">void</span>* &amp;target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target)</span><br><span class="line">    &#123;</span><br><span class="line">        T* temp = <span class="built_in">static_cast</span>&lt;T*&gt;(target);</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line">        target = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="遇到的问题">遇到的问题</h3><div class="tip warning faa-horizontal animated"><p>注意25行用new分配内存C++中，new操作符默认不会返回NULL，而是会在分配内存失败时抛出一个std::bad_alloc异常。这样做的好处是，你不需要在每次使用new操作符后检查返回值是否为NULL，而是可以用try/catch语句统一处理异常。如果你想让new操作符在分配内存失败时返回NULL，而不是抛出异常，你可以使用std::nothrow参数</p></div><p>解决方案:</p><ul><li>try/catch语句统一处理异常</li><li>std::nothrow参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.第一种</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            taskQueue = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (std::bad_alloc &amp;e) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new taskQueue error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadIDs = <span class="keyword">new</span> <span class="type">pthread_t</span>[max];<span class="comment">//分配动态数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (std::bad_alloc &amp;e) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new threadIDs error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种，见上方代码中使用方法,25行</span></span><br></pre></td></tr></table></figure><div class="tip warning faa-horizontal animated"><p>注意这里133行代码，C++中不能用delete直接删除一个void*指针，因为delete需要调用被删除对象的析构函数，而void指针没有类型信息，所以无法确定调用哪个析构函数。这样做会导致未定义行为，可能会出现崩溃或内存泄漏。你必须在delete之前把void指针转换回它原来的类型，才能正确地释放内存。</p></div><ul><li>解决方案一：使用模板定义内联函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">safe_delete_void_ptr</span><span class="params">(<span class="type">void</span>* &amp;target)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_delete_void_ptr</span><span class="params">(<span class="type">void</span>* &amp;target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target)</span><br><span class="line">    &#123;</span><br><span class="line">        T* temp = <span class="built_in">static_cast</span>&lt;T*&gt;(target);</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line">        target = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//</span></span><br></pre></td></tr></table></figure><p>[ C++指针编程你要小心的陷阱——如何优雅的释放指针void*_c++释放void<em>指针_二流小宝的博客-CSDN博客](<a href="https://blog.csdn.net/SweetTool/article/details/77688337?ops_request_misc=%7B%22request%5Fid%22%3A%22168977949416800222881353%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168977949416800222881353&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-77688337-null-null.142%5Ev90%5Einsert_down28v1,239%5Ev2%5Einsert_chatgpt&amp;utm_term=c%2B%2B">https://blog.csdn.net/SweetTool/article/details/77688337?ops_request_misc={&quot;request_id&quot;%3A&quot;168977949416800222881353&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334..&quot;}&amp;request_id=168977949416800222881353&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-77688337-null-null.142^v90^insert_down28v1,239^v2^insert_chatgpt&amp;utm_term=c%2B%2B</a> delete void</em> 指针&amp;spm=1018.2226.3001.4187)</p><ul><li>解决方案二：用模板类</li></ul><h1>3.修改为模板类处理指针释放问题</h1><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">TaskQueue.h</button></li><li class="tab"><button type="button" data-href="#分栏-2">TaskQueue.cpp</button></li><li class="tab"><button type="button" data-href="#分栏-3">ThreadPool.h</button></li><li class="tab"><button type="button" data-href="#分栏-4">ThreadPool.cpp</button></li><li class="tab"><button type="button" data-href="#分栏-5">test.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> C___PRACTICE_TASKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C___PRACTICE_TASKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> function = <span class="built_in">void</span>(*)(<span class="type">void</span>* arg);<span class="comment">//为一个函数指针类型取别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//含有模板类的函数或类都要加这个</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>&lt;T&gt;()&#123;</span><br><span class="line">        working = <span class="literal">nullptr</span>;</span><br><span class="line">        arg = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*无参构造*/</span></span><br><span class="line">    <span class="built_in">Task</span>&lt;T&gt;(function working, <span class="type">void</span>* arg)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;working = working;</span><br><span class="line">        <span class="keyword">this</span>-&gt;arg = (T*)arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*有参构造*/</span></span><br><span class="line">    function working;</span><br><span class="line">    T* arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;Task&lt;T&gt;&gt; taskQueue;<span class="comment">//任务队列,用容器实现</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span>  QueueLock;<span class="comment">//互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task&lt;T&gt; task)</span></span>;</span><br><span class="line">    <span class="comment">/*添加任务*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(function working, <span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">/*addtask重载函数*/</span></span><br><span class="line">    <span class="function">Task&lt;T&gt; <span class="title">takeTask</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*取出任务*/</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">getTaskSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> taskQueue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取任务队列大小*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//C___PRACTICE_TASKQUEUE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">TaskQueue&lt;T&gt;::<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;QueueLock, <span class="literal">nullptr</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//模板类前面都要加这个</span></span><br><span class="line">TaskQueue&lt;T&gt;::~<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;QueueLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> TaskQueue&lt;T&gt;::<span class="built_in">addTask</span>(Task&lt;T&gt; task)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);<span class="comment">//此处如果资源已经被释放，就会发生段错误</span></span><br><span class="line">    taskQueue.<span class="built_in">push</span>(task);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> TaskQueue&lt;T&gt;::<span class="built_in">addTask</span>(function working, <span class="type">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);</span><br><span class="line">    taskQueue.<span class="built_in">push</span>(<span class="built_in">Task</span>&lt;T&gt;(working, arg));</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Task&lt;T&gt; TaskQueue&lt;T&gt;::<span class="built_in">takeTask</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);</span><br><span class="line">    Task&lt;T&gt; t;</span><br><span class="line">    <span class="keyword">if</span>(!taskQueue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      t = taskQueue.<span class="built_in">front</span>();<span class="comment">//取出队列头部元素</span></span><br><span class="line">      taskQueue.<span class="built_in">pop</span>();<span class="comment">//删除队列头部元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> C___PRACTICE_THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C___PRACTICE_THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.cpp&quot;</span></span></span><br><span class="line"><span class="comment">/*特殊:</span></span><br><span class="line"><span class="comment"> * 当有类模板时,类模板的声明和定义分开写时，需要包含头文件和源文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    TaskQueue&lt;T&gt;* taskQueue;<span class="comment">//任务队列</span></span><br><span class="line">    <span class="type">pthread_t</span> managerID;<span class="comment">//管理者线程id</span></span><br><span class="line">    <span class="type">pthread_t</span>* threadIDs;</span><br><span class="line">    <span class="type">int</span> minNum;<span class="comment">//最小线程数</span></span><br><span class="line">    <span class="type">int</span> maxNum;<span class="comment">//最大线程数</span></span><br><span class="line">    <span class="type">int</span> busyNum;<span class="comment">//忙线程数</span></span><br><span class="line">    <span class="type">int</span> liveNum;<span class="comment">//活着的线程数</span></span><br><span class="line">    <span class="type">int</span> exitNum;<span class="comment">//要销毁的线程数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> threadLock;<span class="comment">//锁住整个线程池</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> busyLock;<span class="comment">//单独锁住busyNum，提高效率</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;<span class="comment">//任务队列为空时阻塞，不为空时唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> shutdown;<span class="comment">//是否要销毁线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//工作线程函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//管理者线程函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadExit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> min,<span class="type">int</span> max);</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task&lt;T&gt; task)</span></span>;</span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getBusyNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取忙线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getAliveNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取活着的线程数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//C___PRACTICE_THREADPOOL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_TIME 5<span class="comment">//默认管理者线程检测时间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_NUM 2<span class="comment">//一次添加3个线程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_NUM 2<span class="comment">//一次销毁3个线程</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ThreadPool&lt;T&gt;::<span class="built_in">ThreadPool</span>(<span class="type">int</span> min, <span class="type">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        taskQueue = <span class="keyword">new</span> TaskQueue&lt;T&gt;;</span><br><span class="line">        <span class="keyword">if</span>(taskQueue == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new taskQueue error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threadIDs = <span class="keyword">new</span> <span class="type">pthread_t</span>[max];<span class="comment">//分配动态数组</span></span><br><span class="line">        <span class="keyword">if</span>(threadIDs == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new threadIDs error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(threadIDs, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        minNum = min;</span><br><span class="line">        maxNum = max;</span><br><span class="line">        busyNum = <span class="number">0</span>;</span><br><span class="line">        liveNum = min;</span><br><span class="line">        exitNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;threadLock, <span class="literal">nullptr</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_mutex_init</span>(&amp;busyLock, <span class="literal">nullptr</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_cond_init</span>(&amp;notEmpty, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;init the lock or cond error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shutdown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 类的成员函数传递地址时失败报错:Reference to non-static member function must be called</span></span><br><span class="line"><span class="comment">         * 原因:类的成员函数不是静态时，函数没有地址，只有实例化之后才会有地址，所以不能传递地址</span></span><br><span class="line"><span class="comment">         * 两种解决方案:</span></span><br><span class="line"><span class="comment">         * 1.将成员函数改为静态函数</span></span><br><span class="line"><span class="comment">         * 2.将成员函数改为全局函数，独立于类之外（想要访问成员变量就必须加上友元函数）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">         <span class="built_in">pthread_create</span>(&amp;managerID, <span class="literal">nullptr</span>, manager, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;threadIDs[i], <span class="literal">nullptr</span>, worker, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//此处不返回将会导致之后的释放资源</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] threadIDs;</span><br><span class="line">        threadIDs = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="comment">//如果threadIDs不为空，释放内存</span></span><br><span class="line">    <span class="keyword">if</span>(taskQueue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> taskQueue;</span><br><span class="line">        taskQueue = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="comment">//如果taskQueue不为空，释放内存</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* ThreadPool&lt;T&gt;::<span class="built_in">worker</span>(<span class="type">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">auto</span> pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);<span class="comment">//传递的是(void*)this,所以要强制类型转换</span></span><br><span class="line">     <span class="comment">/*此处为C++的强制类型转换，也可用C中的(ThreadPool*)</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * 静态函数不能访问成员变量，所以必须传入该类的实例化对象</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">         <span class="keyword">while</span>(pool-&gt;taskQueue-&gt;<span class="built_in">getTaskSize</span>()==<span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">         &#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;thread &quot;</span>&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot; is waiting&quot;</span>&lt;&lt;endl;</span><br><span class="line">             <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notEmpty, &amp;pool-&gt;threadLock);</span><br><span class="line">             <span class="comment">//如果任务队列为空，且线程池没有关闭，则等待</span></span><br><span class="line">             <span class="comment">//等待条件变量，会先解锁，等待被唤醒，再次拿到了这把锁</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">/*管理者销毁线程逻辑</span></span><br><span class="line"><span class="comment">              *</span></span><br><span class="line"><span class="comment">              * 唤醒后判断是否要销毁线程</span></span><br><span class="line"><span class="comment">              * */</span></span><br><span class="line">             <span class="keyword">if</span> (pool-&gt;exitNum &gt; <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 pool-&gt;exitNum--;<span class="comment">//不能放在if里面，否则可能在产生新线程时，Num&gt;0,直接就被销毁了，不符合期望，故保证每次循环都减一</span></span><br><span class="line">                 <span class="comment">/*限定当存活的线程个数大于最小个数时才销毁*/</span></span><br><span class="line">                 <span class="keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum) &#123;</span><br><span class="line">                     pool-&gt;liveNum--;</span><br><span class="line">                     <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//解锁</span></span><br><span class="line">                     pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(pool-&gt;shutdown)<span class="comment">//如果线程池关闭，则线程全部退出</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//避免死锁</span></span><br><span class="line">                 pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//取出任务工作</span></span><br><span class="line">             Task task = pool-&gt;taskQueue-&gt;<span class="built_in">takeTask</span>();</span><br><span class="line"></span><br><span class="line">             <span class="comment">//此处生产者不需要被唤醒了，任务队列可以无限大,即可以无限量的任务</span></span><br><span class="line">             <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line">             <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">             pool-&gt;busyNum++;</span><br><span class="line">             <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; start working&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             task.<span class="built_in">working</span>(task.arg);<span class="comment">//执行任务</span></span><br><span class="line">             <span class="keyword">delete</span> task.arg;<span class="comment">//释放参数资源</span></span><br><span class="line">             task.arg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; end working&quot;</span> &lt;&lt; endl;</span><br><span class="line">             <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">             pool-&gt;busyNum--;</span><br><span class="line">             <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* ThreadPool&lt;T&gt;::<span class="built_in">manager</span>(<span class="type">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(CHECK_TIME);<span class="comment">//每隔3秒检测一次</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        <span class="type">size_t</span> queueSize = pool-&gt;taskQueue-&gt;<span class="built_in">getTaskSize</span>();<span class="comment">//取出任务个数</span></span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;<span class="comment">//取出存活线程个数</span></span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加线程规则</span></span><br><span class="line">        <span class="comment">//1.任务个数&gt;存活线程个数&amp;&amp;存活线程个数&lt;最大线程个数时，创建线程</span></span><br><span class="line">        <span class="keyword">if</span>(queueSize&gt;liveNum&amp;&amp;liveNum&lt;pool-&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*for循环三个条件</span></span><br><span class="line"><span class="comment">             * 1.遍历线程id</span></span><br><span class="line"><span class="comment">             * 2.counter&lt;ADD_NUM</span></span><br><span class="line"><span class="comment">             * 3.在存活线程个数小于最大线程个数时才添加*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pool-&gt;maxNum&amp;&amp;counter&lt;ADD_NUM&amp;&amp;pool-&gt;liveNum&lt;pool-&gt;maxNum;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到空闲的线程id，创建线程</span></span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threadIDs[i]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">pthread_create</span>(&amp;pool-&gt;threadIDs[i],<span class="literal">nullptr</span>,worker,pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//销毁线程规则</span></span><br><span class="line">        <span class="comment">//1.忙线程*2&lt;存活线程&amp;&amp;存活线程&gt;最小线程个数时，销毁线程</span></span><br><span class="line">        <span class="keyword">if</span>(busyNum*<span class="number">2</span>&lt;liveNum&amp;&amp;liveNum&gt;pool-&gt;minNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">            pool-&gt;exitNum = EXIT_NUM;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">            <span class="comment">//唤醒线程池中所有的线程，让他们自己执行，判断是否退出</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;EXIT_NUM;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ThreadPool&lt;T&gt;::<span class="built_in">threadExit</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*使线程退出时线程id归0*/</span></span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="built_in">pthread_self</span>();<span class="comment">//获取当前线程的id</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(threadIDs[i] == tid)</span><br><span class="line">        &#123;</span><br><span class="line">            threadIDs[i] = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;threadExit() called, threadID: &quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot; exiting...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);<span class="comment">//C的函数，此处不用nullptr，而是用NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ThreadPool&lt;T&gt;::<span class="built_in">addTask</span>(Task&lt;T&gt; task)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处不用判断任务队列是否满，因为任务队列可以无限大</span></span><br><span class="line">    <span class="keyword">if</span>(shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="comment">//如果线程池关闭，则不添加任务</span></span><br><span class="line"></span><br><span class="line">    taskQueue-&gt;<span class="built_in">addTask</span>(task);<span class="comment">//添加任务,此时不用上锁原因，因为addTask中已经上锁了</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);<span class="comment">//唤醒线程池中的消费者线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> ThreadPool&lt;T&gt;::<span class="built_in">getBusyNumber</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用busyNum自己的锁，提高效率</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;busyLock);</span><br><span class="line">    <span class="type">int</span> busyNum = <span class="keyword">this</span>-&gt;busyNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;busyLock);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> ThreadPool&lt;T&gt;::<span class="built_in">getAliveNumber</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用线程池的锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;threadLock);</span><br><span class="line">    <span class="type">int</span> liveNum = <span class="keyword">this</span>-&gt;liveNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;threadLock);</span><br><span class="line">    <span class="keyword">return</span> liveNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ThreadPool&lt;T&gt;::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shutdown = <span class="literal">true</span>;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(<span class="keyword">this</span>-&gt;managerID, <span class="literal">nullptr</span>);<span class="comment">//等待管理者线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;liveNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);<span class="comment">//唤醒所有线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;threadLock);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;busyLock);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;notEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(taskQueue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> taskQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] threadIDs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ThreadPool.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span>*)arg;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; is working, number = &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadPool&lt;<span class="type">int</span>&gt; <span class="title">pool</span><span class="params">(<span class="number">3</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>*num = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//分配空间</span></span><br><span class="line">        *num = i+<span class="number">100</span>;</span><br><span class="line">        pool.<span class="built_in">addTask</span>(<span class="built_in">Task</span>&lt;<span class="type">int</span>&gt;(working, num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tip warning faa-horizontal animated"><p>特殊:当有类模板时,类模板的声明和定义分开写时，需要包含头文件和源文件，否则会报找不到定义的错误</p></div><div class="tag link"><a class="link-card" title="线程池C++版" href="https://keqiudi.github.io/posts/de7c53fe.html"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">线程池C++版</p><p class="url">https://keqiudi.github.io/posts/de7c53fe.html</p></div></a></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池C语言版</title>
      <link href="/posts/de7c53fe.html"/>
      <url>/posts/de7c53fe.html</url>
      
        <content type="html"><![CDATA[<h1>1.线程池原理</h1><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p><p><strong>线程池</strong>是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）, 则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p><p>在各个编程语言的语种中都有<strong>线程池</strong>的概念，并且很多语言中直接提供了线程池，作为程序猿直接使用就可以了，下面给大家介绍一下<strong>线程池</strong>的实现原理：</p><p><strong>线程池的组成主要分为 3 个部分，这三部分配合工作就可以得到一个完整的线程池：</strong></p><ol><li><p><strong>任务队列，存储需要处理的任务，由工作的线程来处理这些任务</strong></p><ul><li>通过线程池提供的 API 函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除</li><li>已处理的任务会被从任务队列中删除</li><li>线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程</li></ul></li><li><p><strong>工作的线程（任务队列任务的消费者） ，N个</strong></p><ul><li>线程池中维护了一定数量的工作线程，他们的作用是是不停的读任务队列，从里边取出任务并处理</li><li>工作的线程相当于是任务队列的消费者角色，</li><li>如果任务队列为空，工作的线程将会被阻塞 (使用条件变量 / 信号量阻塞)</li><li>如果阻塞之后有了新的任务，由生产者将阻塞解除，工作线程开始工作</li></ul></li><li><p><strong>管理者线程（不处理任务队列中的任务），1个</strong></p></li></ol><ul><li><ul><li>它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测</li><li>当任务过多的时候，可以适当的创建一些新的工作线程</li><li>当任务过少的时候，可以适当的销毁一些工作的线程</li></ul></li></ul><h1>2.任务队列(Task)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">void</span>* arg);</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125;Task;</span><br></pre></td></tr></table></figure><h1>3.线程池定义(ThreadPool)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    Task* taskQ;</span><br><span class="line">    <span class="type">int</span> queueCapacity;  <span class="comment">// 容量</span></span><br><span class="line">    <span class="type">int</span> queueSize;      <span class="comment">// 当前任务个数</span></span><br><span class="line">    <span class="type">int</span> queueFront;     <span class="comment">// 队头 -&gt; 取数据</span></span><br><span class="line">    <span class="type">int</span> queueRear;      <span class="comment">// 队尾 -&gt; 放数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> managerID;    <span class="comment">// 管理者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span> *threadIDs;   <span class="comment">// 工作的线程ID</span></span><br><span class="line">    <span class="type">int</span> minNum;             <span class="comment">// 最小线程数量</span></span><br><span class="line">    <span class="type">int</span> maxNum;             <span class="comment">// 最大线程数量</span></span><br><span class="line">    <span class="type">int</span> busyNum;            <span class="comment">// 忙的线程的个数</span></span><br><span class="line">    <span class="type">int</span> liveNum;            <span class="comment">// 存活的线程的个数</span></span><br><span class="line">    <span class="type">int</span> exitNum;            <span class="comment">// 要销毁的线程个数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexPool;  <span class="comment">// 锁整个的线程池</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexBusy;  <span class="comment">// 锁busyNum变量</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notFull;     <span class="comment">// 任务队列是不是满了</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;    <span class="comment">// 任务队列是不是空了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> shutdown;           <span class="comment">// 是不是要销毁线程池, 销毁为1, 不销毁为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4.头文件声明(ThreadPool.h)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span> <span class="title">ThreadPool</span>;</span></span><br><span class="line"><span class="comment">// 创建线程池并初始化</span></span><br><span class="line">ThreadPool *<span class="title function_">threadPoolCreate</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queueSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁线程池</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolDestroy</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池添加任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadPoolAdd</span><span class="params">(ThreadPool* pool, <span class="type">void</span>(*func)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程池中工作的线程的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolBusyNum</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程池中活着的线程的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolAliveNum</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////</span></span><br><span class="line"><span class="comment">// 工作的线程(消费者线程)任务函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span>;</span><br><span class="line"><span class="comment">// 管理者线程任务函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">manager</span><span class="params">(<span class="type">void</span>* arg)</span>;</span><br><span class="line"><span class="comment">// 单个线程退出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadExit</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// _THREADPOOL_H</span></span></span><br></pre></td></tr></table></figure><h1>5.源文件定义(ThreadPool.c)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool* <span class="title function_">threadPoolCreate</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queueSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadPool));</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadpool fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool-&gt;threadIDs = (<span class="type">pthread_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threadIDs == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadIDs fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;threadIDs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        pool-&gt;minNum = min;</span><br><span class="line">        pool-&gt;maxNum = max;</span><br><span class="line">        pool-&gt;busyNum = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;liveNum = min;    <span class="comment">// 和最小个数相等</span></span><br><span class="line">        pool-&gt;exitNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;pool-&gt;mutexPool, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_mutex_init(&amp;pool-&gt;mutexBusy, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_cond_init(&amp;pool-&gt;notEmpty, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_cond_init(&amp;pool-&gt;notFull, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mutex or condition init fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务队列</span></span><br><span class="line">        pool-&gt;taskQ = (Task*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Task) * queueSize);</span><br><span class="line">        pool-&gt;queueCapacity = queueSize;</span><br><span class="line">        pool-&gt;queueSize = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueFront = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueRear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pool-&gt;shutdown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        pthread_create(&amp;pool-&gt;managerID, <span class="literal">NULL</span>, manager, pool);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_create(&amp;pool-&gt;threadIDs[i], <span class="literal">NULL</span>, worker, pool);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (pool &amp;&amp; pool-&gt;threadIDs) <span class="built_in">free</span>(pool-&gt;threadIDs);</span><br><span class="line">    <span class="keyword">if</span> (pool &amp;&amp; pool-&gt;taskQ) <span class="built_in">free</span>(pool-&gt;taskQ);</span><br><span class="line">    <span class="keyword">if</span> (pool) <span class="built_in">free</span>(pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolDestroy</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    pool-&gt;shutdown = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 阻塞回收管理者线程</span></span><br><span class="line">    pthread_join(pool-&gt;managerID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 唤醒阻塞的消费者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;liveNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放堆内存</span></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;taskQ)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;taskQ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threadIDs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;mutexPool);</span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;notEmpty);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;notFull);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadPoolAdd</span><span class="params">(ThreadPool* pool, <span class="type">void</span>(*func)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">while</span> (pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞生产者线程</span></span><br><span class="line">        pthread_cond_wait(&amp;pool-&gt;notFull, &amp;pool-&gt;mutexPool);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    pool-&gt;taskQ[pool-&gt;queueRear].function = func;</span><br><span class="line">    pool-&gt;taskQ[pool-&gt;queueRear].arg = arg;</span><br><span class="line">    pool-&gt;queueRear = (pool-&gt;queueRear + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">    pool-&gt;queueSize++;</span><br><span class="line"></span><br><span class="line">    pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolBusyNum</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolAliveNum</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="type">int</span> aliveNum = pool-&gt;liveNum;</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> aliveNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">// 当前任务队列是否为空</span></span><br><span class="line">        <span class="keyword">while</span> (pool-&gt;queueSize == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 阻塞工作线程</span></span><br><span class="line">            pthread_cond_wait(&amp;pool-&gt;notEmpty, &amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是不是要销毁线程</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;exitNum &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pool-&gt;exitNum--;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    pool-&gt;liveNum--;</span><br><span class="line">                    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">                    threadExit(pool);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断线程池是否被关闭了</span></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            threadExit(pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从任务队列中取出一个任务</span></span><br><span class="line">        Task task;</span><br><span class="line">        task.function = pool-&gt;taskQ[pool-&gt;queueFront].function;</span><br><span class="line">        task.arg = pool-&gt;taskQ[pool-&gt;queueFront].arg;</span><br><span class="line">        <span class="comment">// 移动头结点</span></span><br><span class="line">        pool-&gt;queueFront = (pool-&gt;queueFront + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">        pool-&gt;queueSize--;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_cond_signal(&amp;pool-&gt;notFull);</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %ld start working...\n&quot;</span>, pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;busyNum++;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        task.function(task.arg);</span><br><span class="line">        <span class="built_in">free</span>(task.arg);</span><br><span class="line">        task.arg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %ld end working...\n&quot;</span>, pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;busyNum--;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)arg;</span><br><span class="line">    <span class="keyword">while</span> (!pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每隔3s检测一次</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出线程池中任务的数量和当前线程的数量</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="type">int</span> queueSize = pool-&gt;queueSize;</span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出忙的线程的数量</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加线程</span></span><br><span class="line">        <span class="comment">// 任务的个数&gt;存活的线程个数 &amp;&amp; 存活的线程数&lt;最大线程数</span></span><br><span class="line">        <span class="keyword">if</span> (queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;maxNum &amp;&amp; counter &lt; NUMBER</span><br><span class="line">                &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;threadIDs[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    pthread_create(&amp;pool-&gt;threadIDs[i], <span class="literal">NULL</span>, worker, pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 销毁线程</span></span><br><span class="line">        <span class="comment">// 忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程&gt;最小线程数</span></span><br><span class="line">        <span class="keyword">if</span> (busyNum * <span class="number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;exitNum = NUMBER;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="comment">// 让工作的线程自杀</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadExit</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;maxNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threadIDs[i] == tid)</span><br><span class="line">        &#123;</span><br><span class="line">            pool-&gt;threadIDs[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;threadExit() called, %ld exiting...\n&quot;</span>, tid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>6.测试代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">taskFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread %ld is working, number = %d\n&quot;</span>,</span><br><span class="line">        pthread_self(), num);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    ThreadPool* pool = threadPoolCreate(<span class="number">3</span>, <span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>* num = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *num = i + <span class="number">100</span>;</span><br><span class="line">        threadPoolAdd(pool, taskFunc, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    threadPoolDestroy(pool);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tag link"><a class="link-card" title="线程池C++版" href="https://keqiudi.github.io/posts/aa76cb12.html"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">线程池C++版</p><p class="url">https://keqiudi.github.io/posts/aa76cb12.html</p></div></a></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步</title>
      <link href="/posts/895e9db.html"/>
      <url>/posts/895e9db.html</url>
      
        <content type="html"><![CDATA[<h1>1.线程同步概念</h1><p>线程同步的真实意思，其实是“<strong>排队</strong>”：几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。 而最让人无语的是，线程同步的目的就是让各个线程去排队使用资源，而不是让线程同时去使用资源。</p><p>假设有 4 个线程 A、B、C、D，当前一个线程 A 对内存中的共享资源进行访问的时候，其他线程 B, C, D 都不可以对这块内存进行操作，直到线程 A 对这块内存访问完毕为止，B，C，D 中的一个才能访问这块内存，剩余的两个需要继续阻塞等待，以此类推，直至所有的线程都对这块内存操作完毕。 线程对内存的这种访问方式就称之为线程同步，通过对概念的介绍，我们可以了解到所谓的同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次进行的。</p><h2 id="为什么要线程同步">为什么要线程同步</h2><p><strong>在研究线程同步之前，先来看一个两个线程交替计数（每个线程数 50 个数，交替数到 100）的例子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 50</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcA_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcB_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个子线程</span></span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，资源回收</span></span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译并执行上面的测试程序，得到如下结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out </span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">1</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">2</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">2</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">3</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">4</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">5</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">6</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">7</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">8</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">7</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">8</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">9</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">8</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">9</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">9</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">10</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">11</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">10</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">11</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">11</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">12</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">13</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">14</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">15</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">16</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">17</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">18</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">19</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">17</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">18</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">19</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">19</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">20</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">20</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">21</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">21</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">22</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">22</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">23</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">23</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">24</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">24</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">25</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">25</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">26</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">26</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">27</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">27</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">28</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">28</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">29</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">29</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">30</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">30</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">31</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">31</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">32</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">32</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">33</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">33</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">34</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">34</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">35</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">35</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">36</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">36</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">37</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">37</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">38</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">38</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">39</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">39</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">40</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">41</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">42</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">42</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">43</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">44</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">45</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">45</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">46</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">46</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">47</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">47</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">48</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">48</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">49</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">50</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">51</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">51</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">52</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">53</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">54</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">55</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">56</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">57</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">58</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">59</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">60</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">61</span></span><br></pre></td></tr></table></figure><p>通过对上面例子的测试，可以看出虽然每个线程内部循环了 50 次每次数一个数，但是最终没有数到 100，通过输出的结果可以看到，有些数字被重复数了多次，其原因就是没有对线程进行同步处理，造成了<strong>数据的混乱。</strong></p><p>两个线程在数数的时候需要分时复用 CPU 时间片，并且测试程序中调用了 sleep() 导致线程的 CPU 时间片没用完就被迫挂起了，这样就能让 CPU 的上下文切换（保存当前状态，下一次继续运行的时候需要加载保存的状态）更加频繁，更容易再现数据混乱的这个现象。</p><p>在测试程序中两个线程共用全局变量 <strong>number</strong> 当线程变成运行态之后开始数数，从物理内存加载数据，让后将数据放到 CPU 进行运算，最后将结果更新到物理内存中。如果数数的两个线程都可以顺利完成这个流程，那么得到的结果肯定是正确的。</p><p>如果线程 A 执行这个过程期间就失去了 CPU 时间片，线程 A 被挂起了最新的数据没能更新到物理内存。线程 B 变成运行态之后从物理内存读数据，很显然它没有拿到最新数据，只能基于旧的数据往后数，然后失去 CPU 时间片挂起。线程 A 得到 CPU 时间片变成运行态，第一件事儿就是将上次没更新到内存的数据更新到内存，但是这样会导致线程 B 已经更新到内存的数据被覆盖，活儿白干了，最终导致有些数据会被重复数很多次。</p><h2 id="同步方式">同步方式</h2><p>对于多个线程访问共享资源出现数据混乱的问题，需要进行线程同步。常用的线程同步方式有四种：<strong>互斥锁、读写锁、条件变量、信号量</strong>。所谓的共享资源就是多个线程共同访问的变量，这些变量通常为全局数据区变量或者堆区变量，这些变量对应的共享资源也被称之为<strong>临界资源</strong>。</p><p><img src="https://subingwen.cn/linux/thread-sync/image-20200106092600543.png" alt="image-20200106092600543"></p><p>找到临界资源之后，再找和临界资源相关的上下文代码，这样就得到了一个代码块，这个代码块可以称之为临界区。确定好临界区（临界区越小越好）之后，就可以进行线程同步了，线程同步的大致处理思路是这样的：</p><ul><li>在临界区代码的上边，添加加锁函数，对临界区加锁。<ul><li>哪个线程调用这句代码，就会把这把锁锁上，其他线程就只能阻塞在锁上了。</li></ul></li><li>在临界区代码的下边，添加解锁函数，对临界区解锁。<ul><li>出临界区的线程会将锁定的那把锁打开，其他抢到锁的线程就可以进入到临界区了。</li></ul></li><li>通过锁机制能保证临界区代码最多只能同时有一个线程访问，这样并行访问就变为串行访问了。</li></ul><h1>2.互斥锁</h1><h2 id="互斥锁函数">互斥锁函数</h2><p>互斥锁是线程同步最常用的一种方式，通过互斥锁可以锁定一个代码块，被锁定的这个代码块，所有的线程只能顺序执行 (不能并行处理)，这样多线程访问共享资源数据混乱的问题就可以被解决了，需要付出的代价就是执行效率的降低，因为默认临界区多个线程是可以并行处理的，现在只能串行处理。</p><p>在 Linux 中互斥锁的类型为 <strong>pthread_mutex_t</strong>，创建一个这种类型的变量就得到了一把互斥锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span>  mutex;</span><br></pre></td></tr></table></figure><p>在创建的锁对象中保存了当前这把锁的状态信息：锁定还是打开，如果是锁定状态还记录了给这把锁加锁的线程信息（线程 ID）。一个互斥锁变量只能被一个线程锁定，被锁定之后其他线程再对互斥锁变量加锁就会被阻塞，直到这把互斥锁被解锁，被阻塞的线程才能被解除阻塞。<strong>一般情况下，每一个共享资源对应一个把互斥锁(全局共享的锁)，锁的个数和线程的个数无关。</strong></p><p><strong>Linux 提供的互斥锁操作函数如下，如果函数调用成功会返回 0，调用失败会返回相应的错误号：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放互斥锁资源            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><p>mutex: 互斥锁变量的地址</p></li><li><p>attr: 互斥锁的属性，一般使用默认属性即可，这个参数指定为 NULL</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改互斥锁的状态, 将其设定为锁定状态, 这个状态被写入到参数 mutex 中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>这个函数被调用，首先会判断参数 mutex 互斥锁中的状态是不是锁定状态:</p><ul><li><p>没有被锁定，是打开的，这个线程可以加锁成功，这个这个锁中会记录是哪个线程加锁成功了</p></li><li><p>如果被锁定了，其他线程加锁就失败了，这些线程都会阻塞在这把锁上</p></li><li><p>当这把锁被解开之后，这些阻塞在锁上的线程就解除阻塞了，并且这些线程是通过竞争的方式对这把锁加锁，没抢到锁的线程继续阻塞</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数对互斥锁变量加锁还是有两种情况:</p><ul><li>如果这把锁没有被锁定是打开的，线程加锁成功</li><li>如果锁变量被锁住了，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对互斥锁解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 不是所有的线程都可以对互斥锁解锁，哪个线程加的锁，哪个线程才能解锁成功。</p><h2 id="互斥锁的使用">互斥锁的使用</h2><p>我们可以将上面多线程交替数数的例子修改一下，使用互斥锁进行线程同步。两个线程一共操作了同一个全局变量，因此需要添加一互斥锁，来控制这两个线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一把互斥锁</span></span><br><span class="line"><span class="comment">// 全局变量, 多个线程共享</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcA_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果线程A加锁成功, 不阻塞</span></span><br><span class="line">        <span class="comment">// 如果B加锁成功, 线程A阻塞</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcB_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// a加锁成功, b线程访问这把锁的时候是锁定的</span></span><br><span class="line">        <span class="comment">// 线程B先阻塞, a线程解锁之后阻塞解除</span></span><br><span class="line">        <span class="comment">// 线程B加锁成功了</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个子线程</span></span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，资源回收</span></span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="comment">// 线程销毁之后, 再去释放互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>3.死锁</h1><p>当多个线程访问共享资源，需要加锁，如果锁使用不当，就会造成死锁这种现象。如果线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。</p><p>造成死锁的场景有如下几种：</p><ul><li><p>1.加锁后忘记解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功, 当前循环完毕没有解锁, 在下一轮循环的时候自己被阻塞了</span></span><br><span class="line">        <span class="comment">// 其余的线程也被阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        <span class="comment">// 忘记解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程被阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        <span class="keyword">if</span>(xxx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 函数退出, 没有解锁（解锁函数无法被执行了）</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2.重复加锁，形成死锁</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 锁被锁住了, A线程阻塞</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏的比较深的情况</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">funcA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">funcB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        funcA();<span class="comment">// 重复加锁</span></span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>3.在程序中有多个共享资源，因此有很多把锁，随意加锁，导致相互被阻塞</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">场景描述:</span><br><span class="line">  1. 有两个共享资源:X, Y，X对应锁A, Y对应锁B</span><br><span class="line">     - 线程A访问资源X, 加锁A</span><br><span class="line">     - 线程B访问资源Y, 加锁B</span><br><span class="line">  2. 线程A要访问资源Y, 线程B要访问资源X，因为资源X和Y已经被对应的锁锁住了，因此这个两个线程被阻塞</span><br><span class="line">     - 线程A被锁B阻塞了, 无法打开A锁</span><br><span class="line">     - 线程B被锁A阻塞了, 无法打开B锁</span><br></pre></td></tr></table></figure></li></ul><p><strong>在使用多线程编程的时候，如何避免死锁呢？</strong></p><ul><li><p>避免多次锁定，多检查</p></li><li><p>对共享资源访问完毕之后，一定要解锁，或者在加锁的使用 trylock</p></li><li><p>如果程序中有多把锁，可以控制对锁的访问顺序 (顺序访问共享资源，但在有些情况下是做不到的)，另外也可以在对其他互斥锁做加锁操作之前，先释放当前线程拥有的互斥锁。</p></li><li><p>项目程序中可以引入一些专门用于死锁检测的模块</p></li></ul><h1>4.读写锁</h1><p>读写锁是互斥锁的升级版，在做读操作的时候可以提高程序的执行效率，如果所有的线程都是做读操作, 那么读是并行的，但是使用互斥锁，读操作也是串行的。</p><p>读写锁是一把锁，锁的类型为 <strong>pthread_rwlock_t</strong>，有了类型之后就可以创建一把互斥锁了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br></pre></td></tr></table></figure><p>之所以称其为读写锁，是因为这把锁既可以锁定读操作，也可以锁定写操作。为了方便理解，可以大致认为在这把锁中记录了这些信息：</p><ul><li>锁的状态：锁定 / 打开</li><li>锁定的是什么操作：读操作 / 写操作，使用读写锁锁定了读操作，需要先解锁才能去锁定写操作，反之亦然。</li><li>哪个线程将这把锁锁上了</li></ul><p>读写锁的使用方式也互斥锁的使用方式是完全相同的：找共享资源，确定临界区，在临界区的开始位置加锁（读锁 / 写锁），临界区的结束位置解锁。</p><p>因为通过一把读写锁可以锁定读或者写操作，下面介绍一下关于读写锁的特点：</p><ol><li>使用读写锁的读锁锁定了临界区，线程对临界区的访问是并行的，读锁是共享的。</li><li>使用读写锁的写锁锁定了临界区，线程对临界区的访问是串行的，写锁是独占的。</li><li>使用读写锁分别对两个临界区加了读锁和写锁，两个线程要同时访问者两个临界区，访问写锁临界区的线程继续运行，访问读锁临界区的线程阻塞，因为<strong>写锁比读锁的优先级高。</strong></li></ol><p>如果说程序中所有的线程都对共享资源做写操作，使用读写锁没有优势，和互斥锁是一样的，如果说程序中所有的线程都对共享资源有写也有读操作，并且对共享资源读的操作越多，读写锁更有优势。</p><p><strong>Linux 提供的读写锁操作函数原型如下，如果函数调用成功返回 0，失败返回对应的错误号：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放读写锁占用的系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>rwlock: 读写锁的地址，传出参数</li><li>attr: 读写锁属性，一般使用默认属性，指定为 NULL</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加读锁, 锁定的是读操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数的线程会被阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加读锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数加锁失败，对应的线程不会被阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加写锁, 锁定的是写操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数的线程会被阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加写锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数加锁失败，但是线程不会阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解锁, 不管锁定了读还是写都可用解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><h2 id="读写锁的使用">读写锁的使用</h2><p>题目要求：8 个线程操作同一个全局变量，3 个线程不定时写同一全局资源，5 个线程不定时读同一全局资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义读写锁</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写的线程的处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writeNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur ++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++写操作完毕, number : %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">// 添加sleep目的是要看到多个线程交替工作</span></span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程的处理函数</span></span><br><span class="line"><span class="comment">// 多个线程可以如果处理动作相同, 可以使用相同的处理函数</span></span><br><span class="line"><span class="comment">// 每个线程中的栈资源是独享</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">readNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--全局变量number = %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化读写锁</span></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3个写线程, 5个读的线程</span></span><br><span class="line">    <span class="type">pthread_t</span> wtid[<span class="number">3</span>];</span><br><span class="line">    <span class="type">pthread_t</span> rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;wtid[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;rtid[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(wtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(rtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>5.条件变量</h1><h2 id="条件变量函数">条件变量函数</h2><p>严格意义上来说，条件变量的主要作用不是处理线程同步，<strong>而是进行线程的阻塞</strong>。如果在多线程程序中只使用条件变量无法实现线程的同步，必须要配合互斥锁来使用。虽然条件变量和互斥锁都能阻塞线程，但是二者的效果是不一样的，二者的区别如下：</p><ul><li>设有 A-Z 26 个线程，这 26 个线程共同访问同一把互斥锁，如果线程 A 加锁成功，那么其余 B-Z 线程访问互斥锁都阻塞，所有的线程只能顺序访问临界区</li><li>条件变量只有在满足指定条件下才会阻塞线程，如果条件不满足，多个线程可以同时进入临界区，同时读写临界资源，这种情况下还是会出现共享资源中数据的混乱。</li></ul><p>一般情况下条件变量用于处理生产者和消费者模型，并且和互斥锁配合使用。条件变量类型对应的类型为 <strong>pthread_cond_t</strong>，这样就可以定义一个条件变量类型的变量了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;<span class="comment">//cond(condition)</span></span><br></pre></td></tr></table></figure><ul><li>被条件变量阻塞的线程的线程信息会被记录到这个变量中，以便在解除阻塞的时候使用。</li></ul><p><strong>条件变量操作函数函数原型如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">      <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 销毁释放资源        </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数:</p><ul><li>cond: 条件变量的地址</li><li>attr: 条件变量属性，一般使用默认属性，指定为 NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure><p>通过函数原型可以看出，该函数在阻塞线程的时候，需要一个互斥锁参数，这个互斥锁主要功能是进行线程同步，让线程顺序进入临界区，避免出现数共享资源的数据混乱。该函数会对这个互斥锁做以下几件事情：</p><ol><li>在阻塞线程时候，如果线程已经对互斥锁 mutex 上锁，那么会将这把锁打开，这样做是为了避免死锁</li><li>当线程解除阻塞的时候，函数内部会帮助这个线程再次将这个 mutex 互斥锁锁上，继续向下访问临界区</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这个函数的前两个参数和 <strong>pthread_cond_wait</strong> 函数是一样的，第三个参数表示线程阻塞的时长，但是需要额外注意一点：<strong>struct timespec</strong> 这个结构体中记录的时间是从1971.1.1到某个时间点的时间，总长度使用秒/纳秒表示。因此赋值方式相对要麻烦一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> mytim = time(<span class="literal">NULL</span>);<span class="comment">// 1970.1.1 0:0:0 到当前的总秒数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tmsp</span>;</span></span><br><span class="line">tmsp.tv_nsec = <span class="number">0</span>;</span><br><span class="line">tmsp.tv_sec = time(<span class="literal">NULL</span>) + <span class="number">100</span>;<span class="comment">// 线程阻塞100s</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><p>调用上面两个函数中的任意一个，都可以唤醒被 pthread_cond_wait 或者 pthread_cond_timedwait 阻塞的线程，区别就在于 pthread_cond_signal 是唤醒至少一个被阻塞的线程（总个数不定），pthread_cond_broadcast 是唤醒所有被阻塞的线程。</p><h2 id="生产者和消费者">生产者和消费者</h2><p><strong>生产者和消费者模型组成：</strong></p><ol><li>生产者线程 -&gt; 若干个<ul><li>生产商品或者任务放入到任务队列中</li><li>任务队列满了就阻塞，不满的时候就工作</li><li>通过一个生产者的条件变量控制生产者线程阻塞和非阻塞</li></ul></li><li>消费者线程 -&gt; 若干个<ul><li>读任务队列，将任务或者数据取出</li><li>任务队列中有数据就消费，没有数据就阻塞</li><li>通过一个消费者的条件变量控制消费者线程阻塞和非阻塞</li></ul></li><li>队列 -&gt; 存储任务 / 数据，对应一块内存，为了读写访问可以通过一个数据结构维护这块内存<ul><li>可以是数组、链表，也可以使用 stl 容器：queue /stack/list/vector</li></ul></li></ol><p><strong>场景描述：使用条件变量实现生产者和消费者模型，生产者有 5 个，往链表头部添加节点，消费者也有 5 个，删除链表头部的节点。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义条件变量, 控制消费者线程</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产了任务, 通知消费者消费</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span><span class="comment">//rand()产生0-32767之间的随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* consumer(<span class="type">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 一直消费, 删除链表中的一个节点</span></span><br><span class="line"><span class="comment">//        if(head == NULL)   // 这样写有bug</span></span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 任务队列, 也就是链表中已经没有节点可以消费了</span></span><br><span class="line">            <span class="comment">// 消费者线程需要阻塞</span></span><br><span class="line">            <span class="comment">// 线程加互斥锁成功, 但是线程阻塞在这行代码上, 锁还没解开</span></span><br><span class="line">            <span class="comment">// 其他线程在访问这把锁的时候也会阻塞, 生产者也会阻塞 ==&gt; 死锁</span></span><br><span class="line">            <span class="comment">// 这函数会自动将线程拥有的锁解开</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">            <span class="comment">// 当消费者线程解除阻塞之后, 会自动将这把锁锁上</span></span><br><span class="line">            <span class="comment">// 这时候当前这个线程又重新拥有了这把互斥锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="keyword">struct</span> Node* pnode = head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);        </span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 一直消费, 删除链表中的一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)   <span class="comment">// 这样写有bug</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);        </span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么在第7行使用if 有bug:</span></span><br><span class="line"><span class="comment">    当任务队列为空, 所有的消费者线程都会被这个函数阻塞 pthread_cond_wait(&amp;cond, &amp;mutex);</span></span><br><span class="line"><span class="comment">    也就是阻塞在代码的第9行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当生产者生产了1个节点, 调用 pthread_cond_broadcast(&amp;cond); 唤醒了所有阻塞的线程</span></span><br><span class="line"><span class="comment">      - 有一个消费者线程通过 pthread_cond_wait()加锁成功, 其余没有加锁成功的线程继续阻塞</span></span><br><span class="line"><span class="comment">      - 加锁成功的线程向下运行, 并成功删除一个节点, 然后解锁</span></span><br><span class="line"><span class="comment">      - 没有加锁成功的线程解除阻塞继续抢这把锁, 另外一个子线程加锁成功</span></span><br><span class="line"><span class="comment">      - 但是这个线程删除链表节点的时候链表已经为空了, 后边访问这个空节点的时候就会出现段错误</span></span><br><span class="line"><span class="comment">    解决方案:</span></span><br><span class="line"><span class="comment">      - 需要循环的对链表是否为空进行判断, 需要将if 该成 while</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1>6.信号量</h1><h2 id="信号量函数">信号量函数</h2><p>信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。信号量不一定是锁定某一个资源，而是流程上的概念，比如：有 A，B 两个线程，B 线程要等 A 线程完成某一任务以后再进行自己下面的步骤，这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。</p><p>**信号量（信号灯）**与互斥锁和条件变量的主要不同在于” 灯” 的概念，灯亮则意味着资源可用，灯灭则意味着不可用。信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。</p><p>**信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。**信号的类型为 sem_t 对应的头文件为 <strong>&lt;semaphore.h&gt;：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br></pre></td></tr></table></figure><ul><li>Linux 提供的信号量操作函数原型如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化信号量/信号灯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">          </span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">// 资源释放, 线程销毁之后调用这个函数即可</span></span><br><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br></pre></td></tr></table></figure><ul><li><p>参数:</p><ul><li><p>sem: 信号量变量地址</p></li><li><p>pshared：</p><ul><li><p>0：线程同步</p></li><li><p>非 0：进程同步</p></li></ul></li><li><p>value：初始化当前信号量拥有的资源数（&gt;=0），如果资源数为 0，线程就会被阻塞了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，因此线程也就被阻塞了。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li>当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，但是线程不会被阻塞，直接返回错误号，因此可以在程序中添加判断分支，用于处理获取资源失败之后的情况。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用该函数线程获取sem中的一个资源，当资源数为0时，线程阻塞，在阻塞abs_timeout对应的时长之后，解除阻塞。</span></span><br><span class="line"><span class="comment">// abs_timeout: 阻塞的时间长度, 单位是s, 是从1970.1.1开始计算的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li>该函数的参数 abs_timeout 和 pthread_cond_timedwait 的最后一个参数是一样的，使用方法不再过多赘述。当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，线程被阻塞，当阻塞指定的时长之后，线程解除阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用该函数给sem中的资源数+1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li>调用该函数会将 sem 中的资源数 +1，如果有线程在调用 sem_wait、sem_trywait、sem_timedwait 时因为 sem 中的资源数为 0 被阻塞了，这时这些线程会解除阻塞，获取到资源之后继续向下运行。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看信号量 sem 中的整形数的当前值, 这个值会被写入到sval指针对应的内存中</span></span><br><span class="line"><span class="comment">// sval是一个传出参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br></pre></td></tr></table></figure><ul><li>通过这个函数可以查看 sem 中现在拥有的资源个数，通过第二个参数 sval 将数据传出，也就是说第二个参数的作用和返回值是一样的。</li></ul><h2 id="生产者和消费者-2">生产者和消费者</h2><p>由于生产者和消费者是两类线程，并且在还没有生成之前是不能进行消费的，在使用信号量处理这类问题的时候可以定义两个信号量，分别用于记录生产者和消费者线程拥有的总资源数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者线程 </span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量初始化</span></span><br><span class="line">sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);    <span class="comment">// 5个生产者可以同时生产</span></span><br><span class="line">sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// 消费者线程没有资源, 因此不能消费</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="comment">// 在生产之前, 从信号量中取出一个资源</span></span><br><span class="line">sem_wait(&amp;psem);</span><br><span class="line"><span class="comment">// 生产者商品代码, 有商品了, 放到任务队列</span></span><br><span class="line">...... </span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 通知消费者消费，给消费者信号量添加资源，让消费者解除阻塞</span></span><br><span class="line">sem_post(&amp;csem);<span class="comment">//消费者资源+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="comment">// 消费者需要等待生产, 默认启动之后应该阻塞</span></span><br><span class="line">sem_wait(&amp;csem);<span class="comment">//生产者资源-1</span></span><br><span class="line"><span class="comment">// 开始消费</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 消费完成, 通过生产者生产，给生产者信号量添加资源</span></span><br><span class="line">sem_post(&amp;psem);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面的代码可以知道，初始化信号量的时候没有消费者分配资源，消费者线程启动之后由于没有资源自然就被阻塞了，等生产者生产出产品之后，再给消费者分配资源，这样二者就可以配合着完成生产和消费流程了。</p><h2 id="信号量的使用">信号量的使用</h2><p><strong>场景描述：使用信号量实现生产者和消费者模型，生产者有 5 个，往链表头部添加节点，消费者也有 5 个，删除链表头部的节点。</strong></p><h3 id="总资源数为1">总资源数为1</h3><p>如果生产者和消费者线程使用的信号量对应的总资源数为 1，那么不管线程有多少个，可以工作的线程只有一个，其余线程由于拿不到资源，都被迫阻塞了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费, 给消费者加信号灯</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="comment">// 生产者和消费者拥有的信号灯的总和为1</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 生成者线程一共有1个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过测试代码可以得到如下结论：如果生产者和消费者使用的信号量总资源数为 1，那么不会出现生产者线程和消费者线程同时访问共享资源的情况，不管生产者和消费者线程有多少个，它们都是顺序执行的。</strong></p><h3 id="总资源数大于1">总资源数大于1</h3><p>如果生产者和消费者线程使用的信号量对应的总资源数为大于 1，这种场景下出现的情况就比较多了：</p><ul><li>多个生产者线程同时生产</li><li>多个消费者同时消费</li><li>生产者线程和消费者线程同时生产和消费</li></ul><p>以上不管哪一种情况都可能会出现多个线程访问共享资源的情况，如果想防止共享资源出现数据混乱，那么就需要使用互斥锁进行线程同步，处理代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 加锁, 这句代码放到 sem_wait()上边, 有可能会造成死锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 生成者线程一共有5个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写上述代码的时候还有一个需要注意是事项，不管是消费者线程的处理函数还是生产者线程的处理函数内部有这么两行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure><p><strong>这两行代码的调用顺序是不能颠倒的，如果颠倒过来就有可能会造成死锁，下面来分析一种死锁的场景：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">......</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">......</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 生成者线程一共有5个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，初始化状态下消费者线程没有任务信号量资源，假设某一个消费者线程先运行，调用 <strong>pthread_mutex_lock(&amp;mutex)</strong>; 对互斥锁加锁成功，然后调用 <strong>sem_wait(&amp;csem)</strong>; 由于没有资源，因此被阻塞了。其余的消费者线程由于没有抢到互斥锁，因此被阻塞在互斥锁上。对应生产者线程第一步操作也是调用 <strong>pthread_mutex_lock(&amp;mutex)</strong>;，但是这时候互斥锁已经被消费者线程锁上了，所有生产者都被阻塞，到此为止，多余的线程都被阻塞了，程序产生了死锁。</p><p><strong>请记住: 先拿信号灯，再加锁!!!</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟地址空间</title>
      <link href="/posts/fb84f8a3.html"/>
      <url>/posts/fb84f8a3.html</url>
      
        <content type="html"><![CDATA[<h1>1.虚拟地址空间</h1><p>虚拟地址空间是一个非常抽象的概念，先根据字面意思进行解释：</p><ul><li>它可以用来加载程序数据（数据可能被加载到物理内存上，空间不够就加载到虚拟内存中）</li><li>它对应着一段连续的内存地址，起始位置为 0。</li><li>之所以说虚拟是因为这个起始的 0 地址是被虚拟出来的， 不是物理内存的 0 地址</li></ul><p>虚拟地址空间的大小也由操作系统决定，32位的操作系统虚拟地址空间的大小为 232 字节，也就是 4G，64 位的操作系统虚拟地址空间大小为 264 字节，这是一个非常大的数，感兴趣可以自己计算一下。当我们运行磁盘上一个可执行程序, 就会得到一个进程，内核会给每一个运行的进程创建一块属于自己的虚拟地址空间，并将应用程序数据装载到虚拟地址空间对应的地址上。</p><p>进程在运行过程中，程序内部所有的指令都是通过 CPU 处理完成的，CPU 只进行数据运算并不具备数据存储的能力，其处理的数据都加载自物理内存，那么进程中的数据是如何进出入到物理内存中的呢？其实是通过 CPU 中的内存管理单元 MMU（Memory Management Unit）从进程的虚拟地址空间中映射过去的。</p><h2 id="意义">意义</h2><p>通过上边的介绍大家会感觉到一头雾水， 为什么操作系统不直接将数据加载到物理内存中而是将数据加载到虚拟地址空间中，在通过 CPU 的 MMU 映射到物理内存中呢？</p><p>先来看一下如果直接将数据加载到物理内存会发生什么事情：</p><p><strong>假设计算机的物理内存大小为 1G, 进程 A 需要 100M 内存因此直接在物理内存上从 0 地址开始分配 100M, 进程 B 启动需要 250M 内存，因此继续在物理内存上为其分配 250M 内存，并且进程 A 和进程 B 占用的内存是连续的。之后再启动其他进程继续按照这种方法进行物理内存的分配。</strong></p><p>使用这种方式分配内存会有如下几个问题：</p><p>1.每个进程的地址不隔离，有安全风险。</p><p>由于程序都是直接访问物理内存，所以恶意程序可以通过内存寻址随意修改别的进程对应的内存数据，以达到破坏的目的。虽然有些时候是非恶意的，但是有些存在 bug 的程序可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。</p><p>2.内存效率低。</p><p>如果直接使用物理内存的话，一个进程对应的内存块就是作为一个整体操作的，如果出现物理内存不够用的时候，我们一般的办法是将不常用的进程拷贝到磁盘的交换分区（虚拟内存）中，以便腾出内存，因此就需要将整个进程一起拷走，如果数据量大，在内存和磁盘之间拷贝时间就会很长，效率低下。</p><p>3.进程中数据的地址不确定，每次都会发生变化。</p><p>由于物理内存的使用情况一直在动态的变化，我们无法确定内存现在使用到哪里了，如果直接将程序数据加载到物理内存，内存中每次存储数据的起始地址都是不一样的，这样数据的加载都需要使用相对地址，加载效率低（静态库是使用绝对地址加载的）。</p><p>总结：有了虚拟地址空间之后就可以完美的解决上边提到的所有问题了，**虚拟地址空间就是一个中间层，相当于在程序和物理内存之间设置了一个屏障，将二者隔离开来。程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。**这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</p><h2 id="分区">分区</h2><p>从操作系统层级上看，虚拟地址空间主要分为两个部分<strong>内核区</strong>和<strong>用户区</strong>。</p><ul><li>内核区：<ul><li>内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</li><li>内核总是驻留在内存中，是操作系统的一部分。</li><li>系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（系统内核只有一个）。</li></ul></li></ul><p><img src="https://subingwen.cn/linux/file-descriptor/image-20210130093015907.png" alt="img"></p><p>每个进程的虚拟地址空间都是从 0 地址开始的，我们在程序中打印的变量地址也其在虚拟地址空间中的地址，程序是无法直接访问物理内存的。虚拟地址空间中用户区地址范围是 0~3G，里边分为多个区块：</p><ul><li><p>保留区: 位于虚拟地址空间的最底部，未赋予物理地址。任何对它的引用都是非法的，程序中的空指针（NULL）指向的就是这块内存地址。</p></li><li><p>.text段: 代码段也称正文段或文本段，通常用于存放程序的执行代码 (即 CPU 执行的机器指令)，代码段一般情况下是只读的，这是对执行代码的一种保护机制。</p></li><li><p>.data段: 数据段通常用于存放程序中已初始化且初值不为 0 的全局变量和静态变量。数据段属于静态内存分配 (静态存储区)，可读可写。</p></li><li><p>.bss段: 未初始化以及初始为 0 的全局变量和静态变量，操作系统会将这些未初始化变量初始化为 0</p></li><li><p>堆(heap)：用于存放进程运行时动态分配的内存。</p><ul><li><p>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。</p></li><li><p>堆向高地址扩展 (即 “向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。</p></li></ul></li><li><p>内存映射区(mmap)：作为内存映射区加载磁盘文件，或者加载程序运作过程中需要调用的动态库。</p></li><li><p>栈(stack): 存储函数内部声明的非静态局部变量，函数参数，函数返回地址等信息，栈内存由编译器自动分配释放。栈和堆相反地址 “向下生长”，分配的内存是连续的。</p></li><li><p>命令行参数：存储进程执行的时候传递给 main() 函数的参数，argc，argv []</p></li><li><p>环境变量: 存储和进程相关的环境变量，比如：工作路径，进程所有者等信息</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/posts/15fc6e8c.html"/>
      <url>/posts/15fc6e8c.html</url>
      
        <content type="html"><![CDATA[<h1>1.线程概述</h1><ul><li><p><strong>多线程和多进程都能够提高程序的并发性，但多线程对系统资源消耗更少，且多线程和多进程效率都是差不多的</strong></p></li><li><p>cpu会将单位时间分为很多份，每一份叫时间片，由系统进行调度，每个线程执行时都需要抢时间片，抢到的线程就执行成为<strong>运行态</strong>，没抢到就处于<strong>就绪态</strong>，执行完之后又成为就绪态继续抢时间片（都是随机的，无序运行）。</p></li></ul><div class="tip "><p>线程是轻量级的进程（LWP：light weight process），在 Linux 环境下线程的本质仍是进程。在计算机上运行的程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行。操作系统会以进程为单位，分配系统资源，可以这样理解，<strong>进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。</strong></p></div><p>先从概念上了解一下线程和进程之间的区别：</p><ul><li><p>进程有自己<strong>独立</strong>的地址空间，多个线程<strong>共用</strong>同一个地址空间</p><ul><li><p>线程更加节省系统资源，效率不仅可以保持的，而且能够更高</p></li><li><p>在一个<strong>地址空间</strong>中多个线程<strong>独享</strong>：每个线程都有属于自己的栈区，寄存器 (内核中管理的)</p></li><li><p>在一个<strong>地址空间</strong>中多个线程<strong>共享</strong>：代码段，堆区，全局数据区，打开的文件 (文件描述符表) 都是线程共享的</p></li></ul><p>(详细见blog篇)虚拟地址空间：于每一个程序在执行时（如a.out），此时会产生一个相应的进程，系统都会自动为其分配一个0~4G的虚拟地址空间，其中1G的内核空间用于：进程管理、内存管理、设备管理和虚拟文件系统等。</p><p>下面详细介绍0~3G的用户空间：</p><pre><code>     强调一点：以下说明的各段都是与编程相关的，不包括虚拟地址空间的全部。    0~3G的用户空间。从小到大（从下往上）依次为：保留区（受保护的地址）、代码段、数据段（.data段）、.bss段、堆空间、内存映射段、栈空间、命令行参数和环境变量。下面依次对每一个段做简单的介绍：</code></pre></li><li><p>线程是程序的最小执行单位，进程是操作系统中最小的资源分配单位</p><ul><li><p>每个进程对应一个虚拟地址空间，一个进程只能抢一个 CPU 时间片</p></li><li><p>一个地址空间中可以划分出多个线程，在有效的资源基础上，能够抢更多的 CPU 时间片</p></li></ul></li><li><p>CPU 的调度和切换：线程的上下文切换比进程要快的多</p><p>上下文切换：进程 / 线程分时复用 CPU 时间片，在切换之前会将上一个任务的状态进行保存，下次切换回这个任务的时候，加载这个状态继续运行，任务从保存到再次加载这个过程就是一次上下文切换。</p></li><li><p>线程更加廉价，启动速度更快，退出也快，对系统资源的冲击小。</p><p><strong>一般考虑多线程，只执行任务的话，考虑多线程</strong></p><p><strong>当同时启动多个程序时，考虑多进程</strong></p><div class="tip "><p><strong>在处理多任务程序的时候使用多线程比使用多进程要更有优势，但是线程并不是越多越好，如何控制线程的个数呢？</strong></p></div><p>1.文件 IO 操作：文件 IO 对 CPU 是使用率不高，因此可以分时复用 CPU 时间片，线程的个数 = 2 * CPU 核心数 (效率最高)</p><p>2.处理复杂的算法 (主要是 CPU 进行运算，压力大)，线程的个数 = CPU 的核心数 (效率最高)</p></li></ul><h1>2.创建线程</h1><h2 id="线程函数">线程函数</h2><p>每一个线程都有一个唯一的线程 ID，ID 类型为 <strong>pthread_t</strong>，这个 ID 是一个<strong>无符号长整形数</strong>，如果想要得到当前线程的线程 ID，可以调用如下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>）<span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">// 返回当前线程的线程ID</span></span><br></pre></td></tr></table></figure><p>在一个进程中调用线程创建函数，就可得到一个子线程，和进程不同，需要给每一个创建出的线程指定一个处理函数，否则这个线程无法工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> <span class="comment">//线程库</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread, 线程库的名字叫pthread</span></span><br><span class="line"><span class="comment">//全名: libpthread.so libptread.a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>thread: 传出参数，是无符号长整形数，线程创建成功，会将线程 ID 写入到这个指针指向的内存中</li><li>attr: 线程的属性，一般情况下使用默认属性即可，写 NULL</li><li>start_routine: 函数指针，创建出的子线程的处理动作，也就是该（回调函数）工作函数在子线程中执行。</li><li>arg: 作为实参传递到 start_routine 指针指向的函数内部，工作函数的参数，会自动传入</li></ul></li></ul><p>返回值：线程创建成功返回 0，创建失败返回对应的错误号</p><div class="note warning flat"><p>注意：1.回调函数返回值为void *型，参数为void * arg。2.回调函数 的参数当有多个时，可以用结构体储存，再将该结构体传入</p></div><h2 id="创建线程">创建线程</h2><p>下面是创建线程的示例代码，在创建过程中一定要保证编写的线程函数与规定的函数指针类型一致：<strong>void *(*start_routine) (void *)</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_create.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//sleep函数所在头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 休息, 休息一会儿...</span></span><br><span class="line">    <span class="comment">// sleep(1);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>linux下编译测试程序，会看到如下错误信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc pthread_create.c</span> </span><br><span class="line">/tmp/cctkubA6.o: In function `main&#x27;:</span><br><span class="line">pthread_create.c:(.text+0x7f): undefined reference to `pthread_create&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>错误原因是因为编译器链接不到线程库文件（动态库），需要在编译的时候通过参数指定出来，动态库名为 <a href="http://libpthread.so">libpthread.so</a> 需要使用的参数为 -l，根据规则掐头去尾最终形态应该写成：-lpthread（参数和参数值中间可以有空格）。正确的编译命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pthread_create 函数的定义在某一个库中, 编译的时候需要加库名 pthread</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc pthread_create.c -lpthread</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span> </span><br><span class="line">子线程创建成功, 线程ID: 139712560109312</span><br><span class="line">我是主线程, 线程ID: 139712568477440</span><br><span class="line">i = 0</span><br><span class="line">i = 1</span><br><span class="line">i = 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意：在打印的日志输出中为什么子线程处理函数没有执行完毕呢（只看到了子线程的部分日志输出）？<br>主线程一直在运行，执行期间创建出了子线程，说明主线程有 CPU 时间片，在这个时间片内将代码执行完毕了，主线程就退出了。<strong>子线程被创建出来之后需要抢cpu时间片, 抢不到就不能运行，如果主线程退出了, 虚拟地址空间就被释放了, 子线程就一并被销毁了。但是如果某一个子线程退出了, 主线程仍在运行, 虚拟地址空间依旧存在。</strong></p></div><p>得到的结论：<strong>在没有人为干预的情况下，虚拟地址空间的生命周期和主线程是一样的，与子线程无关</strong>。</p><p>目前的解决方案：让子线程执行完毕，主线程再退出，可以在主线程中添加挂起函数 sleep()，避免主线程先执行完毕后虚拟地址空间被释放;</p><h1>3.线程退出</h1><div class="tip "><p>在编写多线程程序的时候，如果想要让线程退出，<strong>但是不会导致虚拟地址空间的释放（针对于主线程退出后，不想释放虚拟空间地址的情况）</strong>，我们就可以调用线程库中的线程退出函数，只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，<strong>不管是在子线程或者主线程中都可以使用。</strong></p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数(void *retval)：线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为 NULL</li></ul><p>线程退出示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);<span class="comment">// 直接退出子线程</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程调用退出函数退出, 地址空间不会被释放</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>4.线程回收</h1><h2 id="线程函数-2">线程函数</h2><div class="tip "><p>线程和进程一样，子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做  <strong>pthread_join()</strong>，这个函数是一个阻塞函数，<strong>如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</strong></p></div><p>另外通过线程回收函数还可以获取到子线程退出时传递出来的数据，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这是一个阻塞函数, 子线程在运行这个函数就阻塞</span></span><br><span class="line"><span class="comment">// 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>参数:</p><ul><li>thread: 要被回收的子线程的线程 ID</li><li>retval: 二级指针，指向一级指针的地址，是一个传出参数，这个地址中存储了 pthread_exit () 传递出的数据，如果不需要这个参数，可以指定为 NULL</li></ul></li><li><p>返回值：线程回收成功返回 0，回收失败返回错误号。</p></li></ul><h2 id="回收子线程数据">回收子线程数据</h2><p>在子线程退出的时候可以使用 pthread_exit() 的参数将数据传出，在回收这个子线程的时候可以通过 phread_join() 的第二个参数来接收子线程传递出的数据。接收数据有很多种处理方式，下面来列举几种：</p><h3 id="使用子线程栈">使用子线程栈</h3><p>通过函数 <em>pthread_exit(void *retval);</em> 可以得知，子线程退出的时候，需要将数据记录到一块内存中，通过参数传出的是存储数据的内存的地址，而不是具体数据，由因为参数是 <em>void*</em> 类型，所有这个万能指针可以指向任意类型的内存地址。先来看第一种方式，将子线程退出数据保存在子线程自己的栈区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_join.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span></span><br><span class="line">            p.age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p.id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(&amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">// 代码执行不到这个位置就退出了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">pp</span> =</span> (<span class="keyword">struct</span> Persion*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程返回数据: name: %s, age: %d, id: %d\n&quot;</span>, pp-&gt;name, pp-&gt;age, pp-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行测试程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 编译代码</span><br><span class="line">$ gcc pthread_join.c -lpthread</span><br><span class="line"># 执行程序</span><br><span class="line">$ ./a.out </span><br><span class="line">子线程创建成功, 线程ID: <span class="number">140652794640128</span></span><br><span class="line">我是主线程, 线程ID: <span class="number">140652803008256</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">我是子线程, 线程ID: <span class="number">140652794640128</span></span><br><span class="line">child == i: = <span class="number">0</span></span><br><span class="line">child == i: = <span class="number">1</span></span><br><span class="line">child == i: = <span class="number">2</span></span><br><span class="line">child == i: = <span class="number">3</span></span><br><span class="line">child == i: = <span class="number">4</span></span><br><span class="line">child == i: = <span class="number">5</span></span><br><span class="line">child == i: = <span class="number">6</span></span><br><span class="line">子线程返回数据: name: , age: <span class="number">0</span>, id: <span class="number">0</span></span><br><span class="line">子线程资源被成功回收...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过打印的日志可以发现，在主线程中没有没有得到子线程返回的数据信息，具体原因是这样的：</p><p><strong>如果多个线程共用同一个虚拟地址空间，每个线程在栈区都有一块属于自己的内存，相当于栈区被这几个线程平分了，当线程退出，线程在栈区的内存也就被回收了，因此随着子线程的退出，写入到栈区的数据也就被释放了。</strong></p><h3 id="使用全局变量">使用全局变量</h3><p>位于同一虚拟地址空间中的线程，虽然<strong>不能共享栈区数据，但是可以共享全局数据区和堆区数据</strong>，因此在子线程退出的时候可以将传出数据存储到全局变量、静态变量或者堆内存中。在下面的例子中将数据存储到了全局变量中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span><span class="comment">// 定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用全局变量</span></span><br><span class="line">            p.age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p.id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(&amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">pp</span> =</span> (<span class="keyword">struct</span> Persion*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s, age: %d, id: %d\n&quot;</span>, pp-&gt;name, pp-&gt;age, pp-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用主线程栈">使用主线程栈</h3><p>虽然每个线程都有属于自己的栈区空间，但是<strong>位于同一个地址空间的多个线程是可以相互访问对方的栈空间上的数据的</strong>。由于很多情况下还需要在主线程中回收子线程资源，所以主线程一般都是最后退出，基于这个原因在下面的程序中将子线程返回的数据保存到了主线程的栈区内存中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">p</span> =</span> (<span class="keyword">struct</span> Persion*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用主线程的栈内存</span></span><br><span class="line">            p-&gt;age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p-&gt;id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">// 主线程的栈内存传递给子线程</span></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s, age: %d, id: %d\n&quot;</span>, p.name, p.age, p.id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的程序中，调用 pthread_create() 创建子线程，并将主线程中栈空间变量 p 的地址传递到了子线程中，在子线程中将要传递出的数据写入到了这块内存中。也就是说在程序的 main() 函数中，通过指针变量 ptr 或者通过结构体变量 p 都可以读出子线程传出的数据。</p><h2 id="手动和自动回收资源">手动和自动回收资源</h2><div class="tip "><p><strong>线程退出有多种方式，如return，pthread_exit,pthread_cancel等；线程分为可结合的（joinable）和 分离的（detached）两种，如果没有在创建线程时将线程分离，则线程默认是可结合的。可结合的线程在线程退出后不会立即释放资源，必须要调用pthread_join来显式的结束线程。分离的线程在线程退出时系统会自动回收资源。</strong></p></div><p></p><ul><li><p>pthread_exit()：只退出当前子线程。<strong>注意</strong>：在主线程退出时，其它线程不会结束。同样可以执行。所以这个只字非常重要。并且，与return一样，pthread_exit退出的线程也需要调用pthread_join去回收子线程的资源(8k左右)，不会自行回收，否则服务器长时间运行会浪费资源导致无法再创建新线程。</p></li><li><p>pthread_detach()，自行回收资源</p></li></ul><h1>5.线程分离</h1><div class="tip "><p><strong>某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用 pthread_join() 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。</strong></p></div><p>在线程库函数中为我们提供了线程分离函数 <strong>pthread_detach()</strong>，调用这个函数之后指定的<strong>子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。<strong>线程分离之后在主线程中使用 <strong>pthread_join()</strong> 就回收不到子线程资源了。</strong>(detach后资源自动回收)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p>下面的代码中，在主线程中创建子线程，并调用线程分离函数，实现了主线程和子线程的分离：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子线程和主线程分离</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程自己退出即可，必须有这个，否则虚拟地址空间内存会被释放</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>6.其他线程函数</h1><h2 id="线程取消函数">线程取消函数</h2><p>线程取消的意思就是在某些特定情况下在一个线程中杀死另一个线程。使用这个函数杀死一个线程需要分两步：</p><ul><li>在线程 A 中调用线程取消函数 pthread_cancel，指定杀死线程 B，这时候线程 B 是死不了的</li><li>在线程 B 中进程一次系统调用（从用户区切换到内核区），否则线程 B 可以一直运行。<br>这其实和七步断肠散、含笑半步癫的功效是一样的，吃了毒药不动或者不笑也没啥事儿</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数是子线程的线程ID</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数：要杀死的线程的线程 ID</p></li><li><p>返回值：函数调用成功返回 0，调用失败返回非 0 错误号。</p></li></ul><p>在下面的示例代码中，主线程调用线程取消函数，只要在子线程中进行了系统调用，当子线程执行到这个位置就挂掉了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf这个函数会调用系统函数, 因此这是个间接的系统调用,运行到子线程就挂了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; child i: %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 杀死子线程, 如果子线程中做系统调用, 子线程就结束了</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程自己退出即可</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>关于系统调用有两种方式：</strong></p><ul><li>直接调用 Linux 系统函数</li><li>调用标准 C 库函数，为了实现某些功能，在 Linux 平台下标准 C 库函数会调用相关的系统函数</li></ul><h2 id="线程ID比较">线程ID比较</h2><p>在 Linux 中线程 ID 本质就是一个无符号长整形，因此可以直接使用比较操作符比较两个线程的 ID，但是线程库是可以跨平台使用的，在某些平台上 <strong>pthread_t</strong> 可能不是一个单纯的整形，这中情况下比较两个线程的 ID 必须要使用比较函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：t1 和 t2 是要比较的线程的线程 ID</li><li>返回值：如果两个线程 ID 相等返回非 0 值，如果不相等返回 0</li></ul><h1>7.C++线程类（std::thread）</h1><p><a href="https://blog.csdn.net/sjc_0910/article/details/118861539?spm=1001.2014.3001.5506"> C++11 多线程（std::thread）详解_c++多线程_jcShan709的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clion快捷键</title>
      <link href="/posts/70b69f96.html"/>
      <url>/posts/70b69f96.html</url>
      
        <content type="html"><![CDATA[<h1>CLion编辑快捷键</h1><p><strong>Ctrl+Spacebar</strong> 基本代码完成(任何类、方法或变量的名称)</p><p><strong>Ctrl+Shift+Spacebar</strong> 智能代码完成(按预期类型筛选方法和变量列表)</p><p><strong>Ctrl+Shift+Enter</strong> 完整的语句</p><p><strong>Ctrl+P</strong> 参数信息(在方法调用参数内)</p><p><strong>Ctrl+Q</strong> 快速查找文档</p><p><strong>Ctrl+Mouse over code</strong> 简短的信息</p><p><strong>Ctrl+F1</strong> 在插入符号处显示错误或警告的说明</p><p><strong>Alt+Insert</strong> 生成代码…(Getters, Setters, Constructors, hashCode/equals, toString)</p><p><strong>Ctrl+O</strong> 覆盖方法</p><p><strong>Ctrl+I</strong> 实现方法</p><p><strong>Ctrl+Alt+T</strong> 围绕与…(如果. .其他,试试. .catch, for, synchronized等)</p><p><strong>Ctrl+/</strong> 注释/取消注释行注释</p><p><strong>Ctrl+Shift+/</strong> 注释/取消注释块注释</p><p><strong>Ctrl+W</strong> 选择连续递增代码块</p><p><strong>Ctrl+Shift+W</strong> 减少当前选择到以前的状态</p><p><strong>Alt+Q</strong> 显示强度动作和快速修复</p><p><strong>Ctrl+Alt+L</strong> 重新格式化代码</p><p><strong>Ctrl+Alt+O</strong> 优化进口</p><p><strong>Ctrl+Alt+I</strong> 自动缩进线(年代)</p><p><strong>Tab/Shift+Tab</strong> 缩进/ unindent选定的行</p><p><strong>Ctrl+X</strong> 剪切当前行或选定块到剪贴板</p><p><strong>Ctrl+C</strong> 复制当前行或选定块到剪贴板</p><p><strong>Ctrl+V</strong> 从剪贴板粘贴</p><p><strong>Ctrl+Shift+V</strong> 从最近的缓冲区粘贴…</p><p><strong>Ctrl+D</strong> 复制当前行或选定块</p><p><strong>Ctrl+Y</strong> 删除插入符号处的行</p><p><strong>Ctrl+Shift+J</strong> 智能线连接</p><p><strong>Ctrl+Enter</strong> 智能线分裂</p><p><strong>Shift+Enter</strong> 开始新的一行</p><p><strong>Ctrl+Shift+U</strong> 在插入符号或选定块上切换大小写</p><p><strong>Ctrl+Shift+]/[</strong> 选择直到代码块结束/开始</p><p><strong>Ctrl+Delete</strong> 删除到字尾</p><p><strong>Ctrl+Backspace</strong> 删除到单词开始</p><p><strong>Ctrl+ NumPad +/-</strong> 展开/折叠代码块</p><p><strong>Ctrl+Alt+ NumPad +/-</strong> 展开所有/折叠所有</p><p><strong>Ctrl+F4</strong> 关闭活动编辑器选项卡</p><p><strong>Alt+Shift+Click</strong> 将插入符号放置在多个位置</p><p><strong>Esc</strong> 恢复单插入字符模式</p><p><strong>Alt+G/Alt+Shift+G</strong> 添加/删除下次出现的当前单词选择</p><h1>CLion查找和替换</h1><p><strong>Double Shift</strong> 到处寻找</p><p><strong>Ctrl+F</strong> 找到</p><p><strong>F3 / Shift+F3</strong> 查找下一个/找到之前</p><p><strong>Ctrl+R</strong> 取代</p><p><strong>Ctrl+Shift+F</strong> 找到的路径</p><p><strong>Ctrl+Shift+R</strong> 在路径替换</p><h1>CLion编译、运行快捷键</h1><p><strong>Ctrl+F9</strong> 建设项目</p><p><strong>Alt+Shift+F10</strong> 选择配置并运行</p><p><strong>Alt+Shift+F9</strong> 选择配置和调试</p><p><strong>Shift+F10</strong> 运行</p><p><strong>Shift+F9</strong> 调试</p><h1>CLion Debug快捷键</h1><p><strong>F8</strong> 步进</p><p><strong>F7</strong> 进入</p><p><strong>Shift+F8</strong> 步出</p><p><strong>Alt+F9</strong> 运行到光标</p><p><strong>Alt+F8</strong> 计算表达式</p><p><strong>F9</strong> 恢复程序</p><p><strong>Ctrl+F8</strong> Toggle breakpoint</p><p><strong>Ctrl+Shift+F8</strong> 查看断点</p><h1>CLion Live模板快捷键</h1><p><strong>Ctrl+Alt+J</strong> 使用Live模板包围</p><p><strong>Ctrl+J</strong> 插入Live模板</p><p><strong>for</strong> (索引;,)循环</p><p><strong>iter</strong> 迭代范围(C + + 11)</p><p><strong>itit</strong> 使用Begin/End成员函数迭代</p><p><strong>incboost</strong> 在CMake中包含使用Boost的指示</p><p><strong>function</strong> 在CMake中创建新的函数定义器</p><h1>CLion搜索文件、导航快捷键</h1><p><strong>Ctrl+N</strong> 搜索类文件</p><p><strong>Ctrl+Shift+N</strong> 搜索文件</p><p><strong>Ctrl+Alt+Shift+N</strong> 定位到符号</p><p><strong>Alt+Right Arrow/Left Arrow</strong> 转到下一个/上一个编辑器选项卡</p><p><strong>F12</strong> 返回到前一个工具窗口</p><p><strong>Esc</strong> 转到编辑器(从工具窗口)</p><p><strong>Shift+Esc</strong> 隐藏活动的或最近活动的窗口</p><p><strong>Ctrl+Shift+F4</strong> 关闭活动运行/信息/发现/…选项卡</p><p><strong>Ctrl+G</strong> 去行</p><p><strong>Ctrl+E</strong> 最近文件弹出</p><p><strong>Ctrl+Alt+Left Arrow/Right Arrow</strong> 向后/向前导航</p><p><strong>Ctrl+Shift+Backspace</strong> 导航到最后一次编辑位置</p><p><strong>Alt+F1</strong> 在任意视图中选择当前文件或符号</p><p><strong>Ctrl+B</strong> 定位声明 或 <strong>Ctrl + 鼠标左键</strong></p><p><strong>Ctrl+Alt+B</strong> 搜索实现类(年代)</p><p><strong>Ctrl+Alt+Home</strong> 转到相关符号(头/源)</p><p><strong>Ctrl+Shift+I</strong> 文件)</p><p><strong>Ctrl+Shift+B</strong> 开放快速定义查找</p><p><strong>Ctrl+U</strong> 进入类型声明</p><p><strong>Alt+Up Arrow/Down Arrow</strong> 父类方法/超类</p><p><strong>Ctrl+]/[</strong> 转到前一个/下一个方法</p><p><strong>Ctrl+F12</strong> 移动到代码块结束/移动到代码开始</p><p><strong>Ctrl+H</strong> 弹出文件结构</p><p><strong>Ctrl+Alt+H</strong> 类型层次结构</p><p><strong>F2/Shift+F2</strong> 调用层次结构</p><p><strong>F11</strong> 下一个/以前的错误突出显示</p><p><strong>Ctrl+F11</strong> 切换书签</p><p><strong>Ctrl+0…9</strong> 用助记符切换书签</p><p><strong>Shift+F11</strong> 转到编号书签</p><h1>CLion常用快捷键</h1><p><strong>Alt+0…9</strong> 打开相应的工具窗口</p><p><strong>Alt+Shift+I</strong> 用当前配置文件检查当前文件</p><p><strong>Ctrl+`</strong> 快速开关电流方案</p><p><strong>Ctrl+Alt+S</strong> 编辑应用程序设置</p><p><strong>Ctrl+Shift+F12</strong> 隐藏所有工具窗口</p><p><strong>Alt+Shift+F</strong> 添加到收藏夹</p><h1>CLion 使用过的搜索</h1><p><strong>Alt+F7</strong> 发现使用</p><p><strong>Ctrl+F7</strong> 在文件中查找用法</p><p><strong>Ctrl+Shift+F7</strong> 突出显示文件中的用法</p><p><strong>Ctrl+Alt+F7</strong> 显示用法</p><h1>VCS/Git快捷键</h1><p><strong>Ctrl+K</strong> 向VCS/Git提交项目</p><p><strong>Ctrl+T</strong> 从VCS更新项目</p><p><strong>Alt+Shift+C</strong> 查看最近的变化</p><p><strong>Alt+`</strong> VCS/Git快速弹出</p><h1>CLion重构快捷键</h1><p><strong>Ctrl+Alt+Shift+T</strong> 重构</p><p><strong>F5</strong> 复制</p><p><strong>F6</strong> 移动</p><p><strong>Alt+Delete</strong> 安全的删除</p><p><strong>Shift+F6</strong> 重命名</p><p><strong>Ctrl+F6</strong> 更改签名</p><p><strong>Ctrl+Alt+M</strong> 提取功能</p><p><strong>Ctrl+Alt+N</strong> 内联</p><p><strong>Ctrl+Alt+P</strong> 引入参数</p><p><strong>Ctrl+Alt+V</strong> 引入变量</p><p><strong>Ctrl+Alt+C</strong> 介绍常数</p><p><strong>Ctrl+Alt+D</strong> 介绍定义</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32(HAL库)</title>
      <link href="/posts/b900f0d0.html"/>
      <url>/posts/b900f0d0.html</url>
      
        <content type="html"><![CDATA[<h1>1.IDE选择</h1><ul><li><p><strong>keil + STM32CubeMX</strong></p></li><li><p><strong>Clion + STM32CubeMX/PlatformIO(插件)</strong></p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/145801160">配置CLion用于STM32开发【优雅の嵌入式开发】 - 知乎 (zhihu.com)</a></p><h1>2.时钟RCC</h1><p><a href="https://blog.csdn.net/as480133937/article/details/98845509">【STM32】系统时钟RCC详解(超详细，超全面)_rcc时钟_Z小旋的博客-CSDN博客</a></p><h1>3.STM32-GPIO介绍</h1><p><a href="https://blog.csdn.net/qq_44016222/article/details/123206403?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stm32GPIO&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-123206403.nonecase&amp;spm=1018.2226.3001.4187"> STM32-GPIO介绍_stm32gpio_KevinFlyn的博客-CSDN博客</a></p><h2 id="HAL库-GPIO函数库">HAL库 GPIO函数库</h2><p><a href="https://blog.csdn.net/as480133937/article/details/98983268"> 【STM32】HAL库 STM32CubeMX教程三----外部中断(HAL库GPIO讲解)_HAL_GPIO_EXTI_callback_Z小旋的博客-CSDN博客</a></p><h2 id="单片机引脚的上拉、下拉和三态">单片机引脚的上拉、下拉和三态</h2><p>**上拉：**上拉是指单片机的引脚通过电阻接VCC，这样可以把这个引脚的电平固定为高电平。</p><p>**下拉：**下拉的情况和上拉的相反，是为了把引脚固定为低电平，要有下拉电阻也是为了防止误配置导致烧掉芯片。</p><p>**三态：**三态又称为高阻态，简单理解就是电平的高低由这根线上的外部电路决定，当外部电路为高电平的时候，它也是高电平；当外部电路为低电平的时候，它也是低电平；当外部电路为高阻态的时候，它就是高阻态的，状态完全和外部电路一样。</p><h2 id="上升沿和下降沿"><strong>上升沿和下降沿</strong></h2><p>**电平：**简单理解就是电压，但却不相同。</p><p>**上升沿触发：**数字电路中，数字电平从低电平（数字“0”代表低电平）变为高电平（数字“1”代表高电平）的那一瞬间叫作上升沿。上升沿触发是当信号有上升沿时的开关动作，当电位由低变高而触发输出变化的就叫上升沿触发。也就是当测到的信号电位是从低到高也就是上升时就触发，叫做上升沿触发。</p><p>**下降沿触发：**数字电路中，数字电平从高电平（数字“1”）变为低电平（数字“0”）的那一瞬间叫作下降沿。 下降沿触发是当信号有下降沿时的开关动作，当电位由高变低而触发输出变化的就叫下降沿触发。也就是当测到的信号电位是从高到低也就是下降时就触发，叫做下降沿触发。</p><h1>定时器</h1><h2 id="定时器的介绍">定时器的介绍</h2><h3 id="STM32G070RBT6定时器资源">STM32G070RBT6定时器资源</h3><blockquote><p>STM32G070RBT6拥有一个PWM高级定时器，五个16位通用定时器，两个基础定时器，两个看门狗定时器，一个SysTick定时器，共有11个定时器。</p></blockquote><p>基本定时器 TIM6 和 TIM7 是一个 16 位的只能向上计数的定时器，只能定时，没有外部 IO。通用定时器 TIM14/15/16/17 是 16 位的只能向上计数的定时器，可以定时，可以输出比较，可以输入捕获，其中TIM15拥有外部输入引脚，和两个输出通道，TIM14/16/17都仅只有一个通道。高级定时器 TIM1 是一个 16 位的可以向上/下计数的定时器，可以定时，可以输出比较，可以输入捕捉，还可以有三相电机互补输出信号，有 8 个外部 IO。</p><h3 id="基本定时器功能框图讲解">基本定时器功能框图讲解</h3><p>基本定时器的核心是时基，不仅基本定时器有，通用定时器和高级定时器也有。学习定时器时，我们先从简单的基本定时器学起。</p><h4 id="时钟源">时钟源</h4><p>定时器时钟 TIMxCLK，即内部时钟 CK_INT，经 APB 预分频器后分频提供，如果APB1 预分频系数等于 1，则频率不变，否则频率乘以 2，库函数中 APB 预分频的系数是 1，即TPCLK=64M，所以定时器TIMxCLK=64MHz。</p><h4 id="计数器时钟">计数器时钟</h4><p>定时器时钟经过 PSC 预分频器之后，即计数器时钟 CK_CNT，用来驱动计数器计数。PSC 是一个16 位的预分频器，可以对定时器时钟 TIMxCLK 进行 1~65536 之间的任何一个数进行分频。具体计算方式为：CK_CNT=TIMxCLK/(PSC+1)。</p><h4 id="计数器">计数器</h4><p>计数器 CNT 是一个 16 位的计数器，只能往上计数，最大计数值为 65535。当计数达到自动重装载寄存器的时候产生更新事件，并清零从头开始计数。</p><h4 id="自动重装载寄存器">自动重装载寄存器</h4><p>自动重装载寄存器 ARR 是一个 16 位的寄存器，这里面装着计数器能计数的最大数值。当计数到这个值的时候，如果使能了中断的话，定时器就产生溢出中断。</p><h4 id="定时器时间的计算">定时器时间的计算</h4><p>定时器的定时时间等于计数器的中断周期乘以中断的次数。计数器在 CK_CNT 的驱动下，计一个数的时间则是 CK_CNT 的倒数，等于：1/（TIMxCLK/(PSC+1)），产生一次中断的时间则等于：(1/CK_CNT) * (ARR+1)。如果在中断服务程序里面设置一个变量 time，用来记录中断的次数，那么就可以计算出我们需要的定时时间等于：(1/CK_CNT) * (ARR+1) * time。</p><h2 id="实验内容">实验内容</h2><h3 id="Ⅰ-定时器控制小灯每秒闪烁一次">Ⅰ.定时器控制小灯每秒闪烁一次</h3><h3 id="实验原理">实验原理</h3><p>定时器溢出时间（us）= (定时器预分频值+1)*(定时器自动重装载值+1)/(定时器输入时钟频率(MHz))</p><p>通过配置基础定时器TIM7的 <em><strong>Psc</strong></em> (预分频值)与 <em><strong>Arr</strong></em> (自动重装载值)，使得其溢出时间为1 s；在定时器中断回调函数中调用GPIO状态翻转函数控制LED的引脚电平翻转，从而实现小灯每秒闪烁一次。</p><h3 id="STM32CubeMX的配置">STM32CubeMX的配置</h3><p><a href="https://blog.csdn.net/as480133937/article/details/99231677">【STM32】HAL库 STM32CubeMX教程七—PWM输出(呼吸灯)_stm32cubemx pwm呼吸灯_Z小旋的博客-CSDN博客</a></p><h4 id="Keil工程代码讲解">Keil工程代码讲解</h4><h4 id="引用或定义的函数">引用或定义的函数</h4><h5 id="需要引用的函数：">需要引用的函数：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数原型 */</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_TIM_Base_Start_IT</span><span class="params">(TIM_HandleTypeDef *htim)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数引用举例 */</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim7);<span class="comment">//以中断工作方式启动定时器TIM7，发生UEV事件时产生中断</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_TogglePin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数引用举例 */</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); <span class="comment">//控制PC13翻转电平</span></span><br></pre></td></tr></table></figure><h4 id="需要定义的函数：">需要定义的函数：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数原型 */</span></span><br><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数重定义举例 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 判断进入中断定时器是否为TIM7 */</span></span><br><span class="line"><span class="keyword">if</span> (htim == &amp;htim7)&#123;</span><br><span class="line"><span class="comment">/* 控制PC13引脚翻转电平 */</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h5 id="拓展：">拓展：</h5><p><a href="https://baike.baidu.com/item/%E4%B8%AD%E6%96%AD/3933007?fromModule=lemma_search-box">中断（Interrupt）</a>：是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p><p><a href="https://zhidao.baidu.com/question/345550524.html#:~:text=UEV%EF%BC%8C%E9%95%BF%E7%A7%B0%EF%BC%8Cupdate,event%EF%BC%8C%E4%B8%AD%E6%96%87%E4%B8%BA%E6%9B%B4%E6%96%B0%E4%BA%8B%E4%BB%B6%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%B4%E4%BA%8B%E4%BB%B6%E6%9B%B4%E6%96%B0%E5%8F%91%E7%94%9F%EF%BC%8C%E6%98%AF%E6%8C%87%E8%BF%99%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E5%90%8E%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%B0%86%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%BB%A5%E4%BD%BF%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%9C%A8%E6%96%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8B%EF%BC%8C%E4%BE%8B%E5%A6%82%E5%BD%93%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%91%A8%E6%9C%9F%E7%BB%93%E6%9D%9F%EF%BC%88%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%8A%E6%BA%A2%EF%BC%89%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E4%BA%8B%E4%BB%B6%E3%80%82">UEV事件</a>：全称——update event，中文为更新事件，或者说事件更新发生，是指这个事件发生后，将会将定时器的寄存器进行更新，以使定时器工作在新的配置下，例如当一个定时周期结束（计数器上溢）或者其他事件。</p><p><a href="https://baike.baidu.com/item/%E8%BD%AE%E8%AF%A2?fromModule=lemma_search-box">轮询（Polling）</a>：是一种CPU决策如何提供周边设备服务的方式，又称“程控输入输出”（Programmed I/O）。轮询法的概念是：由CPU定时发出询问，依序询问每一个周边设备是否需要其服务，有即给予服务，服务结束后再问下一个周边，接着不断周而复始。</p><p><strong>控制基础定时器启动的HAL库函数</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start(&amp;htimx); <span class="comment">// 以轮询工作方式启动定时器，不会产生中断。</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htimx); <span class="comment">// 以中断工作方式启动定时器，发生UEV事件时产生中断</span></span><br><span class="line">HAL_TIM_Base_Start_DMA(&amp;htimx); <span class="comment">// 以DMA工作方式启动定时器</span></span><br></pre></td></tr></table></figure><p><strong>GPIO引脚相关的部分HAL库函数</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOX, GPIO_PIN_XX, GPIO_PIN_RESET); <span class="comment">// 控制PX_XX引脚输出低电平</span></span><br><span class="line">HAL_GPIO_WritePin(GPIOX, GPIO_PIN_XX, GPIO_PIN_SET); <span class="comment">// 控制PX_XX引脚输出高电平</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOX, GPIO_PIN_XX); <span class="comment">// 控制PX_XX引脚翻转电平</span></span><br><span class="line">HAL_GPIO_ReadPin(GPIOX, GPIO_PIN_XX); <span class="comment">// 读取PX_XX引脚当前状态</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq562029186/article/details/76216311">__weak修饰符</a>：在 HAL 库中，很多<a href="https://so.csdn.net/so/search?q=%E5%9B%9E%E8%B0%83&amp;spm=1001.2101.3001.7020">回调</a>函数前面使用__weak 修饰符。例如本次实验所用到的定时器中断回调函数：<code>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) </code>其函数原型为：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>;</span><br></pre></td></tr></table></figure><p>加上了__weak 修饰符的函数,用户可以在用户文件中重新定义一个同名函数，最终编译器编译的时候，会选择用户定义的函数，如果用户没有重新定义这个函数，那么编译器就会执行 weak 声明的函数，并且编译器不会报错。</p></blockquote><h4 id="在main-c文件中在所指示的位置添加以下代码">在main.c文件中在所指示的位置添加以下代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*以中断模式开启定时器7 */</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim7);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器中断回调函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 判断进入中断定时器是否为TIM7 */</span></span><br><span class="line"><span class="keyword">if</span> (htim == &amp;htim7)&#123;</span><br><span class="line"><span class="comment">/* 控制连接LED的引脚翻转电平 */</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在单片机上观察实验现象</strong></p><h3 id="Ⅱ-软件PWM实现控制蜂鸣器响度">Ⅱ.软件PWM实现控制蜂鸣器响度</h3><h4 id="实验原理-2">实验原理</h4><h5 id="（1）PWM">（1）PWM</h5><p><a href="https://baike.baidu.com/item/PWM%E6%8A%80%E6%9C%AF/10204668">脉冲宽度调制(PWM)</a>，是英文“Pulse Width Modulation”的缩写，简称<strong>脉宽调制</strong>，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，广泛应用在从测量、通信到功率控制与变换的许多领域中。</p><p>以单片机为例，我们知道，单片机的IO口输出的是<strong>数字信号</strong>，<strong>IO口只能输出高电平和低电平</strong></p><p>假设高电平为5V 低电平则为0V 那么我们要<strong>输出不同的模拟电压</strong>，就要用到PWM，通过改变IO口输出的<strong>方波的占空比</strong>从而获得使用数字信号模拟成的模拟电压信号</p><p>我们知道，电压是以一种连接1或断开0的重复脉冲序列被夹到模拟负载上去的（例如LED灯，直流电机等），连接即是直流供电输出，断开即是直流供电断开。通过对连接和断开时间的控制，理论上来讲，可以输出任意不大于最大电压值（即0~5V之间任意大小）的模拟电压</p><p>比方说 占空比为50% 那就是高电平时间一半，低电平时间一半，在一定的频率下，就可以得到模拟的2.5V输出电压 那么75%的占空比 得到的电压就是3.75V</p><p>pwm的调节作用来源于对“占周期”的宽度控制，“占周期”变宽，输出的能量就会提高，通过阻容变换电路所得到的平均电压值也会上升，“占周期”变窄，输出的电压信号的电压平均值就会降低，通过阻容变换电路所得到的平均电压值也会下降</p><p>也就是，<strong>在一定的频率下，通过不同的占空比即可得到不同的输出模拟电压</strong></p><p>pwm就是通过这种原理实现D/A转换的。</p><ul><li><strong>占空比是指在一个脉冲循环内，通电时间相对于总时间所占的比例。 占空比(Duty Ratio)在电信领域中有如下含义：例如：脉冲宽度1μs，信号周期4μs的脉冲序列占空比为0.25</strong></li></ul><h5 id="（2）PWM控制蜂鸣器响度的原理">（2）PWM控制蜂鸣器响度的原理</h5><p><strong>蜂鸣器音量的大小与电压大小成正比</strong>，因此通过调节软件pwm的占空比，来得到不同的输出模拟电压，即可控制蜂鸣器的响度。</p><h4 id="STM32CubeMX的配置-2">STM32CubeMX的配置</h4><p><strong>Step1：配置RCC</strong></p><p><strong>Step2：配置SYS</strong></p><p><strong>Step3：配置基础定时器TIM7</strong></p><p>要实现通过调节软件PWM的占空比模拟不同的输出电压，PWM需有较高频率。</p><p>所以此处设Psc = 31， Arr = 99；</p><p><strong>Step4：查看开发板原理图查找到蜂鸣器BEEP引脚 -&gt; PC12</strong></p><p><em>如果使用的是其他开发板，则根据所使用开发板的原理图寻找到接BEEP（蜂鸣器）的引脚，若该开发板无蜂鸣器，可寻找一个引出的引脚，准备一个蜂鸣器模块/蜂鸣器，按照蜂鸣器的正负极手动将蜂鸣器的一端与所选引脚相连，另一端与开发板上的GND相连</em></p><p><strong>Step5：配置BEEP引脚PC12为GPIO_Output（输出）模式</strong></p><p><strong>Step6：配置时钟树,主频率设为64HMz</strong></p><p><strong>Step7：配置工程属性</strong></p><p><strong>Step8：生成Keil工程</strong></p><h6 id="在main-c文件中在所指示的位置添加以下代码-2">在main.c文件中在所指示的位置添加以下代码</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 所定义的全局变量 */</span></span><br><span class="line"><span class="type">uint8_t</span> counter = <span class="number">0</span>; <span class="comment">//计数器</span></span><br><span class="line"><span class="type">uint8_t</span> pwmrate = <span class="number">20</span>;<span class="comment">//软件PWM的占空比</span></span><br><span class="line"><span class="type">_Bool</span> sw = <span class="number">0</span>; <span class="comment">//用于控制pwmrate的自增或自减【_Bool为布尔类型变量，只有1位即0和1】</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 以中断模式开启定时器7 */</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim7);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器中断回调函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 软件PWM */</span></span><br><span class="line"><span class="keyword">if</span> (counter &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">counter++;</span><br><span class="line"><span class="comment">/* 当计数值小于等于pwmrate时PC12为1，反之为0 */</span></span><br><span class="line"><span class="comment">/* 占空比为 pwmrate/100％，即pamrate */</span></span><br><span class="line"><span class="keyword">if</span>(counter &lt;= pwmrate)</span><br><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_SET);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 当counter值超过100归零 */</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当pwmrate即占空比小于100，且sw为0时，占空比逐渐增加，直至100 */</span></span><br><span class="line"><span class="keyword">if</span> (pwmrate &lt; <span class="number">100</span> &amp;&amp; sw == <span class="number">0</span>)</span><br><span class="line">pwmrate++;</span><br><span class="line"><span class="comment">/* 当pwmrate即占空比大于或等于100时，sw置为1 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sw = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当pwmrate即占空比大于20，且sw为1时，占空比逐渐减小，直至20 */</span></span><br><span class="line"><span class="keyword">if</span> (pwmrate &gt; <span class="number">20</span> &amp;&amp; sw == <span class="number">1</span>)</span><br><span class="line">pwmrate--;</span><br><span class="line"><span class="comment">/* 当pwmrate即占空比小于或等于20时，sw置0 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sw = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 延时20ms，使现象可以被人观测到 */</span></span><br><span class="line">HAL_Delay(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h6 id="在单片机上观察实验现象">在单片机上观察实验现象</h6><blockquote><h6 id="拓展：HAL库中的部分重定义变量类型">拓展：HAL库中的部分重定义变量类型</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/* 位于“stdint.h”文件中 */</span></span><br><span class="line">&gt;<span class="comment">/* exact-width signed integer types */</span></span><br><span class="line">&gt;<span class="keyword">typedef</span>   <span class="type">signed</span>          <span class="type">char</span> <span class="type">int8_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span>   <span class="type">signed</span> <span class="type">short</span>     <span class="type">int</span> <span class="type">int16_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span>   <span class="type">signed</span>           <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span>   <span class="type">signed</span>       __INT64 <span class="type">int64_t</span>;</span><br><span class="line">&gt;<span class="comment">/* exact-width unsigned integer types */</span></span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span>          <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>     <span class="type">int</span> <span class="type">uint16_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span>           <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span>       __INT64 <span class="type">uint64_t</span>;</span><br></pre></td></tr></table></figure><p><strong>常用的类型有：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">typedef</span>   <span class="type">signed</span> <span class="type">short</span>     <span class="type">int</span> <span class="type">int16_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span>   <span class="type">signed</span>           <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span>          <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>     <span class="type">int</span> <span class="type">uint16_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span>           <span class="type">int</span> <span class="type">uint32_t</span>;</span><br></pre></td></tr></table></figure></blockquote><h3 id="参考资料">参考资料</h3><p><a href="https://www.cnblogs.com/dongxiaodong/p/14351398.html">【来源于网络】STM32定时器详细篇（基于HAL库）</a></p><p><a href="https://blog.csdn.net/as480133937/article/details/103439546">【来源于网络】PWM原理 PWM频率与占空比详解-z小旋</a></p><p><a href="https://blog.csdn.net/as480133937/article/details/99201209">【来源于网络】【STM32】HAL库 STM32CubeMX教程六----定时器中断-z小旋</a></p><p><a href="https://blog.csdn.net/as480133937/article/details/99231677">【来源于网络】【STM32】HAL库 STM32CubeMX教程七—PWM输出(呼吸灯) -z小旋</a></p><h1>4.STM32串口通信、LCD的使用及SPI、IIC</h1><p><a href="https://blog.csdn.net/as480133937/article/details/99073783">【STM32】HAL库 STM32CubeMX教程四—UART串口通信详解_hal_uart_transmit_Z小旋的博客-CSDN博客</a></p><h2 id="串口-USART-、SPI、IIC的介绍（文末附相关博客）">串口(USART)、SPI、IIC的介绍（文末附相关博客）</h2><h3 id="STM32G070RBT6———串口">STM32G070RBT6———串口</h3><p><strong>1.通信方式</strong></p><p>STM32G070RBT6拥有四个串口，每个串口都拥有多种不同的工作式，大致可以按照如下分类：</p><p>第一分类为<strong>并行通信和串行通信</strong>，而由于串行通信的优点以及对缺点的弥补，导致如今基本都采用<strong>串行通信</strong>；</p><p>对于串行通信，又按照是否有同步时钟和收发间的数据传输方向分成两大类；</p><pre><code> 其中，按照是否有同步时钟分成同步和异步：</code></pre><p>同步通信：带时钟同步信号，发送方和接收方在同一时钟的控制下，实现同步传输。</p><p>异步通信：不带时钟同步信号，使用各自的时钟控制。 但需要双方相互约定好数据传输速率。</p><pre><code> 传输速率的衡量方式——波特率—单位：bps（位/秒） 按照数据传输方向分成单工、半双工和全工：</code></pre><p>单工通信：数据只沿着一个方向传输，发送端和接受端固定，只需要一根数据线。</p><p>半双工通信：数据可以沿着两个方向传输，但不能同时进行，需要两根数据线。</p><p>全双工通信：数据可以沿着两个方向传输，可以同时进行，需要两根数据线。</p><p>大纲图：<a href="https://i.postimg.cc/TYmzmtBG/20210720113312701.png">https://i.postimg.cc/TYmzmtBG/20210720113312701.png</a></p><p><strong>2.UART协议</strong></p><ul><li><strong>USART-通用同步异步收发器(Universal Synchronous Asynchronous Receiver and Transmitter)是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换。</strong></li><li><strong>UART-通用异步收发器(Universal Asynchronous Receiver and Transmitter)，它是在 USART 基础上裁剪掉了同步通信功能（时钟同步），只有异步通信。简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是 UART。</strong></li></ul><p><strong>UART-全双工</strong></p><p><a href="https://blog.csdn.net/k666499436/article/details/124354165">STM32串口通信详解_rivencode的博客-CSDN博客</a></p><h3 id="STM32G070RBT6———SPI通讯协议">STM32G070RBT6———SPI通讯协议</h3><p><strong>SPI-全双工</strong></p><p><a href="https://great.blog.csdn.net/article/details/109460814"> SPI协议详解（图文并茂+超详细）_小麦大叔的博客-CSDN博客</a></p><h3 id="STM32G070RBT6———IIC（I2C）">STM32G070RBT6———IIC（I2C）</h3><p><strong>IIC-半双工</strong></p><p><a href="https://blog.csdn.net/weixin_44933419/article/details/114991088?ops_request_misc=%7B%22request%5Fid%22%3A%22168112795916800226579942%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168112795916800226579942&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-114991088-null-null.142%5Ev82%5Einsert_down1,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=IIC&amp;spm=1018.2226.3001.4187"> 常用通信协议——IIC详解（全网最全）_iic通信协议_阿波罗啦啦啦啦的博客-CSDN博客</a></p><p><strong>printf的重定向问题:</strong></p><p><a href="https://zhuanlan.zhihu.com/p/145801160">配置CLion用于STM32开发【优雅の嵌入式开发】 - 知乎 (zhihu.com)</a></p><h2 id="LCD显示">LCD显示</h2><p><strong>见第四次培训</strong></p><h1>5.STM32ADC 外设</h1><p><a href="https://blog.csdn.net/as480133937/article/details/99627062">【STM32】HAL库 STM32CubeMX教程九—ADC_stm32cubemx adc_Z小旋的博客-CSDN博客</a></p><h2 id="ADC-介绍">ADC 介绍</h2><p><strong>什么是 ADC？</strong></p><p>Analog-to-Digital Converter 的缩写。指模/数转换器或者模拟/数字转换器。是指将连续</p><p>变量的模拟信号转换为离散的数字信号的器件。典型的模拟数字转换器将模拟信号转换为</p><p>表示一定比例电压值的数字信号。简单地说就是将模拟电压值，转换成对应的肉眼可读数</p><p>值 12 位 ADC 是一种逐次逼近型模拟数字转换器。A/D 转换可以单次、连续、扫描或间断</p><p>模式执行。ADC 的结果可以左对齐或右对齐方式存储在 16 位数据寄存器中</p><p>“输入的模拟量”是输入电压信号，“START”用来控制 ADC 启动转换，“CLOCK”是 ADC 模块的输入时钟，“EOC”是 ADC 转换结束信号，</p><p>“OE”是 ADC 转换结果输出允许信号，“VREF”是参考电压。</p><h3 id="ADC-的转换模式-重要，请务必看懂">ADC 的转换模式 (重要，请务必看懂)</h3><p><strong>单次转换模式</strong>：ADC 只执行一次转换；</p><p><strong>连续转换模式</strong>：转换结束之后马上开始新的转换；</p><p><strong>扫描模式</strong>：ADC 扫描被规则通道和注入通道选中的所有通道，在每个组的每个通道上执行单次转换。</p><p>在每个转换结束时，这一组的下一个通道被自动转换。如果设置了 CONT 位</p><p>（开启了连续 转换模式），转换不会在选择组的最后一个通道上停止，而是再次从选择组</p><p>的第一个通道继续转换。</p><p><strong>间断模式</strong>：触发一次，转换一个通道，再触发，再转换。在所选转换通道循环，由触发信号启动新一轮的转换，直到转换完成为止。（扫描模式简单的说是一次对所有所选中的通道进行转换，</p><p>比如开了 ch0，ch1，ch4，ch5。 ch0 转换完以后就会自动转换通道 1,4,5</p><p>直到转换完这个过程不能被打断。如果开启了连续转换模式，则会在转换完 ch5 之后开始</p><p>新一轮的转换。这就引入了间断模式，可以说是对扫描模式的一种补充。它可以把 0,1,4,5</p><p>这四个通道进行分组。可以分成 0,1 一组，4,5 一组。也可以每个通道单独配置为一组。</p><p>这样每一组转换之前都需要先触发一次。）</p><p><strong>ADC 单通道：</strong></p><p>只进行一次 ADC 转换：<strong>配置为“单次转换模式”，扫描模式关闭</strong>。ADC 通道转换一次后，</p><p>就停止转换。等待再次使能后才会重新转换</p><p>进行连续 ADC 转换：<strong>配置为“连续转换模式”，扫描模式关闭</strong>。ADC 通道转换一次后，</p><p>接着进行下一次转换，不断连续。</p><p><strong>ADC 多通道：</strong></p><p>只进行一次 ADC 转换：<strong>配置为“单次转换模式”，扫描模式使能</strong>。ADC 的多个通道，按照配置的顺序依次转换一次后，就停止转换。等待再次使能后才会重新转换</p><p>进行连续 ADC 转换：<strong>配置为“连续转换模式”，扫描模式使能</strong>。ADC 的多个通道，按照</p><p>配置的顺序依次转换一次后，接着进行下一次转换，不断连续。</p><p>也就是：<strong>多通道必须使能扫描模式</strong></p><p><strong>左对齐或右对齐</strong></p><p>因为 ADC 得到的数据是 12 位精度的，但是数据存储在 16 位，所以 ADC 的存储结果可</p><p>以分为左对齐或右对齐两种方式</p><p><strong>注入通道，规则通道：</strong></p><p><strong>注入通道：</strong></p><p>程序正常运行的通道</p><p><strong>规则通道：</strong></p><p>注入通道可以打断规则通道，如果在规则通道转换过程中，有注入通道进行转换，那么就</p><p>要先转换完注入通道，等注入通道转换完成后，再回到规则通道的转换流程（类似于中断）</p><h3 id="ADC-时钟">ADC 时钟</h3><p>ADC 模块的时钟来源是 ADC 预分频器的 ADCCLK</p><p>RCC 控制器为 ADC 时钟提供一个专用的可编程预分频器。 分频因子由 RCC_CFGR 的</p><p>ADCPRE[1:0]配置，可配置 2/4/6/8 分频</p><p><strong>STM32 的 ADC 最大的转换速率为 1MHz,也就是说最快转换时间为 1us，为了保证 ADC转换结果的准确性，ADC 的时钟最好不超过 14M</strong></p><h3 id="ADC-工作流程">ADC 工作流程</h3><p>ADC 一般用于采集小电压，其输入值不能超过 VDDA，即 ADC 输入范围：VREF- ≤ VIN ≤ VREF+. <strong>一般把VSSA 和VREF-接地，VREF+ 和VDDA 接 3V3，那么ADC的输入范围是0~3.3V！超过会烧坏单片机！！</strong></p><h3 id="ADC-函数">ADC 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADC_Start(&amp;hadcx); <span class="comment">//轮询模式开启 ADC</span></span><br><span class="line">HAL_ADC_Start_IT(&amp;hadcx); <span class="comment">//中断轮询模式开启 ADC</span></span><br><span class="line">HAL_ADC_Start_DMA(&amp;hadcx)； <span class="comment">//DMA 模式开启 ADC</span></span><br><span class="line">HAL_ADC_Stop() <span class="comment">//轮询模式关闭 ADC</span></span><br><span class="line">HAL_ADC_Stop_IT() <span class="comment">//中断轮询模式关闭 ADC</span></span><br><span class="line">HAL_ADC_Stop_DMA() <span class="comment">//DMA 模式关闭 ADC</span></span><br><span class="line">HAL_ADCEx_Calibration_Start(&amp;hadcx); <span class="comment">//ADC 校准函数</span></span><br><span class="line">HAL_ADC_GetValue() <span class="comment">//读取 ADC 转换值</span></span><br><span class="line">HAL_ADC_PollForConversion(&amp;hadc1, <span class="number">50</span>); <span class="comment">//等待转换结束函数，50 为等待时间（ms）</span></span><br><span class="line">HAL_ADC_ConvCpltCallback() <span class="comment">//ADC 中断回调函数，转换完成后回调，DMA 模式下</span></span><br><span class="line">DMA 传输完成后调用</span><br><span class="line">HAL_ADC_ConfigChannel() <span class="comment">//配置规则组通道</span></span><br><span class="line">•HAL_ADC_AnalogWDGConfig(） <span class="comment">//看门狗配置</span></span><br></pre></td></tr></table></figure><h2 id="DMA-的基本介绍">DMA 的基本介绍</h2><p><strong>什么是 DMA (DMA 的基本定义)</strong></p><p><strong>DMA，全称 Direct Memory Access，即直接存储器访问。</strong></p><p><strong>DMA 传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者</strong></p><p><strong>存储器和存储器之间的高速数据传输。</strong></p><p>我们知道 CPU 有转移数据、计算、控制程序转移等很多功能，系统运作的核心就是 CPU，CPU 无时不刻的在处理着大量的事务，但有些事情却没有那么重要，比方说数据的复制和存储数据，如果我们把这部分的 CPU 资源拿出来，让 CPU 去处理其他的复杂计算事务，是不是能够更好的利用 CPU 的资源呢？</p><p>**因此：转移数据（尤其是转移大量数据）是可以不需要 CPU 参与。**比如希望外设 A 的数据拷贝到外设 B，只要给两种外设提供一条数据通路，直接让数据由 A 拷贝到 B 不经过CPU 的处理。</p><p>数据传输之间有一个<strong>独立的DMA通道</strong>。</p><p><strong>ADC</strong> <strong>使用</strong> <strong>DMA</strong> <strong>相关函数：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADC_Start_DMA(ADC_HandleTypeDef *hadc, <span class="type">uint32_t</span>* pData, <span class="type">uint32_t</span> Length);</span><br></pre></td></tr></table></figure><h2 id="实验">实验</h2><p>1.使用 ADC 查询模式，采集电阻分压值，显示在 LCD 上，同时控制 RGB 灯</p><p>2.查看开发板硬件原理图找到 ADC 采集</p><p>3.开启 ADC 外设，使能 IN0 端口</p><p>4.设置端口</p><p>5.设置 GPIO 输出</p><p>6.设置 SPI，及 LCD 端口*</p><p>7.设置时钟</p><p>8.设置储存位置及编译器</p><p>9.设置添加头文件，并生成代码</p><p>10.代码编写及注释</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用指令</title>
      <link href="/posts/519ff8b5.html"/>
      <url>/posts/519ff8b5.html</url>
      
        <content type="html"><![CDATA[<h1>1.Linux 目录结构</h1><p>Linux只有一个根目录叫:  <strong>/</strong>  的文件夹，全部内容都在该文件夹下，开头总是  <strong>/</strong> 。</p><ul><li>在Linux系统中，路径之间的层级关系，使用：/来表示</li><li>在Windows系统中，路径之间的层级关系，使用：\来表示</li></ul><p><strong>Linux例</strong>：/user/local/hello.txt(根目录/)</p><p><strong>windows例</strong>：D\data\work\hello.txt(D盘)</p><p><strong>注意:</strong></p><ul><li>开头的 / 表示 根目录</li><li>后面的 / 表示 层级关系</li></ul><h1>2.路径</h1><h2 id="相对路径和绝对路径">相对路径和绝对路径</h2><ul><li>cd  /home/itheima/Desktop   <strong>绝对路径写法</strong></li><li>cd  Desktop                               <strong>相对路径写法</strong></li></ul><p><strong>绝对路径</strong>：以根目录（/）为起点，描述路径的一种写法，路径描述以 / 开头</p><p><strong>相对路径</strong>：以当前目录为起点，描述路径的一种写法，路径描述无需以 /  开头</p><p><strong>相对路径写法：</strong>./ 表示当前目录下，…/表示上一级目录</p><h2 id="特殊路径符">特殊路径符</h2><ul><li><strong>.</strong>    表示当前目录，比如: cd ./Desktop 表示切换成到当前目录下的Desktop目录内，和cd Desktop效果一致</li><li><strong>…</strong>     表示上一级目录，比如:  cd  <strong>…</strong>  即可切换到上一级目录, cd …/… 切换到上二级目录</li><li>~     表示HOME目录，比如:  cd ~   即可切换到HOME目录或cd ~/Desktop，切换到HOME内的Desktop目录</li></ul><h1>3.Linux命令</h1><p><strong>通用格式：</strong></p><p><strong>command  [-options]  [parameter]</strong></p><ul><li><p>command: 命令本身</p></li><li><p>-options:[可选，非必填]，命令的一些选项，控制命令行为细节</p></li><li><p>parameter：[可选，非必填]，命令的参数，多数用于命令的指向目标</p><p>三部分 : 本体，选项，参数</p><p><strong>实例：</strong></p><p>ls -l /home/itheima , ls命令本身，-l选项，/home/itheima是参数</p></li></ul><h2 id="ls命令">ls命令</h2><p><strong>语法： ls     [-a -l -h]     [Linux路径]</strong></p><ul><li>-a ，-l，-h 是<strong>可选</strong>选项</li><li>Linux路径是命令<strong>可选</strong>参数</li></ul><p>当不使用选项和参数，直接使用ls命令本体，表示：以平铺的形式，列出当前工作目录下的内容</p><ul><li><p>-a选项，表示all，列出全部隐藏文件/文件夹</p></li><li><p>-l选项，表示：列表（竖向排列）的形式展示内容，并展示更多信息</p></li><li><p>-i选项，表示：要查看文件或目录的incode编号</p></li><li><p>-al，-la，-l -a，三种都表示同时运用-a，-l功能</p></li><li><p>-h 表示以易于阅读的形式，列出文件大小，如K、M、G，<strong>同时-h必须搭配-l一起使用</strong>。例:  ls -lh</p></li><li><p>ls -lah = ls -a -l -h，都是三个选项一起使用</p></li></ul><h2 id="cd命令（切换目录）">cd命令（切换目录）</h2><ul><li>cd : Change Directory (更改目录)</li><li>cd命令可以切换当前工作目录(进入某个文件夹)</li></ul><p><strong>语法： cd  [Linux路径]</strong></p><ul><li>cd命令无需选项，只有参数，表示要切换到哪个目录下（再ls 列出目录下内容）</li><li>cd命令直接执行，不写参数，表示从当前目录回到用户的HOME目录</li></ul><h2 id="pwd命令">pwd命令</h2><p>pwd ： Print Work Directory</p><p><strong>pwd ：查看当前工作目录，直接打印当前工作目录</strong></p><p>语法： pwd</p><ul><li>pwd 命令，无选项，无参数，直接输入pwd即可</li></ul><h2 id="mkdir命令创建目录-文件夹">mkdir命令创建目录(文件夹)</h2><p>mkdir : Make Directory  ——创建 文件夹</p><p><strong>语法：mkdir  [-p]  Linux路径</strong></p><ul><li>参数必填，表示Linux路径，即要创建的文件夹路径，相对路径或绝对路径均可以</li><li>-p选项可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录</li></ul><p>例子：</p><p>mkdir test  在当前目录中创建一个test文件夹</p><p>mkdir /home/keqiudi/test 在keqiudi里面创建一个test文件夹</p><p>mkdir home/good/666 创建失败，因为<strong>上级目录home和good并不存在</strong>，所以无法创建666目录</p><p>mkdir -p home/good/666 创建成功，通过-p将一整个链条都创建完成</p><p>**注意：**创建文件夹需要修改权限，请确保操作均在HOME目录内，不要再HOME外操作涉及权限问题，HOME外无法成功</p><h2 id="文件操作命令par1">文件操作命令par1</h2><h3 id="touch命令">touch命令</h3><p><strong>作用：创建文件夹</strong></p><p><strong>语法：touch  Linux路径</strong></p><ul><li>touch命令无选项，参数必填，表示要创建的文件路径， 相对、绝对、特殊路径符均可使用</li></ul><h3 id="cat命令">cat命令</h3><p><strong>作用：1.查看文件内容 2.合并文件</strong></p><p><strong>语法： cat Linux路径</strong></p><ul><li>cat同样没有选项，只有必填参数，参数表示：被查看的文件路径，相对、绝对、特殊路径符都可以使用</li></ul><p><strong>语法：cat 文件名 文件名</strong></p><ul><li>将两个文件进行合并</li></ul><h3 id="more命令">more命令</h3><p><strong>作用：查看文件内容</strong></p><p><strong>语法： more Linux路径</strong></p><ul><li><p>cat是将内容全部显示出来</p></li><li><p>more支持翻页，如果文件内容过多，可以一页一页的展示</p><p>同样没有选项，只有必填参数，参数表示：被查看的文件路径，相对、绝对、特殊路径符都可以使用</p></li><li><p>再查看的过程中，通过空格翻页</p></li><li><p>通过q退出查看</p></li></ul><h3 id="less命令">less命令</h3><p><strong>作用：与more类似，功能上强于more</strong></p><p><strong>用法：less Linux路径</strong></p><ul><li>退出按q键</li></ul><h3 id="head命令">head命令</h3><p><strong>作用：在屏幕上显示指定文件的开头若干行</strong></p><p><strong>语法：head [选项] filename</strong></p><p><strong>选项：</strong></p><ul><li>-n，n代表显示的行数</li><li>-q，不显示给定文件的标题</li><li>-v，始终显示给定文件的标题</li></ul><h2 id="文件操作命令part2">文件操作命令part2</h2><h3 id="cp命令">cp命令</h3><p>作用:用于复制文件\文件夹，cp命令来自：copy</p><p><strong>语法：cp [-r]  参数1 参数2</strong></p><ul><li>-r选项，可选，用于复制文件夹使用，表示递归</li><li>参数1，Linux路径，表示被复制的文件或文件夹,如果</li><li>参数2，Linux路径，表示要复制去的地方,没有文件将会创建一个新的文件夹</li></ul><p>复制文件夹必须要加 -r</p><h3 id="mv命令">mv命令</h3><p>**作用：**对文件或目录重新命名,或者移动文件\文件夹，mv来自英文: <strong>move</strong></p><p><strong>语法： mv  [选项] 参数1 参数2</strong></p><ul><li>选项：-i  同名时询问是否覆盖，输入y表示同意</li><li>参数1：Linux路径，表示被移动的文件</li><li>参数2：Linux路径，表示要移动的地方，当目标不存在时，将会有改名的效果</li></ul><p><strong>注意：</strong></p><ul><li>若目标文件是到某一<strong>目录</strong>文件的路径，则源文件会被移到此目录下，且文件名不变</li><li>若目标文件不是<strong>目录</strong>文件时，则源文件名（只能有一个）会变成此目标文件名，并且覆盖已存在的同名文件，原文件消失</li><li>当目标文件是<strong>目录</strong>文件时，源文件或目录参数可以有多个，则所有的源文件都会被移动到目标文件中。所有移到该目录下的文件都将保留以前的文件名</li></ul><h3 id="rm命令">rm命令</h3><p><strong>作用：用于删除文件、文件夹，rm来自英文：remove</strong></p><p><strong>语法：rm [-r -f] 参数1 参数2 参数3  …  参数N</strong></p><ul><li><p>同cp命令一样，<strong>-r</strong>选项用于删除文件夹（删除文件夹必须加）</p></li><li><p><strong>-f</strong>表示force，强制删除(不会弹出提示确认信息)</p><ul><li>普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示</li><li>所以一般普通用户用不到-f选项</li></ul></li><li><p>参数1、参数2、…、参数N 表示要删除的文件或文件夹路径，按照空格隔开</p></li></ul><p><em><em>rm命令支持通配符</em>，用来做模糊匹配</em>*</p><ul><li><p>符号*表示通配符，即匹配任意内容(包含空)，示例:</p></li><li><p>test*，表示匹配任何以test开头的内容</p></li><li><p>*test，表示匹配任何以test结尾的内容</p></li><li><p>*test*，表示任何包含test的内容</p><p>删除所有以test开头的文件夹或文件</p><p><strong>例：rm -r test</strong>*</p></li></ul><p><strong>在root时删除内容会有提示，但-f选项强制删除可以不会弹出提示</strong></p><ul><li>可以输入 su - root，并输入密码123456(和普通用户默认一样)临时切换到root用户体验</li><li>通过输入exit命令，退回普通用户。(临时用root，用完记得退出，不要一直用)</li></ul><p><strong>注意：</strong></p><ul><li>rm是一个危险的命令，特别是在root(超级管理员)用户的时候。请谨慎使用。</li><li>千万不要再root管理员用户下执行:<ul><li>rm -rf /</li><li>rm -rf /*</li><li>效果相当于在windows上执行C盘格式化</li></ul></li></ul><h2 id="查找和排序命令">查找和排序命令</h2><h3 id="which命令-命令查找">which命令(命令查找)</h3><p>Linux命令，本体是一个个二进制可执行程序，和windows中的.exe文件是一个意思</p><p><strong>我们可以通过which命令，查看所使用的一系列命令的b本体程序文件存放在哪里</strong></p><p><strong>语法 :  which 要查找的命令</strong></p><p><strong>例</strong>：which cd    which pwd      which  touch…</p><h3 id="find命令-文件查找">find命令(文件查找)</h3><p><strong>作用：find命令可以去搜索指定的文件</strong></p><p><strong>基本语法：find   起始路径  -name   被查找文件名</strong></p><p>按文件大小查找文件</p><p><strong>语法：find  起始路径  -size +/- n[kMG]</strong></p><ul><li>+、-表示大于和小于</li><li>n表示大小数字</li><li>kMG表示大小单位, k(小写)表示kb，M表示MB，G表示GB</li></ul><p><strong>例：</strong></p><ul><li>查找小于10KB文件：<strong>find / -size -10k</strong></li><li>查找大于100MB的文件：<strong>find / -size +100M</strong></li></ul><h2 id="grep命令">grep命令</h2><p>grep命令</p><p>**作用：**从文件中通过关键字过滤文件行，会显示出所有包含关键字的一行并且标红</p><p><strong>语法：grep [-n] 关键字 文件路径</strong></p><ul><li>选项-n，可选，表示在结果中显示匹配的行的行号</li><li>关键字，参数，<strong>必填</strong>，表示过滤的关键字，带有空格或其他特殊符号，建议用” ” 将关键字包围</li><li>文件路径，参数，<strong>必填</strong>，表示要过滤内容的文件路径，<strong>可作为内容输入端口</strong></li></ul><h2 id="wc命令">wc命令</h2><p>**作用：**wc命令可以统计文件的行数、单词数量等</p><p><strong>语法： wc [-c  -m  -l  -w]  文件路径</strong></p><ul><li>选项，-c，统计bytes数量</li><li>选项，-m，统计字符数量</li><li>选项，-l，统计行数</li><li>选项，-w，统计单词数量</li><li>参数，文件路径，背统计的文件，<strong>可作为内容输入</strong></li></ul><h2 id="管道符：">管道符：|</h2><p>**作用：**将管道符左边命令的结果，作为右边命令的输入</p><p>**例子：**cat test.txt | grep keqiudi</p><p>相当于左边的结果直接是右边的输入路径</p><p>即将会在test.txt中找出含有keqiudi的内容</p><p>通常 搭配使用和嵌套使用</p><p>cat test.txt | grep keqiudi | grep kqd</p><p>这将会在test.txt中找出含有keqiudi的内容，再继续在这之中找出含有kqd的内容</p><h2 id="echo命令">echo命令</h2><p><strong>作用：可以用echo命令在命令行内输出指定内容</strong></p><p><strong>语法：echo 输入的内容</strong></p><ul><li>无需选项，只需要一个参数，表示要输出的内容</li></ul><p>**例：**在终端上显示：Hello Linux</p><p>echo Hello Linux</p><p>注意：带有空格或\等特殊符号，建议用双引号包围，不包围空格后面很容易被识别为参数2。</p><h2 id="反引号">反引号`</h2><p><strong>被反引号`包围的内容，会被作为命令执行，而非普通字符</strong></p><p>echo pwd  结果为pwd</p><p>echo （反引号）pwd（反引号） 结果为当前工作目录</p><h2 id="重定向符">重定向符</h2><p><strong>重定向符号：&gt;和&gt;&gt;</strong></p><ul><li>第一个符号&gt;，表示将左侧命令的结果，<strong>覆盖</strong>写入到符号右侧指定文件中</li><li>第二个符号&gt;&gt;，表示将左侧命令的结果，<strong>追加</strong>写入到符号右侧指定文件中</li></ul><p><strong>例子：</strong></p><p>echo “Hello Linux” &gt; test.txt</p><p>将会把Hello Linux写入到test.txt中</p><p>echo “keqiudi” &gt;&gt; test.txt</p><p>将会把keqiudi追加到test.txt文件中</p><h2 id="tail命令">tail命令</h2><p>**作用：**tail可以查看文件尾部的内容，跟踪文件的最新更改</p><p>**语法：**tail [-f -num] Linux路径</p><ul><li>参数，Linux路径，表示被跟踪的文件路径</li><li>选项，-f，表示持续跟踪</li><li>选项，-num，表示，查看尾部多少行，不填默认10行</li></ul><p>用**-f**时，再开一个命令行，对该文件内部内容进行的增添或删减内容可以在之前的命令行中持续追踪（观察到）不会立即停止，Ctrl c 停止</p><h2 id="vi-vim编辑器">vi/vim编辑器</h2><p><strong>三种工作模式：</strong></p><ul><li><strong>命令模式： (Command code)</strong></li></ul><p>​             命令模式下，所敲的按键编辑器都理解为命令，以命令驱动执行不同的功能。此模型下，不能自由进行文本编辑。</p><ul><li><strong>输入模式：（insert mode）</strong></li></ul><p>​            也就是所谓的编辑模式，插入模式。此模式下，可以对文件内容进行自由编辑。</p><ul><li><strong>底线命令模式(Last line mode)</strong></li></ul><p>​          以：开始，通常用于文件的保存、退出</p><p><strong>注：打开默认为命令模式</strong></p><p><strong>输入模式和底线命令模式不连通</strong></p><p><strong>语法：  vi   文件路径</strong></p><p>​             <strong>vim 文件路径(vim兼容全部的vi功能，推荐使用vim)</strong></p><pre><code> - 如果文件路径表示的文件不存在，那么此命令会先创建再编辑新文件 - 如果文件路径表示的文件存在，那么此命令用于编辑已有文件</code></pre><h3 id="命令模式快捷键">命令模式快捷键</h3><p><strong>在命令模式下输入:</strong></p><ul><li><p><strong>i <strong>——当前光标位置进入</strong>输入模式</strong></p></li><li><p><strong>a</strong>——在当前光标位置之后进入<strong>输入模式</strong></p></li><li><p><strong>I</strong> ——在当前行的开头，进入<strong>输入模式</strong></p></li><li><p><strong>A</strong>——在当前行的结尾，进入<strong>输入模式</strong></p></li><li><p><strong>o</strong>——在当前光标下一行进入<strong>输入模式</strong></p></li><li><p><strong>O</strong>——在当前光标的上一行进入<strong>输入模式</strong></p></li><li><p><strong>esc</strong>——任何情况下输入<strong>esc都能回到命令模式</strong></p></li><li><p><strong>dd</strong>——删除当前光标所在行内容</p></li><li><p><strong>yy</strong>——复制当前行</p></li><li><p><strong>p</strong>——粘贴复制的内容</p></li><li><p><strong>u</strong>——撤销修改</p></li><li><p><strong>dG</strong>——从当前行开始，向下全部删除</p></li><li><p><strong>dgg</strong>——从当前行开始，向上全部删除</p></li><li><p><strong>wq</strong>——w为保存文件，q为退出文件，<strong>wq同时为保存并退出</strong></p></li><li><p>/ ——进入搜索模式</p><p><strong>其余快捷键自行在网上查询</strong></p></li></ul><h3 id="底线命令模式">底线命令模式</h3><p>在命令模式中按  **：**进入底线命令模式</p><ul><li><strong>wq</strong> ——保存退出(<strong>常用</strong>)</li><li><strong>q</strong>    ——仅退出</li><li><strong>q！</strong>——强制退出</li><li><strong>w</strong>   ——仅保存</li><li><strong>w！</strong>——强制保存</li><li><strong>set nu</strong> ——显示行号</li><li><strong>set paste</strong> —— 设置粘贴模式</li></ul><h1>4.root用户（超级管理员）</h1><p>root用户拥有最大的系统操作权限，而普通用户在许多地方的权限是受限的。</p><ul><li>普通用户的权限，一般在HOME目录内是不受限的</li><li>一旦出了HOME目录，大多数地方，普通用户仅有只读和执行的权限，无修改的权限</li></ul><h2 id="su-和-exit-命令">su 和 exit 命令</h2><p>su命令就是用于账户切换的系统命令，英文单词为：<strong>Switch User</strong></p><p><strong>语法： su  -   用户名    通常切换到root 用户 （su - root）</strong></p><ul><li><p>-符号是可选的，表示是否在切换用户后加载环境变量，一般带上</p></li><li><p>参数：用户名，表示要切换的用户，用户名也可以省略，省略表示却换到root</p></li><li><p>使用普通用户，切换到其他用户需要输入密码，如切换到root用户（密码默认为：123456）</p></li><li><p>使用root用户切换到其他用户，<strong>无需密码</strong>，可以直接切换</p></li></ul><p>**exit命令：**切换用户后，在root用户下输入exit，退出root权限，也可以使用快捷键：ctrl + d</p><h2 id="sudo命令">sudo命令</h2><p>可以让一条普通命令带有root权限，<strong>语法：sudo 其他命令</strong></p><ul><li>需要以root用户执行visudo命令，增加配置方可让普通用户有sudo命令的执行权限</li></ul><p>在打开的文件最后添加: <strong>用户名  ALL=(ALL)          NOPASSWD: ALL</strong></p><p>再通过wq保存</p><p>切换回普通用户后，执行的命令，均以root运行</p><p><strong>sudo passwd 用户名—为当前用户设置密码</strong></p><h1>5.用户和用户组</h1><h2 id="用户组管理">用户组管理</h2><p>以下命令需root用户执行</p><ul><li>创建用户组</li></ul><p><strong>groupadd 用户组名</strong></p><ul><li>删除用户组</li></ul><p><strong>groupdel 用户组名</strong></p><ul><li>创建用户</li></ul><p><strong>useradd [-g -d] 用户名</strong></p><p>选项：-g指定用户的组，不指定-g，会创建同名组并自动加入，指定-g需要组已经存在，如已存在同名组，必须使用-g</p><p>选型：-d指定用户HOME路径，不指定，HOME目录默认在：/home/用户名</p><p><strong>userdel [-r] 用户名</strong></p><p>选项：-r ，删除用户的HOME目录，不使用-r，删除用户时，HOME目录保留</p><ul><li>查看用户所属组</li></ul><p>id [用户名]</p><p>参数：用户名，被查看的用户，如果不提供则查看自身</p><ul><li>修改用户所属组</li><li>usermod -aG 用户组 用户名，将指定用户加入指定用户组</li></ul><h3 id="getent"><strong>getent</strong></h3><p><strong>使用getent命令，可以查看当前系统中有哪些用户</strong></p><p><strong>语法:  getent passwd</strong></p><p>得到的信息共七个</p><p>用户名：密码(x):用户ID：组ID：描述信息(无用)：HOME目录：执行终端（默认bash）</p><p><strong>查看系统中有哪些用户组</strong></p><p><strong>语法：getent group</strong></p><h1>6.权限控制信息</h1><h2 id="查看权限控制信息">查看权限控制信息</h2><p>通过ls -l 可以列表形式查看内容，并显示权限细节</p><p><strong>例：</strong></p><p>drwxr-x—  7 keqiudi keqiudi 4096 Mar  7 16:25 keqiudi</p><p>-rw-rw-r-- 1   keqiudi keqiudi   46   Mar  7 16:25 test.txt</p><ul><li><p><strong>第一列代表</strong>：文件，文件夹的权限控制信息</p></li><li><p><strong>第三列代表</strong>：文件，文件夹所属用户</p></li><li><p><strong>第四列代表</strong>：文件，文件夹所属用户组</p></li></ul><p><strong>第一列权限控制信息：</strong></p><p>权限细节总共分为<strong>10</strong>个槽位：</p><p><strong>第一个位置：-或d或l</strong></p><ul><li>**-**表示一个文件</li><li><strong>d</strong> 表示一个文件夹(directory)</li><li><strong>I</strong>表示软链接(快捷方式)</li></ul><p><strong>第2-4个位置：表示所属用户权限（u（user简称））</strong></p><p>**2：**r或-  权限</p><p>**3：**w或- 权限</p><p>**4：**x或- 权限</p><p><strong>第5-7个位置：表示所属用户组权限（g（group简称））</strong></p><p>**5：**r或-  权限</p><p>**6：**w或- 权限</p><p>**7：**x或- 权限</p><p><strong>第8-10个位置：表示其他用户权限（o（other简称））</strong></p><p>**8：**r或-  权限</p><p>**9：**w或- 权限</p><p>**10：**x或- 权限</p><p>例：drwxr-xr-x，表示：</p><ul><li>这是一个文件夹，d</li><li>所属用户的权限是有r有w有x，rwx</li><li>所属用户组权限有r无w有x，r-x(-表示无此权限)</li><li>其他用户权限时：有r无w有x，r-x</li></ul><p><strong>rwx含义：</strong></p><ul><li><strong>r表示读权限</strong>：针对文件夹，可以查看文件夹的内容，如ls命令</li><li><strong>w表示写权限</strong>：针对文件夹，可以再文件夹内：创建、删除、改名等操作</li><li><strong>x表示执行权限</strong>：针对文件夹，表示可以更改工作目录到此文件夹，即cd进入</li></ul><h2 id="修改权限控制信息">修改权限控制信息</h2><h3 id="chmod命令">chmod命令</h3><p><strong>（1）以符号模式改变权限</strong></p><p><strong>作用：修改文件，文件夹的权限信息。</strong></p><p><strong>注意，只有文件，文件夹的所属用户或root用户可以更改</strong></p><p><strong>语法：chmod [选项] [who] [操作符号] [权限符号] [文件名/文件夹]</strong></p><p><strong>选项：</strong>-R，可选，对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</p><p><strong>who:</strong> 可为u，g，o，a(所有用户)</p><p><strong>操作符号：</strong>+添加权限，-取消权限，=赋予指定权限并取消其他权限</p><p>**权限符号：**r读，w写，x执行</p><p>**u：**用户权限</p><p>**g：**用户组权限</p><p>**o：**其他用户权限</p><p>**a：**所有用户权限</p><p><strong>示例：</strong></p><ul><li><p>写法1：chmod a+x hello.txt ，表示所有用户添加执行权限</p></li><li><p>写法2：chmod u=rwx，g=rx，o=x   hello.txt，表示将文件权限改为：rwxr-x-</p></li><li><p>chmod -R u=rwx，g=rx，o=x  test，表示将文件夹test以及文件夹内部权限设置为：rwxr-x–x</p></li></ul><p><strong>（2）以绝对方式改变权限</strong></p><p><strong>语法：chmod mode 文件名</strong></p><p>**mode：**Linux中mode，由1~4位八进制数字表示，第一位表示用户ID为4或组ID为2或粘着属性为1，第二位表示u权限，第三位表示g权限，第四位表示o权限(通常修改权限第一位不写)</p><p><strong>权限的数字序号</strong>：<strong>r记为4，w记为2，x记为1</strong></p><p>可以通过chmod 751/0751 hello.txt</p><p>所以751表示： rwx(7) r-x(5) --x(1)，即rwxr-x–x</p><p>7-5-1的三个位置权限二进制表示：111 101 001</p><h3 id="chown命令">chown命令</h3><p>**作用：**修改文件，文件夹所属用户和用户组</p><p>普通用户无法修改所属为其他用户或组，所以此命令只适用于root用户执行</p><p>**语法：**chown [-R] [用户] [:] [用户组] 文件或文件夹</p><ul><li>选项：-R，同chmod，对文件夹内全部内容应用相同规则</li><li>选项，用户，修改所属用户</li><li>选项，用户组，修改所属用户组</li><li>：用于分隔用户和用户组</li></ul><p><strong>示例：</strong></p><ul><li>chown root hello.txt 将hello.txt所属用户修改为root</li><li>chown :root hello.txt  将hello.txt所属用户组修改为root</li><li>chown root:keqiudi hello.txt 将hello.txt所属用户修改为root，用户组修改为keqiudi</li></ul><h1>7.链接文件命令</h1><h2 id="硬链接">硬链接</h2><ul><li><p>先来看看 ln 默认创建的硬链接，由于 Linux 下的文件是通过索引节点（Inode）来识别文件，在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号 (Inode Number)。</p></li><li><p>在 Linux 中，多个文件名指向同一索引节点是存在的，所以硬连接指通过索引节点来进行的连接，即每一个硬链接都是一个指向对应区域的文件。修改任意一个硬链接对应的文件内容，其余的都将会被修改。</p></li></ul><p>语法：ln [选项] [源文件] [目标文件]</p><p>不填选项，默认创建硬链接</p><p>注意：</p><ul><li>不能对目录文件创建硬链接</li><li>不能在不同的文件系统之间创建硬链接。也就是说，链接文件和被链接文件必须位于同一个文件系统中</li><li>只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个链接被删除后，文件的数据块及目录的连接才会被释放，也就是说，文件才会被真正删除</li></ul><h2 id="软链接">软链接</h2><ul><li>软链接又叫符号链接，这个文件包含了另一个文件的路径名，可以将文件，文件夹链接到其他位置</li><li>软连接可以是任意文件或目录，可以链接不同文件系统的文件，在对符号文件进行读或写操作的时候，系统会自动把该操作转换为对源文件的操作，但删除链接文件时，系统仅仅删除链接文件，而不删除源文件本身，这一点类似于 Windows 操作系统下的<strong>快捷方式。</strong></li></ul><p><strong>语法：ln -s  参数1 参数2</strong></p><ul><li>-s，创建软链接  symbolic符号链接</li><li>参数1：被链接的文件或文件夹</li><li>参数2：要链接去的目的地</li></ul><p>例:</p><ul><li><p>ln -s /etc/yum.conf  ~/yum.conf</p><p>在home目录创建一个yum.conf的软链接(快捷方式)</p></li></ul><h1>8.联机帮助命令</h1><h2 id="man命令">man命令</h2><p>man命令格式化并显示某一命令的联机帮助手册（manual的缩写表示手册）</p><p><strong>语法：man [选项] 命令名</strong></p><p>**选项：**略，可不填</p><h2 id="help帮助命令">help帮助命令</h2><p>help命令可以查看所有shell内置命令的帮助信息</p><p><strong>语法：help 命令名</strong></p><p>**说明：**用户可以利用help命令查看shell内置命令的用法，若help命令后面不带任何参数，则显示help命令的用法，列出shell的内置命令列表。</p><h1>9.进程管理命令</h1><h2 id="nice命令">nice命令</h2><p><strong>作用：nice命令用来修改进程的优先级</strong></p><p><strong>语法：nice [选项] [命令]</strong></p><p>**说明：**Linux中，命令通常以进程的形式运行，每个进程都有相对优先级，影响到系统对进程所需资源的分配，用户使用nice命令可以修改相应进程的调度优先级。nice 的取值范围为-20~19，<strong>数值越小优先级越高</strong>，只有root可以指定负数，普通用户指定的nice值必须是正数，在不需要命令马上运行时，可以用nice降低后台或批处理进程的优先级</p><p>选项：</p><ul><li>-n，–adjustment=N     将nice的值加上整数N（默认为10）</li><li>–help     显示help帮助信息，然后终止</li></ul><p>例子：</p><p>nice -n 1 ls    将ls的优先级加1并执行</p><p>nice ls 将ls的优先级加10并执行（默认）</p><h2 id="kill命令">kill命令</h2><p><strong>作用：终止一个程序的运行</strong></p><p><strong>语法：kill [-s ] [程序]　或　kill [-l ]</strong></p><p><strong>参数：</strong></p><ul><li>-l ，指&lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则 -l 参数会列出全部的信息名称（信号列表）。</li><li>-s ，指&lt;信息名称或编号&gt; 　指定要送出的信息。</li><li>[程序] ，[程序]可以是程序的PID或是PGID，也可以是工作编号。</li></ul><p><strong>使用 kill -l 命令列出所有可用信号。</strong></p><p><strong>最常用的信号是：</strong></p><ul><li>1 (HUP)：重新加载进程。   1为信息编号，HUP为信息名称-1 == -HUP</li><li>9 (KILL)：杀死一个进程。    9为信息编号，HUP为信息名称-9 == -KILL</li><li>15 (TERM)：正常停止一个进程。（默认情况下发送15）</li></ul><p><strong>例子：</strong></p><pre><code>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># kill 12345   <span class="comment">//杀死进程12345</span></span></span><br><span class="line"></span><br><span class="line">写法一:<span class="meta"># kill -KILL 123456  <span class="comment">//强制杀死进程12345</span></span></span><br><span class="line">写法二:<span class="meta"># kill -9 123456 <span class="comment">//强制杀死进程12345，与上方等价</span></span></span><br><span class="line">写法三:<span class="meta"># kill -s 9 123456  <span class="comment">//强制杀死12345</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># kill -HUP 123456 <span class="comment">//发送SIGHUP信号，可以使用一下信号</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><h2 id="sleep命令">sleep命令</h2><p><strong>作用：使进程暂停执行一段时间</strong></p><p><strong>语法：sleep 时间值（s）</strong></p><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep <span class="number">2</span>; cat test.txt <span class="comment">//使进程先暂停2秒，然后在显示出test.txt的内容</span></span><br></pre></td></tr></table></figure><h2 id="ps命令">ps命令</h2><p><strong>作用：列出当前的进程</strong></p><p><strong>语法：ps [参数]</strong></p><p><strong>参数：</strong></p><ul><li>-A, 列出所有进程</li></ul><h1>10.文件压缩和解压缩命令</h1><h2 id="gzip命令">gzip命令</h2><p><strong>作用：对文件进行压缩和解压，压缩文件拓展名为 .gz</strong></p><p><strong>语法：gzip [选项] [文件或目录]</strong></p><p><strong>选项：</strong></p><ul><li>-d :  将被压缩的文件解压</li><li>-v：显示出文件名和压缩比</li><li>-l：对于每个压缩文件，列出信息</li></ul><p><strong>注意：不能压缩文件夹-目录</strong></p><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#gzip test.txt <span class="comment">//将test.txt压缩为test.txt.gz</span></span></span><br><span class="line"><span class="meta">#gzip -dv test.txt <span class="comment">//将.gz解压</span></span></span><br><span class="line"><span class="meta">#gzip * <span class="comment">//将该目录下文件全部压缩</span></span></span><br><span class="line"><span class="meta">#gzip -d * <span class="comment">//将目录下文件全部解压</span></span></span><br></pre></td></tr></table></figure><h2 id="unzip命令">unzip命令</h2><p><strong>作用：unzip命令对ZIP格式的压缩文件进行解压.文件带有后缀.zip</strong></p><p><strong>语法：unzip [选项] 被压缩的文件名</strong></p><p>**说明：**被压缩的文件名是ZIP文件的路径名，其中只有文件名可以是通配符(*等)而整个路径不能是通配符，参数中可以给出多个文件名，彼此用空格分开</p><p><strong>选项:</strong></p><ul><li>-v ：显示压缩文件信息</li><li>-d 目录 ：将压缩文件加压后放到指定目录中</li><li>-x 文件列表：解压缩文件，对文件列表中所指定的文件并不解压缩</li></ul><p>注意：Linux下可能需要先安装unzip</p><p>sudo apt install unzip</p><h1>11.各类小技巧快捷键</h1><h2 id="ctrl-c-强制停止">ctrl +c 强制停止</h2><ul><li>Linux某些程序运行，ctrl + c 可以强制停止它</li><li>命令输入错误，也可通过 ctrl + c ，退出当前命令的输入</li></ul><h2 id="ctrl-d退出或登出">ctrl +d退出或登出</h2><ul><li>ctrl +d 退出账户的登录</li><li>退出某些特定程序的专属页面（python等） **ps：**不能用于退出vi/vim</li></ul><h2 id="history命令">history命令</h2><ul><li><p>可以通过history命令，查看历史输入过的命令</p></li><li><p>可以通过：！+ 命令前缀，自动执行上一次匹配前缀</p><p><strong>ctrl + r ，输入内容去匹配历史命令</strong></p></li><li><p>回车键可以直接执行</p></li><li><p>键盘左右键，可以得到此命令(不执行)</p></li></ul><h2 id="光标移动快捷键">光标移动快捷键</h2><ul><li><strong>ctrl + a</strong>，跳到命令开头</li><li><strong>ctrl + e</strong> ，跳到命令结尾</li><li><strong>ctrl + 键盘左键</strong>，向左跳一个单词</li><li><strong>ctrl + 键盘右键</strong>，向右跳一个单词</li></ul><h2 id="清屏">清屏</h2><ul><li>通过快捷键<strong>ctrl +l</strong> ，可以清空终端内容</li><li>或者通过命令clear得到同样的效果</li></ul><h1>12.包管理</h1><p><strong>Linux命令行内的应用商店安装软件，CentOS和Ubuntu用的不同包管理器。</strong></p><p>CentOS使用<strong>yum</strong>管理器，Ubuntu使用<strong>apt</strong>管理器</p><p><strong>故以下分两种讨论：</strong></p><h2 id="CentOS">CentOS</h2><h3 id="yum命令">yum命令</h3><p>**yum：**RPM包软件管理器，用于自动化安装配置Linux软件，并可以自动解决依赖问题</p><p><strong>语法：yum   [-y]    install/remove/search    软件名称</strong></p><ul><li><strong>选项：</strong>-y，自动确认，无需手动确认安装过程或卸载过程</li><li>**install：**安装</li><li>**remove：**卸载</li><li>**search：**搜索</li></ul><p><strong>注意：yum命令需要root权限，且需要联网</strong></p><p>例子：</p><ul><li><strong>yum [-y] install wget，通过yum命令安装wget程序</strong></li><li><strong>yum [-y] remove wget，卸载wget</strong></li><li><strong>yum  search wget ，搜索是否有wget安装包</strong></li></ul><h2 id="Ubuntu">Ubuntu</h2><h3 id="apt命令">apt命令</h3><p><strong>用法与yum一致，同样需要root权限</strong></p><p><strong>语法：apt   [-y]    install/remove/search    软件名称</strong></p><ul><li><strong>apt [-y] install wget，安装wget程序</strong></li><li><strong>apt [-y] remove wget，卸载wget</strong></li><li><strong>apt  search wget ，搜索是否有wget安装包</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket</title>
      <link href="/posts/174bd570.html"/>
      <url>/posts/174bd570.html</url>
      
        <content type="html"><![CDATA[<h1>1.socket套接字:</h1><h2 id="概念：">概念：</h2><ul><li><strong>局域网和广域网</strong><ul><li><strong>局域网</strong>：局域网将一定区域内的各种计算机、外部设备和数据库连接起来形成计算机通信的私有网络。</li><li><strong>广域网</strong>：又称广域网、外网、公网。是连接不同地区局域网或城域网计算机 通信的远程公共网络。</li><li><strong>IP</strong>（Internet Protocol）：本质是一个整形数，用于表示计算机在网络中的地址。IP 协议版本有两个：IPv4 和 IPv6</li></ul></li></ul><p><strong>IPv4</strong>（Internet Protocol version4）：</p><ul><li>使用一个 32 位的整形数描述一个 IP 地址，4 个字节，int 型<br>也可以使用一个点分十进制字符串描述这个 IP 地址： 192.168.247.135<br>分成了 4 份，每份 1 字节，8bit（char），最大值为 255<br>0.0.0.0 是最小的 IP 地址<br>255.255.255.255 是最大的 IP 地址<br>按照 IPv4 协议计算，可以使用的 IP 地址共有 2^32^ 个</li></ul><p><strong>IPv6</strong>（Internet Protocol version6）：</p><ul><li>使用一个 128 位的整形数描述一个 IP 地址，16 个字节<br>也可以使用一个字符串描述这个 IP 地址：2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b<br>分成了 8 份，每份 2 字节，每一部分以 16 进制的方式表示<br>按照 IPv6 协议计算，可以使用的 IP 地址共有 2^128^ 个</li></ul><p><strong>查看IP地址：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">windows</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ipconfig</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试网络是否畅通</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主机a: 192.168.1.11</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前主机: 192.168.1.12</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping 192.168.1.11     <span class="comment"># 测试是否可用连接局域网</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping www.baidu.com    <span class="comment"># 测试是否可用连接外网</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">特殊的IP地址: 127.0.0.1  ==&gt; 和本地的IP地址是等价的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假设当前电脑没有联网, 就没有IP地址, 又要做网络测试, 可用使用 127.0.0.1 进行本地测试</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>端口:</strong></li></ul><p>端口的作用是定位到主机上的某一个进程，通过这个端口进程就可以接受到对应的网络数据了。</p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>比如: 在电脑上运行了微信和QQ, 小明通过客户端给我的的微信发消息, 电脑上的微信就收到了消息, 为什么?</p><ul><li>运行在电脑上的微信和QQ都绑定了不同的端口</li><li>通过IP地址可以定位到某一台主机，通过端口就可以定位到主机上的某一个进程</li><li>通过指定的IP和端口，发送数据的时候对端就能接受到数据了</li></ul></div><p>端口也是一个整形数 unsigned short ，一个 16 位整形数，有效端口的取值范围是：<strong>0 ~ 65535</strong>(0 ~ 2^16^-1)</p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>提问：计算机中所有的进程都需要关联一个端口吗，一个端口可以被重复使用吗?</p></div><ul><li><p><strong>不需要，如果这个进程不需要网络通信，那么这个进程就不需要绑定端口的</strong></p></li><li><p><strong>一个端口只能给某一个进程使用，多个进程不能同时使用同一个端口</strong></p></li><li><p><strong>OSI/ISO 网络(七层)分层模型</strong></p><p>OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织组织）在1985年研究的网络互联模型。</p><p><img src="https://subingwen.cn/linux/socket/ip%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B.png" alt="img"></p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li>物理层：负责最后将信息编码成电流脉冲或其它信号用于网上传输</li><li>数据链路层:<br>数据链路层通过物理网络链路供数据传输。<br>规定了0和1的分包形式，确定了网络数据包的形式；</li><li>网络层<br>网络层负责在源和终点之间建立连接;<br>此处需要确定计算机的位置，通过IPv4，IPv6格式的IP地址来找到对应的主机</li><li>传输层<br>传输层向高层提供可靠的端到端的网络数据流服务。<br>每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信</li><li>会话层<br>会话层建立、管理和终止表示层与实体之间的通信会话；<br>建立一个连接（自动的手机信息、自动的网络寻址）;</li><li>表示层:<br>对应用层数据编码和转化, 确保以一个系统应用层发送的信息 可以被另一个系统应用层识别;</li><li>应用层：</li></ul></div></li></ul><p><strong>tcp/ip 四层模型：</strong></p><ul><li>应用层：对应iso/osi的应用层、表示层、会话层</li><li>传输层：对应iso/osi的传输层</li><li>网络互联层： 对应iso/osi的网络互联层</li><li>网络接口层：对应iso/osi数据链路层、物理层</li></ul><h2 id="网络协议">网络协议</h2><p>网络协议指的是计算机网络中互相通信的对等实体之间交换信息时所必须遵守的规则的集合。一般系统网络协议包括五个部分：通信环境，传输服务，词汇表，信息的编码格式，时序、规则和过程。下面是常用的协议格式：</p><p><strong>TCP 协议 -&gt; 传输层协议：</strong></p><p><img src="https://subingwen.cn/linux/socket/tcp.png" alt="img"></p><p><strong>UDP 协议 -&gt; 传输层协议：</strong></p><p><img src="https://subingwen.cn/linux/socket/udp.png" alt="img"></p><p><strong>IP 协议 -&gt; 网络层协议</strong>：</p><p><img src="https://subingwen.cn/linux/socket/ip.png" alt="img"></p><p><strong>以太网帧协议 -&gt; 网络接口层协议</strong>：</p><p><img src="https://subingwen.cn/linux/socket/mac.png" alt="img"></p><p><strong>数据的封装：</strong></p><p><img src="https://subingwen.cn/linux/socket/1558001080021.png" alt="1558001080021"></p><p>在网络通信的时候, 程序猿需要负责的应用层数据的处理(最上层)</p><ul><li><p>应用层的数据可以使用某些协议进行封装，也可以不封装</p></li><li><p>程序猿需要调用发送数据的接口函数，将数据发送出去</p></li><li><p>程序猿调用的 API 做底层数据处理</p></li><li><p>传输层使用传输层协议打包数据</p><ul><li>网络层使用网络层协议打包数据</li><li>网络接口层使用网络接口层协议打包数据</li><li>数据被发送到 internet</li><li>接收端接收到发送端的数据</li></ul></li><li><p>接收端接收到发送端的数据</p><ul><li><p>程序猿调用接收数据的函数接收数据</p></li><li><p>调用的 API 做相关的底层处理:</p></li><li><p>网络接口层拆包 ==&gt; 网络层的包</p></li><li><p>网络层拆包 ==&gt; 网络层的包</p></li><li><p>传输层拆包 ==&gt; 传输层数据</p></li><li><p>如果应用层也使用了协议对数据进行了封装，数据的包的解析需要程序猿做</p></li></ul></li></ul><h2 id="socket编程">socket编程</h2><p>Socket套接字由远景研究规划局（Advanced Research Projects Agency, ARPA）资助加里福尼亚大学伯克利分校的一个研究组研发。其目的是将TCP/IP协议相关软件移植到UNIX类系统中。设计者开发了一个接口，以便应用程序能简单地调用该接口通信。这个接口不断完善，最终形成了Socket套接字。Linux系统采用了Socket套接字，因此，Socket接口就被广泛使用，到现在已经成为事实上的标准。与套接字相关的函数被包含在头文件sys/socket.h中。</p><p>套接字对应程序猿来说就是一套网络通信的接口，使用这套接口就可以完成网络通信。网络通信的主体主要分为两部分：客户端和服务器端。在客户端和服务器通信的时候需要频繁提到三个概念：IP、端口、通信数据，下面介绍一下需要注意的一些细节问题。</p><h3 id="字节序">字节序</h3><p>在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编/译码从而导致通信失败。</p><p><strong>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，也就是说对于单字符来说是没有字节序问题的，字符串是单字符的集合，因此字符串也没有字节序问题。</strong></p><p>目前在各种体系的计算机中通常采用的字节存储机制主要有两种：<strong>Big-Endian 和 Little-Endian</strong>，下面先从字节序说起。</p><ul><li><p><strong>Little-Endian -&gt; 主机字节序 (小端)</strong></p></li><li></li><li><p>数据的<strong>低</strong>位字节存储到内存的<strong>低</strong>地址位 , 数据的<strong>高</strong>位字节存储到内存的<strong>高</strong>地址位</p></li><li><p>我们使用的 <strong>PC 机</strong>，数据的存储默认使用的是<strong>小端</strong></p></li><li><p><strong>Big-Endian -&gt; 网络字节序 (大端)</strong></p></li><li><p>据的<strong>低位字节</strong>存储到内存的<strong>高地址位</strong> , 数据的<strong>高位字节</strong>存储到内存的<strong>低地址位</strong></p></li><li><p>套接字<strong>通信</strong>过程中操作的数据都是<strong>大端存储</strong>的，包括：接收/发送的数据、IP地址、端口。</p></li></ul><p>下面给一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/ 有一个<span class="number">16</span>进制的数, 有<span class="number">32</span>位 (<span class="type">int</span>): <span class="number">0xab5c01ff</span></span><br><span class="line"><span class="comment">// 字节序, 最小的单位: char 字节, int 有4个字节, 需要将其拆分为4份</span></span><br><span class="line"><span class="comment">// 一个字节 unsigned char, 最大值是 255(十进制) ==&gt; ff(16进制) </span></span><br><span class="line">                 内存低地址位                内存的高地址位</span><br><span class="line">---------------------------------------------------------------------------&gt;</span><br><span class="line">小端:         <span class="number">0xff</span>        <span class="number">0x01</span>        <span class="number">0x5c</span>        <span class="number">0xab</span></span><br><span class="line">大端:         <span class="number">0xab</span>        <span class="number">0x5c</span>        <span class="number">0x01</span>        <span class="number">0xff</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>函数:</strong></p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>BSD Socket 提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// u:unsigned</span></span><br><span class="line"><span class="comment">// 16: 16位, 32:32位</span></span><br><span class="line"><span class="comment">// h: host, 主机字节序</span></span><br><span class="line"><span class="comment">// n: net, 网络字节序</span></span><br><span class="line"><span class="comment">// s: short</span></span><br><span class="line"><span class="comment">// l: int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这套api主要用于 网络通信过程中 IP 和 端口 的 转换</span></span><br><span class="line"><span class="comment">// 将一个短整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line"><span class="comment">// 将一个整形从主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个短整形从网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span><br><span class="line"><span class="comment">// 将一个整形从网络字节序 -&gt; 主机字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="IP-地址转换">IP 地址转换</h3><p>虽然 IP 地址本质是一个整形数，但是在使用的过程中都是通过一个字符串来描述，下面的函数描述了如何将一个字符串类型的 IP 地址进行大小端转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主机字节序的IP地址转换为网络字节序</span></span><br><span class="line"><span class="comment">// 主机字节序的IP地址是字符串, 网络字节序IP地址是整形</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>; </span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><ul><li>af: 地址族 (IP 地址的家族包括 ipv4 和 ipv6) 协议<ul><li>AF_INET: ipv4 格式的 ip 地址</li><li>AF_INET6: ipv6 格式的 ip 地址</li></ul></li><li>src: 传入参数，对应要转换的点分十进制的 ip 地址: 192.168.1.100</li><li>dst: 传出参数，函数调用完成，转换得到的大端整形 IP 被写入到这块内存中</li><li>返回值：成功返回 1，失败返回 0 或者 - 1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将大端的整形数, 转换为小端的点分十进制的IP地址        </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li>af: 地址族 (IP 地址的家族包括 ipv4 和 ipv6) 协议<ul><li>AF_INET: ipv4 格式的 ip 地址</li><li>AF_INET6: ipv6 格式的 ip 地址</li></ul></li><li>src: 传入参数，这个指针指向的内存中存储了大端的整形IP地址</li><li>dst: 传出参数，存储转换得到的小端的点分十进制的IP地址</li><li>size: 修饰dst参数的, 标记dst指向的内存中最多可以存储多少个字节</li><li>返回值：成功返回 1，失败返回 0 或者 - 1<ul><li>成功: 指针指向第三个参数对应的内存地址, 通过返回值也可以直接取出转换得到的IP字符串</li><li>失败: NULL</li><li></li></ul></li></ul><p>还有一组函数也能进程 IP 地址大小端的转换，但是只能处理 ipv4 的 ip 地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点分十进制IP -&gt; 大端整形</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大端整形 -&gt; 点分十进制IP</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure><h3 id="sockaddr数据结构">sockaddr数据结构</h3><p><img src="https://subingwen.cn/linux/socket/sockaddr.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在写数据的时候不好用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;       <span class="comment">// 地址族协议, ipv4</span></span><br><span class="line"><span class="type">char</span>        sa_data[<span class="number">14</span>];     <span class="comment">// 端口(2字节) + IP地址(4字节) + 填充(8字节)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>    <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(struct sockaddr) == sizeof(struct sockaddr_in)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;<span class="comment">/* 地址族协议: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;         <span class="comment">/* 端口, 2字节-&gt; 大端  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">/* IP地址, 4字节 -&gt; 大端  */</span></span><br><span class="line">    <span class="comment">/* 填充 8字节 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - <span class="keyword">sizeof</span>(sin_family) -</span><br><span class="line">               <span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">通常用</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clientaddr</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> client_fd;<span class="comment">//通信套接字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>//储存从<span class="title">accept</span>反馈来的客户端<span class="title">ip</span>信息  </span></span><br><span class="line"><span class="class">&#125;//该结构体通常用于每个子线程</span></span><br></pre></td></tr></table></figure><h3 id="套接字函数">套接字函数</h3><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>使用套接字通信函数需要包含头文件 <strong>&lt;arpa/inet.h&gt;（Linux下），如果包含了这个头文件, &lt;sys/socket.h&gt;</strong> 就不用在包含了。</p></div><p><strong>1.监听套接字：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个套接字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><ul><li>domain: 使用的地址族协议<ul><li>AF_INET: 使用 IPv4 格式的 ip 地址</li><li>AF_INET6: 使用 IPv4 格式的 ip 地址</li></ul></li><li>type:<ul><li>SOCK_STREAM: 使用流式的传输协议</li><li>SOCK_DGRAM: 使用报式 (报文) 的传输协议</li></ul></li><li>protocol: 一般写 0 即可，使用默认的协议<ul><li>SOCK_STREAM: 流式传输默认使用的是 tcp</li><li>SOCK_DGRAM: 报式传输默认使用的 udp、</li><li>SOCK_RAW: 原始套接字</li></ul></li><li>返回值:<br>成功：可用于套接字通信的文件描述符<br>失败: -1</li></ul><p>函数的返回值是一个文件描述符，通过这个文件描述符可以操作内核中的某一块内存，网络通信是基于这个文件描述符来完成的。</p><p><strong>2.绑定IP和端口</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将文件描述符和本地的IP与端口进行绑定   </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><ul><li>sockfd: 监听的文件描述符，通过 socket () 调用得到的返回值</li><li>addr: 传入参数，要绑定的 IP 和端口信息需要初始化到这个结构体中，IP和端口要转换为网络字节序</li><li>addrlen: 参数 addr 指向的内存大小，sizeof (struct sockaddr)<br>返回值：成功返回 0，失败返回 - 1</li></ul><p><strong>3.设置监听</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给监听的套接字设置监听</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><ul><li>sockfd: 文件描述符，可以通过调用 socket () 得到，在监听之前必须要绑定 bind ()</li><li>backlog: 同时能处理的最大连接要求，最大值为 128</li><li>返回值：函数调用成功返回 0，调用失败返回 -1</li></ul><p><strong>4.通信套接字</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待并接受客户端的连接请求, 建立新的连接, 会得到一个新的文件描述符(通信的)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><ul><li>sockfd: 监听的文件描述符</li><li>addr: 传出参数，里边存储了建立连接的客户端的地址信息</li><li>addrlen: 传入传出参数，用于存储 addr 指向的内存大小<br>返回值：函数调用成功，得到一个文件描述符，用于和建立连接的这个客户端通信，调用失败返回 -1</li></ul><p><strong>主:当客户端信息(IP,端口)不被要求知晓时，通常后两个参数为nullptr</strong></p><p><strong>accept函数是一个阻塞函数，当没有新的客户端连接请求的时候，该函数阻塞；当检测到有新的客户端连接请求时，阻塞解除，新连接就建立了，得到的返回值也是一个文件描述符，基于这个文件描述符就可以和客户端通信了。</strong></p><p><strong>5.数据接受和传递函数(需要包含头文件unistd.h)：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据(两个为一组)</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> sock_fd, <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span>;<span class="comment">//没有收到数据会阻塞，直到收到数据</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> sock_fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sock_fd, <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sock_fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><ul><li><p>sockfd: 用于通信的文件描述符，accept () 函数的返回值</p></li><li><p>buf: 指向一块有效内存，用于存储接收是数据</p></li><li><p>size: 参数 buf 指向的内存的容量</p></li><li><p>flags: 特殊的属性，一般不使用，指定为 0</p></li><li><p>返回值:<br>大于 0：实际接收的字节数<br>等于 0：客户端/服务端断开了连接<br>-1：接收数据失败了</p></li><li><p>如果连接没有断开，接收端接收不到数据，接收数据的函数会阻塞等待数据到达，数据到达后函数解除阻塞，开始接收数据，当发送端断开连接，接收端无法接收到任何数据，但是这时候就不会阻塞了，函数直接返回0。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功连接服务器之后, 客户端会自动随机绑定一个端口</span></span><br><span class="line"><span class="comment">// 服务器端调用accept()的函数, 第二个参数存储的就是客户端的IP和端口信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><ul><li>sockfd: 通信的文件描述符，通过调用 socket () 函数就得到了</li><li>addr: 存储了要连接的服务器端的地址信息: iP 和 端口，这个 IP 和端口也需要转换为大端然后再赋值</li><li>addrlen: addr 指针指向的内存的大小 sizeof (struct sockaddr)</li><li>返回值：连接成功返回 0，连接失败返回 - 1</li></ul><h3 id="端口复用（setsockopt）">端口复用（setsockopt）</h3><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>端口复用最常用的用途应该是防止服务器重启时之前绑定的端口还未释放或者程序突然退出而系统没有释放端口。这种情况下如果设定了端口复用，则新启动的服务器进程可以直接绑定端口。如果没有设定端口复用，绑定会失败，提示ADDR已经在使用中——那只好等等再重试了，麻烦！</strong></p></div><ul><li><strong>起因</strong>: 由socket状态转换图可知, 主动关闭连接的一端都会有一个TIME_WAIT, 时间为2msl, 以确保对端收到最后一个ACK</li><li><strong>影响</strong>: 如果是服务器端需要主动断开连接(例如网站更新等), 那么再次重启则需要浪费2msl时间, 为了减少这种时间开销, 因此有了<a href="https://so.csdn.net/so/search?q=%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8&amp;spm=1001.2101.3001.7020">端口复用</a></li><li><strong>作用</strong>: 可以立马重启服务器, 而不必等待2msl, 且不会在bind的时候发生端口被占用的错误.</li></ul><p>​       <strong>函数原型+实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockFd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> opt;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">void</span> *) &amp;opt, <span class="keyword">sizeof</span>(opt))) &#123;</span><br><span class="line">    perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="comment">//设置端口复用</span></span><br><span class="line"><span class="comment">/*  Returns 0 on success, -1 for errors. */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 注意：在所有TCP服务器中，在调用bind之前设置端口复用</span><br></pre></td></tr></table></figure><h2 id="TCP通信流程">TCP通信流程</h2><p>TCP 是一个面向连接的，安全的，流式传输协议，这个协议是一个传输层协议。</p><ul><li>面向连接：是一个双向连接，通过三次握手完成，断开连接需要通过四次挥手完成。</li><li>安全：tcp 通信过程中，会对发送的每一数据包都会进行校验，如果发现数据丢失，会自动重传</li><li>流式传输：发送端和接收端处理数据的速度，数据的量都可以不一致</li></ul><p><img src="https://subingwen.cn/linux/socket/tcp.jpg" alt="img"></p><h3 id="服务器端通信流程：">服务器端通信流程：</h3><ul><li>1.创建用于监听的套接字，这个套接字是一个文件描述符</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lfd = socket();</span><br></pre></td></tr></table></figure><ul><li>2.将得到的监听的文件描述符和本地的 IP 端口进行绑定</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind();</span><br></pre></td></tr></table></figure><ul><li>3.设置监听 (成功之后开始监听，监听的是客户端的连接)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen();</span><br></pre></td></tr></table></figure><ul><li>4.等待并接受客户端的连接请求，建立新的连接，会得到一个新的文件描述符 (通信的)，<strong>没有新连接请求就阻塞</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = accept();</span><br></pre></td></tr></table></figure><ul><li>5.通信，读写操作默认都是阻塞的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">read(); / recv();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">write(); / send();</span><br></pre></td></tr></table></figure><ul><li>6.断开连接，关闭套接字(close()函数需要包含unistd.h头文件)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close();</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>在 tcp 的服务器端，有两类文件描述符</strong></p><ul><li><strong>监听的文件描述符</strong><ul><li><strong>只需要有一个</strong></li><li><strong>不负责和客户端通信，负责检测客户端的连接请求，检测到之后调用 accept 就可以建立新的连接</strong></li></ul></li><li><strong>通信的文件描述符</strong><ul><li><strong>负责和建立连接的客户端通信</strong></li><li><strong>如果有 N 个客户端和服务器建立了新的连接，通信的文件描述符就有 N 个，每个客户端和服务器都对应一个通信的文件描述符</strong></li></ul></li></ul></div><ul><li><p><strong>文件描述符对应的内存结构：</strong></p><ul><li><p>个文件文件描述符对应两块内存, 一块内存是读缓冲区, 一块内存是写缓冲区</p></li><li><p>读数据: 通过文件描述符将内存中的数据读出, 这块内存称之为读缓冲区</p></li><li><p>写数据: 通过文件描述符将数据写入到某块内存中, 这块内存称之为写缓冲区</p></li></ul></li><li><p><strong>监听的文件描述符(socket_fd):</strong></p><ul><li><p>客户端的连接请求会发送到服务器端监听的文件描述符的读缓冲区中<br>​</p></li><li><p>读缓冲区中有数据，说明有新的客户端连接<br>​</p></li><li><p>调用 accept () 函数，这个函数会检测监听文件描述符的读缓冲区<br>​</p></li><li><p>检测不到数据，该函数阻塞<br>​</p></li><li><p>如果检测到数据，解除阻塞，新的连接建立</p></li></ul></li><li><p><strong>通信的文件描述符(correspondence_fd）:</strong></p></li><li><p>客户端和服务器端都有<strong>通信</strong>的文件描述符</p></li><li><p>发送数据：调用函数 write () /send ()，数据进入到内核中</p><ul><li><p>数据并没有被发送出去，而是将数据写入到了通信的文件描述符对应的写缓冲区中</p></li><li><p>内核检测到通信的文件描述符写缓冲区中有数据，内核会将数据发送到网络中<br>​</p></li></ul></li><li><p>接收数据：调用的函数 read () /recv (), 从内核读数据</p><ul><li><p>数据如何进入到内核程序猿不需要处理，数据进入到通信的文件描述符的读缓冲区中</p></li><li><p>数据进入到内核，必须使用通信的文件描述符，将数据从读缓冲区中读出即可</p></li></ul></li></ul><p><strong>客户端的通信流程：</strong></p><ul><li>1.创建一个通信的套接字</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = socket();</span><br></pre></td></tr></table></figure><ul><li>2.连接服务器，需要知道服务器绑定的 IP 和端口</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">connect</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>3.通信</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">read(); / recv();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">write(); / send();</span><br></pre></td></tr></table></figure><ul><li>4.断开连接，关闭文件描述符 (套接字)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close();</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>基于tcp的服务器端通信代码:</p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏一般用于本地的绑定操作</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line"><span class="comment">//    inet_pton(AF_INET, &quot;192.168.237.131&quot;, &amp;addr.sin_addr.s_addr);</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印客户端的地址信息</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;客户端的IP地址: %s, 端口: %d\n&quot;</span>,</span><br><span class="line">           inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip)),</span><br><span class="line">           ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            write(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端的通信流程">客户端的通信流程</h3><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>在单线程的情况下客户端通信的文件描述符有一个, 没有监听的文件描述符</p></div><ol><li>创建一个通信的套接字</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cfd = socket();</span><br></pre></td></tr></table></figure><ol start="2"><li>连接服务器, 需要知道服务器绑定的IP和端口(通过指定的ip和端口就可以连接到指定的服务器)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect();</span><br></pre></td></tr></table></figure><ol start="3"><li>通信</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">read(); / recv();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">write(); / send();</span><br></pre></td></tr></table></figure><ol start="4"><li>断开连接, 关闭文件描述符(套接字)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close();</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>在基于tcp通信的客户端通信代码:</p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建通信的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">//连接到的服务器端口</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.237.131&quot;</span>, &amp;addr.sin_addr.s_addr); <span class="comment">//远程连接，指定实际服务器地址,转换为大端地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 和服务器端通信</span></span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送数据，前面的fd已经是通信的套接字了</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;你好, 服务器...%d\n&quot;</span>, number++);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器say: %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);   <span class="comment">// 每隔1s发送一条数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2.一个简单的键值数据库：</h1><h2 id="习题和源码">习题和源码</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">题目</button></li><li class="tab"><button type="button" data-href="#分栏-2">main.cpp</button></li><li class="tab"><button type="button" data-href="#分栏-3">ClassTcp.h</button></li><li class="tab"><button type="button" data-href="#分栏-4">ClassTcp.cpp</button></li><li class="tab"><button type="button" data-href="#分栏-5">ClassMessage.h</button></li><li class="tab"><button type="button" data-href="#分栏-6">ClassMessage.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">ASYNC CPP GROUP FINAL <span class="title function_">PROJECT</span><span class="params">(<span class="number">2022</span>)</span>:Simple Key</span><br><span class="line">Value Database</span><br><span class="line">在这个项目中，你们要实现一个简单的键值数据库。</span><br><span class="line">架构如图所示：</span><br><span class="line">要求</span><br><span class="line">你们要编写database服务端，从文件中读取和写入数据，在这个项目中，总数据量不会大于内存容量。</span><br><span class="line">你们需要实现以下操作：</span><br><span class="line"><span class="title function_">Put</span><span class="params">(Key,Value)</span> - 将key value保存到数据库中。</span><br><span class="line"><span class="title function_">Delete</span><span class="params">(Key)</span> - 将指定key删除。</span><br><span class="line"><span class="title function_">Get</span><span class="params">(Key)</span> - 返回指定Key的value。</span><br><span class="line">你们只需要编写服务端，我们会用编写好的Client测试你的程序，所以请注意你们必须按照指定协议来与Clien</span><br><span class="line">通信。</span><br><span class="line">我们会使用多个连接向你的datbase发送请求，所以为你的数据结构添加线程安全的特性是必须的，但我们不会</span><br><span class="line">发出有写写冲突或读写冲突的请求。</span><br><span class="line">协议格式:</span><br><span class="line"></span><br><span class="line">Header：<span class="comment">//在传输数据前都会先发送一遍协议头的数据</span></span><br><span class="line">Field       Length    Type     Meaning</span><br><span class="line">MagicNumber 4 bytes   UInt32<span class="comment">// 魔数（固定为1234）</span></span><br><span class="line">Size        4 bytes   UInt32 <span class="comment">//包大小，不包括头部</span></span><br><span class="line">Type        4 bytes   UInt32 <span class="comment">//包类型</span></span><br><span class="line">Padding     4 bytes   UInt32 <span class="comment">//填充（固定为0）</span></span><br><span class="line">Types:</span><br><span class="line">        Number         Meaning</span><br><span class="line">           0            Put请求</span><br><span class="line">           1            Delete请求</span><br><span class="line">           2            Get请求</span><br><span class="line">               3            Put响应</span><br><span class="line">               4            Delete响应</span><br><span class="line">               5            Get响应</span><br><span class="line"> </span><br><span class="line">        Put Request Body:</span><br><span class="line">   Field     Length    Type      Meaning</span><br><span class="line">  Key Size   4 bytes   UInt32     Key的长度</span><br><span class="line">  Key        N bytes   Byte[]     Key</span><br><span class="line">  Value Size 4 bytes   UInt32     Value的长度</span><br><span class="line">  Value      N bytes   Byte[]     Value</span><br><span class="line">       </span><br><span class="line">       Delete Request Body:</span><br><span class="line">  Field     Length   Type    Meaning</span><br><span class="line">  Key Size  4 bytes UInt32   Key的长度</span><br><span class="line">  Key       N bytes Byte[]   Key</span><br><span class="line">      </span><br><span class="line">      Get Request Body:</span><br><span class="line">   Field    Length   Type    Meaning</span><br><span class="line">   Key Size 4 bytes UInt32   Key的长度</span><br><span class="line">   Key      N bytes Byte[]   Key</span><br><span class="line">   </span><br><span class="line">       Put Response Body:</span><br><span class="line">   Field Length Type Meaning</span><br><span class="line">   Status 1 byte Bool 是否成功</span><br><span class="line">   </span><br><span class="line">       Delete Response Body:</span><br><span class="line">   Field    Length   Type    Meaning</span><br><span class="line">   Status   1 byte   Bool    是否成功</span><br><span class="line">  </span><br><span class="line">       Get Response Body:</span><br><span class="line">   Field       Length     Type    Meaning</span><br><span class="line">  Value Size   4 bytes   UInt32   Value的长度</span><br><span class="line">  Value        N bytes   Byte[]   Value</span><br><span class="line">Notes:</span><br><span class="line">我们不会使用一个连接同时发送多个请求。</span><br><span class="line">我们可能会使用多个连接同时发送多个请求，但这些请求之间不会有竟态条件。</span><br><span class="line">你的程序所存储的Key Value对的总内存量不会超过内存总量。</span><br><span class="line">我们可能会重启你的程序，请确保你确实对数据进行了持久化。</span><br><span class="line">我们假定所有的通信都是可靠，因此不会出现断连的情况。</span><br><span class="line">我们至多同时使用100个连接。</span><br><span class="line">文中提及的所有Int均使用小端序。</span><br><span class="line">稍后我们会放出Client的源码作为参考</span><br><span class="line"> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by: keqiudi</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ClassTCP.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">TCP *TOC=<span class="keyword">new</span> TCP;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TOC-&gt;<span class="built_in">Socket_Start</span>();<span class="comment">//启动服务器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiudi on 2023/2/27.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLIONSERVER_CLASSTCP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIONSERVER_CLASSTCP_H <span class="comment">//防止头文件重复引用，降低编译效率</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCP</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> ser_addr;</span><br><span class="line">    <span class="type">int</span> socket_fd;</span><br><span class="line">    <span class="type">int</span> bin_d;</span><br><span class="line">    <span class="type">int</span> lis;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">TCP</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Message_import</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Message_save</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Socket_Start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Connect_Start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CLIONSERVER_CLASSTCP_H</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiudi on 2023/2/27.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ClassMessage.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;string,string&gt;Map;<span class="comment">//全局Map容器</span></span><br><span class="line">mutex WriteMutexMap;<span class="comment">//创建全局锁，避免多线程对map容器的操作造成数据混乱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> TCP *TOC;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCP::Socket_Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;socket_fd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>); <span class="comment">//创造监听的套接字</span></span><br><span class="line">    <span class="keyword">if</span>(socket_fd==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ser_addr.sin_family=AF_INET;<span class="comment">//将socket()返回值和本地的IP（IPv4）端口绑定到一起</span></span><br><span class="line">    ser_addr.sin_port=<span class="built_in">htons</span>(<span class="number">9999</span>);<span class="comment">//大端端口</span></span><br><span class="line">    ser_addr.sin_addr.s_addr=INADDR_ANY;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> opt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(socket_fd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="built_in">sizeof</span>(opt));<span class="comment">//设置端口复用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>-&gt;bin_d= <span class="built_in">bind</span>(socket_fd,(<span class="keyword">struct</span> sockaddr*)&amp;ser_addr,<span class="built_in">sizeof</span>(ser_addr));<span class="comment">//设置监听</span></span><br><span class="line">    <span class="keyword">if</span>(bin_d==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;lis= <span class="built_in">listen</span>(socket_fd,<span class="number">100</span>);<span class="comment">//100表示一次同时最大监听数</span></span><br><span class="line">    <span class="keyword">if</span>(lis==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="built_in">Connect_Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(Message message,<span class="keyword">struct</span> Client_Message client_message)</span> </span>&#123;</span><br><span class="line">    message.client_message = client_message;   <span class="comment">//拷贝一份message类使每个子线程单独使用，千万不能全部共用一个类 </span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.<span class="built_in">Message_get</span>(message) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//子线程退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCP::Connect_Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Client_Message</span> Client;</span><br><span class="line"></span><br><span class="line">    Message message;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Client.connect_fd= <span class="built_in">accept</span>(socket_fd, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);<span class="comment">//阻塞等待客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (Client.connect_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;客户端连接成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(working,message,Client)</span></span>;<span class="comment">//创建子线程</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程创建成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">        t.<span class="built_in">detach</span>();<span class="comment">//分离子线程,</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCP::Message_save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ofstream outFile;</span><br><span class="line">    outFile.<span class="built_in">open</span>(<span class="string">&quot;DATA.txt&quot;</span>,ios::out);</span><br><span class="line">    <span class="keyword">if</span>(!outFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    WriteMutexMap.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; it : Map)</span><br><span class="line">    &#123;</span><br><span class="line">        outFile &lt;&lt; it.first &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; it.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    WriteMutexMap.<span class="built_in">unlock</span>();</span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCP::Message_import</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string key,value;</span><br><span class="line">    ifstream inFile;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">open</span>(<span class="string">&quot;DATA.txt&quot;</span>,ios::in);</span><br><span class="line">    <span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!inFile.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        inFile &gt;&gt; key;</span><br><span class="line">        inFile &gt;&gt; value;</span><br><span class="line">        Map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,string&gt;(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCP::~<span class="built_in">TCP</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> TOC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiudi on 2023/2/27.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CLIONSERVER_CLASSMESSAGE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIONSERVER_CLASSMESSAGE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ClassTCP.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Client_Message</span>&#123;</span><br><span class="line">    <span class="type">int</span> connect_fd;<span class="comment">//用于通信的套接字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;<span class="comment">//不用的东西懒得改了,不影响</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">         <span class="type">uint32_t</span> MagicNumber;</span><br><span class="line">         <span class="type">uint32_t</span> Size;</span><br><span class="line">         <span class="type">uint32_t</span> Type;</span><br><span class="line">         <span class="type">uint32_t</span> Padding;</span><br><span class="line">    &#125;inf;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Message</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Message_get</span><span class="params">(Message message)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Types_Request</span><span class="params">(Message message)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Put_Response</span><span class="params">(Message message)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Delete_Response</span><span class="params">(Message message)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Get_Response</span><span class="params">(Message message)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header_send</span><span class="params">(Message message,<span class="type">uint32_t</span> MagicNumber,<span class="type">uint32_t</span> Size,<span class="type">uint32_t</span> Type,<span class="type">uint32_t</span> Padding)</span></span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Client_Message</span> client_message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//CLIONSERVER_CLASSMESSAGE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-6"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiudi on 2023/2/27.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ClassTCP.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ClassMessage.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> map&lt;string, string&gt; Map;<span class="comment">//全局map容器</span></span><br><span class="line"><span class="keyword">extern</span> TCP *TOC;</span><br><span class="line"></span><br><span class="line">Message::<span class="built_in">Message</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;inf.MagicNumber = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;inf.Size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;inf.Type = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;inf.Padding = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Message::Message_get</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">size_t</span> len, len1, len2, len3;<span class="comment">//Header数据存储</span></span><br><span class="line">        len = <span class="built_in">read</span>(message.client_message.connect_fd, &amp;(<span class="keyword">this</span>-&gt;inf.MagicNumber), <span class="built_in">sizeof</span>(<span class="keyword">this</span>-&gt;inf.MagicNumber));</span><br><span class="line">        len1 = <span class="built_in">read</span>(message.client_message.connect_fd, &amp;(<span class="keyword">this</span>-&gt;inf.Size), <span class="built_in">sizeof</span>(<span class="keyword">this</span>-&gt;inf.MagicNumber));</span><br><span class="line">        len2 = <span class="built_in">read</span>(message.client_message.connect_fd, &amp;(<span class="keyword">this</span>-&gt;inf.Type), <span class="built_in">sizeof</span>(<span class="keyword">this</span>-&gt;inf.MagicNumber));</span><br><span class="line">        len3 = <span class="built_in">read</span>(message.client_message.connect_fd, &amp;(<span class="keyword">this</span>-&gt;inf.Padding), <span class="built_in">sizeof</span>(<span class="keyword">this</span>-&gt;inf.MagicNumber));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span> || len1 == <span class="number">-1</span> || len2 == <span class="number">-1</span> || len3 == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span> || len1 == <span class="number">0</span> || len2 == <span class="number">0</span> || len3 == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;客户端断开连接&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">close</span>(message.client_message.connect_fd);<span class="comment">//关闭子线程通信套接字</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Types_Request</span>(message);<span class="comment">//根据Type类型进行不同的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::Types_Request</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>-&gt;inf.Type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">Put_Response</span>(message);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            TOC-&gt;<span class="built_in">Message_import</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">Delete_Response</span>(message);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            TOC-&gt;<span class="built_in">Message_import</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">Get_Response</span>(message);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::header_send</span><span class="params">(Message message, <span class="type">uint32_t</span> MagicNumber, <span class="type">uint32_t</span> Size, <span class="type">uint32_t</span> Type, <span class="type">uint32_t</span> Padding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(message.client_message.connect_fd, &amp;MagicNumber, <span class="built_in">sizeof</span>(MagicNumber)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(message.client_message.connect_fd, &amp;Size, <span class="built_in">sizeof</span>(Size)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(message.client_message.connect_fd, &amp;Type, <span class="built_in">sizeof</span>(Type)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(message.client_message.connect_fd, &amp;Padding, <span class="built_in">sizeof</span>(Padding)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::Put_Response</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    string key, value;</span><br><span class="line">    <span class="type">uint32_t</span> keysize, valuesize;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(message.client_message.connect_fd, &amp;keysize, <span class="built_in">sizeof</span>(keysize)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    key.<span class="built_in">resize</span>(keysize);<span class="comment">//设置key的大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(message.client_message.connect_fd, <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(key.<span class="built_in">data</span>()), keysize) ==</span><br><span class="line">        <span class="number">-1</span>)<span class="comment">//.data()将字符串类型转换为const char*指针，const_cast&lt;char *&gt;(key.data())将const char*转换为char,不能直接对字符串类型进行取地址,</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(message.client_message.connect_fd, &amp;valuesize, <span class="built_in">sizeof</span>(valuesize)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    value.<span class="built_in">resize</span>(valuesize);<span class="comment">//设置value的大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(message.client_message.connect_fd, <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(value.<span class="built_in">data</span>()), valuesize) ==<span class="number">-1</span>)<span class="comment">//const_cast&lt;char *&gt;(key.data())将const char*转换为char*</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map[key] = value;<span class="comment">//将数据存入map中</span></span><br><span class="line">    <span class="type">bool</span> result = TOC-&gt;<span class="built_in">Message_save</span>();<span class="comment">//将数据保存到文件中,返回值作为回应</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> MagicNumber = <span class="number">1234</span>;</span><br><span class="line">    <span class="type">uint32_t</span> Size = <span class="built_in">sizeof</span>(<span class="type">bool</span>);</span><br><span class="line">    <span class="type">uint32_t</span> Type = <span class="number">3</span>;</span><br><span class="line">    <span class="type">uint32_t</span> Padding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">header_send</span>(message, MagicNumber, Size, Type, Padding);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(message.client_message.connect_fd, &amp;result, <span class="built_in">sizeof</span>(result)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::Delete_Response</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    string key;</span><br><span class="line">    <span class="type">uint32_t</span> keysize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(message.client_message.connect_fd, &amp;keysize, <span class="built_in">sizeof</span>(keysize)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    key.<span class="built_in">resize</span>(keysize);<span class="comment">//设置key的大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(message.client_message.connect_fd, <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(key.<span class="built_in">data</span>()), keysize) ==</span><br><span class="line">        <span class="number">-1</span>)<span class="comment">//const_cast&lt;char *&gt;(key.data())将const char*转换为char*</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Map.<span class="built_in">erase</span>(key);</span><br><span class="line">    <span class="type">bool</span> result = TOC-&gt;<span class="built_in">Message_save</span>();<span class="comment">//将数据保存到文件中,返回值作为回应</span></span><br><span class="line">    <span class="type">uint32_t</span> MagicNumber = <span class="number">1234</span>;</span><br><span class="line">    <span class="type">uint32_t</span> Size = <span class="built_in">sizeof</span>(<span class="type">bool</span>);</span><br><span class="line">    <span class="type">uint32_t</span> Type = <span class="number">4</span>;</span><br><span class="line">    <span class="type">uint32_t</span> Padding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">header_send</span>(message, MagicNumber, Size, Type, Padding);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(message.client_message.connect_fd, &amp;result, <span class="built_in">sizeof</span>(result)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::Get_Response</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    string key;</span><br><span class="line">    <span class="type">uint32_t</span> keysize;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(message.client_message.connect_fd, &amp;keysize, <span class="built_in">sizeof</span>(keysize)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    key.<span class="built_in">resize</span>(keysize);<span class="comment">//设置key的大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(message.client_message.connect_fd, <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(key.<span class="built_in">data</span>()), keysize) ==</span><br><span class="line">        <span class="number">-1</span>)<span class="comment">//const_cast&lt;char *&gt;(key.data())将const char*转换为char*</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iter = Map.<span class="built_in">find</span>(key);</span><br><span class="line">    string value = (iter-&gt;second);</span><br><span class="line">    <span class="type">uint32_t</span> valuesize = (iter-&gt;second).<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">uint32_t</span> MagicNumber = <span class="number">1234</span>;</span><br><span class="line">    <span class="type">uint32_t</span> Size = valuesize + <span class="number">4</span>;</span><br><span class="line">    <span class="type">uint32_t</span> Type = <span class="number">5</span>;</span><br><span class="line">    <span class="type">uint32_t</span> Padding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">header_send</span>(message, MagicNumber, Size, Type, Padding);</span><br><span class="line">    cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; valuesize &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(message.client_message.connect_fd, &amp;valuesize, <span class="built_in">sizeof</span>(valuesize)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(message.client_message.connect_fd, <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(value.<span class="built_in">data</span>()), valuesize) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="相关笔记">相关笔记</h2><h3 id="map">map</h3><p>map是STL（标准模板库）的一个关联容器，它提供一对一的hash</p><ul><li><p>第一个可以称为关键字(key)，每个关键字（key）只能在map中出现一次；</p></li><li><p>第二个可能称为该关键字的值(value)；</p></li></ul><p><strong>map的功能</strong>：</p><p>自动建立key － value的对应。key 和 value可以是任意你需要的类型，包括自定义类型。</p><p>map&lt;type_name,type_name&gt;</p><p><strong>使用map</strong></p><p>使用map得包含map类所在的头文件</p><p>#include <map> //注意，STL头文件没有扩展名.h</p><p>map对象是模板类，需要关键字和存储对象两个模板参数：</p><p>std:map&lt;<strong>int</strong>, string&gt; personnel;</p><p><strong>用法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个map对象</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一种 用insert函數插入pair</span></span><br><span class="line">mapStudent.insert(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="built_in">string</span>&gt;(<span class="number">000</span>, <span class="string">&quot;student_zero&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第二种 用insert函数插入value_type数据</span></span><br><span class="line">mapStudent.insert(<span class="built_in">map</span>&lt;<span class="type">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">001</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第三种 用&quot;array&quot;方式插入</span></span><br><span class="line">mapStudent[<span class="number">123</span>] = <span class="string">&quot;student_first&quot;</span>;<span class="comment">//123为key，&quot;student_first&quot;为value</span></span><br><span class="line">mapStudent[<span class="number">456</span>] = <span class="string">&quot;student_second&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//map查找元素</span></span><br><span class="line">mapStudent.find(key)<span class="comment">//当所查找的关键key出现时，它返回数据所在对象的位置,否则返回map::end()位置</span></span><br><span class="line">用<span class="keyword">auto</span> iter = mapStudent.find(key);<span class="comment">//得到指向key的一个指针</span></span><br><span class="line">  iter-&gt;first<span class="comment">//key的值</span></span><br><span class="line">  iter-&gt;second<span class="comment">//value的值</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//map删除元素</span></span><br><span class="line">mapStudent.erase(key)<span class="comment">//删除关键字，如果成功删除返回1，否则返回0</span></span><br><span class="line">mapStudent.clear()<span class="comment">//清空所有元素</span></span><br><span class="line">mapStudent.(mapStudent.begin(),mapStudent.end());<span class="comment">//与上方等同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取map的大小</span></span><br><span class="line"><span class="type">int</span> nSize = mapStudent.size();</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>的基本操作函数：更多见CSDN </span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，<strong>insert操作是不能在插入数据的</strong>，但是用<strong>数组</strong>方式就不同了，它<strong>可以覆盖以前该关键字对 应的值</strong>，用程序说明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,string&gt;Map;</span><br><span class="line"><span class="comment">//以下都是string类型</span></span><br><span class="line">Map[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;value&quot;</span>;<span class="comment">//key与value对应</span></span><br><span class="line"></span><br><span class="line">Map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, string&gt;(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;other&quot;</span>));<span class="comment">//操作失败，已经存在key，insert失败，</span></span><br><span class="line">Map[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;other&quot;</span>;<span class="comment">//操作成功，用数组写入相同key 时，会将原来存在的value覆盖</span></span><br></pre></td></tr></table></figure><p><strong>补充：</strong></p><p><strong>map的遍历(迭代器)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">map</span>迭代器</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">char</span>,<span class="built_in">string</span>&gt;::iterator it;      <span class="comment">//it能读写map&lt;char,string&gt;的元素</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="type">char</span>,<span class="built_in">string</span>&gt;::const_iterator it;<span class="comment">//it只能读map&lt;char,string&gt;的元素，不可以修改map&lt;char,string&gt;中的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp; iter : Map)</span><br><span class="line">    &#123;</span><br><span class="line">        outFile &lt;&lt; iter.first &lt;&lt;<span class="built_in">endl</span></span><br><span class="line">        outFile &lt;&lt; iter.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//iter.first是关键子key的值</span></span><br><span class="line"><span class="comment">//iter.second是value的值</span></span><br><span class="line"><span class="comment">//遍历的时候按照key值遍历</span></span><br></pre></td></tr></table></figure><h3 id="perror函数">perror函数</h3><p>perror函数可以在发生错误时多输出的数据</p><p>下方为例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lis==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="data-成员函数用法">data()成员函数用法</h3><p><strong>标准库的string类供了3个成员函数来从一个string得到c类型的字符数组</strong>：c_str()、data()、copy(p,n)。</p><p><strong>1. c_str()：生成一个const char*指针，指向以空字符终止的数组</strong></p><p><strong>2. data()：生成一个const char*指针，指向的数组不以空字符结束</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处用于通信时读取数据read函数的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意通常不直接对字符串类型直接取地址！！！，string是个类，所以需要data（）获取指针</span></span><br><span class="line"></span><br><span class="line">string key；</span><br><span class="line"><span class="built_in">read</span>(message.client_message.connect_fd, <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(key.<span class="built_in">data</span>()，keysize)；</span><br><span class="line">     </span><br><span class="line"><span class="comment">//const_cast&lt;char *&gt;可以将const char*转化为char*型</span></span><br></pre></td></tr></table></figure><h3 id="resize-函数">resize 函数</h3><p>resize()，设置大小;</p><p>reserve()，设置容量;</p><p>resize()是分配容器的内存大小，而reserve()只是设置容器容量大小，但并没有真正分配内存。</p><p>resize()可以传递两个参数，分别是大小和初始值，初始值默认为0，reserve()只能传递一个参数，不能设置初始值，其初始值为系统随机生成。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string key1;</span><br><span class="line"><span class="type">uint32_t</span> keysize;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;key2;</span><br><span class="line"></span><br><span class="line">key1.<span class="built_in">resize</span>(keysize);<span class="comment">//可以为字符串设置大小</span></span><br><span class="line">key2.<span class="built_in">resize</span>(keysize);<span class="comment">//为vector容器设置大小</span></span><br></pre></td></tr></table></figure><h3 id="多线程std-thread">多线程std::thread</h3><p>头文件#include<thread></p><p>看看CSDN全面用法：<a href="https://blog.csdn.net/sjc_0910/article/details/118861539?spm=1001.2014.3001.5506">(10条消息) C++11 多线程（std::thread）详解_std::thread（）是个函数吗_sjc_0910的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/lu_embedded/article/details/121639992?spm=1001.2014.3001.5506">(10条消息) 两种 C++ 多线程编程方式，看完不懂打我…_c++多线程_阿基米东的博客-CSDN博客</a></p><p>创建线程基本用法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">thread <span class="title function_">t</span><span class="params">(工作的函数,该函数参数,该函数参数,,,,,)</span></span><br></pre></td></tr></table></figure><p>我的用法（具体见上方代码）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCP::Connect_Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Client_Message</span> Client;<span class="comment">//这个地方可以直接用一个in connect_fd，下面传参的时候同样也传进去，当不用客户端数据的时候,就不用结构体了</span></span><br><span class="line"></span><br><span class="line">    Message message;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Client.connect_fd= <span class="built_in">accept</span>(socket_fd, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);<span class="comment">//阻塞等待客户端连接</span></span><br><span class="line">        <span class="keyword">if</span> (Client.connect_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;客户端连接成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(working,message,Client)</span></span>;<span class="comment">//创建子线程</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程创建成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">        t.<span class="built_in">detach</span>();<span class="comment">//分离子线程，使子线程独立于主线程并发运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(Message message,<span class="keyword">struct</span> Client_Message client_message)</span> </span>&#123;</span><br><span class="line">    message.client_message = client_message;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//这里的循环避免传入数据被回收</span></span><br><span class="line">        <span class="keyword">if</span> (message.<span class="built_in">Message_get</span>(message) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//子线程退出，一定要有</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//每个线程的入口函数</span></span><br></pre></td></tr></table></figure><p><strong>关于我在第一次写多线程犯的致命错误：</strong></p><p>刚开始写我竟然让所有线程共用全局的一个类！！！(这样会导致不同线程在同时读写该类数据，一定会爆炸)  血的教训！！</p><p><strong>注意：在写子线程的工作函数时，最好是让这个thread_working函数独立(独立于类)出来，不要什么东西都一起用</strong></p><p>这个地方后面修改为了将使用类在每个子线程中拷贝一份类（所有数据都会拷贝一份），使所有的线程单独使用不同的类，这样就避免了同时读写导致程序崩溃</p><p>还有一定要让子线程退出，不退出也会爆炸</p><p>还有别忘了断开连接时close()关闭通信套接字</p><h3 id="std-mutex-互斥锁">std::mutex(互斥锁)</h3><p>头文件:#include<mutex></p><p><code>std::mutex</code>是 C++11 中最基本的互斥量，一个线程将mutex锁住时，其它的线程就不能操作mutex，直到这个线程将mutex解锁。</p><p><strong>一般都是创建全局锁</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line">map&lt;string,string&gt;Map;</span><br><span class="line">mutex WriteMutexMap;<span class="comment">//创建全局锁，避免多线程对map容器的操作造成数据混乱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在写入数据时的简单操作：</span></span><br><span class="line"></span><br><span class="line">WriteMutexMap.<span class="built_in">lock</span>();<span class="comment">//此时锁住，其他线程不能操作数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; it : Map)</span><br><span class="line">    &#123;</span><br><span class="line">        outFile &lt;&lt; it.first &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; it.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    WriteMutexMap.<span class="built_in">unlock</span>();<span class="comment">//解锁</span></span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>常用函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">mutex WriteMutexMap;</span><br><span class="line"></span><br><span class="line">WriteMutexMap.<span class="built_in">lock</span>();<span class="comment">//将mutex上锁。如果mutex已经被其它线程上锁，，那么会阻塞，直到解锁；如果mutex已经被同一个线程锁住，那么会产生死锁。</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">WriteMutexMap.<span class="built_in">unlock</span>();<span class="comment">//解锁mutex，释放其所有权。如果有线程因为调用lock()不能上锁而被阻塞，则调用此函数会将mutex的主动权随机交给其中一个线程；如果mutex不是被此线程上锁，那么会引发未定义的异常。</span></span><br><span class="line"></span><br><span class="line">WriteMutexMap.<span class="built_in">try_lock</span>();<span class="comment">//尝试将mutex上锁。如果mutex未被上锁，则将其上锁并返回true；如果mutex已被锁则返回false。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学生管理程序</title>
      <link href="/posts/f28c0c7b.html"/>
      <url>/posts/f28c0c7b.html</url>
      
        <content type="html"><![CDATA[<p>这是一个简单的学生管理程序，记录了四个不同版本</p><h1>1.第一次学生管理程序(结构体实现):</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1<span class="comment">//防止scanf报错</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">STUDENTS</span> &#123;<span class="comment">//主结构体</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line"><span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> sex;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">stu</span> &#123;<span class="comment">//联合体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> year:<span class="number">11</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> month:<span class="number">4</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> day:<span class="number">5</span>;</span><br><span class="line">&#125;birthday;</span><br><span class="line"><span class="type">int</span> date;</span><br><span class="line">&#125;STU;</span><br><span class="line"><span class="type">int</span> score[<span class="number">4</span>];</span><br><span class="line">&#125;STUDENT;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">types</span> &#123;<span class="comment">//枚举类型</span></span><br><span class="line">男 = <span class="number">0</span>,</span><br><span class="line">女 =<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Input</span><span class="params">(STUDENT student[],<span class="type">int</span> n)</span></span>;<span class="comment">//输入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Search</span><span class="params">(<span class="type">char</span> name[], STUDENT student[], <span class="type">int</span> n)</span></span>;<span class="comment">//查找函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Average</span><span class="params">(STUDENT student[],<span class="type">int</span> n)</span></span>;<span class="comment">//平均成绩和及格率函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Comparemin</span><span class="params">(STUDENT student[], <span class="type">int</span> n)</span></span>;<span class="comment">//最小年龄显示函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">char</span> names[], STUDENT student[<span class="number">100</span>], <span class="type">int</span> n)</span></span>;<span class="comment">//匹配字符串的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans1</span><span class="params">(STUDENT student[], <span class="type">int</span> n)</span></span>;<span class="comment">//联合体中两成员的值互化，下同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans2</span><span class="params">(STUDENT student[], <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">STUDENT student[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> n, chose,func;</span><br><span class="line"><span class="type">char</span> names[<span class="number">100</span>];</span><br><span class="line">part1:<span class="built_in">printf</span>(<span class="string">&quot;请先输入班级学生信息,输入1跳转: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;chose);</span><br><span class="line"><span class="built_in">rewind</span>(stdin);</span><br><span class="line"><span class="keyword">if</span> (chose == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入班级人数:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">Input</span>(student, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (chose != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入错误!,请重新输入\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> part1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请选择你要使用的功能:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1.查找学生信息\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2.统计某科目的平均成绩和及格率\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3.查找年龄最小的学生信息\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;func);</span><br><span class="line"><span class="keyword">switch</span> (func)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入学生姓名 &quot;</span>);</span><br><span class="line"><span class="built_in">rewind</span>(stdin);</span><br><span class="line"><span class="built_in">gets</span>(names);</span><br><span class="line"><span class="built_in">Search</span>(names, student, n);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">Average</span>(student, n);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">Comparemin</span>(student, n);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Input</span><span class="params">(STUDENT student[<span class="number">100</span>], <span class="type">int</span> n)</span> </span>&#123;<span class="comment">//输入函数</span></span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请依次输入学号:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;student[i].number);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请依次输入学生姓名:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, student[i].name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请依次输入学生的性别(男:0女:1):&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;student[i].sex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请依次输入学生出生年: 月: 日:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;year, &amp;month, &amp;day);</span><br><span class="line">student[i].STU.birthday.year = year;</span><br><span class="line">student[i].STU.birthday.month =month;</span><br><span class="line">student[i].STU.birthday.day = day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请依次输入学生的语文 数学 英语 理综成绩:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;student[i].score[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Search</span><span class="params">(<span class="type">char</span> names[], STUDENT student[], <span class="type">int</span> n)</span><span class="comment">//查找函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">a = <span class="built_in">compare</span>(names, student, n);</span><br><span class="line"><span class="keyword">if</span> (a!=<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;您输入的学生信息如下:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;姓名: %s\n&quot;</span>, student[a].name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学号: %d\n&quot;</span>, student[a].number);</span><br><span class="line"><span class="keyword">if</span> (student[a].sex == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;性别: 男\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (student[a].sex == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;性别: 女\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出生日期: %d%02d%02d\n&quot;</span>, student[a].STU.birthday.year, student[a].STU.birthday.month, student[a].STU.birthday.day);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该学生的各科成绩为\n语文:%d\n&quot;</span>, student[a].score[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数学:%d\n&quot;</span>, student[a].score[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;英语:%d\n&quot;</span>, student[a].score[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;理综:%d\n&quot;</span>, student[a].score[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">compare</span>(names, student, n)==<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;无该学生信息\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">char</span> names[] ,STUDENT student[], <span class="type">int</span> n)</span> </span>&#123;<span class="comment">//名字匹配</span></span><br><span class="line"><span class="type">int</span> i,flag,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(names); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (names[j] == student[i].name[j]) </span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Average</span><span class="params">(STUDENT student[], <span class="type">int</span> n)</span><span class="comment">//及格率和平均成绩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> subject,i;</span><br><span class="line"><span class="type">double</span> avg,pass,sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入你想统计的科目:\n1.语文\n2.数学\n3.英语\n4.理综\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;subject);</span><br><span class="line"><span class="keyword">if</span> (subject == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">sum += student[i].score[<span class="number">0</span>];&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">&#123;<span class="keyword">if</span> (student[i].score[<span class="number">0</span>] &gt;= <span class="number">60</span>)</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (student[i].score[<span class="number">0</span>] &lt; <span class="number">60</span>)</span><br><span class="line">b++;&#125;</span><br><span class="line">avg = sum / n;</span><br><span class="line">pass = (<span class="type">double</span>)a / (a + b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;语文的平均成绩为:%.2lf\n语文的及格率为%%%.2lf&quot;</span>, avg, pass);&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (subject == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">sum += student[i].score[<span class="number">1</span>];&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (student[i].score[<span class="number">1</span>] &gt;= <span class="number">60</span>)</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (student[i].score[<span class="number">1</span>] &lt; <span class="number">60</span>)</span><br><span class="line">b++;&#125;</span><br><span class="line">avg = sum / n;</span><br><span class="line">pass = (<span class="type">double</span>)a / (a + b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数学的平均成绩为:%.2lf\n数学的及格率为%%%.2lf&quot;</span>, avg, pass);&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (subject == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">sum += student[i].score[<span class="number">2</span>];&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (student[i].score[<span class="number">2</span>] &gt;= <span class="number">60</span>)</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (student[i].score[<span class="number">2</span>] &lt; <span class="number">60</span>)</span><br><span class="line">b++;&#125;</span><br><span class="line">avg = sum / n;</span><br><span class="line">pass = (<span class="type">double</span>)a / (a + b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;英语的平均成绩为:%.2lf\n英语的及格率为%%%.2lf&quot;</span>, avg, pass);&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (subject == <span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">sum += student[i].score[<span class="number">3</span>];&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (student[i].score[<span class="number">3</span>] &gt;= <span class="number">60</span>)</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (student[i].score[<span class="number">3</span>] &lt; <span class="number">60</span>)</span><br><span class="line">b++;&#125;</span><br><span class="line">avg = sum / n;</span><br><span class="line">pass = (<span class="type">double</span>)a / (a + b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;理综的平均成绩为:%.2lf\n理综的及格率为%%%.2lf&quot;</span>, avg, pass);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Comparemin</span><span class="params">(STUDENT student[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">trans1</span>(student, n);</span><br><span class="line"><span class="type">int</span> min=<span class="number">0</span>,i;</span><br><span class="line"><span class="keyword">for</span> (i =<span class="number">0</span>; i &lt; n;i++)<span class="comment">//找出年龄最小的学生对应的出生日期</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (min &lt; student[i].STU.date)</span><br><span class="line">min = student[i].STU.date;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (min == student[i].STU.date)<span class="comment">//学生匹配</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">trans2</span>(student, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;年龄最小的学生信息如下:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;姓名: %s\n&quot;</span>, student[i].name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学号: %d\n&quot;</span>, student[i].number);</span><br><span class="line"><span class="keyword">if</span> (student[i].sex == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;性别: 男\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (student[i].sex == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;性别: 女\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出生日期: %d%02d%02d\n&quot;</span>, student[i].STU.birthday.year, student[i].STU.birthday.month, student[i].STU.birthday.day);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该学生的各科成绩为\n语文:%d\n&quot;</span>, student[i].score[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数学:%d\n&quot;</span>, student[i].score[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;英语:%d\n&quot;</span>, student[i].score[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;理综:%d\n&quot;</span>, student[i].score[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans1</span><span class="params">(STUDENT student[], <span class="type">int</span> n)</span><span class="comment">//联合体中两成员值的转换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">student[i].STU.date = (student[i].STU.birthday.year)* <span class="number">10000</span> + (student[i].STU.birthday.month) * <span class="number">100</span> + student[i].STU.birthday.day;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans2</span><span class="params">(STUDENT student[], <span class="type">int</span> n)</span><span class="comment">//联合体中两成员值的转换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i,a;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a = student[i].STU.date;</span><br><span class="line">student[i].STU.birthday.year = a / <span class="number">10000</span>;</span><br><span class="line">student[i].STU.birthday.month = (a%<span class="number">10000</span>)/<span class="number">100</span>;</span><br><span class="line">student[i].STU.birthday.day = a % <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2.第二次学生管理程序(链表实现)</h1><p>main.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;function.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* p;</span><br><span class="line">    p = <span class="built_in">fopen</span>(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;加载数据失败,开始录入学生数据:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">Input</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fclose</span>(p);</span><br><span class="line">        <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">menu</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>function.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1<span class="comment">//防止scanf报错</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STUDENT</span> &#123;</span><span class="comment">//主结构体</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">stu</span> &#123;</span><span class="comment">//联合体</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">birthday</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> day : <span class="number">5</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> month : <span class="number">4</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> year : <span class="number">11</span>;</span><br><span class="line">        &#125;stus;</span><br><span class="line">        <span class="type">int</span> date;</span><br><span class="line">    &#125;STU;</span><br><span class="line">    <span class="type">int</span> score[<span class="number">4</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STUDENT</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STUDENT</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STUDENT</span>* <span class="title">student</span> =</span> <span class="literal">NULL</span>, * current = <span class="literal">NULL</span>;<span class="comment">//创建链表结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">types</span> &#123;</span></span><br><span class="line">    男 = <span class="number">0</span>,</span><br><span class="line">    女 = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Input</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        current = (<span class="keyword">struct</span> STUDENT*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> STUDENT));</span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">                head = current;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                student-&gt;next = current;</span><br><span class="line">            current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;请输入学生姓名: &quot;</span>);</span><br><span class="line">            gets(temp);</span><br><span class="line">            <span class="built_in">strcpy</span>(current-&gt;name, temp);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;请输入该学生的学号: &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;current-&gt;number);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;请输入该学生的性别(男:0女:1): &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;current-&gt;sex);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;请输入学生的出生日期年 月 日: &quot;</span>);</span><br><span class="line">            <span class="type">int</span> year, month, day;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;year, &amp;month, &amp;day);</span><br><span class="line">            current-&gt;STU.stus.year = year;</span><br><span class="line">            current-&gt;STU.stus.month = month;</span><br><span class="line">            current-&gt;STU.stus.day = day;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;请依次输入学生的语文 数学 英语 理综成绩: &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;current-&gt;score[<span class="number">0</span>], &amp;current-&gt;score[<span class="number">1</span>], &amp;current-&gt;score[<span class="number">2</span>], &amp;current-&gt;score[<span class="number">3</span>]);</span><br><span class="line">            student = current;</span><br><span class="line">            rewind(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;继续输入请按1,输入完成请按2:&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Find</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;所有学生的信息如下:\n&quot;</span>);</span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;学生姓名:%s\n&quot;</span>, current-&gt;name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;学号:%d\n&quot;</span>, current-&gt;number);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;sex == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;性别: 男\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;sex == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;性别: 女\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出生日期:%d%02d%02d\n&quot;</span>, current-&gt;STU.stus.year, current-&gt;STU.stus.month, current-&gt;STU.stus.day);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该学生的各科成绩为\n语文:%d\n&quot;</span>, current-&gt;score[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数学:%d\n&quot;</span>, current-&gt;score[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;英语:%d\n&quot;</span>, current-&gt;score[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;理综:%d\n&quot;</span>, current-&gt;score[<span class="number">3</span>]);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Search</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> names[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入学生的姓名: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, names);</span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (match(names, current) == <span class="number">1</span>)<span class="comment">//匹配名字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;您要查找的学生信息如下:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;姓名: %s\n&quot;</span>, current-&gt;name);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;学号: %d\n&quot;</span>, current-&gt;number);</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;sex == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;性别: 男\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;sex == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;性别: 女\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;出生日期:%4d%02d%02d\n&quot;</span>, current-&gt;STU.stus.year, current-&gt;STU.stus.month, current-&gt;STU.stus.day);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;该学生的各科成绩为\n语文:%d\n&quot;</span>, current-&gt;score[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;数学:%d\n&quot;</span>, current-&gt;score[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;英语:%d\n&quot;</span>, current-&gt;score[<span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;理综:%d\n&quot;</span>, current-&gt;score[<span class="number">3</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有该学生信息\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Average</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> subject, n = <span class="number">0</span>;<span class="comment">//n用于统计结点个数</span></span><br><span class="line">    <span class="type">double</span> avg = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    current = head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你想统计的科目:\n1.语文\n2.数学\n3.英语\n4.理综\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;subject);</span><br><span class="line">    <span class="keyword">if</span> (subject == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += current-&gt;score[<span class="number">0</span>];</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        avg = sum / n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;语文的平均成绩为:%.2lf&quot;</span>, avg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (subject == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += current-&gt;score[<span class="number">2</span>];</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        avg = sum / n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数学的平均成绩为:%.2lf&quot;</span>, avg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (subject == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += current-&gt;score[<span class="number">2</span>];</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        avg = sum / n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;英语的平均成绩为:%.2lf\n&quot;</span>, avg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (subject == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += current-&gt;score[<span class="number">3</span>];</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        avg = sum / n;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;理综的平均成绩为:%.2lf&quot;</span>, avg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">match</span><span class="params">(<span class="type">char</span> names[], <span class="keyword">struct</span> STUDENT* current)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flag, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(names); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;name[i] == names[i])</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;name[i] != names[i])</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">preserve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    current = head;</span><br><span class="line">    FILE* p1;</span><br><span class="line">    p1 = fopen(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(p1, <span class="string">&quot;%s\n&quot;</span>, current-&gt;name);</span><br><span class="line">        <span class="built_in">fprintf</span>(p1, <span class="string">&quot;%d\n&quot;</span>, current-&gt;number);</span><br><span class="line">        <span class="built_in">fprintf</span>(p1, <span class="string">&quot;%d\n&quot;</span>, current-&gt;sex);</span><br><span class="line">        <span class="built_in">fprintf</span>(p1, <span class="string">&quot;%4d%02d%02d\n&quot;</span>, current-&gt;STU.stus.year, current-&gt;STU.stus.month, current-&gt;STU.stus.day);</span><br><span class="line">        <span class="built_in">fprintf</span>(p1, <span class="string">&quot;%d\n&quot;</span>, current-&gt;score[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">fprintf</span>(p1, <span class="string">&quot;%d\n&quot;</span>, current-&gt;score[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">fprintf</span>(p1, <span class="string">&quot;%d\n&quot;</span>, current-&gt;score[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">fprintf</span>(p1, <span class="string">&quot;%d\n&quot;</span>, current-&gt;score[<span class="number">3</span>]);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fclose(p1) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件关闭失败&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;保存数据成功,文件关闭成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* p2;</span><br><span class="line">    p2 = fopen(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!feof(p2))<span class="comment">//读取到文件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        current = (<span class="keyword">struct</span> STUDENT*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> STUDENT));</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            head = current;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            student-&gt;next = current;</span><br><span class="line">        current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">fscanf</span>(p2, <span class="string">&quot;%s\n&quot;</span>, current-&gt;name);</span><br><span class="line">        <span class="built_in">fscanf</span>(p2, <span class="string">&quot;%d\n&quot;</span>, &amp;current-&gt;number);</span><br><span class="line">        <span class="built_in">fscanf</span>(p2, <span class="string">&quot;%d\n&quot;</span>, &amp;current-&gt;sex);</span><br><span class="line">        <span class="type">int</span> year, month, day;</span><br><span class="line">        <span class="built_in">fscanf</span>(p2, <span class="string">&quot;%4d%02d%02d\n&quot;</span>, &amp;year, &amp;month, &amp;day);。</span><br><span class="line">        current-&gt;STU.stus.year = year;</span><br><span class="line">        current-&gt;STU.stus.month = month;</span><br><span class="line">        current-&gt;STU.stus.day = day;<span class="comment">//设置位宽后的处理</span></span><br><span class="line">        <span class="built_in">fscanf</span>(p2, <span class="string">&quot;%d\n&quot;</span>, &amp;current-&gt;score[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">fscanf</span>(p2, <span class="string">&quot;%d\n&quot;</span>, &amp;current-&gt;score[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">fscanf</span>(p2, <span class="string">&quot;%d\n&quot;</span>, &amp;current-&gt;score[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">fscanf</span>(p2, <span class="string">&quot;%d\n&quot;</span>, &amp;current-&gt;score[<span class="number">3</span>]);</span><br><span class="line">        student = current;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fclose(p2) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件关闭失败&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;学生数据加载成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SearchID</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入学生的学号: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == current-&gt;number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>)<span class="comment">//到达最后一个结点的判断条件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无该学生信息&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该学生信息如下:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;姓名: %s\n&quot;</span>, current-&gt;name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;学号: %d\n&quot;</span>, current-&gt;number);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;sex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;性别: 男\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;sex == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;性别: 女\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出生日期:%4d%02d%02d\n&quot;</span>, current-&gt;STU.stus.year, current-&gt;STU.stus.month, current-&gt;STU.stus.day);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该学生的各科成绩为\n语文:%d\n&quot;</span>, current-&gt;score[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数学:%d\n&quot;</span>, current-&gt;score[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;英语:%d\n&quot;</span>, current-&gt;score[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;理综:%d\n&quot;</span>, current-&gt;score[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteID</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, flag;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入删除学生的学号: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;next-&gt;number == a)</span><br><span class="line">            &#123;</span><br><span class="line">                current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">                flag = <span class="number">1</span>;<span class="comment">//删除改链表结点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//删除链表尾结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;next-&gt;number == a) &#123;</span><br><span class="line">                current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除失败,找不到该学生&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Deletename</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> names[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入删除学生的姓名: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, names);</span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (match(names, current) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                current-&gt;next = current-&gt;next-&gt;next;<span class="comment">//删除列表结点</span></span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (match(names, current-&gt;next) == <span class="number">1</span>) &#123;<span class="comment">//单独处理列表尾结点</span></span><br><span class="line">                current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除失败,没有该学生信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> func;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请选择你要使用的功能:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1.查看所有学生\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2.姓名查找学生信息\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3.学号查找学生信息\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4.输入学号删除学生信息\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5.输入姓名删除学生信息\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;6.统计某科目的平均成绩\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;7.保存学生数据\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;func);</span><br><span class="line">    <span class="keyword">switch</span> (func)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        Find();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        rewind(<span class="built_in">stdin</span>);</span><br><span class="line">        Search();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        SearchID();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        DeleteID();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        Deletename();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        Average();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        preserve();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>3.第三次学生管理程序(类+链表+c++ 实现)</h1><p>define.h:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">            <span class="type">int</span> number;</span><br><span class="line">            std::string name;</span><br><span class="line">            <span class="type">int</span> sex;</span><br><span class="line">            <span class="keyword">union</span> <span class="title class_">stu</span> &#123;<span class="comment">//联合体</span></span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">birthday</span> &#123;</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">int</span> day : <span class="number">5</span>;</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">int</span> month : <span class="number">4</span>;</span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">int</span> year : <span class="number">12</span>;</span><br><span class="line">                &#125;stus;</span><br><span class="line">                <span class="type">int</span> date;</span><br><span class="line">            &#125;STU;</span><br><span class="line">            <span class="type">int</span> score[<span class="number">4</span>];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Student</span>()<span class="comment">//构造函数初始化变量</span></span><br><span class="line">        &#123;</span><br><span class="line">            number = <span class="number">0</span>;</span><br><span class="line">            name = <span class="string">&quot;names&quot;</span>;</span><br><span class="line">            sex = <span class="number">0</span>;</span><br><span class="line">            score[<span class="number">0</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            score[<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            score[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            score[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        Student* next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Classroom</span>;<span class="comment">//友元类(使得current能够访问Student类中的私有变量)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classroom</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Student* head = <span class="literal">nullptr</span>;      <span class="comment">//指向下一结点</span></span><br><span class="line">        Student* latter = <span class="literal">nullptr</span>;</span><br><span class="line">        Student* current = <span class="literal">nullptr</span>;       <span class="comment">//c++中用nullptr代表空指针,而NULL当作0使用</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Input</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Find</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Search</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SearchID</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Average</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">DeleteID</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Deletename</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">preserve</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">menu</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>achieve.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span><span class="comment">//用于处理文件输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span><span class="comment">//为exit()提供原型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;define.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Classroom::Input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       current = <span class="keyword">new</span> Student; </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            head = current;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            latter-&gt;next = current;</span><br><span class="line">            current-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;请输入学生姓名: &quot;</span>;</span><br><span class="line">            cin &gt;&gt;current-&gt;name;</span><br><span class="line">            cout &lt;&lt;<span class="string">&quot;请输入该学生的学号: &quot;</span>;</span><br><span class="line">            cin &gt;&gt; current-&gt;number;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;请输入该学生的性别(男:0女:1): &quot;</span>;</span><br><span class="line">            cin &gt;&gt; current-&gt;sex;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;请输入学生的出生日期年 月 日: &quot;</span>;</span><br><span class="line">            <span class="built_in">rewind</span>(stdin);</span><br><span class="line">            <span class="type">int</span> year, month, day;</span><br><span class="line">            cin &gt;&gt; year ;</span><br><span class="line">            cin &gt;&gt; month;</span><br><span class="line">            cin &gt;&gt; day;</span><br><span class="line">            current-&gt;STU.stus.year = year;</span><br><span class="line">            current-&gt;STU.stus.month = month;</span><br><span class="line">            current-&gt;STU.stus.day = day;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;请依次输入学生的语文 数学 英语 理综成绩: &quot;</span>;</span><br><span class="line">            cin &gt;&gt; current-&gt;score[<span class="number">0</span>] &gt;&gt; current-&gt;score[<span class="number">1</span>] &gt;&gt; current-&gt;score[<span class="number">2</span>] &gt;&gt;current-&gt; score[<span class="number">3</span>];</span><br><span class="line">            latter = current ;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;继续输入请按1,输入完成请按2:&quot;</span>;</span><br><span class="line">            cin &gt;&gt; i;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Classroom::Find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;所有学生的信息如下:\n&quot;</span>);</span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;学生姓名: &quot;</span> &lt;&lt; current-&gt;name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;学号: &quot;</span> &lt;&lt; current-&gt;number &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;性别: &quot;</span> &lt;&lt; current-&gt;sex &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;sex == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;性别: 男&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;sex == <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;性别: 女&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;出生日期: &quot;</span> &lt;&lt; current-&gt;STU.stus.year &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; current-&gt;STU.stus.month &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; current-&gt;STU.stus.day &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;该学生的各科成绩为: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;语文: &quot;</span> &lt;&lt; current-&gt;score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;数学: &quot;</span> &lt;&lt; current-&gt;score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;英语: &quot;</span> &lt;&lt; current-&gt;score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;理综: &quot;</span> &lt;&lt; current-&gt;score[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Classroom::Search</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     string names;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;请输入学生的姓名: &quot;</span>;</span><br><span class="line">     cin &gt;&gt; names;</span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (names==current-&gt;name)<span class="comment">//匹配名字</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;您要查找的学生信息如下: &quot;</span>&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;姓名: &quot;</span>&lt;&lt;current-&gt;name&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;学号: &quot;</span>&lt;&lt; current-&gt;number&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;sex == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;性别: 男&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;sex == <span class="number">1</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;性别: 女&quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;出生日期: &quot;</span> &lt;&lt; current-&gt;STU.stus.year &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; current-&gt;STU.stus.month &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; current-&gt;STU.stus.day &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;该学生的各科成绩为: &quot;</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;语文: &quot;</span> &lt;&lt; current-&gt;score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;数学: &quot;</span> &lt;&lt; current-&gt;score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;英语: &quot;</span> &lt;&lt; current-&gt;score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;理综: &quot;</span> &lt;&lt; current-&gt;score[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">nullptr</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;没有该学生信息\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Classroom::SearchID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入学生的学号: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == current-&gt;number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">nullptr</span>)<span class="comment">//到达最后一个结点的判断条件</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无该学生信息&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;您要查找的学生信息如下: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; current-&gt;name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;学号: &quot;</span> &lt;&lt; current-&gt;number &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;sex == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;性别: 男&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;sex == <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;性别: 女&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;出生日期: &quot;</span> &lt;&lt; current-&gt;STU.stus.year &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; current-&gt;STU.stus.month &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; current-&gt;STU.stus.day &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;该学生的各科成绩为: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;语文: &quot;</span> &lt;&lt; current-&gt;score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;数学: &quot;</span> &lt;&lt; current-&gt;score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;英语: &quot;</span> &lt;&lt; current-&gt;score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;理综: &quot;</span> &lt;&lt; current-&gt;score[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Classroom::Average</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> subject, n = <span class="number">0</span>;<span class="comment">//n用于统计结点个数</span></span><br><span class="line">        <span class="type">double</span> avg = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        current = head;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入你想统计的科目:\n1.语文\n2.数学\n3.英语\n4.理综\n&quot;</span>;</span><br><span class="line">        cin &gt;&gt; subject;</span><br><span class="line">        <span class="keyword">if</span> (subject == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += current-&gt;score[<span class="number">0</span>];</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">            avg = sum / n;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;语文的平均成绩为: &quot;</span>&lt;&lt; avg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (subject == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += current-&gt;score[<span class="number">2</span>];</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">            avg = sum / n;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;数学的平均成绩为: &quot;</span>&lt;&lt; avg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (subject == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += current-&gt;score[<span class="number">2</span>];</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">            avg = sum / n;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;英语的平均成绩为: &quot;</span> &lt;&lt; avg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (subject == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += current-&gt;score[<span class="number">3</span>];</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">            avg = sum / n;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;理综的平均成绩为: &quot;</span> &lt;&lt; avg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Classroom::DeleteID</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="type">int</span> a, flag;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入删除学生的学号: &quot;</span>;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        current = head;</span><br><span class="line">     <span class="keyword">while</span> (current-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (current-&gt;number == a)<span class="comment">//删除列表头结点</span></span><br><span class="line">         &#123;</span><br><span class="line">             head = current-&gt;next;</span><br><span class="line">             <span class="built_in">delete</span>(current);</span><br><span class="line">             flag = <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (current-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (current-&gt;next-&gt;number == a)</span><br><span class="line">             &#123;</span><br><span class="line">                 current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">                 <span class="built_in">delete</span>(current-&gt;next);</span><br><span class="line">                 flag = <span class="number">1</span>;<span class="comment">//删除改链表结点</span></span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span><span class="comment">//删除链表尾结点</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span> (current-&gt;next-&gt;number == a) &#123;</span><br><span class="line">                 current-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                 <span class="built_in">delete</span>(current-&gt;next);</span><br><span class="line">                 flag = <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         current = current-&gt;next;</span><br><span class="line">         flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">         cout&lt;&lt;<span class="string">&quot;删除成功&quot;</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         cout &lt;&lt;<span class="string">&quot;删除失败,找不到该学生&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Classroom::Deletename</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     string names;</span><br><span class="line">     <span class="type">int</span> flag;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;请输入删除学生的姓名: &quot;</span>;</span><br><span class="line">     cin &gt;&gt; names;</span><br><span class="line">     current = head;</span><br><span class="line">     <span class="keyword">while</span> (current-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">     &#123;</span><br><span class="line"> </span><br><span class="line">             <span class="keyword">if</span> (current-&gt;name == names)<span class="comment">//删除列表头结点</span></span><br><span class="line">             &#123;</span><br><span class="line">                 head = current-&gt;next;</span><br><span class="line">                 <span class="built_in">delete</span>(current);</span><br><span class="line">                 flag = <span class="number">0</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">          <span class="keyword">if</span> (current-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (names==current-&gt;next-&gt;name)</span><br><span class="line">             &#123;</span><br><span class="line">                  <span class="built_in">delete</span>(current-&gt;next);</span><br><span class="line">                 current-&gt;next = current-&gt;next-&gt;next;<span class="comment">//删除列表结点</span></span><br><span class="line">                 flag = <span class="number">0</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span> (names == current-&gt;next-&gt;name) &#123;<span class="comment">//单独处理列表尾结点</span></span><br><span class="line">                 <span class="built_in">delete</span>(current-&gt;next);</span><br><span class="line">                 current-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                 flag = <span class="number">0</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         flag = <span class="number">1</span>;</span><br><span class="line">         current = current-&gt;next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;删除成功&quot;</span>;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;删除失败,没有该学生信息&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Classroom::preserve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     current = head;</span><br><span class="line">     ofstream outFile;</span><br><span class="line">     outFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (!outFile.<span class="built_in">is_open</span>()) &#123;<span class="comment">//判断文件是否打开成功，打开成功返回true</span></span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">             <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span> (current != <span class="literal">nullptr</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        outFile&lt;&lt;current-&gt;name&lt;&lt;endl;</span><br><span class="line">        outFile&lt;&lt; current-&gt;number &lt;&lt; endl;</span><br><span class="line">        outFile &lt;&lt; current-&gt;sex &lt;&lt; endl;</span><br><span class="line">        outFile &lt;&lt; current-&gt;STU.stus.year &lt;&lt; endl &lt;&lt; current-&gt;STU.stus.month &lt;&lt; endl &lt;&lt; current-&gt;STU.stus.day &lt;&lt; endl;</span><br><span class="line">        outFile &lt;&lt; current-&gt;score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        outFile &lt;&lt; current-&gt;score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">        outFile &lt;&lt; current-&gt;score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">        outFile &lt;&lt; current-&gt;score[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">         current = current-&gt;next;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     outFile.<span class="built_in">close</span>();</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;保存成功&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Classroom::read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     ifstream inFile;</span><br><span class="line">     inFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">     &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span> (!inFile.<span class="built_in">eof</span>())<span class="comment">//读取到文件结尾</span></span><br><span class="line">     &#123;</span><br><span class="line">         current = <span class="keyword">new</span> Student;</span><br><span class="line">         <span class="keyword">if</span> (head ==<span class="literal">nullptr</span>)</span><br><span class="line">             head = current;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             latter-&gt;next = current;</span><br><span class="line">         current-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">         inFile &gt;&gt; current-&gt;name;</span><br><span class="line">         inFile &gt;&gt; current-&gt;number;</span><br><span class="line">         inFile &gt;&gt; current-&gt;sex;</span><br><span class="line">         <span class="type">int</span> year, month, day;</span><br><span class="line">         inFile &gt;&gt; year;</span><br><span class="line">         inFile &gt;&gt; month;</span><br><span class="line">         inFile &gt;&gt; day;</span><br><span class="line">         current-&gt;STU.stus.year = year;</span><br><span class="line">         current-&gt;STU.stus.month = month;</span><br><span class="line">         current-&gt;STU.stus.day = day;<span class="comment">//设置位宽后的处理</span></span><br><span class="line">         inFile &gt;&gt; current-&gt;score[<span class="number">0</span>];</span><br><span class="line">         inFile &gt;&gt; current-&gt;score[<span class="number">1</span>];</span><br><span class="line">         inFile &gt;&gt; current-&gt;score[<span class="number">2</span>];</span><br><span class="line">         inFile &gt;&gt; current-&gt;score[<span class="number">3</span>];</span><br><span class="line">         latter = current;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     inFile.<span class="built_in">close</span>();</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;学生数据加载成功\n&quot;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;define.h&quot;</span></span></span><br><span class="line">Classroom a;<span class="comment">//创建Classroom对象(变量)，便于调用函数,同时创建的全局变量，具有外部链接，便于菜单调用;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ifstream inFile;</span><br><span class="line">    inFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>, std::ios::in);<span class="comment">//第一个参数为文件名，第二个参数为打开方式，ios::in为只读模式</span></span><br><span class="line">    <span class="keyword">if</span> (!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;开始录入数据:&quot;</span>;</span><br><span class="line">        a.<span class="built_in">Input</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        inFile.<span class="built_in">close</span>();</span><br><span class="line">        a.<span class="built_in">read</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;数据加载成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">menu</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>menu.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;define.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Classroom::menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> func;</span><br><span class="line">    <span class="keyword">extern</span> Classroom a;<span class="comment">//extern引用声明main文件中的a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                 **********请选择你要使用的功能: **********                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                 **********1.查看所有学生       **********                 \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                 **********2.姓名查找学生信息   **********                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                 **********3.学号查找学生信息    **********                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                 **********4.输入学号删除学生信息**********                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                 **********5.输入姓名删除学生信息**********                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                 **********6.统计某科目的平均成绩**********                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                 **********7.保存学生数据        **********                  \n&quot;</span>);</span><br><span class="line">    std::cin &gt;&gt; func;</span><br><span class="line">    <span class="keyword">switch</span> (func)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        a.<span class="built_in">Find</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">rewind</span>(stdin);</span><br><span class="line">        a.<span class="built_in">Search</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        a.<span class="built_in">SearchID</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        a.<span class="built_in">DeleteID</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        a.<span class="built_in">Deletename</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        a.<span class="built_in">Average</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        a.<span class="built_in">preserve</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>4.第四个版本在github仓库</h1><h1>5.Base64编码解码</h1><h2 id="bitset——定义及常用操作">bitset——定义及常用操作</h2><p>bitset 就相当于一个 只能存储二进制，也就是 0 和 1 的 bool 数组(容器)<br>但是可以直接当作一个数进行左移右移，取或取反等二进制操作。</p><p>如果直接用 bool 数组存储二进制每一位的话，n 位存储复杂度为 O(n)，但是用 bitset 的话复杂度会减少到 O(n/32)。</p><p><strong>所以一般用二进制状态压缩时就会用 bitset。</strong></p><p>使用时引入头文件#include<bitset></p><h4 id="定义：">定义：</h4><p>对于 <code>bitset</code> 的定义有四种方式：<br>1、直接定义，每一位初始为0：<br><code>bitset&lt;N&gt; name;</code> // 定义长度为 N 的二进制数组，命名为 name；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;8&gt; b1;</span><br><span class="line">cout &lt;&lt; b1 &lt;&lt;endl; <span class="comment">// 00000000</span></span><br></pre></td></tr></table></figure><p>2、存储数字的二进制：<br><code>bitset&lt;N&gt; name(num);</code> // 定义长度为 N 的二进制数组，命名为 name，将数字 num 的二进制存到其中；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bitset&lt;8&gt; <span class="title">b2</span><span class="params">(<span class="number">12</span>)</span></span>; <span class="comment">//二进制长度8，将12转化为二进制存到其中。</span></span><br><span class="line">cout &lt;&lt; b2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>3、存储 01字符串 对应的二进制：<br><code>bitset&lt;N&gt; name(string);</code> // 定义长度为 N 的二进制数组，命名为 name，将01串 string 存到其中，<strong>长度不够前补 0，长度过长截断</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;10010&quot;</span>;</span><br><span class="line"><span class="function">bitset&lt;8&gt; <span class="title">b3</span><span class="params">(s)</span></span>;</span><br><span class="line">cout &lt;&lt; b3 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>4、存储 01字符数组 中的二进制：<br><code>bitset&lt;N&gt; name(char[]);</code> // 定义长度为 N 的二进制数组，命名为 name，将 01字符数组存到其中，<strong>长度不够前补0，长度过长截断</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> chs[<span class="number">10</span>] = <span class="string">&quot;10010&quot;</span>;</span><br><span class="line"><span class="function">bitset&lt;8&gt; <span class="title">b4</span><span class="params">(chs)</span></span>;</span><br><span class="line">cout &lt;&lt; b4 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>直接输出 <strong>bitset</strong> 为正常的二进制，但是遍历所有位置来输出的话就是逆序的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bitset&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="number">13</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; bs &lt;&lt;endl; <span class="comment">//00001101</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++) cout&lt;&lt;bs[i]; <span class="comment">//10110000</span></span><br></pre></td></tr></table></figure><h4 id="常用操作：">常用操作：</h4><p><strong>像数字一样进行 取或 或者 左移右移：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b2 |= b3; <span class="comment">//两个二进制数取或操作； </span></span><br><span class="line">b2 &amp;= b3; <span class="comment">//两个二进制数取与操作； </span></span><br><span class="line">b2 ^= b3; <span class="comment">//取异或；</span></span><br><span class="line">b2 = ~b2; <span class="comment">//取反; </span></span><br><span class="line">b2 &lt;&lt;= <span class="number">2</span>; <span class="comment">//左移右移；自带函数：</span></span><br></pre></td></tr></table></figure><p><strong>自带函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt_1 = b2.<span class="built_in">count</span>(); <span class="comment">//查询二进制数组中，1的个数；</span></span><br><span class="line"><span class="type">int</span> len  = b2.<span class="built_in">size</span>(); <span class="comment">//二进制数组的长度，就是定义的长度； </span></span><br><span class="line"><span class="type">int</span> test = b2.<span class="built_in">test</span>(<span class="number">7</span>); <span class="comment">//判断第x个位置是0还是1，也就是输出第x个位置，注意逆序；</span></span><br><span class="line"></span><br><span class="line">b2.<span class="built_in">flip</span>(); <span class="comment">//将二进制每一位取反；</span></span><br><span class="line">b2.<span class="built_in">flip</span>(<span class="number">3</span>); <span class="comment">//将二进制第x位取反；</span></span><br><span class="line">b2.<span class="built_in">set</span>(); <span class="comment">//将二进制每一位置为1； reset置为0； </span></span><br><span class="line">b2.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">//将第x个位置置为1；</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>常用操作:</strong></p><p><strong>string ss = b2.to_string(); //将二进制数组转化为字符串.</strong></p><h2 id="代码实现">代码实现:</h2><p><strong>main.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DATA data,data1;</span><br><span class="line">    <span class="type">int</span> choose;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;选择你想使用的功能(请确保进行操作的文件路径存在):&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*****1.   编码   *****&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*****2.   解码   *****&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*****3.创建编码文件*****&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*****4.创建解码文件*****&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin &gt;&gt; choose;</span><br><span class="line">    <span class="keyword">switch</span>(choose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">inFile</span>(data);</span><br><span class="line">            <span class="built_in">transform_2_string</span>(data);</span><br><span class="line">            <span class="built_in">encode_number</span>(data);</span><br><span class="line">            <span class="built_in">transform_string_10</span>(data);</span><br><span class="line">            <span class="built_in">output_encode</span>(data);</span><br><span class="line">            <span class="built_in">outFile_encode</span>(data);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">inFile</span>(data1);</span><br><span class="line">            <span class="built_in">decode_2_string</span>(data1);</span><br><span class="line">            <span class="built_in">decode_number</span>(data1);</span><br><span class="line">            <span class="built_in">decode_string_10</span>(data1);</span><br><span class="line">            <span class="built_in">output_decode</span>(data1);</span><br><span class="line">            <span class="built_in">outFile_decode</span>(data1);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">Input_encode</span>(data);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">Input_decode</span>(data1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">// Created by 柯秋迪 on 2022/11/29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UNTITLED2_MAIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNTITLED2_MAIN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DATA</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> aci[<span class="number">64</span>]=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;Q&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;V&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;Z&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">                        <span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;/&#x27;</span>&#125;;<span class="comment">//映射表</span></span><br><span class="line">    string input;</span><br><span class="line">    string trans_input;</span><br><span class="line">    string a[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> b[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform_2_string</span><span class="params">(DATA &amp;data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encode_number</span><span class="params">(DATA &amp;data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform_string_10</span><span class="params">(DATA &amp;data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_encode</span><span class="params">(DATA &amp;data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode_2_string</span><span class="params">(DATA &amp;data1)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode_number</span><span class="params">(DATA &amp;data1)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode_string_10</span><span class="params">(DATA &amp;data1)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_decode</span><span class="params">(DATA &amp;data1)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inFile</span><span class="params">(DATA &amp;data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outFile_decode</span><span class="params">(DATA &amp;data1)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outFile_encode</span><span class="params">(DATA &amp;data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Input_encode</span><span class="params">(DATA &amp;data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Input_decode</span><span class="params">(DATA &amp;data1)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//UNTITLED2_MAIN_H</span></span></span><br></pre></td></tr></table></figure><p><strong>define.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 柯秋迪 on 2022/11/29.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform_2_string</span><span class="params">(DATA &amp;data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;data.input.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        bitset&lt;8&gt;<span class="built_in">bs</span>(data.input[i]);<span class="comment">//将数据转化为二进制储存在bs中</span></span><br><span class="line">        data.trans_input+=bs.<span class="built_in">to_string</span>();<span class="comment">//将bs中的数据转化为字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encode_number</span><span class="params">(DATA &amp;data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(data.trans_input.<span class="built_in">size</span>()%<span class="number">24</span>==<span class="number">0</span>) &#123;<span class="comment">//每一组完全占满的情况</span></span><br><span class="line">        num = data.trans_input.<span class="built_in">size</span>() / <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; data.trans_input.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                data.a[i] += data.trans_input[j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((j + <span class="number">1</span>) % <span class="number">6</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        j++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//不完全占满的情况</span></span><br><span class="line">        num = (data.trans_input.<span class="built_in">size</span>() / <span class="number">24</span>);</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">            num=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num=<span class="number">4</span>*((data.trans_input.<span class="built_in">size</span>()/<span class="number">24</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;data.trans_input.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                data.a[i]+=data.trans_input[j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=<span class="number">5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>((j+<span class="number">1</span>)%<span class="number">6</span>==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        j++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.a[i].<span class="built_in">size</span>() &lt; <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="type">size_t</span> n = data.a[i].<span class="built_in">size</span>();<span class="comment">//size()的返回值为size_t/unsigned int类型,用int型接收返回值会警告,返回值为正数</span></span><br><span class="line">            <span class="keyword">if</span> (!data.a[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span> - n; k++) &#123;</span><br><span class="line">                    data.a[i].<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);<span class="comment">//不能用0,0是数值无法加到字符串后面，0不是字符&#x27;0&#x27;才是，&#x27;0&#x27;可加到后面</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">6</span>; m++)</span><br><span class="line">                &#123;</span><br><span class="line">                    data.a[i].<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform_string_10</span><span class="params">(DATA &amp;data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.a[i]!=<span class="string">&quot;000000&quot;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> j = data.a[i].<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                sum += (data.a[i][l] - <span class="number">48</span>) * <span class="built_in">pow</span>(<span class="number">2</span>, j);<span class="comment">//</span></span><br><span class="line">                l++;<span class="comment">// 字符数字转数值</span></span><br><span class="line">            &#125;</span><br><span class="line">            data.b[i] = (<span class="type">int</span>)sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            data.b[i]=<span class="number">64</span>;<span class="comment">//对等号的单独处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_encode</span><span class="params">(DATA&amp; data)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;编码后为:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; <span class="number">64</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.b[i] == j) &#123;</span><br><span class="line">                cout &lt;&lt; data.aci[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">64</span>)<span class="comment">//与上方令其为64呼应</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode_2_string</span><span class="params">(DATA &amp;data1)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;data1.input.<span class="built_in">size</span>();n++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">64</span>; m++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data1.input[n] == data1.aci[m]) &#123;</span><br><span class="line">                    data1.input[n]=(<span class="type">char</span>)m;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;  <span class="comment">//先将需要解码的字符变为base64中匹配的aci码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data1.input.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data1.input[i]!=<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">        <span class="function">bitset&lt;6&gt; <span class="title">bs</span><span class="params">(data1.input[i])</span></span>;</span><br><span class="line">        data1.trans_input += bs.<span class="built_in">to_string</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode_number</span><span class="params">(DATA &amp;data1)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (data1.trans_input.<span class="built_in">size</span>() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        num = data1.trans_input.<span class="built_in">size</span>() / <span class="number">8</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num = (data1.trans_input.<span class="built_in">size</span>() / <span class="number">8</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; data1.trans_input.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            data1.a[i] += data1.trans_input[j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((j + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data1.a[i].<span class="built_in">size</span>() &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="type">size_t</span> k = <span class="number">8</span> - data1.a[i].<span class="built_in">size</span>();<span class="comment">//补齐8位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; k; m++)</span><br><span class="line">                data1.a[i].<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);<span class="comment">//注意不要写成0了，0为数值不能添加到字符串后面，应为&#x27;0&#x27;是字符才能放到字符串的后面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode_string_10</span><span class="params">(DATA &amp;data1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data1.a[i] != <span class="string">&quot;000000&quot;</span>) &#123;<span class="comment">//为=时就会全为0，当全为0时不会转换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">                <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = data1.a[i].<span class="built_in">size</span>() - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--, l++) &#123;</span><br><span class="line">                    sum += (data1.a[i][l] - <span class="number">48</span>) * <span class="built_in">pow</span>(<span class="number">2</span>, k);<span class="comment">// 字符数字转数值</span></span><br><span class="line">                &#125;</span><br><span class="line">                data1.b[i] = (<span class="type">int</span>) sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            data1.b[i]=<span class="number">64</span>;<span class="comment">//对等号的处理防止出现奇怪的字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_decode</span><span class="params">(DATA &amp;data1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;解码后为:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data1.b[i]!=<span class="number">64</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,data1.b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inFile</span><span class="params">(DATA &amp;data)</span></span>&#123;</span><br><span class="line">    string encode_txt;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;请输入文件路径:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; encode_txt;</span><br><span class="line">    ifstream inFile;</span><br><span class="line">    inFile.<span class="built_in">open</span>(encode_txt,ios::in);<span class="comment">//只读模式打开</span></span><br><span class="line">    <span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找不到需要编码的文件,程序已自动结束&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    inFile &gt;&gt; data.input;</span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outFile_decode</span><span class="params">(DATA &amp;data1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string encode_txt;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;请输入保存结果的文件路径:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; encode_txt;</span><br><span class="line">    ofstream outFile;</span><br><span class="line">    outFile.<span class="built_in">open</span>(encode_txt);</span><br><span class="line">    <span class="keyword">if</span>(!outFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件保存失败&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data1.b[i]!=<span class="number">64</span>)</span><br><span class="line">            outFile &lt;&lt; (<span class="type">char</span>)data1.b[i];</span><br><span class="line">    &#125;</span><br><span class="line">   outFile.<span class="built_in">close</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件保存成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outFile_encode</span><span class="params">(DATA &amp;data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string encode_txt;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;请输入保存结果的文件路径:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; encode_txt;</span><br><span class="line">    ofstream outFile;</span><br><span class="line">    outFile.<span class="built_in">open</span>(encode_txt);</span><br><span class="line">    <span class="keyword">if</span>(!outFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件保存失败&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; <span class="number">64</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.b[i] == j) &#123;</span><br><span class="line">                cout &lt;&lt; data.aci[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">64</span>)<span class="comment">//与上方令其为64呼应</span></span><br><span class="line">            outFile&lt;&lt;<span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Input_encode</span><span class="params">(DATA &amp;data)</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入编码内容:&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>();<span class="comment">//吸收回车;</span></span><br><span class="line">    <span class="built_in">getline</span>(cin,data.input);<span class="comment">//此处不用cin，否则会造成有空格的时候，会被截断,下同</span></span><br><span class="line">    <span class="built_in">transform_2_string</span>(data);</span><br><span class="line">    <span class="built_in">encode_number</span>(data);</span><br><span class="line">    <span class="built_in">transform_string_10</span>(data);</span><br><span class="line">    <span class="built_in">output_encode</span>(data);</span><br><span class="line">    <span class="built_in">outFile_encode</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Input_decode</span><span class="params">(DATA &amp;data1)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入解码内容:&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>();<span class="comment">//吸收回车;</span></span><br><span class="line">    <span class="built_in">getline</span>(cin,data1.input);</span><br><span class="line">    <span class="built_in">decode_2_string</span>(data1);</span><br><span class="line">    <span class="built_in">decode_number</span>(data1);</span><br><span class="line">    <span class="built_in">decode_string_10</span>(data1);</span><br><span class="line">    <span class="built_in">output_decode</span>(data1);</span><br><span class="line">    <span class="built_in">outFile_decode</span>(data1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法与外挂标签写法汇总</title>
      <link href="/posts/2013454d.html"/>
      <url>/posts/2013454d.html</url>
      
        <content type="html"><![CDATA[<h1>1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="1-1-代码块">1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-2-多级标题">1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-3-文字样式">1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="1-4-引用">1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-5-分割线">1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-6-列表-跟空格都可以">1.6 列表(*,+,-跟空格都可以)</h2><h3 id="1-6-1-无序列表">1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-2-有序列表">1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-7-图片">1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-8-表格">1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-9-公式">1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1>2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="2-1-行内文本样式-text">2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-2-行内文本-span">2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-3-段落文本-p">2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-4-引用note">2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-5-上标标签-tip">2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-6-动态标签-anima">2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-7-复选列表-checkbox">2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-8-单选列表-radio">2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-9-时间轴-timeline">2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-10-链接卡片-link">2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-11-按钮-btns">2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-12-github卡片-ghcard">2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-13-github徽标-ghbdage">2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-14-网站卡片-sites">2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-15-行内图片-inlineimage">2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-16-单张图片-image">2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-17-音频-audio">2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-18-视频-video">2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-19-相册-gallery">2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-20-折叠框-folding">2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-21-分栏-tab">2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-22-诗词标签-poem">2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-23-阿里图标-icon">2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-24-特效标签wow">2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-25-进度条-progress">2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-26-注释-notation">2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-27-气泡注释-bubble">2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-28-引用文献-reference">2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-29-PDF展示">2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-30-Hexo-tag-map-插件">2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-31-隐藏块">2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 外挂标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
