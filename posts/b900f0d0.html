<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>STM32(HAL库) | Thedi的仓库</title><meta name="keywords" content="嵌入式"><meta name="author" content="Thedi🍭"><meta name="copyright" content="Thedi🍭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="STM32单片机开发">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32(HAL库)">
<meta property="og:url" content="https://www.thekqd.top/posts/b900f0d0.html">
<meta property="og:site_name" content="Thedi的仓库">
<meta property="og:description" content="STM32单片机开发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.thekqd.top/assets/36.webp">
<meta property="article:published_time" content="2023-04-02T15:03:08.000Z">
<meta property="article:modified_time" content="2025-01-22T07:22:09.650Z">
<meta property="article:author" content="Thedi🍭">
<meta property="article:tag" content="嵌入式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.thekqd.top/assets/36.webp"><link rel="shortcut icon" href="https://i.postimg.cc/4xP8HS1p/Computer.png"><link rel="canonical" href="https://www.thekqd.top/posts/b900f0d0"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32(HAL库)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-22 15:22:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Thedi的仓库" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Thedi的仓库</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">STM32(HAL库)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2023-04-02T15:03:08.000Z" title="发表于 2023-04-02 23:03:08">2023-04-02</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-22T07:22:09.650Z" title="更新于 2025-01-22 15:22:09">2025-01-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">3.4w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>120分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="STM32(HAL库)"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="实验和一些好用的工具"><a href="#实验和一些好用的工具" class="headerlink" title="实验和一些好用的工具"></a>实验和一些好用的工具</h1><p><a target="_blank" rel="noopener" href="https://docs.keysking.com/docs/stm32/intro">欢迎来到 波特律动 | 波特律动 (keysking.com)</a></p>
<p><strong>串口调试助手、蓝牙调试助手</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://serial.keysking.com/">波特律动 串口助手 (keysking.com)</a></p>
<p><strong>OLED驱动库、图片字体取模</strong>：<a target="_blank" rel="noopener" href="https://led.baud-dance.com/">波特律动LED字模生成器 (baud-dance.com)</a></p>
<h1 id="讲解视频"><a href="#讲解视频" class="headerlink" title="讲解视频"></a>讲解视频</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1do4y1F7wt/?spm_id_from=333.788&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【工作STM32】第10集 STM32串口DMA模式与收发不定长数据 | keysking的stm32教程_哔哩哔哩_bilibili</a></p>
<h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="GPIO介绍"><a href="#GPIO介绍" class="headerlink" title="GPIO介绍"></a>GPIO介绍</h2><p>GPIO是<strong>通用输入输出端口</strong>（General-purpose input/output）的英文简写，是所有的微控制器必不可少的外设之一，可以由STM32直接驱动从而实现与外部设备通信、控制以及采集和捕获的功能。STM32单片机的GPIO被分为很多组，每组有16个引脚，不同型号的MCU的GPIO个数是不同的，比如STM32F103C8T6只有PA、PB以及个别PC引脚而STM32F103ZET6拥有PA~PG的全部112个引脚。<strong>所有的GPIO都有基本的输入输出功能，同时GPIO还可以作为其它的外设功能引脚</strong>。</p>
<p>作为STM32最基本的外设，GPIO最基本的输出功能是由STM32控制 引脚输出高低电平，比如可以把GPIO接LED灯来控制其亮灭，也可以接继电器或者三极管，通过继电器或三极管来控制外部大功率电路的通断。</p>
<h2 id="GPIO工作模式"><a href="#GPIO工作模式" class="headerlink" title="GPIO工作模式"></a>GPIO工作模式</h2><ul>
<li>输入模式：<ul>
<li>浮空输入</li>
<li>上拉输入(内部上拉和外部上拉)</li>
<li>下拉输入</li>
<li>模拟输入</li>
</ul>
</li>
<li>输出模式：<ul>
<li>推挽输出(PP)：高低电平均有驱动能力(一般使用)</li>
<li>开漏输出(OD,open drain)：高电平相当于高阻态，没有驱动能力，低电平有驱动能力(特殊使用)</li>
<li>开漏复用输出</li>
<li>推挽复用输出</li>
</ul>
</li>
</ul>
<p><strong>VCC：C=circuit，表示电路的意思，即接入电路的电压。</strong></p>
<p><strong>VDD：D=device，表示器件的意思，即器件内部的工作电压。</strong></p>
<p><strong>VSS：S=series，表示公共连接的意思，通常指电路公共接地端电压。</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_63094577/article/details/124489756?ops_request_misc=%7B%22request%5Fid%22%3A%22171126819716800211573854%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171126819716800211573854&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124489756-null-null.142^v99^pc_search_result_base1&amp;utm_term=stm32GPIO&amp;spm=1018.2226.3001.4187">STM32基础入门——GPIO详解_stm32gpio采集0、1信号-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44016222/article/details/123206403?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stm32GPIO&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-123206403.nonecase&amp;spm=1018.2226.3001.4187">STM32-GPIO介绍_stm32 gpio-CSDN博客</a></p>
<h2 id="点灯"><a href="#点灯" class="headerlink" title="点灯"></a>点灯</h2><h1 id="STM32启动流程"><a href="#STM32启动流程" class="headerlink" title="STM32启动流程"></a>STM32启动流程</h1><h2 id="启动文件"><a href="#启动文件" class="headerlink" title="启动文件"></a>启动文件</h2><p>startup_stm32xxx.s(汇编文件)文件具体工作</p>
<h1 id="RCC"><a href="#RCC" class="headerlink" title="RCC"></a>RCC</h1><p>stm32上的<strong>RCC(Reset and Clock Control)</strong>外设，是复位和时钟控制的英文缩写。简单理解为’’心跳’’</p>
<h2 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h2><p> 可见<strong>参考手册</strong></p>
<ul>
<li>系统复位</li>
<li>电源复位</li>
<li>后备域复位</li>
</ul>
<p>原理图上有复位电路</p>
<h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/98845509?ops_request_misc=%7B%22request%5Fid%22%3A%22171266890916800182712783%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=171266890916800182712783&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-16-98845509-null-null.142^v100^pc_search_result_base5&amp;utm_term=rcc&amp;spm=1018.2226.3001.4187">【STM32】系统时钟RCC详解(超详细，超全面)_rcc时钟-CSDN博客</a></p>
<h3 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h3><p>STM32中能够主动发出时钟信号的元器件，可以用作<strong>时钟源</strong>。STM32中有四个时钟源，还有一个辅助时钟源生成倍频时钟信号的器件锁相环。</p>
<ul>
<li><strong>HSI(高速内部时钟)</strong></li>
</ul>
<p>时钟信号由内部RC震荡电路提供，时钟频率为<strong>8MHz</strong>，但是这个时钟频率会随着温度产生漂移，<strong>很不稳定</strong>，所以一般不使用此时钟信号</p>
<ul>
<li><strong>HSE(高速外部时钟)</strong></li>
</ul>
<p>时钟信号由外部晶振提供，时钟频率一般在<strong>4-16MHz</strong>，是经常会用到的时钟源</p>
<blockquote>
<p>这里的外部晶振可以是有源晶振，也可以是无源晶振，它们的区别在于与<strong>STM32的 连接方式，以及需不需要谐振电容</strong></p>
</blockquote>
<ul>
<li><strong>LSI(低速内部时钟)</strong></li>
</ul>
<p>时钟信号由内部RC振荡电路提供，时钟频率一般为40KHz，这个信号<strong>一般用于独立看门狗时钟</strong></p>
<ul>
<li><strong>LSE(低速外部时钟)</strong></li>
</ul>
<p>时钟信号由外部晶振提供，时钟频率一般为32.768KHz，这个信号一般用于<strong>RTC实时时钟</strong></p>
<ul>
<li><strong>PLLCLK(锁相环倍频时钟)</strong></li>
</ul>
<p>PLL锁相环是辅助产生时钟信号的器件。PLL并不是自己产生的时钟源，而是通过倍频得到的时钟。将时钟信号输入锁相环，锁相环可以将这个时钟信号的频率按照<strong>指定倍率提高</strong>（倍频）之后，再输出。</p>
<blockquote>
<p>与锁相环具有相反作用的是分频器，分频器可以将输入时钟信号分率按照指定倍率降低之后，再输出。简单理解<strong>分频就是做除法</strong></p>
</blockquote>
<h3 id="系统时钟SYSCLK"><a href="#系统时钟SYSCLK" class="headerlink" title="系统时钟SYSCLK"></a>系统时钟SYSCLK</h3><p>系统时钟SYSCLK可<strong>来源于三个时钟源</strong>：</p>
<ul>
<li><strong>HSI振荡器时钟</strong></li>
<li><strong>HSE振荡器时钟</strong></li>
<li><strong>PLLCLK时钟</strong></li>
</ul>
<h2 id="配置时钟树"><a href="#配置时钟树" class="headerlink" title="配置时钟树"></a>配置时钟树</h2><p>STM32CubeMX一般填入指定最大即可</p>
<p>但对STM32上的时钟，具体怎么配置，根据需求决定。时钟频率选取越高，功耗也会越高。</p>
<p>所以实际情况中考虑芯片的工作条件，根据芯片运行的工作条件选取时钟频率</p>
<p>相关AHB、APB1、APB2总线上的时钟工作条件可以在STM32数据手册的通用工作条件模块可以查看到满足的条件</p>
<h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><p><strong>中断概念</strong>：中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续执行。</p>
<p><strong>STM32中断触发后流程</strong>：</p>
<p>触发中断-&gt;中断向量表(存放中断服务函数地址)-&gt;偏移：入口地址</p>
<p>中断可以分为<strong>内部中断</strong>和<strong>外部中断</strong>：</p>
<p><strong>外部中断</strong>：STM32说的中断一般指这个外部中断，发生在<strong>处理器外部</strong>连接的设备或外部信号，例如按键按下、外部传感器信号变化等。外部中断用于响应外部事件，并及时处理相关任务。</p>
<p><strong>异常(内部中断)</strong>：异常和中断概念相近，异常可以说是<strong>内核活动(处理器内部)产生</strong>，比如执行<strong>未定义指令、除零运算</strong>等发生在CPU内部的意外事件。这些异常的发生，会引起CPU运行相应的异常处理程序，因为发生在处理器内部，故叫做<strong>内部中断</strong>。</p>
<p><strong>注</strong>：中断一般指连接到内核的<strong>外部器件(外设)</strong>产生，。使用一般不严格区分中断和异常，但无论是异常还是中断，都会引起程序执行偏离正常的流程，转而去执行异常/中断的处理函数。</p>
<h2 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h2><p><strong>中断优先级分为两种</strong>：</p>
<ol>
<li><p><strong>可编程</strong></p>
</li>
<li><p><strong>不可编程</strong></p>
</li>
</ol>
<p>STM32的中断优先级，决定着内核优先响应谁的中断请求:</p>
<ul>
<li><strong>中断优先级数值越小，优先级越大</strong>，中断会被优先响应</li>
<li>中断优先级按照<strong>优先级分组</strong>配置</li>
</ul>
<blockquote>
<p>在STM32的芯片参考手册中可以找到中断向量表，里面可找到优先级数值等信息</p>
</blockquote>
<h2 id="优先级分组"><a href="#优先级分组" class="headerlink" title="优先级分组"></a>优先级分组</h2><p>在优先级分组中存在<strong>抢占优先级</strong>和<strong>子优先级</strong></p>
<p>分组个数和各优先级数值图片：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41066277/article/details/88728661?ops_request_misc=%7B%22request%5Fid%22%3A%22171275025416800215044240%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171275025416800215044240&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-88728661-null-null.142^v100^pc_search_result_base5&amp;utm_term=中断优先级分组&amp;spm=1018.2226.3001.4187">stm32入门篇—中断的初步认识及其优先级和分组_中断优先级和分组-CSDN博客</a></p>
<ol>
<li>通过优先级分组，我们可以管理中断的响应顺序</li>
</ol>
<ol>
<li>只有抢占优先级才具有抢占中断的权限，打断了就发生了<strong>中断嵌套</strong></li>
</ol>
<blockquote>
<p><strong>中断嵌套</strong>：中断嵌套是指中断系统正在执行一个中断服务时，有另一个抢占优先级更高的中断提出，这时会暂时终止当前正在执行的级别较低的的，去处理级别更高的中断源，待处理完毕，再返回到被中断了的的过程。</p>
<p>例如：B中断正在执行，突然发生了A中断，<strong>但是A中断的抢占优先级数值更小比B的更小(数值更小，    A抢占优先级更高)</strong>，A中断则抢过B中断的使用权，响应A的中断服务函数，A中断执行完毕后再交回B继续执行。</p>
</blockquote>
<ol>
<li>如果中断抢占优先级相同，将不会发生抢占行为(只能乖乖的排队等待),这就叫做<strong>中断挂起</strong></li>
</ol>
<ol>
<li>如果多个在挂起状态的中断具有<strong>相同的抢占优先级</strong>，则<strong>子优先级高的先响应</strong>，如果<strong>子优先级也相同</strong>，则由<strong>IRQ编号(中断编号)小的响应</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一些中断编号的定义，一般在芯片头文件中找到，下列为stm32f103xe.h*/</span> </span><br><span class="line">NonMaskableInt_IRQn         = <span class="number">-14</span>,    </span><br><span class="line"> HardFault_IRQn              = <span class="number">-13</span>,   </span><br><span class="line"> MemoryManagement_IRQn       = <span class="number">-12</span>,    </span><br><span class="line"> BusFault_IRQn               = <span class="number">-11</span>,    </span><br><span class="line"> UsageFault_IRQn             = <span class="number">-10</span>,   </span><br><span class="line"> SVCall_IRQn                 = <span class="number">-5</span>,    </span><br><span class="line"> DebugMonitor_IRQn           = <span class="number">-4</span>,    </span><br><span class="line"> PendSV_IRQn                 = <span class="number">-2</span>,     </span><br><span class="line"> SysTick_IRQn                = <span class="number">-1</span>, </span><br></pre></td></tr></table></figure>
<p><strong>总结</strong>：抢占优先级&gt;子优先级&gt;IRQ编号。</p>
<ol>
<li><strong>可编程的优先级</strong>，可以通过<strong>嵌套向量中断控制器(NVIC)</strong>实现</li>
</ol>
<h2 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h2><p>NVIC（Nested Vectored Interrupt Controller）-<strong>嵌套向量中断控制器</strong>，是STM32系列微控制器中的中断控制器模块，其主要功能如下：</p>
<ol>
<li>中断优先级管理</li>
<li>中断使能和禁止</li>
<li>中断嵌套</li>
<li>中断状态控制</li>
<li>中断向量表管理</li>
</ol>
<p><strong>通常在STM32CubeMX中开启各EXTI线的中断</strong></p>
<p>有关EXTI和NVIC的介绍：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_56694518/article/details/131260526?ops_request_misc=%7B%22request%5Fid%22%3A%22171275275416800186516157%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171275275416800186516157&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-131260526-null-null.142^v100^pc_search_result_base5&amp;utm_term=stm32内部中断&amp;spm=1018.2226.3001.4187">STM32的中断系统详解（嵌入式学习）_stm32中断嵌套-CSDN博客</a></p>
<h2 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h2><p>EXTI(External interrupt/event controller)，是STM32的<strong>外部中断/事件控制器</strong>，是STM32的外设，用于处理外部引脚的中断请求。EXTI模块与NVIC紧密合作，使得处理器能够响应外部事件并执行相应的中断处理程序。</p>
<p>通过EXTI线，捕获EXTI线事件，并且去生成中断，在中断回调函数中，翻转LED状态，并且<strong>清除EXTI中断标志</strong>(中断标志要清除不然就会一直产生中断)。</p>
<blockquote>
<p>使用外部中断模块特性：</p>
<p>对于STM32来说，想要获取的信号是外部的很快的突发信号。由外部驱动，STM32只能被动读取。</p>
</blockquote>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="外部按键中断控制LED亮灭"><a href="#外部按键中断控制LED亮灭" class="headerlink" title="外部按键中断控制LED亮灭"></a>外部按键中断控制LED亮灭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span>	</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">						</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (GPIO_Pin == KEY0_Pin) </span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试时发现灯的行为有一些奇怪，比如闪烁，不完全亮等情况会发生，所以需要按键消抖。</p>
<h3 id="按键消抖"><a href="#按键消抖" class="headerlink" title="按键消抖:"></a>按键消抖:</h3><p>当用户按下一个物理按键时，由于<strong>按键使用的是机械式弹簧片的结构</strong>，通常会导致按键在接通和断开状态之间快速切换，造成一系列的开关状态变化。<strong>这种短暂的状态变化称为按键抖动</strong>。按键抖动可能会导致系统误以为用户进行了多次按键操作，从而引发意外行为或错误。</p>
<p>抖动时间的长短由按键的机械特性决定，<strong>一般为5ms～10ms</strong>。这是一个很重要的时间参数，在很多场合都要用到。按键稳定闭合时间的长短则是由操作人员的按键动作决定的，一般为零点几秒至数秒。为确保CPU对键的一次闭合仅作一次处理，必须去除键抖动。在键闭合稳定时读取键的状态，并且必须判别到键释放稳定后再作处理。</p>
<p><strong>按键消抖分为硬件消抖和软件消抖</strong>:</p>
<ul>
<li><p>硬件消抖：一般是添加RC滤波电容</p>
</li>
<li><p>软件消抖：延时函数按键消抖或者定时器按键消抖或状态机消抖，<strong>消抖时间设置为20ms-100ms即可</strong></p>
</li>
</ul>
<blockquote>
<p><strong>首先一定要在CubeMX中的按键引脚设置为上拉(pull up)状态，不要设置为浮空输入(no pull up and no pull down)。</strong></p>
<p><strong>做了按键消抖却失效的原因</strong>：</p>
<p>按键消抖的有效性通常取决于按键引脚的电气特性，尤其是在没有上拉或下拉电阻的情况下。<strong>没有上拉电阻时，处于浮空输入状态，按键引脚可能会更容易受到电气噪声和抖动等外部环境的影响，从而使消抖无法正常工作。</strong></p>
</blockquote>
<h4 id="轮询按键控制LED亮灭-延时消抖"><a href="#轮询按键控制LED亮灭-延时消抖" class="headerlink" title="轮询按键控制LED亮灭(延时消抖)"></a>轮询按键控制LED亮灭(延时消抖)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_RESET)<span class="comment">//按下检测!</span></span><br><span class="line">    &#123;</span><br><span class="line">        HAL_Delay(<span class="number">20</span>);<span class="comment">//延时消抖</span></span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_RESET)<span class="comment">//再次确认是否按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_TogglePin(LED_BLUE_GPIO_Port,LED_BLUE_Pin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_RESET)&#123;&#125;;<span class="comment">//松手检测!</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>()<span class="comment">//其他颜色的灯同理...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>优点：代码简单</strong></p>
<p><strong>缺点：delay会使cpu空等浪费时间</strong></p>
</blockquote>
<h4 id="外部中断-定时器消抖-推荐"><a href="#外部中断-定时器消抖-推荐" class="headerlink" title="外部中断+定时器消抖(推荐)"></a>外部中断+定时器消抖(推荐)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*消抖时间设置为20ms-100ms即可,一般设置为20ms,Pre=7199,arr=199~500*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(GPIO_Pin == KEY1_Pin)</span><br><span class="line">  &#123;</span><br><span class="line">       HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_TIM_Base_Stop_IT(&amp;htim2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_TogglePin(LED_BLUE_GPIO_Port,LED_BLUE_Pin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>优点</strong>：cpu并没有浪费时间</p>
<p><strong>缺点</strong>：会浪费一个定时器</p>
<p><strong>注意</strong>：在CubeMX配置时注意上升沿触发还是下降沿触发,可能效果会不同,一般都是<strong>设置下降沿触发</strong>，按下开关为低电平</p>
<p><strong>注意</strong>：</p>
<p><strong>别在中断回调函数中使用延时函数，可能会出现神奇的bug，严重会导致死机</strong></p>
</blockquote>
<h4 id="按键状态机消抖"><a href="#按键状态机消抖" class="headerlink" title="按键状态机消抖"></a>按键状态机消抖</h4><h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p><code>volatile关键字作用：</code>避免编译器优化。编译器优化会可以去除无用的繁杂代码，降低代码空间，提升运行效率，但优化后编译器在某些地方可能会弄巧成拙。</p>
<p><code>例1：</code>空循环延时，编译器就会觉得没什么用浪费时间，会直接给你优化掉</p>
<p><code>例2：</code></p>
<p><strong>中断方式下，如果需要访问全局变量，最好把全局变量使用 volatile 来进行修饰，避免编译器对该 变量进行优化。</strong></p>
<p>具体参考  <a target="_blank" rel="noopener" href="https://blog.csdn.net/dengjin20104042056/article/details/107716564">https://blog.csdn.net/dengjin20104042056/article/details/107716564</a>  。</p>
<p>主函数和中断处理函数相当于两个线程，因为编译器的优化，在一个线程中改变一个全局变量的值，另外一个线程读取到的可能是没有改变前的值，因此需要用 volatile 来标识这个变量，让编译器不优化这个变量的存储（这个变量的值可能因为编译器的优化在寄存器中进行改变，而不是在真 正的内存区间）。这个问题书上在中断这部分也说明了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> A;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    A...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span><br><span class="line">&#123;</span><br><span class="line">    A....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="SysTick系统定时器"><a href="#SysTick系统定时器" class="headerlink" title="SysTick系统定时器"></a>SysTick系统定时器</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>SysTick系统定时器(又叫系统滴答定时器)是属于 Cortex-M3 <strong>内核中的一个外设，内嵌在 NVIC中</strong>。系统定时器是一个计数宽度24bit的向下递减的计数器，计数器每计数一次的时间为 1/SYSCLK，一般我们设置系统时钟 SYSCLK等于72M。<strong>当重装载数值寄存器的值递减到 0 的时候，系统定时器就产生一次中断，以此循环往复</strong>。</p>
<p>因为 SysTick 是属于 CM3 内核的外设，所以所有基于 Cortex-M 内核的单片机都具有这个系统定时器，使得软件在 CM3 单片机中可以很容易的移植。</p>
<ul>
<li>计数宽度：24bit来储存数据，2^24=16,777,216</li>
<li>向下递减：计数器的工作模式</li>
<li>计数器的工作周期：1/CLKSource，1/72Mhz(每-1的时间为1/72000000)</li>
</ul>
<p><strong>常用功能</strong>：</p>
<ul>
<li><p>系统定时器一般用于操作系统，用于产生时基，维持操作系统的心跳</p>
</li>
<li><p>最常用的功能是计数。比如用来进行微秒、毫秒的延时，以此产生特定时序</p>
</li>
</ul>
<h2 id="寄存器介绍"><a href="#寄存器介绍" class="headerlink" title="寄存器介绍"></a>寄存器介绍</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/PORKWOTONLEE/article/details/121154152?ops_request_misc=%7B%22request%5Fid%22%3A%22171309432516800184129019%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=171309432516800184129019&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-121154152-null-null.142^v100^pc_search_result_base2&amp;utm_term=Systick定时器寄存器介绍&amp;spm=1018.2226.3001.4187">第7课【SysTick定时器】中断 系统定时器 寄存器-CSDN博客</a></p>
<p><strong>HAL库中HAL_Delay是基于SysTick来实现，使用时基源SysTick</strong></p>
<h2 id="uwTick"><a href="#uwTick" class="headerlink" title="uwTick"></a>uwTick</h2><p><code>uwTick</code> 是 STM32 中用于存储系统运行时间的变量，它在 <code>HAL</code> 库中与滴答定时器（SysTick）一起使用，通常用于实现毫秒级的计时。<code>uwTick</code> 是一个全局变量，保存了从系统启动开始经过的毫秒数，通常用于延时、超时管理或作为定时器的时间基准。</p>
<h3 id="uwTick的工作原理"><a href="#uwTick的工作原理" class="headerlink" title="uwTick的工作原理"></a>uwTick的工作原理</h3><ul>
<li><code>uwTick</code> 由系统的滴答定时器（SysTick Timer）自动递增。每当 SysTick 定时器触发中断时，<code>uwTick</code> 的值增加 1，表示已经过去了 1 毫秒。</li>
<li><code>HAL_InitTick()</code> 函数会初始化 <code>uwTick</code>，并确保 SysTick 定时器按照指定的时钟频率（通常是 1ms）定期递增。</li>
</ul>
<h3 id="uwTick的使用场景"><a href="#uwTick的使用场景" class="headerlink" title="uwTick的使用场景"></a>uwTick的使用场景</h3><ul>
<li><strong>延时函数</strong>：<code>uwTick</code> 可用于在没有 RTOS 的情况下实现毫秒级的延时函数。</li>
<li><strong>定时任务</strong>：可以使用 <code>uwTick</code> 来实现周期性定时任务。</li>
<li><strong>超时管理</strong>：可以通过 <code>uwTick</code> 计算超时，进行时间监控。</li>
</ul>
<h3 id="如何配置和使用-uwTick"><a href="#如何配置和使用-uwTick" class="headerlink" title="如何配置和使用 uwTick"></a>如何配置和使用 uwTick</h3><p>在 STM32 系列中，<code>uwTick</code> 是由 <code>HAL</code> 库自动管理的，因此你不需要手动操作它，只需配置好 SysTick 定时器，并让它触发 <code>uwTick</code> 的更新。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在调用 <code>HAL_Init()</code> 时，<code>HAL_InitTick()</code> 会被自动调用，确保滴答定时器已启用并正确地递增 <code>uwTick</code>。</p>
<h4 id="读取-uwTick"><a href="#读取-uwTick" class="headerlink" title="读取 uwTick"></a>读取 uwTick</h4><p>你可以直接读取 <code>uwTick</code> 来获取从系统启动以来的毫秒数。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">uint32_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> startTick = uwTick;</span><br><span class="line">    <span class="keyword">while</span> ((uwTick - startTick) &lt; ms)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 等待指定的毫秒数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数可以实现一个简单的延时功能，利用 <code>uwTick</code> 的递增特性来实现时间等待。</p>
<h4 id="获取系统启动后的时间"><a href="#获取系统启动后的时间" class="headerlink" title="获取系统启动后的时间"></a>获取系统启动后的时间</h4><p><code>uwTick</code> 保存了系统从启动以来经过的毫秒数。如果你需要获取系统的运行时间，可以直接读取 <code>uwTick</code>。</p>
<p>例如，获取系统启动后的运行时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">getSystemUptime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> uwTick;  <span class="comment">// 返回从启动以来的毫秒数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理溢出问题"><a href="#处理溢出问题" class="headerlink" title="处理溢出问题"></a>处理溢出问题</h4><p><code>uwTick</code> 是一个 32 位无符号整数，因此当它达到最大值（0xFFFFFFFF）时会溢出回 0。一般情况下，你不需要担心溢出问题，因为 <code>uwTick</code> 的更新是连续的，你可以通过以下方式避免溢出导致的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">getTickDiff</span><span class="params">(<span class="type">uint32_t</span> startTick)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (uwTick - startTick);  <span class="comment">// 自动处理溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，你可以计算当前 <code>uwTick</code> 和之前记录的时间差，无论它是否经历了溢出。</p>
<h3 id="HAL-Delay"><a href="#HAL-Delay" class="headerlink" title="HAL_Delay"></a>HAL_Delay</h3><p>HAL_Delay()函数就是使用系统滴答定时器Systick实现的。</p>
<h3 id="自定义延时函数"><a href="#自定义延时函数" class="headerlink" title="自定义延时函数"></a>自定义延时函数</h3><p>除了使用 <code>HAL_Delay()</code>，你也可以编写自定义延时函数。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_ms_custom</span><span class="params">(<span class="type">uint32_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> start_tick = uwTick;</span><br><span class="line">    <span class="keyword">while</span> ((uwTick - start_tick) &lt; ms) &#123;</span><br><span class="line">        <span class="comment">// 可以放置其他任务或者空闲等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>定时精度</strong>：<code>uwTick</code> 的精度依赖于系统时钟频率，如果系统时钟较低，延时精度可能不如高精度时钟。</li>
<li><strong>溢出</strong>：<code>uwTick</code> 是一个 32 位计数器，每 49.7 天会溢出一次。大部分应用场景中不需要特别处理溢出问题，除非你需要精确计时更长时间段。</li>
<li><strong>RTOS 与 <code>uwTick</code></strong>：如果使用 RTOS（如 FreeRTOS），<code>uwTick</code> 可以作为 RTOS 内部定时器的基础，进行任务调度和延时处理。</li>
</ul>
<h2 id="uwTick与硬件定时器外设区别"><a href="#uwTick与硬件定时器外设区别" class="headerlink" title="uwTick与硬件定时器外设区别"></a>uwTick与硬件定时器外设区别</h2><h3 id="uwTick-1"><a href="#uwTick-1" class="headerlink" title="uwTick"></a>uwTick</h3><ul>
<li><strong>来源</strong>：<code>uwTick</code> 是由 <strong>SysTick 定时器</strong>（系统定时器）更新的全局变量，通常用于提供一个基于毫秒的系统时基。它是由 STM32 的 <strong>Cortex-M 内核</strong>提供，通常用于时间管理和简单的延时。</li>
<li><strong>精度</strong>：<code>uwTick</code> 的精度取决于系统时钟频率（通常是 1 毫秒）。对于很多应用场景，这种精度足够了。</li>
<li><strong>功能</strong>：<code>uwTick</code> 只是一个软件计数器，它每 1 毫秒递增，并通过 SysTick 中断（如果启用）更新。它通常用于：<ul>
<li>延时操作（比如定时任务、超时控制）。</li>
<li>简单的时间基准（比如计算系统运行时间）。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>简单易用，尤其是没有 RTOS 时，它可以作为一个基本的定时机制。</li>
<li>使用非常灵活，可以通过 <code>uwTick</code> 实现延时、超时、周期性任务等功能。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>只能提供低精度的时间基准（通常为 1 毫秒）。</li>
<li>不能直接处理复杂的定时器任务，如生成特定频率的 PWM 信号，或者需要高精度计时的应用。</li>
</ul>
</li>
</ul>
<h3 id="硬件定时器外设"><a href="#硬件定时器外设" class="headerlink" title="硬件定时器外设"></a>硬件定时器外设</h3><ul>
<li><strong>来源</strong>：硬件定时器是 STM32 提供的专用硬件模块，它们可以用来精确地生成定时中断、PWM 输出、计数器等。STM32 通常具有多个定时器外设（如 TIM1、TIM2 等）。</li>
<li><strong>精度</strong>：硬件定时器的精度非常高，通常由定时器的计数时钟频率（通常是系统时钟或 APB 时钟的一部分）决定，可以达到微秒级别的精度。硬件定时器可以配置为不同的分频因子，以适应不同的应用需求。</li>
<li><strong>功能</strong>：硬件定时器可以用于：<ul>
<li>生成高精度的定时中断。</li>
<li>生成 PWM 波形输出。</li>
<li>实现高精度延时、时间测量和计数。</li>
<li>用于编码器、频率测量、信号发生等。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>提供高精度定时。</li>
<li>不需要依赖系统时钟或软件轮询，硬件定时器直接生成中断，效率较高。</li>
<li>可以配置为多种不同模式，如 PWM、脉冲计数、输入捕获等。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>配置较复杂，尤其是在需要多种不同定时器功能时，配置工作量较大。</li>
<li>受限于硬件资源，每个 STM32 芯片上有固定数量的定时器。</li>
</ul>
</li>
</ul>
<h3 id="使用场景分析"><a href="#使用场景分析" class="headerlink" title="使用场景分析"></a>使用场景分析</h3><h4 id="使用-uwTick-的场景"><a href="#使用-uwTick-的场景" class="headerlink" title="使用 uwTick 的场景"></a>使用 uwTick 的场景</h4><p><code>uwTick</code> 主要适用于以下场景：</p>
<ul>
<li><p><strong>简单的定时器应用</strong>：如延时、超时控制、周期性任务等。如果你的系统不需要极高的定时精度，并且不需要复杂的定时任务管理，<code>uwTick</code> 是一个非常便捷的选择。</p>
<p>例如：</p>
<ul>
<li><strong>延时功能</strong>：你可以用 <code>uwTick</code> 实现简单的延时操作（如延时 1 秒、5 秒等）。</li>
<li><strong>超时检测</strong>：在没有 RTOS 的情况下，可以用 <code>uwTick</code> 检测外部事件是否超时（如等待串口数据、等待传感器响应等）。</li>
<li><strong>周期性任务</strong>：比如每 100 毫秒执行一次某些任务，使用 <code>uwTick</code> 来检测时间是否满足周期要求。</li>
</ul>
</li>
<li><p><strong>低精度任务</strong>：当任务不依赖于极高的定时精度时，<code>uwTick</code> 足够满足需求。比如一些简单的 LED 闪烁、定时任务等。</p>
</li>
</ul>
<h4 id="使用硬件定时器外设的场景"><a href="#使用硬件定时器外设的场景" class="headerlink" title="使用硬件定时器外设的场景"></a>使用硬件定时器外设的场景</h4><p>硬件定时器外设适用于以下场景：</p>
<ul>
<li><p><strong>高精度定时任务</strong>：如精确的时间测量、频率产生等。硬件定时器可以提供比 <code>uwTick</code> 更高精度的定时，通常是微秒级别。</p>
<p>例如：</p>
<ul>
<li><strong>PWM 生成</strong>：当你需要控制电机、灯光等硬件时，通常需要高精度的 PWM 信号，这时就需要硬件定时器。</li>
<li><strong>频率计数</strong>：通过硬件定时器的输入捕获功能，可以精确地测量信号的频率。</li>
<li><strong>精确延时</strong>：对于一些要求非常精确延时的场景，如通信协议中的时序控制，硬件定时器可以提供更高的精度。</li>
</ul>
</li>
<li><p><strong>复杂的定时功能</strong>：如果你需要多个定时器同步运行，或者需要定时器在某个特定事件（如输入信号）时产生中断，硬件定时器会是一个更合适的选择。</p>
</li>
<li><p><strong>RTOS 应用</strong>：在 RTOS 环境中，硬件定时器通常用于管理任务的时间片，或者作为周期性任务的时基。</p>
</li>
<li><p><strong>硬件事件捕捉</strong>：硬件定时器支持的输入捕获模式使得它可以捕捉外部信号的事件，如测量脉冲宽度、时间间隔等。</p>
</li>
</ul>
<h3 id="总结对比表"><a href="#总结对比表" class="headerlink" title="总结对比表"></a>总结对比表</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250117235719124-17375302847761.png" alt="image-20250117235719124"></p>
<h1 id="通讯概念"><a href="#通讯概念" class="headerlink" title="通讯概念"></a>通讯概念</h1><h2 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h2><p>通讯方式分类：</p>
<ul>
<li><strong>串行通讯和并行通讯</strong></li>
</ul>
<p>按数据传送的方式，通讯可分为串行通讯与并行通讯，<strong>串行通讯是指设备之间通过少量数据信号线 (一般是 8 根以下)，地线以及控制信号线，按数据位形式一位一位地传输数据的通讯方式</strong>。<strong>并行通讯一般是指使用 8、16、32 及 64 根或更多的数据线进行传输的通讯方式，并行通讯就像多个车道的公路，可以同时传输多个数据位的数据</strong>。而串行通讯，而串行通讯就像单个车道的公路，同一时刻只能传输一个数据位的数据。</p>
<p><strong>一般情况下，串行通讯成本更低(节省数据线),且通讯距离、抗干扰能力较强，但传输速率较慢</strong></p>
<ul>
<li><strong>全双工通讯、半双工、单工通讯</strong><ul>
<li>全双工 ：在同一时刻，两个设备之间可以同时收发数据</li>
<li>半双工：在同一时刻，两个设备之间可以收发数据，但不能在同一时刻进行</li>
<li>单工 ：在任何时刻都只能进行一个方向的通讯，即一个固定为发送设备，另一个固定为接收设备</li>
</ul>
</li>
</ul>
<ul>
<li><strong>同步通讯和异步通讯</strong></li>
</ul>
<p>根据<strong>通讯的数据同步方式</strong>，又分为同步和异步两种，可以根据通讯过程中<strong>是否有使用到时钟信号</strong>进行简单的区分，<strong>使用时钟信号的叫同步通讯，未使用时钟信号则叫异步通讯</strong>。</p>
<p>在同步通讯中，收发设备双方会使用一根信号线表示时钟信号，在时钟信号的驱动下双方进行协调，同步数据，<strong>通讯中通常双方会统一规定在时钟信号的上升沿或下降沿对数据线进行采样</strong>。</p>
<h2 id="通讯速率"><a href="#通讯速率" class="headerlink" title="通讯速率"></a>通讯速率</h2><p>衡量通讯性能的一个非常重要的参数就是通讯速率，通常以<strong>比特率</strong> (Bitrate) 来表示，即<strong>每秒钟传输的二进制位数，单位为比特每秒 (bit/s)</strong>。</p>
<p>容易与比特率混淆的概念是“<strong>波特率</strong>”(Baudrate)，它表示<strong>每秒钟传输了多少个码元</strong>。而码元是通讯信号调制的概念，通讯中常用时间间隔相同的符号来表示一个二进制数字，这样的信号称为<strong>码元</strong>。如常见的通讯传输中，用 0V 表示数字 0，5V 表示数字 1，那么一个码元可以表示两种状态 0 和 1，所以<strong>一个码元等于一个二进制比特位，此时波特率的大小与比特率一致</strong>；如果在通讯传输中，有 0V、2V、4V 以及 6V 分别表示二进制数 00、01、10、11，那么<strong>每个码元可以表示四种状态，即两个二进制比特位，所以码元数是二进制比特位数的一半，这个时候的波特率为比特率的一半。</strong></p>
<p>因为很多常见的通讯中一个码元都是表示两种状态，人们常常直接以波特率来表示比特率，虽然严格来说没什么错误，但不能混淆。</p>
<h1 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43743762/article/details/97811470?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stm32usart串口通信&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-97811470.142^v100^pc_search_result_base2&amp;spm=1018.2226.3001.4187">STM32—串口通讯详解_串口通讯的原理流程图-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/99073783">【STM32】HAL库 STM32CubeMX教程四—-UART串口通信详解_hal_uart_transmit-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fuhanghang/article/details/123280368?ops_request_misc=%7B%22request%5Fid%22%3A%22171370716116800226596446%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171370716116800226596446&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-123280368-null-null.142^v100^pc_search_result_base8&amp;utm_term=CH340芯片&amp;spm=1018.2226.3001.4187">ch340是什么芯片_ch340是干嘛的-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59161987/article/details/128480063">STM32 —— USB 转 TTL（CH340）-CSDN博客</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>USART-通用同步/异步收发器(Universal Synchronous/Asynchronous Receiver/Transmitter)，USART是一个全双工通用同步/异步串行收发模块，该接口是一个高度灵活的串行通信设备。</p>
<blockquote>
<ul>
<li>STM32中的USART外设可以实现<strong>同步传输</strong>功能，所以命名为USART，比UART多了一个S，即synchronous(同步)</li>
</ul>
</blockquote>
<p>UART器件<strong>主要用来产生相关接口的协议信号</strong>，如<code>TTL串口</code> /<code>RS232</code>/<code>RS485</code>等<strong>串行接口标准规范和总线的标准规范</strong>，要使用传输数据的这些接口，就要按照接口规定的协议信号发送数据。所以<strong>UART期间广泛应用于串口通信中，扮演者传输者的角色</strong>。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>STM32的串口通常用于与其他设备进行通信。</p>
<p><strong>它可以用于与计算机、其他微控制器、传感器、显示屏或其他外围设备进行数据传输</strong>。串口通常用于发送和接收数据，可以是文本、二进制数据或其他格式。</p>
<p><strong>常见的应用</strong>：</p>
<p>通过<strong>串口进行调试、控制外部设备、传感器数据采集和与外部设备进行通信等</strong>。串口通常是嵌入式系统中基本且常用的通信接口之一。</p>
<h2 id="串口接受与发送"><a href="#串口接受与发送" class="headerlink" title="串口接受与发送"></a>串口接受与发送</h2><p>在 <strong>stm32f4xx_hal.c</strong>中包含#include <stdio.h></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> UART_HandleTypeDef huart1;   <span class="comment">//声明串口</span></span><br></pre></td></tr></table></figure>
<p><strong>重定向printf函数：</strong></p>
<p>在 <strong>stm32f4xx_hal.c</strong> 中重写fget和fput函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数功能: 重定向c库函数printf到DEBUG_USARTx</span></span><br><span class="line"><span class="comment">  * 输入参数: 无</span></span><br><span class="line"><span class="comment">  * 返 回 值: 无</span></span><br><span class="line"><span class="comment">  * 说    明：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, (<span class="type">uint8_t</span> *)&amp;ch, <span class="number">1</span>, HAL_MAX_DELAY);</span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数功能: 重定向c库函数getchar,scanf到DEBUG_USARTx</span></span><br><span class="line"><span class="comment">  * 输入参数: 无</span></span><br><span class="line"><span class="comment">  * 返 回 值: 无</span></span><br><span class="line"><span class="comment">  * 说    明：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint8_t</span> ch = <span class="number">0</span>;</span><br><span class="line">  HAL_UART_Receive(&amp;huart1, &amp;ch, <span class="number">1</span>, HAL_MAX_DELAY);<span class="comment">//该函数在轮询中会堵塞执行</span></span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * UART_HandleTypeDef *huart      UATR的别名    如 :   </span></span><br><span class="line"><span class="comment">  * UART_HandleTypeDef huart1;   别名就是huart1  </span></span><br><span class="line"><span class="comment">  *	*pData      需要发送的数据 </span></span><br><span class="line"><span class="comment">  *  Size    发送的字节数</span></span><br><span class="line"><span class="comment">  * Timeout   最大发送时间，发送数据超过该时间退出发送   </span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在main函数中使用printf、getchar、scanf等*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch = getchar();<span class="comment">//从串口获取单个字符</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="USART中断"><a href="#USART中断" class="headerlink" title="USART中断"></a>USART中断</h2><p>轮询状态下的串口接收数据会使cpu效率一直查看是否有数据，干不了其他事情，使程序堵塞，效率低下。但如果使用中断发送和接收比较高效,cpu需要处理时会被叫回处理，其他时间可以干其他事情,不会长期占用cpu时间。</p>
<blockquote>
<p><strong>轮询模式是阻塞模式，程序会等到所有数据发送/接收完成后才会着向下执行</strong></p>
<p><strong>而中断和DMA是非阻塞模式，他们将任务交给外设后就会接着向下执行，不会等待数据发送/接收完成</strong></p>
</blockquote>
<p><strong>主要有三个函数</strong>：</p>
<ul>
<li><strong>串口中断处理函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_IRQHandler(UART_HandleTypeDef *huart);  </span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>：对接收到的数据进行判断和处理 <strong>判断是发送中断还是接收中断</strong>，然后进行数据的发送和接收，在中断服务函数中使用</p>
<ul>
<li><strong>中断接收数据</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>中断发送数据</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>串口接收中断回调函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span><br><span class="line">&#123;</span><br><span class="line">    .......</span><br><span class="line">        </span><br><span class="line">    HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);<span class="comment">//再次开启串口接收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cplt代表 complete完成，代表接收完成后触发中断回调</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：别忘了在中断回调函数中重新启动接收</strong></p>
<ul>
<li><strong>空闲中断idle对应回调函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart2, rData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="keyword">sizeof</span>(rData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ex代表扩展</span></span><br><span class="line"><span class="comment"> * 参数2：size代表接收的数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h2 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h2><h3 id="USART1普通中断回显实验"><a href="#USART1普通中断回显实验" class="headerlink" title="USART1普通中断回显实验"></a>USART1普通中断回显实验</h3><p><strong>主要的函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;haurt1,(<span class="type">uint8_t</span>*)&amp;buffer,<span class="number">1</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数功能: 用于启用串口的接收中断，并指定接收数据存放位置。每当接收到数据时，将触发一个中断，然后调用相应的中断回调函数处理接收数据</span></span><br><span class="line"><span class="comment">  * 输入参数: 一共三个，串口别名，数据存放地址，字节数</span></span><br><span class="line"><span class="comment">  * 返 回 值: 无</span></span><br><span class="line"><span class="comment">  * 说    明：无</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>UART_HandleTypeDef <em>huart   <em>*UATR的别名</em></em>  如 :  UART_HandleTypeDef huart1;  别名就是huart1 </li>
<li><em>pData   <em>*接收到的数据存放地址</em></em></li>
<li>Size  <strong>一次接收的字节数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数功能: 串口接收中断回调函数，由用户自己编写,当接收到一个或多个字符后会被调用。在这个函数中处理接收到的数据，比如回显到终端或者储存到缓冲区中</span></span><br><span class="line"><span class="comment">  * 输入参数: 无</span></span><br><span class="line"><span class="comment">  * 返 回 值: 无</span></span><br><span class="line"><span class="comment">  * 说    明：无</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">255</span>];</span><br><span class="line"><span class="type">uint8_t</span> bufferCounter=<span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> charBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  	HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_RESET);</span><br><span class="line">		HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_RESET);</span><br><span class="line">	  </span><br><span class="line">		HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);<span class="comment">//开启串口接收中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//		HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_2);</span></span><br><span class="line"><span class="comment">//	  HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_3);</span></span><br><span class="line"><span class="comment">//	  HAL_Delay(1000);</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//		if(bufferCounter&gt;=255)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			HAL_UART_Transmit(&amp;huart1,(uint8_t * )&quot;数据溢出&quot;,10,HAL_MAX_DELAY);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">//		else</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line">	</span><br><span class="line">			<span class="keyword">if</span>(huart == &amp;huart1)</span><br><span class="line">			&#123;</span><br><span class="line">				buffer[bufferCounter++] = charBuffer;</span><br><span class="line">				HAL_UART_Transmit(&amp;huart1,&amp;charBuffer,<span class="number">1</span>,HAL_MAX_DELAY);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">	</span><br><span class="line">		HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);<span class="comment">//开启串口中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>每次中断接收一个字节的数据，数据量大会频繁触发中断</p>
<p>可以改进为一次接收N个字节的数据。</p>
</blockquote>
<h3 id="USART2控制LED灯"><a href="#USART2控制LED灯" class="headerlink" title="USART2控制LED灯"></a>USART2控制LED灯</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">255</span>];</span><br><span class="line"><span class="type">uint8_t</span> bufferCounter=<span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> charBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_SET);</span><br><span class="line">		HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_SET);</span><br><span class="line">	  </span><br><span class="line">	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请操作小灯：\n1.只有小灯1亮\n2.只有小灯2亮\n3.两个小灯同时亮\n4.两个小灯同时熄灭\n&quot;</span>);</span><br><span class="line">		HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);<span class="comment">//开启串口接收中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//		HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_2);</span></span><br><span class="line"><span class="comment">//	  HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_3);</span></span><br><span class="line"><span class="comment">//	  HAL_Delay(1000);</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">			<span class="keyword">if</span>(huart == &amp;huart1)</span><br><span class="line">			&#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(charBuffer == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_RESET),</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_SET);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(charBuffer == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_SET),</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_RESET);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(charBuffer == <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_RESET),</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_RESET);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_SET),</span><br><span class="line">							HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_SET);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">		HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在串口调试助手时，发送1，2，3，4在单片机上可以看到明显的现象</p>
</blockquote>
<h1 id="HAL库函数的一些调用流程"><a href="#HAL库函数的一些调用流程" class="headerlink" title="HAL库函数的一些调用流程"></a>HAL库函数的一些调用流程</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>HAL_外设名_Init()</span><br><span class="line">-- 该函数一般会调用<span class="number">2</span>函数，实际操作寄存器初始化外设功能，由HAL库实现</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>HAL_外设名_MspInit()</span><br><span class="line">-- 该函数是外设外围相关功能的初始化，比如：引脚、特殊功能比如时钟使能等等，由用户自己实现</span><br></pre></td></tr></table></figure>
<p><strong>以USART初始化来举例</strong>：</p>
<ol>
<li>定义一个UART_HandleTypeDef结构体句柄</li>
<li>通过HAL_UART_MspInit函数来实现串口外设的底层初始化</li>
</ol>
<ul>
<li><p>要做的功能：</p>
<ol>
<li><p>使能UART外设时钟</p>
</li>
<li><p>配置UART使用的引脚模式</p>
</li>
<li><p>如果要使用中断，就配置中断</p>
</li>
<li><p>如果要用DMA，就配置DMA</p>
</li>
</ol>
</li>
</ul>
<ol>
<li>通过前面定义的结构体具备，来配置串口的波特率、数据字长、停止位、奇偶校验位。</li>
<li>如果要使用异步模式，则通过调用HAL_UART_Init()函数来将串口配置为异步模式。</li>
</ol>
<h1 id="TIM-定时器"><a href="#TIM-定时器" class="headerlink" title="TIM(定时器)"></a>TIM(定时器)</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>STM32中的定时器是一种内置的硬件模块，用于<strong>生成精确的时间延迟、执行周期性任务、捕获外部事件</strong>等。<strong>定时器通常用于需要精确时间控制的应用，比如实时操作系统、通信协议、PWM（脉冲宽度调制）生成等</strong>。</p>
<p><strong>以下常见的几种定时器</strong>:</p>
<ul>
<li><strong>高级定时器</strong></li>
<li><strong>通用定时器</strong></li>
<li><strong>基本定时器</strong></li>
</ul>
<p><strong>定时器的常见作用</strong>：</p>
<ol>
<li><strong>计时器模式（Timer Mode）</strong>：定时器可以作为简单的计时器，用于生成一段时间延迟。你可以设置定时器的计数值和时钟频率来控制延迟的精度。</li>
<li><strong>定时器中断（Timer Interrupts）</strong>：定时器可以配置为在计数器达到特定值时生成中断请求。这对于周期性任务执行或时间精确控制非常有用。</li>
<li><strong>PWM输出（Pulse Width Modulation）</strong>：定时器可以用来生成PWM信号，用于控制电机速度、LED亮度、音频输出等。</li>
<li><strong>捕获模式（Capture Mode）</strong>：定时器可以捕获外部事件的时间戳，比如测量输入脉冲的周期或脉宽。</li>
<li><strong>计数器级联（Timer Cascade）</strong>：一些STM32系列的芯片支持多个定时器级联，可以扩展定时器的计数范围或增加功能。</li>
</ol>
<p>还有一些相关知识例如:定时器的主从模式</p>
<p><strong>定时器相关寄存器可以查看参考手册、数据手册等</strong></p>
<p><strong>还有一些相关知识(定时器的主从模式等)，以下为定时器详细介绍</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44016222/article/details/123507270?ops_request_misc=%7B%22request%5Fid%22%3A%22171386792116800185878220%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171386792116800185878220&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123507270-null-null.142^v100^control&amp;utm_term=stm32定时器&amp;spm=1018.2226.3001.4187">STM32-定时器详解_stm32定时器-CSDN博客</a></p>
<h2 id="基于定时器的LED闪烁"><a href="#基于定时器的LED闪烁" class="headerlink" title="基于定时器的LED闪烁"></a>基于定时器的LED闪烁</h2><h3 id="CubeMX配置"><a href="#CubeMX配置" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><ol>
<li><p><strong>确定时钟输入</strong>: 这里我们需要一个稳定的时钟输入，以精确的进行定时，因此可以选择内部时钟源。这里以<code>TIM2</code>为例，在CubeMX中将<code>Clock Source</code>选择为<code>Internal Clock</code>, 使用内部时钟源。那么这个内部时钟源是哪来的呢？参考芯片手册。找到时钟源输入频率。<strong>即在CubeMX中配置Clock Source为Internal Clock(内部时钟源)</strong></p>
</li>
<li><p><strong>确定预分频值</strong>：预分频值就是指时钟信号输入之后会在这里被分频，也就是降低了输入频率。 假设这里的值设定为2，则最终信号会变成36MHz，也就是计数器每秒会加36M次，很显然这个速度对我们来说还是太大了。 为了便于计算，我这里更倾向于让输出的时钟频率变成10k，这样每0.1ms定时器就加1。</p>
</li>
<li><p><strong>确定重装载值</strong>：</p>
<p>当我们在上面分完频后，就很容易计算这里的值应该为多少了。显然，要使定时器100ms触发一次，这里的这个值应该为1000，最后别忘了-1，才是准确的值(从0开始)。<strong>别忘了使能自动重装载enable</strong>。</p>
</li>
<li><p><strong>使能定时器中断</strong>：在NVIC中开启TIM中断。</p>
</li>
</ol>
<blockquote>
<p><strong>主要涉及三个概念</strong>：</p>
<ol>
<li><p><strong>Prescaler(psc)-预分频值</strong>：内部有一个预分频器PSC，简单来说就是分频值</p>
<p>时钟信号被分频后的频率 F= TCLK/(PSC+1) </p>
</li>
<li><p><strong>auto-reload preload(arr)-自动重装载值</strong>：内部有一个自动重装载寄存器，简单来说就是设置计数值上限，最大为65535</p>
</li>
</ol>
<ol>
<li><strong>CNT-计数器</strong>：内部有一个计数器自增，会与自动重装在寄存器比较，当计数值等于自动重装载值arr时，将会触发<strong>更新中断或更新事件</strong>，同时清零计数器</li>
</ol>
<p><strong>定时器溢出时间 Tout =  (arr+1)/F   =   (arr+1)*(PSC+1) /TCLK</strong></p>
<p><strong>注意：psc和arr的值配置时都要-1，因为从0开始数</strong></p>
</blockquote>
<p><strong>举个例子</strong>：</p>
<p>​        假设时钟源频率为72MHZ，我们设置psc为7200-1=7199，那么得到分频后的时钟频率为10000HZ, 每秒计数10000次，要使定时器0.1s溢出一次，那么1000-1=999次，1000/10000 = 0.1s</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/99201209">【STM32】HAL库 STM32CubeMX教程六——定时器中断_hal_tim_irqhandler-CSDN博客</a></p>
<h3 id="函数和业务代码"><a href="#函数和业务代码" class="headerlink" title="函数和业务代码"></a>函数和业务代码</h3><p><strong>主要函数</strong>：</p>
<p><strong>定时器中断处理函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_IRQHandler(&amp;htim2);</span><br></pre></td></tr></table></figure>
<p><strong>定时器溢出中断回调函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>;   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在stm32f1xx_it.c中可以找到HAL_TIM_IRQHandler(&amp;htim2);里面调用了这个溢出中断回调函数</span></span><br><span class="line"><span class="comment">  */</span> </span><br></pre></td></tr></table></figure>
<p><strong>使能定时器中断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line"><span class="comment">/*使用之前别忘了在setup中使能定时器中断*/</span></span><br></pre></td></tr></table></figure>
<p><strong>业务代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*定时器中断使能*/</span></span><br><span class="line">	HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">if</span>(htim == &amp;htim2)</span><br><span class="line">	 &#123;</span><br><span class="line">		 HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_2);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h2><p>STM32 微控制器中的 RTC（Real Time Clock，实时时钟）模块是一个低功耗的独立计时器，用于提供精确的时间和日期信息。<strong>RTC 模块设计为即使在主电源关闭的情况下也能继续运行，从而确保时间信息不会丢失。这通常是通过一个备用电池或超级电容来实现的，它能够为 RTC 供电，即便主电源断开</strong>。</p>
<p>以下是关于 STM32 中 RTC 的一些关键点：</p>
<ol>
<li><strong>功能</strong>:<ul>
<li><strong>提供实时时间</strong>：RTC 可以作为系统时钟，提供准确的小时、分钟、秒等。</li>
<li><strong>日历功能</strong>：除了时间，RTC 还可以提供年、月、日等日期信息。</li>
<li><strong>闹钟功能</strong>：可以设置特定时间触发中断，用于定时唤醒或其他用途。</li>
<li><strong>定时任务</strong>：可用于执行定期的任务或事件。</li>
</ul>
</li>
<li><strong>硬件特性</strong>:<ul>
<li>低功耗设计：RTC 在低功耗模式下也能工作，适合于电池供电的应用。</li>
<li>备用电源：通过 VBAT 引脚连接备用电源，保证在主电源断开后仍能维持时间信息。</li>
<li>时钟源：可以选择多种时钟源，如 LSE (低速外部晶振, 通常为 32.768kHz)、LSI (低速内部 RC 振荡器) 或 HSE (高速外部晶振) 经过分频后的信号。</li>
</ul>
</li>
</ol>
<h3 id="RTC时钟选择"><a href="#RTC时钟选择" class="headerlink" title="RTC时钟选择"></a>RTC时钟选择</h3><blockquote>
<p><strong>RTC设备因为其独特的运行方式（即掉电依旧运行）使用HSE分频时钟或者LSI的时候,在主电源VDD掉电的情况下,这两个时钟来源都会受到影响，资源消耗太大，小小的纽扣电池根本吃不消。</strong></p>
</blockquote>
<p>​    所以<strong>RTC一般都时钟低速外部时钟LSE</strong>,频率为实时时钟模块中常用的32.768KHz,因为32768 = 2^15,分频容易实现,所以被广泛应用到RTC模块.(在主电源VDD有效的情况下(待机),RTC还可以配置闹钟事件使STM32退出待机模式).</p>
<blockquote>
<p><strong>故使用RTC时记得使能LSE的外部晶振，配置时钟树时RTC选择LSE</strong></p>
</blockquote>
<h3 id="RTC中断"><a href="#RTC中断" class="headerlink" title="RTC中断"></a>RTC中断</h3><blockquote>
<p><strong>秒中断</strong>：<br>这里时钟自带一个秒中断，每当计数加一的时候就会触发一次秒中断，。注意，这里所说的秒中断并非一定是一秒的时间，它是由RTC时钟源和分频值决定的“秒”的时间，当然也是可以做到1秒钟中断一次。我们通过往秒中断里写更新时间的函数来达到时间同步的效果</p>
<p><strong>闹钟中断</strong>：<br>闹钟中断就是设置一个预设定的值，计数每自加多少次触发一次闹钟中断</p>
</blockquote>
<h3 id="CubeMX配置-1"><a href="#CubeMX配置-1" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><blockquote>
<p>Activate Clock Source 激活时钟源<br>Activate calendar激活日历<br>这两个都要使能，作用也很明显，先是使能时钟源，再使能RTC日历</p>
<p>RTC_OUT： Not RTC_OUT<br>Tamper： ×</p>
<p>第一个参数：是否使能tamper引脚作为校正的秒脉冲输出</p>
<p>第二个参数：是否使能tamper引脚作为RTC入侵检测校验功能</p>
<p><strong>剩下的就是时间配置</strong></p>
</blockquote>
<h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设置系统时间*/</span></span><br><span class="line">HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, <span class="type">uint32_t</span> Format) </span><br><span class="line"><span class="comment">/*读取系统时间*/</span></span><br><span class="line">HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*设置系统日期*/</span></span><br><span class="line">HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*读取系统日期*/</span></span><br><span class="line"> HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*启动报警功能*/</span></span><br><span class="line">HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*设置报警中断*/</span></span><br><span class="line">HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*报警时间回调函数*/</span></span><br><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_RTC_AlarmAEventCallback</span><span class="params">(RTC_HandleTypeDef *hrtc)</span></span><br><span class="line"><span class="comment">/*写入备份储存器*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_RTCEx_BKUPWrite</span><span class="params">(RTC_HandleTypeDef *hrtc, <span class="type">uint32_t</span> BackupRegister, <span class="type">uint32_t</span> Data)</span></span><br><span class="line"><span class="comment">/*读取备份储存器*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">HAL_RTCEx_BKUPRead</span><span class="params">(RTC_HandleTypeDef *hrtc, <span class="type">uint32_t</span> BackupRegister  </span></span><br><span class="line"><span class="params"></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>参数1</strong>：RTC句柄结构体参数</p>
<p><strong>参数2</strong>：<strong>RTC_TimeTypeDef</strong> *sTime： 获取RTC时间的结构体</p>
<p><strong>参数3</strong>： <strong>获取时间的格式</strong><br><strong>RTC_FORMAT_BIN 使用2进制<br>RTC_FORMAT_BCD 使用BCD进制</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Time structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> Hours;            <span class="comment">/*!&lt; Specifies the RTC Time Hour.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Minutes;          <span class="comment">/*!&lt; Specifies the RTC Time Minutes.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Seconds;          <span class="comment">/*!&lt; Specifies the RTC Time Seconds.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">&#125; RTC_TimeTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Date structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> WeekDay;  <span class="comment">/*!&lt; Specifies the RTC Date WeekDay (not necessary for HAL_RTC_SetDate).</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_WeekDay_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Month;    <span class="comment">/*!&lt; Specifies the RTC Date Month (in BCD format).</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_Month_Date_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Date;     <span class="comment">/*!&lt; Specifies the RTC Date.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 1 and Max_Data = 31 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Year;     <span class="comment">/*!&lt; Specifies the RTC Date Year.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 0 and Max_Data = 99 */</span></span><br><span class="line"></span><br><span class="line">&#125; RTC_DateTypeDef;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="实验-实时时间OLED显示"><a href="#实验-实时时间OLED显示" class="headerlink" title="实验-实时时间OLED显示"></a>实验-实时时间OLED显示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> realTime[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> realDate[<span class="number">10</span>];</span><br><span class="line">RTC_DateTypeDef GetDate;<span class="comment">//获取日期结构体</span></span><br><span class="line">RTC_TimeTypeDef GetTime;<span class="comment">//获取时间结构体</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    HAL_RTC_GetTime(&amp;hrtc, &amp;GetTime, RTC_FORMAT_BIN);</span><br><span class="line">   <span class="comment">/*分别从RTC获取时间结构体和日期结构体*/</span> HAL_RTC_GetDate(&amp;hrtc,&amp;GetDate,RTC_FORMAT_BIN);</span><br><span class="line">   </span><br><span class="line">    OLED_NewFrame();</span><br><span class="line"><span class="built_in">sprintf</span>(realDate,<span class="string">&quot;%02d/%02d/%02d&quot;</span>,<span class="number">2000</span>+GetData.Year, GetData.Month, GetData.Date);</span><br><span class="line">    <span class="built_in">sprintf</span>(realTime,<span class="string">&quot;%02d:%02d:%02d&quot;</span>,GetTime.Hours, GetTime.Minutes, GetTime.Seconds);</span><br><span class="line"></span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>,realDate ,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">16</span>,realTime ,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RTC掉电重置"><a href="#RTC掉电重置" class="headerlink" title="RTC掉电重置"></a>RTC掉电重置</h3><h4 id="BKP寄存器"><a href="#BKP寄存器" class="headerlink" title="BKP寄存器"></a>BKP寄存器</h4><p>是在嵌入式系统（如STM32微控制器）中用于在系统掉电或复位时保存数据的特殊寄存器。它们通常用于需要在掉电或复位后保留的重要数据，这些数据在重新上电或复位时能够被恢复。<strong>即使系统复位或电源复位，备份寄存器的内容会保留不变，直到手动修改或在特定条件下被重置</strong>。</p>
<blockquote>
<p>BKP寄存器可以在芯片手册中找到</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241008202341686-17375302847772.png" alt="image-20241008202341686"></p>
<h4 id="解决掉电重置代码"><a href="#解决掉电重置代码" class="headerlink" title="解决掉电重置代码"></a>解决掉电重置代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MX_RTC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTC_Init 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END RTC_Init 0 */</span></span><br><span class="line"></span><br><span class="line">  RTC_TimeTypeDef sTime = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  RTC_DateTypeDef DateToUpdate = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTC_Init 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END RTC_Init 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initialize RTC Only</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  hrtc.Instance = RTC;</span><br><span class="line">  hrtc.Init.AsynchPrediv = RTC_AUTO_1_SECOND;</span><br><span class="line">  hrtc.Init.OutPut = RTC_OUTPUTSOURCE_NONE;</span><br><span class="line">  <span class="keyword">if</span> (HAL_RTC_Init(&amp;hrtc) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Check_RTC_BKUP */</span></span><br><span class="line">   <span class="comment">/*新增代码处1：*/</span></span><br><span class="line">  <span class="keyword">if</span>(HAL_RTCEx_BKUPRead(&amp;hrtc,RTC_BKP_DR1)!= <span class="number">0x1234</span>)</span><br><span class="line">    <span class="comment">// 读取备份寄存器，检查是否已经初始化过</span></span><br><span class="line">      </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END Check_RTC_BKUP */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize RTC and set the Time and Date</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sTime.Hours = <span class="number">0x19</span>;</span><br><span class="line">    sTime.Minutes = <span class="number">0x0</span>;</span><br><span class="line">    sTime.Seconds = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAL_RTC_SetTime(&amp;hrtc, &amp;sTime, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    DateToUpdate.WeekDay = RTC_WEEKDAY_TUESDAY;</span><br><span class="line">    DateToUpdate.Month = RTC_MONTH_OCTOBER;</span><br><span class="line">    DateToUpdate.Date = <span class="number">0x8</span>;</span><br><span class="line">    DateToUpdate.Year = <span class="number">0x24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAL_RTC_SetDate(&amp;hrtc, &amp;DateToUpdate, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN RTC_Init 2 */</span></span><br><span class="line">    <span class="comment">/*新增代码处2：*/</span></span><br><span class="line">    <span class="comment">// 设置完成后，将标志位写入备份寄存器，标记RTC已初始化,下次开机后将不再初始化</span></span><br><span class="line">    HAL_RTCEx_BKUPWrite(&amp;hrtc,RTC_BKP_DR1,<span class="number">0x1234</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END RTC_Init 2 */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><p><strong>检查BKP寄存器值</strong>： 在 <code>USER CODE BEGIN Check_RTC_BKUP</code> 部分，通过 <code>HAL_RTCEx_BKUPRead()</code> 函数读取备份寄存器 <code>RTC_BKP_DR1</code> 的值。我们约定用值 <code>0x1234</code> 来表示RTC已经被初始化。<strong>该值自己约定即可！！！！</strong></p>
</li>
<li><p><strong>RTC初始化和时间设置</strong>： 如果读取到的值不是 <code>0x1234</code>，说明RTC未初始化，接着会进行RTC的时间和日期设置。否则，跳过初始化，保留当前时间。</p>
</li>
<li><p><strong>保存初始化标志</strong>： 设置完时间后，通过 <code>HAL_RTCEx_BKUPWrite()</code> 将 <code>0x1234</code> 写入 <code>RTC_BKP_DR1</code>，标记RTC已经完成初始化，以便下次重启时检测。</p>
</li>
</ol>
<p>在 STM32 中，备份寄存器可以使用 <code>RTC_BKP_DR1</code> 到<code>RTC_BKP_DRx</code>（多个寄存器）。上面的例子使用的是 <code>RTC_BKP_DR1</code>，你可以根据需要选择其他备份寄存器。</p>
</blockquote>
<h2 id="定时器外部时钟与循迹模块"><a href="#定时器外部时钟与循迹模块" class="headerlink" title="定时器外部时钟与循迹模块"></a>定时器外部时钟与循迹模块</h2><h3 id="循迹模块"><a href="#循迹模块" class="headerlink" title="循迹模块"></a>循迹模块</h3><p><strong>作用</strong>：为传送带测速/测距，计算流水线上的货物数量等</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1N94y1u7Uz?spm_id_from=333.788.videopod.sections&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32】动画讲解定时器外部时钟 &amp; 实战传送带测速装置_哔哩哔哩_bilibili</a></p>
<h3 id="抖动脉冲"><a href="#抖动脉冲" class="headerlink" title="抖动脉冲"></a>抖动脉冲</h3><h3 id="输入滤波器"><a href="#输入滤波器" class="headerlink" title="输入滤波器"></a>输入滤波器</h3><h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p> <strong>脉冲宽度调制-PWM</strong>，是英文“Pulse Width Modulation”的缩写，简称<strong>脉宽调制</strong>，其实是在利用微控制器的<strong>定时器模块</strong>来生成一种特定频率和占空比的<strong>脉冲信号</strong>，调整脉冲的宽度从而影响功率等。PWM信号是一种周期性的脉冲信号，通过调整脉冲的宽度（高电平时间）可以<strong>模拟模拟信号，控制电机速度、LED亮度、蜂鸣器响度</strong>等。</p>
<blockquote>
<p><strong>PWM无非就是一定的频率(周期)，输出不断交替的高低电平信号。</strong></p>
<p>占空比：高电平在一个周期中占用时间的比重叫做占空比，占空比越大其在宏观上表现的电压也就越大，成线性关系。</p>
<p>通用或者高级定时器具有输出比较模式，可以通过不断比较<strong>计数器</strong>与<strong>比较寄存器的值</strong>。</p>
</blockquote>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ul>
<li><strong>启动定时器PWM输出</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_TIM_PWM_Start</span><span class="params">(TIM_HandleTypeDef *htim, <span class="type">uint32_t</span> Channel)</span>;</span><br><span class="line"><span class="comment">/*第一个参数为指向定时器句柄的指针，第二个参数为启动的通道，一个有1，2，3，4共四个,例：TIM_CHANNEL_1*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数返回一个 HAL_StatusTypeDef 类型的值，表示操作的状态。常见的返回值包括：HAL_OK(操作成功)、HAL_ERROR(操作失败)*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>启动PWM输出，并启动比较中断</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_PWM_Start_IT(&amp;htim2);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>修改占空比</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_SetCompare(&amp;htim2, TIM_CHANNEL_1, pwmVal);</span><br><span class="line"><span class="comment">/*或*/</span></span><br><span class="line">__HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, pwmVal);</span><br><span class="line"><span class="comment">/*前两个参数不变，第三个参数为用户占空比，占空比=pwmVal/arr*/</span></span><br><span class="line"></span><br><span class="line">-------------------上下两种都可以----------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">/*它是HAL库中的一个宏，用于快速设置定时器的比较寄存器的值。*/</span></span><br><span class="line">TIM2-&gt;CCR1 = pwmVal </span><br><span class="line">htim2.Instance-&gt;CCR1 = pwmVal</span><br><span class="line"><span class="comment">/*直接修改比较寄存器CCRx的值也可以访问定时器相关寄存器*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>修改PSC或ARR的值</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*修改预分频值,PSC寄存器*/</span></span><br><span class="line">htim2.Instance-&gt;PSC = <span class="number">72</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改自动重装载值，ARR寄存器*/</span></span><br><span class="line">htim2.Instance-&gt;ARR = <span class="number">1000</span><span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="实验-PWM控制LED亮度实现呼吸灯"><a href="#实验-PWM控制LED亮度实现呼吸灯" class="headerlink" title="实验-PWM控制LED亮度实现呼吸灯"></a>实验-PWM控制LED亮度实现呼吸灯</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/99231677">【STM32】HAL库 STM32CubeMX教程七—-PWM输出(呼吸灯)_stm32 hal pwm-CSDN博客</a></p>
<h4 id="CubeMX配置-2"><a href="#CubeMX配置-2" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h4><p><strong>第一步</strong>：配置时钟树</p>
<p><strong>第二步</strong>：选用定时器，这里用TIM2，Clock Source选择内部时钟源，四个独立通道channel任选一个，选择PWM模式(PWM Generation CH1),CH1代表通道1，对应引脚将自动配置为复用模式。</p>
<blockquote>
<p>Channel1~4 就是设置定时器通道的功能   (<strong>输入捕获、输出比较、PWM输出、单脉冲模式</strong>)</p>
</blockquote>
<p><strong>第三步</strong>：Mode选择PWM mode 1，Pulse(宽度/占空比)先选择0，Fast Mode不使能，通道极性(CH Polarity)配置为Low(<strong>选择Low可以使占空比变为低电平占整个周期的比例</strong>)</p>
<blockquote>
<p>PWM mode 1 和 2 区别在于一个是向上计数一个是向下计数，以及频率和占空比是否固定上等</p>
<p><strong>CHPolarity的选择上：</strong>当占空比为30%时，如果选择High那么高电平占30%，选择Low那么低电平占30%。</p>
<p>但一般情况下占空比都是指高电平所占周期的比例</p>
</blockquote>
<p><strong>第四步</strong>：设置预分频值和重装载值以及占空比，我设置arr = 100-1，psc = 71，得到的Fpwm = 72000000/7200 = 10000HZ </p>
<blockquote>
<p><strong>定时溢出频率即pwm的频率，故Fpwm =  TCLK/(arr+1)*(PSC+1)</strong> </p>
<p><strong>占空比为高电平所占时间与整个周期比例：TIM2-&gt;CCR1/arr</strong></p>
<p><strong>TIM2-&gt;CCR1是定时器2的比较(捕获)寄存器1可以修改其值来调整占空比</strong></p>
</blockquote>
<p><strong>第五步</strong>：生成项目</p>
<h4 id="业务代码-轮询修改占空比"><a href="#业务代码-轮询修改占空比" class="headerlink" title="业务代码(轮询修改占空比)"></a>业务代码(轮询修改占空比)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按键控制LED呼吸灯开关*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="type">uint16_t</span> pwmVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> mode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(pwmVal&lt;<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pwmVal+=<span class="number">1</span>;</span><br><span class="line">            __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_2, pwmVal);</span><br><span class="line">            HAL_Delay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!mode)</span><br><span class="line">            &#123;</span><br><span class="line">                __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_2, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pwmVal)</span><br><span class="line">        &#123;</span><br><span class="line">            pwmVal-=<span class="number">1</span>;;</span><br><span class="line">            __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_2, pwmVal);</span><br><span class="line">            HAL_Delay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!mode)</span><br><span class="line">            &#123;</span><br><span class="line">                __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_2, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_Delay(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">/*此时占空比为0，代表全为低电平，这里的延迟可以使到达最暗或者最亮之后可以持续一会，以便于灯的变化更加顺畅*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(GPIO_Pin == KEY1_Pin)</span><br><span class="line">  &#123;</span><br><span class="line">      HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_TIM_Base_Stop_IT(&amp;htim2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            mode = !mode; <span class="comment">// 注意切换模式要卸载消抖里面，否则可能会出现关不上灯的情况</span></span><br><span class="line">            <span class="comment">// HAL_GPIO_TogglePin(LED_BLUE_GPIO_Port,LED_BLUE_Pin);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<p><strong>tips</strong>：</p>
<ul>
<li>如果感觉灯到达最亮或者最暗的时间比较慢，可以调整一次循环中pwmVal加或减的值，使亮度变化更平滑。</li>
<li>如果感觉灯到达最亮或者最暗之后的维持的一段时间比较慢(快)，可以修改每一次大循环的延迟，HAL_Delay(200)比较合适</li>
<li>每一次pwmVal加或减之后有一个HAL_Delay(1),在每次循环迭代中产生一个较小的延迟，因为每一次while循环都是很快的pwmVal+=1的速度远远小于一个pwm输出周期的时间，如果删除它那么占空比将会很快到达0，我们肉眼观察就是瞬间亮了又瞬间灭了，而不会产生亮度慢慢变化的结果，一般设置为1ms即可</li>
</ul>
<p><strong>提问：每一个周期不应是有高电平和低电平吗，为什么观察到的不是LED灯一闪一闪的到达最亮或最暗呢？</strong></p>
<p>那么我们平时见到的LED灯，当它的频率大于50Hz的时候，人眼就会产生视觉暂留效果，基本就看不到闪烁了，而是一个常亮的LED灯，</p>
<p>你在1秒内，高电平0.5秒，低电平0.5秒，(频率1Hz)如此反复，那么你看到的电灯就会闪烁，</p>
<p>但是如果是10毫秒内，5毫秒打开，5毫秒关闭，(频率100Hz) 这时候灯光的亮灭速度赶不上开关速度(LED灯还没完全亮就又熄灭了)，由于视觉暂留作用 人眼不感觉电灯在闪烁，而是感觉灯的亮度少了 ，然后占空比在不断变化，所以才会感觉在慢慢变亮和慢慢变暗。</p>
<h4 id="业务代码-定时器修改占空比"><a href="#业务代码-定时器修改占空比" class="headerlink" title="业务代码(定时器修改占空比)"></a>业务代码(定时器修改占空比)</h4><blockquote>
<p>另外启用了一个定时器修改占空比，数秒内让占空比从0~100。假定5s内，那么0.05s(50ms)增加一占空比，所以PSC = 72-1，ARR = 20000-1。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-10-14.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> pwmVal1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> pwmVal2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> pwmVal3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_1);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3);</span><br><span class="line">    HAL_TIM_Base_Start_IT(&amp;htim4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim-&gt;Instance == TIM4)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通道1的呼吸效果</span></span><br><span class="line">        <span class="keyword">if</span>(!flag1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal1 &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal1 += <span class="number">1</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, pwmVal1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag1 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal1 &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal1 -= <span class="number">1</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, pwmVal1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag1 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通道2的呼吸效果</span></span><br><span class="line">        <span class="keyword">if</span>(!flag2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal2 &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal2 += <span class="number">2</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_2, pwmVal2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag2 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal2 &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal2 -= <span class="number">2</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_2, pwmVal2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag2 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通道3的呼吸效果</span></span><br><span class="line">        <span class="keyword">if</span>(!flag3)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal3 &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal3 += <span class="number">3</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_3, pwmVal3);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag3 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal3 &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal3 -= <span class="number">3</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_3, pwmVal3);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag3 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="实验-PWM控制无源蜂鸣器"><a href="#实验-PWM控制无源蜂鸣器" class="headerlink" title="实验-PWM控制无源蜂鸣器"></a>实验-PWM控制无源蜂鸣器</h3><p>通过改变<strong>PWM频率</strong>，可以输出不同频率的方波信号。用这个信号驱动<strong>无源蜂鸣器</strong>，便能播放不同频率的声音。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>学习板上的蜂鸣器型号为：<strong>QMB-09B-03电磁式无源蜂鸣器</strong>。</li>
<li>蜂鸣器内部有一个<strong>电磁线圈</strong>，能够驱动<strong>振动膜片</strong>发出声音。通过PWM给蜂鸣器提供不同频率的信号，即可发出不同频率的声音</li>
<li>实际操作中，除了控制<strong>PWM频率</strong>，还需要控制<strong>PWM占空比</strong>，以使膜片振动趋近于正弦波，从而发出清脆明亮的声音。在学习板上，使用<strong>20%占空比</strong>可以有较好的响度和音质</li>
</ul>
<h4 id="CubeMX配置-3"><a href="#CubeMX配置-3" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h4><blockquote>
<ol>
<li><strong>配置Debug，打开外部晶振，配置时钟树</strong></li>
<li><strong>配置对应按键输入模式，上拉等</strong></li>
<li><strong>找到蜂鸣器对应的TIM引脚和通道，勾选对应TIM内部时钟，对应通道选择PWM生成模式</strong></li>
<li><strong>TIM参数：PSC = 72-1 ARR = 按照要求或随意</strong></li>
</ol>
</blockquote>
<h4 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim4,TIM_CHANNEL_4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// KEY1按下: 输出2kHz声波</span></span><br><span class="line">    <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_Delay(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            htim4.Instance-&gt;ARR = <span class="number">500</span>;<span class="comment">// 2kHz = 72MHz / 72 / 500</span></span><br><span class="line">            __HAL_TIM_SET_COMPARE(&amp;htim4, TIM_CHANNEL_4, <span class="number">500</span>/<span class="number">5</span>);<span class="comment">// 设置占空比为20%</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2按下: 输出3kHz声波</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY2_GPIO_Port,KEY2_Pin) == GPIO_PIN_RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_Delay(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span> (HAL_GPIO_ReadPin(KEY2_GPIO_Port,KEY2_Pin) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            htim4.Instance-&gt;ARR = <span class="number">334</span>; <span class="comment">// 3kHz = 72MHz / 72 / 334</span></span><br><span class="line">            __HAL_TIM_SET_COMPARE(&amp;htim4, TIM_CHANNEL_4, <span class="number">1000</span>/<span class="number">5</span>);<span class="comment">// 设置占空比为20%</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 否则: 关闭声波输出</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim4, TIM_CHANNEL_4, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实验-PWM控制直流电机"><a href="#实验-PWM控制直流电机" class="headerlink" title="实验-PWM控制直流电机"></a>实验-PWM控制直流电机</h3><p><strong>直流电机一端通正极，一端通负极就可以旋转,电压越大，旋转也就越快，正负极反过来还可以实现反转</strong></p>
<h4 id="DRV8833电机驱动模块"><a href="#DRV8833电机驱动模块" class="headerlink" title="DRV8833电机驱动模块"></a>DRV8833电机驱动模块</h4><p>通常驱动一个小电机需要几百毫安的电流，但单片机上的I/O口只能支持几毫安的电流，直接接上可能会损坏STM32单片机。所有我们需要一个电机驱动芯片</p>
<p>，常见的有DRV8833等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20240929204303792-17375302847783.png" alt="image-20240929204303792"></p>
<blockquote>
<p>一共4个IN口，4个OUT口。其中<strong>N1 IN2与OUT1 OUT2一组，N3 N4与OUT3 OUT4一组</strong>。</p>
<p>我们可以通过单片机输出PWM到IN1 IN2，来控制OUT1 OUT2的输出来控制电机。IN3 IN4同理，也就是说DRV8833电机芯片可以驱动两个电机。</p>
<p><strong>SLEPP引脚可以让芯片暂停工作，实现低功耗。</strong></p>
<p><strong>FAULT的脚可以在出现控制错误时提醒单片机</strong></p>
<p><strong>VCC和GND脚用于给芯片和电机供电</strong></p>
<p><strong>原理</strong></p>
<p><strong>停止旋转时：</strong></p>
<p><strong>STM32向IN1输入高电平，向IN2输入低电平时。OUT1输出高电平，OUT2输出低电平，使电机正转。</strong></p>
<p><strong>STM32向IN1输入低电平，向IN2输入高电平时，OUT1输出低电平，OUT2输出高电平，电机反转</strong>。</p>
<p><strong>旋转时</strong>：</p>
<p><strong>IN1、IN2都输入高电平</strong>，OUT1与OUT2都输出低电平，相当于将电机的两根线短路，由于电机内的转子由很多线圈组成，相当于电感，产生反电动势阻碍电流变化，因此电流在整个回路中是缓慢变小消失，这种情况称为<strong>电流慢衰减</strong>。反电动势产生的磁场与定子产生的磁场相互作用，会使电机转子很快的刹停，叫<strong>刹车</strong>。</p>
<p><strong>IN1、IN2都输入低电平</strong>，DRV8833会将OUT1与OUT2都输出高电平，使得转子电流瞬间释放，这种情况称为<strong>电流快衰减</strong>，相当于将电机的两根线断路，无回路不能形成磁场，此时会随着摩擦力慢慢停下来，叫<strong>滑行</strong>。</p>
</blockquote>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><blockquote>
<p><strong>正转</strong>：      </p>
<p><strong>IN1             IN2               OUT1          OUT2</strong>   </p>
<p><strong>PWM输入     低电平            正转&amp;滑行(快衰减)</strong>    </p>
<p>​         </p>
<p>电机一会处于正转一会处于滑行，<strong>PWM占空比越高，正转时间越长</strong>，宏观上来看也就是<strong>电机转速也就越快</strong>。</p>
<p><strong>IN1             IN2               OUT1          OUT2</strong>   </p>
<p><strong>高电平    PWM输入              正转&amp;刹车(慢衰减)</strong>                  </p>
<p>电机一会处于正转一会处于刹车，<strong>PWM占空比越低，正转时间越长</strong>，宏观上来看也就是<strong>电机转速也就越快</strong>。  </p>
<blockquote>
<p> <strong>滑行和刹车区别</strong>： 都可以实现控制电机转速，区别就在于占空比一个高越快，一个低越快</p>
<p> <strong>应用场景</strong>：</p>
<ul>
<li><p>快衰减能够迅速降低电流，故常用于需要快速变化的高动态响应场景。</p>
</li>
<li><p>慢衰减电流变化比较平稳，因而比较适合用于平稳运行，降低噪音的场景中</p>
<p><strong>对于小电机来说其实感受不到什么区别</strong></p>
</li>
</ul>
</blockquote>
<p><strong>反转</strong>：</p>
<p><strong>IN1             IN2               OUT1          OUT2</strong>   </p>
<p><strong>低电平     PWM输入           反转&amp;滑行</strong>     </p>
<p><strong>IN1             IN2               OUT1          OUT2</strong>   </p>
<p><strong>PWM输入     高电平             反转&amp;刹车</strong>    </p>
</blockquote>
<p><strong>注意：占空比过低时，电机可能无法启动</strong></p>
<h4 id="CubeMX配置-4"><a href="#CubeMX配置-4" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h4><blockquote>
<ol>
<li><strong>配置Debug，打开外部晶振，配置时钟树</strong></li>
<li><strong>查看对应引脚对应的TIM通道，切换到TIM配置，选择内部时钟源，将对应通道设置为PWM生成模式(一个通道正转，一个通道反转)</strong></li>
<li><strong>TIM参数配置：PSC = 72-1 ，ARR = 100-1 ，PWM频率变为10000HZ</strong></li>
<li>其他配置</li>
<li>生成代码</li>
</ol>
</blockquote>
<h4 id="业务代码-1"><a href="#业务代码-1" class="headerlink" title="业务代码"></a>业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT_MID 20 <span class="comment">//停止转动</span></span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> speed = <span class="number">0</span>;<span class="comment">//电机转速由counter计算而来</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_TIM_Encoder_Start(&amp;htim1, TIM_CHANNEL_ALL);</span><br><span class="line">    <span class="comment">/*使用旋转编码器控制电机转速*/</span></span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim2, TIM_CHANNEL_1);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim2, TIM_CHANNEL_2);</span><br><span class="line">    <span class="comment">/*启动两个通道*/</span></span><br><span class="line">    </span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1,COUNT_MID);</span><br><span class="line">    <span class="comment">/*设置编码器初始值为20，停止转动*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    counter = __HAL_TIM_GET_COUNTER(&amp;htim1);</span><br><span class="line">    <span class="comment">/*控制编码器count在0~40之间，0~19代表反转,21~40代表正转，离中点越远转速越快,0最快反转,40最快正转*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(counter&gt;<span class="number">60000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        counter = <span class="number">0</span>;</span><br><span class="line">        __HAL_TIM_SET_COUNTER(&amp;htim2,<span class="number">0</span>);<span class="comment">//保持反转最快</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(counter&gt;COUNT_MID*<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        counter = COUNT_MID*<span class="number">2</span>;</span><br><span class="line">        __HAL_TIM_SET_COUNTER(&amp;htim2, COUNT_MID*<span class="number">2</span>);<span class="comment">//保持正转最快</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*控制counter的值在0~40之间*/</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(counter &lt; COUNT_MID)</span><br><span class="line">    &#123;</span><br><span class="line">        speed = (COUNT_MID - counter) * <span class="number">100</span> /  COUNT_MID; <span class="comment">//通过控制counter0~19,使speed映射在0~100之间</span></span><br><span class="line">        </span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_2, speed);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/*反转&amp;滑行*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        speed = (counter - COUNT_MID) * <span class="number">100</span> / COUNT_MID;<span class="comment">//通过控制counter21~40,使speed映射在0~100之间</span></span><br><span class="line">        </span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, speed);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_2, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/*正转&amp;滑行*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;counter:%d&quot;</span>, counter);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line"></span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>最好将该DRV8833模块拆分为单独的.c/.h 实现驱动的编写!!!!</strong></p>
</blockquote>
<h4 id="驱动库"><a href="#驱动库" class="headerlink" title="驱动库"></a>驱动库</h4><p>DRV8833电机驱动：</p>
<p><a target="_blank" rel="noopener" href="https://led.baud-dance.com/">波特律动LED字模生成器 (baud-dance.com)</a></p>
<p><strong>可以参照别人写的驱动，自己编写代码!!!!!!!!</strong></p>
<h2 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HM4m1R75B/?spm_id_from=333.788&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32】动画讲解输入捕获 并实现超声波测距_哔哩哔哩_bilibili</a></p>
<h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><strong>输入捕获</strong>：当定时器输入通道上检测到<strong>上升沿(或者下降沿)时</strong>，立刻将此时计数器的值记录到捕获寄存器中，等待程序稍后读取，并且可以借用另一个输入通道的捕获寄存器进行输入捕获。此种方法不会受到软件运行时间的干扰，更加准确。</p>
<h3 id="捕获寄存器"><a href="#捕获寄存器" class="headerlink" title="捕获寄存器"></a>捕获寄存器</h3><p>对于通用定时器和高级定时器来说，<strong>每个输入通道</strong>都有它自己的捕获寄存器，。</p>
<blockquote>
<p>假设我们启动了输入通道1(TI1FP1)的输入捕获模式，并且设定为上升沿捕获，定时器启动计数后，<strong>若输入到输入通道TI1的信号出现了一个上升沿，边沿检测器立即检测到就会通过TI1FP1传递到捕获寄存器1，捕获寄存器1便立刻将此时计数器的值复制到自身</strong>，如果对此输入捕获开启了中断，就还会触发输入捕获中断，通知程序尽快读取捕获寄存器中的数值，这样就获取到了<strong>上升沿出现时定时器的时刻，当我们再获取下降沿出现时定时器的时刻，就可以获得到高电平持续时间</strong></p>
<p>但一个输入通道的输入捕获只能进行上升沿捕获或者下降沿捕获，不能设置为双边沿捕获。所以STM32又从TI1上引出了一条线 连接到了<strong>捕获寄存器2</strong>上，这条线就是<strong>TI1FP2</strong>。</p>
<p><strong>输入捕获的直接模式和间接模式</strong>：<strong>信号从TI1引入</strong>，在自己的捕获寄存器1上进行输入捕获，就叫做<strong>输入捕获的直接模式</strong>。而借用捕获寄存器2进行输入捕获，则叫做<strong>输入捕获的间接模式</strong>。</p>
<p><strong>TI1和TI2是一对可以相互借用，TI3和TI4是一对可以相互借用</strong></p>
</blockquote>
<h3 id="超声波测距介绍"><a href="#超声波测距介绍" class="headerlink" title="超声波测距介绍"></a>超声波测距介绍</h3><p><strong>超声波测距模块是各种需要测距的产品中常用的一类传感器</strong>：</p>
<blockquote>
<p><strong>测距原理</strong>：首先发送一定频率的超声波，超声波遇见被测物体后就会被反射回来，当模块接收到反射回来的超声波后，只要将超声波从发送到接收的时间差乘以声速，再除以2 , 就可以得到超声波测距模块和被测物体的距离了。</p>
<p>(发送时刻-接受时刻)×声速 ÷ 2 = 距离</p>
<p>注意：若被测物体和超声波测距模块之间有障碍物，则测得的是障碍物的距离，因而某些场景不适合，但<strong>倒车雷达</strong>等需要对一个范围内进行测距的便非常合适。</p>
</blockquote>
<p><strong>超声波测距模块以HC-SR04为例：共有四个引脚</strong></p>
<blockquote>
<ul>
<li><p>VCC</p>
</li>
<li><p>GND</p>
</li>
<li><p><strong>控制端Trig</strong>：用于触发模块进行测距</p>
</li>
<li><p><strong>输出端Echo</strong>：用于测量模块输出的高电平持续时间</p>
</li>
</ul>
<p><strong>原理</strong>：当需要超声波测距时，只需要通过<strong>GPIO口向Trig引脚</strong>发送一个脉冲信号，超声波模块接收到脉冲信号就会向外发送一段超声波，然后模块会将Echo拉高，当模块接收到反射回来的超声波后，Echo会被拉低，<strong>那么Echo高电平持续时间也就是超声波在往返路途中消耗的时间</strong>。</p>
<p><strong>向Trig引脚发送脉冲信号(启动超声波测距)</strong>：先将GPIO口拉高，等待一会后，再将GPIO口拉低即可，<strong>等待的时间可以查看超声波模块手册(us级别）</strong></p>
<p><strong>测量Echo上高电平持续时间(得到超声波往返时间)</strong>：使用STM32定时器上的<strong>输入捕获,通过两个输入捕获寄存器的差可以得到高电平持续时间</strong></p>
</blockquote>
<h3 id="实验-使用超声波测距"><a href="#实验-使用超声波测距" class="headerlink" title="实验-使用超声波测距"></a>实验-使用超声波测距</h3><h4 id="CubeMX配置："><a href="#CubeMX配置：" class="headerlink" title="CubeMX配置："></a>CubeMX配置：</h4><blockquote>
<p> <strong>CubeMX配置</strong>：</p>
<p> 先启动Debug，开启外部晶振，配置时钟树72MHZ，使用OLED屏幕显示测距，所以打开I2C1。</p>
<p> 查看手册找到控制端Trig和输出端Echo对应引脚，Trig配置为GPIO_Output，Echo配置为TIM1_CH3，并打好对应Label</p>
<p> 然后转到TIM1，选择内部时钟源，配置TIM1的Channel3为输入捕获直接模式(Input Caputure direct mode)，配置Channel4为输入捕获间接模式(indirect)</p>
<p> 转到参数设置：PSC设置为72-1，计数器频率变为1MHZ，每1us计数值+1</p>
<p> Arr = 65535</p>
<p> <strong>Input Capture Channel 3</strong> ：设置<strong>上升沿检测</strong>，<strong>输入捕获直接模式(direct)</strong>，<strong>捕获寄存器前的分频设置为不分频</strong>，<strong>Input Filter(滤波)为0</strong>，因为没什么抖动所以不用滤波。</p>
<p> <strong>Input Capture Channel 4</strong>：置<strong>下降沿检测</strong>，<strong>输入捕获间接模式(indirect)</strong>，<strong>捕获寄存器前的分频设置为不分频</strong>，<strong>Input Filter(滤波)为0</strong>，</p>
<p> 因为需要使用中断模式，<strong>最后使能TIM1捕获比较中断(TIM1 capture compare interrupt)</strong></p>
</blockquote>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><strong>输入捕获函数启动</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_IC_Start(&amp;htim1, TIM_CHANNEL_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*IC就是input Capture输入捕获的意思*/</span></span><br></pre></td></tr></table></figure>
<p><strong>输入捕获中断</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_IC_Start_IT(&amp;htim1, TIM_CHANNEL_4);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当下降沿来临时，说明高电平结束，我们需要获取两个输入捕获寄存器的值进行计算，因此需要在通道4捕获完成后,中断通知我们*/</span></span><br></pre></td></tr></table></figure>
<p><strong>读取捕获寄存器数值</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读取对应通道的捕获寄存器值*/</span></span><br></pre></td></tr></table></figure>
<p><strong>输入捕获中断回调</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在输入捕获完成后将会进入该函数*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>定时器计数值设置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_SET_COUNTER(&amp;htim1,<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*参数1为对应定时器句柄，参数2为设置的值*/</span></span><br></pre></td></tr></table></figure>
<h4 id="业务代码-2"><a href="#业务代码-2" class="headerlink" title="业务代码"></a>业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> upEdge = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> downEdge = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> distance = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_TIM_Base_Start(&amp;htim1);<span class="comment">//启动定时器</span></span><br><span class="line">    HAL_TIM_IC_Start(&amp;htim1, TIM_CHANNEL_3);<span class="comment">//启动上升沿输入捕获</span></span><br><span class="line">    HAL_TIM_IC_Start_IT(&amp;htim1, TIM_CHANNEL_4);<span class="comment">//启动下降沿输入捕获,此处中断启动，因为得到捕获值后要计算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">/*Tig引脚发送脉冲信号：先拉高Trig引脚，等待一段时间后，再拉低     用于启动超声波测距*/</span></span><br><span class="line">    HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_SET);</span><br><span class="line">    HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_RESET);</span><br><span class="line">    <span class="comment">/*重置计数器的值，避免下降沿捕获数值小于上升沿捕获数值*/</span></span><br><span class="line">    __HAL_TIM_SET_COUNTER(&amp;htim1,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*使用显示器*/</span></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line">    <span class="built_in">sprintf</span>(message,<span class="string">&quot;距离：%.2fcm&quot;</span>,distance);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>,<span class="number">0</span>,message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    </span><br><span class="line">    HAL_Delay(<span class="number">500</span>);<span class="comment">//缓慢发送</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在HAL_TIM_IRQHandler中可以发现每次进入中断回调函数前，htim-&gt;Channel都会被重新赋值*/</span></span><br><span class="line">    <span class="comment">/*以表示当前处理的是哪个通道, 注意和之前的HAL_CHANNEL_4是不同的*/</span></span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim1 &amp;&amp; htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_4)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        upEdge = HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_3);</span><br><span class="line">        <span class="comment">/*分别通过两个捕获寄存器得到上升沿对应计数和下降沿对应计数*/</span></span><br><span class="line">        downEdge = HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_4);</span><br><span class="line">        distance = (upEdge - downEdge) * <span class="number">0.034</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/*TIM分频后为1Mhz即1μs一次,声速影响条件较多，这里取340m/s，即0.034cm/us,最后单位为cm*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>启动超声波测距</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">startMeasureDistance</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*Trig引脚发送脉冲信号：先拉高Trig引脚，等待一段时间后，再拉低     用于启动超声波测距*/</span></span><br><span class="line">    HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_SET);</span><br><span class="line">    HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_RESET);</span><br><span class="line">    <span class="comment">/*重置计数器的值，避免下降沿捕获数值小于上升沿捕获数值*/</span></span><br><span class="line">    __HAL_TIM_SET_COUNTER(&amp;htim1,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>计算高电平持续时间和被测物体距离</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在HAL_TIM_IRQHandler中可以发现每次进入中断回调函数前，htim-&gt;Channel都会被重新赋值*/</span></span><br><span class="line">    <span class="comment">/*以表示当前处理的是哪个通道, 注意和之前的HAL_CHANNEL_4是不同的*/</span></span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim1 &amp;&amp; htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_4)</span><br><span class="line">    &#123;</span><br><span class="line">        upEdge = HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_3);</span><br><span class="line">        downEdge = HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_4);</span><br><span class="line">        distance = (downEdge - upEdge) * <span class="number">0.034</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/*TIM分频后为1Mhz即1μs一次,声速影响条件较多，这里取340m/s，即0.034cm/us,最后单位为cm*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="旋转编码器"><a href="#旋转编码器" class="headerlink" title="旋转编码器"></a>旋转编码器</h2><p><strong>概念</strong>：用来测量位置、速度或旋转方向的传感器，当期旋转轴旋转时，其输出端可以输出与<strong>旋转速度和方向对应的方波信号</strong>，读取方波信号的频率和相位信息可以得知<strong>旋转轴的速度和方向</strong>。</p>
<p><strong>常见的有</strong>：<strong>增量型旋转编码器、绝对型编码器</strong>等</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1f4421U7Uj/?spm_id_from=333.337.search-card.all.click&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32教程】扭扭扭，转转转，轻松掌握编码器！_哔哩哔哩_bilibili</a></p>
<h3 id="增量型旋转编码器"><a href="#增量型旋转编码器" class="headerlink" title="增量型旋转编码器"></a>增量型旋转编码器</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p><strong>增量型旋转编码器一般有A、B两相输出信号</strong>，当旋转编码器没有旋转时，A、B两相均没有电平变化，稳定输出高电平或者低电平。</p>
<p>当旋转编码器被<strong>顺时针旋转</strong>时，A相会输出一个方波，B相此时也会输出一个方波，但是<strong>B相方波领先A相90度</strong>，也就是B相先产生上升沿/下降沿，稍后A相再产生上升沿/下降沿。也可以说A相上升沿时，B相为高电平，A相为下降沿时，B相为低电平。</p>
<p>当<strong>逆时针旋转时</strong>，情况相反，<strong>B相方波落后A相90度</strong>，A相上升沿时，B相为低电平，A相为上升沿时，B相为高电平。</p>
<blockquote>
<p><strong>这样我们可以</strong>：</p>
<ol>
<li>通过计算A相或者B相上升沿或者下降沿的数量来获取旋转编码器的角度。</li>
<li>可以通过A相边沿时，B相电平的情况得知当前的旋转方向</li>
</ol>
<p><strong>注意</strong>：不同旋转方向下A、B相到底谁在前谁在后，也可能根据具体元器件的不同而反过来！！！！</p>
<p>查阅旋转编码器的手册中可以看到，20 pulses/360°，即每360读输出20个脉冲，也就是每个脉冲为18°，所以用<strong>脉冲数量乘以18°</strong>就能得到真实的旋转角度</p>
<p><strong>旋转角度° = 脉冲数量 * 每个脉冲对应的角度</strong> </p>
<p>当然对于旋钮这种用户输入，我们一般只需要知道用户向哪个方向旋转了多大程度就好，不必计算真实角度</p>
</blockquote>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><blockquote>
<p><strong>思路1(中断)</strong>：</p>
<ol>
<li><p>将A、B相信号接入到GPIO口后，将A相的GPIO口设置为上升沿(或者下降沿触发中断)，然后再<strong>中断回调</strong>中读取B相GPIO口的电平状态，即可判断旋转方向。</p>
</li>
<li><p>同时，根据旋转方向对计数值加1或减1，来记录脉冲数量。</p>
</li>
</ol>
<p><strong>缺点</strong>：</p>
<p>处理单片机上转的慢的旋钮效果不错，但是处理转的非常快的电机的旋转编码器时，<strong>容易频繁触发中断，导致CPU工作效率低</strong>，还有可能出现软件处理跟不上导致<strong>丢步问题</strong>。</p>
<p><strong>思路2(定时器)</strong>:</p>
<p>通用/高级定时器为增量型编码器准备了<strong>专门的编码器接口</strong>，只要将A、B两相信号同时输入进去就可以实现<strong>正传时计数器自增，反转时计数器自减</strong>。</p>
<p><strong>那么我们将如何将A、B相信号输入编码器呢？</strong></p>
<p>编码器两个输入接口其实是早已了解过的TI1FP1和TI2FP2，也就是说我们<strong>直接将A、B相信号接入到定时器的通道1(TI1)和通道2(TI2)，就可以接入到编码器接口，让编码器可以根据A、B相的信号 控制计数器进行增加和减少,</strong>而且还可以利用这两个通道的滤波器与边沿检测器对A、B相信号初步处理</p>
<p><strong>编码器接口对上下边沿都很敏感</strong>，对于A、B相上的一组脉冲会计数两次。例如：A相下降沿时，B相为低电平，计数器+1，A相上升沿时，B相为高电平，计数器又+1。反向时同理。</p>
<p><strong>一句话来说就是：一个脉冲上下降沿都会被计数，一共两次</strong></p>
</blockquote>
<h3 id="实验-使用增量型旋转编码器控制小灯亮度"><a href="#实验-使用增量型旋转编码器控制小灯亮度" class="headerlink" title="实验-使用增量型旋转编码器控制小灯亮度"></a>实验-使用增量型旋转编码器控制小灯亮度</h3><h4 id="CubeMX配置-5"><a href="#CubeMX配置-5" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h4><ol>
<li><p><strong>配置Debug，打开外部晶振，配置时钟树</strong></p>
</li>
<li><p><strong>查阅原理图找到A相、B相、按键找到对应引脚和TIM(该板为TIM1)，配置引脚和TIM</strong></p>
</li>
<li><p><strong>由于旋转编码器能自主产生两路信号，故不用配置内部时钟源。直接找到Combined Channels(组合通道)设置，选择为Encoder Mode(编码器模式)，引脚自动被设置。</strong></p>
</li>
<li><p><strong>旋转编码器对应定时器参数配置</strong>：</p>
</li>
</ol>
<blockquote>
<blockquote>
<p><strong>Counter Settings</strong>:</p>
<p>PSC：默认为0不分频，由于编码器对上下沿都敏感，此时编码器旋转一次计数为2，如果想要旋转一次计数器计数为1的话，设置PSC = 2-1 (二分频)即可，或者可以在代码中手动对counter值进行修改</p>
<p>ARR：编码器对应定时器的计数器，保持默认的65535，或设置为想要的值即可</p>
<p><strong>Encoder</strong>：</p>
<p>Encoder Mode：是选择在哪个通道进行计数，如果选择两个通道都计数的话，一个脉冲将会被计数4次，通常配置为TI1即可</p>
<p>Polarity(极性设置)：类似于有效电平机制，设置下降沿有效，会将此通道波形翻转，如果与平时顺时针增加，逆时针减少不符，可<strong>以修改一个通道的极性即可</strong></p>
<p>IC Selection(输入捕获)：只能进行直接捕获 走TI1FP1和TI2FP2</p>
<p>Prescaler Division Ratio(预分频器分频比)：不进行预分频</p>
<p>Input Filter(输入滤波)：可以设置为最大值15，不滤波其实也没为问题</p>
</blockquote>
</blockquote>
<ol>
<li>编码器可以按下当按键使用，配置为输入模式或中断模式都可，注意是否需要开启内部上拉。</li>
<li>为了实现亮度调节，找到小灯对应的定时器设置(这里为TIM3)，勾选内部时钟源，将通道设置为PWM生成模式(PWM Generation)，PSC = 72-1  ARR = 100-1</li>
<li>为了使用OLED，打开I2C1</li>
</ol>
<h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><ul>
<li><strong>编码器启动</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Encoder_Start(&amp;htim1,TIM_CHANNEL_ALL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*参数1：定时器对应结构体句柄*/</span></span><br><span class="line"><span class="comment">/*参数2：对应通道，对于只有一相信号的单相编码器来说，填通道1或2。若有A、B两项以上的，一般填TIM_CHANNEL_ALL，所有通道,其实也就是通道1和2。*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>获取定时器计数值</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_GET_COUNTER(&amp;htim1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*内部库使用，能够获取当前的计数器值，编码器旋转时计数值会自增或自减*/</span></span><br></pre></td></tr></table></figure>
<h4 id="业务代码-3"><a href="#业务代码-3" class="headerlink" title="业务代码"></a>业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Channel[<span class="number">3</span>] = &#123;TIM_CHANNEL_1, TIM_CHANNEL_2, TIM_CHANNEL_3&#125;;</span><br><span class="line"><span class="type">int</span> ChannelIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*启动编码器，启动小灯的PWM输出*/</span></span><br><span class="line">    HAL_TIM_Encoder_Start(&amp;htim1, TIM_CHANNEL_ALL);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3,TIM_CHANNEL_1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     counter = __HAL_TIM_GET_COUNTER(&amp;htim1);</span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim3, Channel[ChannelIndex], counter);</span><br><span class="line">    <span class="comment">/*每次循环更新encoder定时器的计数值*/</span></span><br><span class="line">    </span><br><span class="line">    OLED_NewFrame();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;counter:%d&quot;</span>, counter);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message, &amp;font16x16, OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_DrawRectangle(<span class="number">0</span>,<span class="number">20</span>,<span class="number">100</span>,<span class="number">12</span>,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_DrawFilledRectangle(<span class="number">1</span>,<span class="number">20</span>,counter,<span class="number">12</span>,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    HAL_Delay(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">/*OLED上显示counter，和进度条*/</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (GPIO_Pin == KEY_ENCODER_Pin)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_TIM_PWM_Stop(&amp;htim3,Channel[ChannelIndex]);</span><br><span class="line">        ChannelIndex = (ChannelIndex+<span class="number">1</span>)%<span class="number">3</span>;</span><br><span class="line">        HAL_TIM_PWM_Start(&amp;htim3,Channel[ChannelIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*实现按下编码器切换小灯，未作消抖处理*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="舵机-SERVO"><a href="#舵机-SERVO" class="headerlink" title="舵机(SERVO)"></a>舵机(SERVO)</h2><p>概念：舵机由于经常用于控制航模船模的舵面而得名，是一种比较简易的伺服电机系统。</p>
<h3 id="原理-PWM"><a href="#原理-PWM" class="headerlink" title="原理(PWM)"></a>原理(PWM)</h3><blockquote>
<p>以SG90为例，可以控制舵机从0°旋转到180°<strong>，查看舵机手册</strong>可以得到0~180°分别对应着500~2500us的高电平时长。</p>
<p>我们见到的多数舵机通常使用<strong>50HZ</strong>，也就是<strong>周期为20ms的PWM信号</strong>进行控制，因而500us~2500us对应的占空比为：</p>
<p>500us~2500us/20ms = 2.5%~12.5% -&gt; 0°~180°  </p>
<p>即输出占空比为2.5%时，舵机旋转到0°，输出占空比为7.5%，舵机旋转到90°，输出占空比为12.5%时，舵机旋转到180°</p>
<p><strong>绝大多数舵机控制的占空比范围都是2.5%~12.5%，因为绝大多数的航模遥控器也是输出这个范围的信号</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/99-17375302847784.png" alt="image-20241123213856589"></p>
<h3 id="实验-使用旋转编码器控制舵机-SG90-旋转"><a href="#实验-使用旋转编码器控制舵机-SG90-旋转" class="headerlink" title="实验-使用旋转编码器控制舵机(SG90)旋转"></a>实验-使用旋转编码器控制舵机(SG90)旋转</h3><h4 id="CubeMX配置-6"><a href="#CubeMX配置-6" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h4><ol>
<li><strong>配置Debug，打开外部晶振，配置时钟树</strong></li>
<li><strong>配置好旋转编码器</strong>，PSC默认，ARR设置为20，其余默认即可</li>
<li>查看手册找到舵机对应TIM，打开内部时钟，配置对应通道的PWM生成模式。</li>
<li>使用<strong>50HZ</strong>的PWM信号，假设TIM的内部时钟为72MHZ，配置PSC为720-1 ，ARR = 2000-1。</li>
<li>生成代码</li>
</ol>
<blockquote>
<p>注意：因为旋转编码器20个脉冲对应的是360°，也就是计数40次。而舵机只能旋转180°，所以最大计数值应该设为20</p>
</blockquote>
<h4 id="业务代码-4"><a href="#业务代码-4" class="headerlink" title="业务代码"></a>业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COUNT 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[<span class="number">50</span>]</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> duty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// AHT20_Init();</span></span><br><span class="line"></span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_TIM_Encoder_Start(&amp;htim1, TIM_CHANNEL_ALL);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim4,TIM_CHANNEL_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    counter = __HAL_TIM_GET_COUNTER(&amp;htim1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*占空比(duty cycle)*/</span></span><br><span class="line">    duty = ((((<span class="type">float</span>)counter / MAX_COUNT)*<span class="number">10</span> + <span class="number">2.5</span>)/<span class="number">100.0</span>)*<span class="number">2000</span>;</span><br><span class="line">    <span class="comment">/*定时器最大值为2000,计算占空比为2.5%~12.5%对应的比较寄存器的值*/</span></span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim4, TIM_CHANNEL_3, duty);</span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;counter:%d&quot;</span>, counter);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    HAL_Delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="看门狗"><a href="#看门狗" class="headerlink" title="看门狗"></a>看门狗</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>STM32微控制器中的看门狗外设是一种用于<strong>监视系统运行的外设，它是一种硬件计时器，用于检测系统是否正常运行</strong>。其基本原理是周期性地重置系统，以确保系统在正常情况下能够响应。当系统出现异常情况（如死循环、软件错误等）导致停止响应时，看门狗定时器将超时并执行其预设的动作，例如重置系统或触发中断，从而使系统得以恢复或采取适当的措施。</p>
<p>在STM32微控制器中，看门狗外设主要分为两种类型：<strong>独立看门狗和窗口看门狗。</strong></p>
<h2 id="独立看门狗"><a href="#独立看门狗" class="headerlink" title="独立看门狗"></a>独立看门狗</h2><p><strong>独立看门狗-IWDG</strong>(Independent Watchdog)：</p>
<ul>
<li><strong>特点</strong>： 独立看门狗是一种基本的看门狗类型，本质是一个单独的定时器，独立于主处理器，即使主时钟发生故障仍然有效。</li>
<li><strong>驱动时钟</strong>：由专用的低速时钟（LSI）驱动（40kHz），由于LSI的时钟频率不精确，故<strong>独立看门狗只适用于对时间精度要求比较低的场合</strong>。</li>
<li><strong>用途</strong>： <strong>独立看门狗主要用于监视整个系统的运行状态</strong>。当系统出现故障、死锁或其他异常情况时，独立看门狗会在预设的超时时间内未收到系统的喂狗信号时，触发重启操作，以恢复系统的正常运行。</li>
</ul>
<blockquote>
<p>独立看门狗可以简单理解为<strong>一个12位的递减计数器</strong>，看门狗激活后，如果计数器的重装载值递减到0，系统就会产生复位。如果在计数器递减到0之前刷新了计数器值，那么系统就不会产生复位。<strong>这个刷新计数器的过程我们称为”喂狗”</strong></p>
</blockquote>
<h3 id="CubeMX配置-7"><a href="#CubeMX配置-7" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><p>LSI时钟并不直接提供给计数器时钟，而是通过一个8位的预分频器寄存器IWDG_PR分频后输入给计数器时钟(具体见STM32xxxx的参考手册IWDG寄存器章节)。</p>
<blockquote>
<p>CubeMX配置:</p>
<p>预分频系数prescaler取值：4、8、16、32、64、128、256。</p>
<p>溢出时间：Tout = (4<em>2^pre^ )  / 40 </em> rl r =  (prescaler/40) *rlr    单位：ms</p>
<ul>
<li><p>pre是预分频系数(0-6)，而(4*2^pre^)是prescaler的取值代表4分频、8分频等。</p>
</li>
<li><p>rlr是重装载寄存器的值   (12位,rlr&lt;4096,即0xFFF)</p>
</li>
<li><p>40KHz为LSI输入时钟频率</p>
</li>
<li><p>prescaler/40是分频后的频率的倒数即周期，再乘rlr代表定时器溢出时间</p>
</li>
</ul>
</blockquote>
<h3 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h3><p><strong>看门狗初始化函数</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)</span><br></pre></td></tr></table></figure>
<p><strong>喂狗函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg)</span><br><span class="line">    </span><br><span class="line">举例：  HAL_IWDG_Refresh(&amp;hiwdg);   <span class="comment">//看门狗喂狗</span></span><br></pre></td></tr></table></figure>
<h2 id="窗口看门狗"><a href="#窗口看门狗" class="headerlink" title="窗口看门狗"></a>窗口看门狗</h2><p><strong>窗口看门狗-WWDG</strong>(Window Watchdog)：</p>
<ul>
<li><strong>特点：</strong> 窗口看门狗是一种高级的看门狗类型，它具有两个阈值，即看门狗窗口。只有在这个窗口内喂狗信号才被视为有效，超出窗口范围的喂狗信号会被视为异常。</li>
<li><strong>驱动时钟</strong>：由APB1时钟(如：36MHZ)分频后得到时钟驱动，通过可配置的时间窗口来检测应用程序非正常的过迟或过早操作。 窗口看门狗最适合那些要求看门狗在精确计时窗口起作用的程序。</li>
<li><strong>用途：</strong> 窗口看门狗不仅可以监视系统的整体运行状态，还可以检测特定时间段内的系统运行状态。<strong>它可以帮助系统在特定的时间窗口内完成任务，以确保系统的实时性和稳定性</strong>。比如一个程序段正常运行的时间是50ms， 在运行完这个段程序之后紧接着进行喂狗，如果在规定的时间窗口内还没有喂狗，那就说明我们监控的程序出故障了，跑飞了，那么就会产生系统复位，让程序重新运行。</li>
</ul>
<blockquote>
<p>窗口看门狗跟独立看门狗一样，也是一个递减计数器不断的往下递减计数，当减到一个固定值 <strong>0x3F</strong> 时还不喂狗的话，产生复位，这个值叫窗口的下限，是固定的值，不能改变。</p>
<p>窗口看门狗之所以称为窗口，就是因为<strong>其喂狗时间限制在一个有上下限(上下窗口)的范围内（计数器减到某个值~计数器减到0x3F），在这个范围内才可以喂狗，可以通过设定相关寄存器，设定其上限时间（但是下限是固定的0x3F）</strong></p>
</blockquote>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>相比于独立看门狗，窗口看门狗可以使能中断，如果使能了提前唤醒中断，系统出现问题，喂狗函数没有生效，那么在计数器由减到<strong>0x40 (0x3F+1)</strong>  的时候，<strong>便会先进入中断，之后再递减一次才会复位</strong>。当然你也可以在中断里面喂狗</p>
<blockquote>
<p><strong>喂狗的操作，必须要在主循环里，而不能放在定时器中断里</strong>！这是很多初学者容易犯的错误！因为，如果出现了主循环跑飞或者陷入某个死循环，定时器中断可能还在正常运行，定期进入中断喂狗，则看门狗不能复位系统，起不到监测系统正常运行的作用；</p>
</blockquote>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote>
<ol>
<li>预分频系数选择(prescaler)：1、2、4、8</li>
<li><p>window value：上窗口值（要求在0x3F和计数器值之间）</p>
</li>
<li><p>free-running downcounter value：向下递减的计数器值，如果不喂狗到0x3F会复位MCU(有7位，取值为0~127)</p>
</li>
<li>Early wakeup interrupt：Enable使能提前唤醒中断，并开启中断</li>
</ol>
<p>若APB1时钟为36MHZ，选择8分频，计数器取最大值127,上窗口设置为126</p>
<p>分频后 CLK = (APB1CLK/4096)/8 = 1098.63281HZ</p>
<p>(127-126)/1098.63281 = 0.910ms (递减到上窗口的最短时间)</p>
<p>(127-0x3F)/1098.63281 =  58.25ms(递减到下窗口的最长时间)</p>
<p>喂狗窗口期为：0.910ms~58.25ms，超出这个时间没有喂狗那么MCU就会复位</p>
</blockquote>
<h3 id="相关函数-2"><a href="#相关函数-2" class="headerlink" title="相关函数"></a>相关函数</h3><p><strong>看门狗初始化</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_WWDG_Init(WWDG_HandleTypeDef *hwwdg)</span><br></pre></td></tr></table></figure>
<p><strong>喂狗</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_WWDG_Refresh(WWDG_HandleTypeDef *hwwdg)</span><br></pre></td></tr></table></figure>
<p><strong>看门狗中断处理函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_WWDG_IRQHandler(WWDG_HandleTypeDef *hwwdg)</span><br></pre></td></tr></table></figure>
<p><strong>看门狗中断回调函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak <span class="title function_">HAL_WWDG_EarlyWakeupCallback</span><span class="params">(WWDG_HandleTypeDef *hwwdg)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="实验-2"><a href="#实验-2" class="headerlink" title="实验"></a>实验</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建的user.c中*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wwdg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> early_wwdg_flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*中断发生标志位*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setUp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		HAL_GPIO_WritePin(LED0_GPIO_Port,LED0_Pin,GPIO_PIN_RESET);</span><br><span class="line">		HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span>(early_wwdg_flag==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,GPIO_PIN_SET);</span><br><span class="line">			HAL_WWDG_Refresh(&amp;hwwdg);</span><br><span class="line">        </span><br><span class="line">			early_wwdg_flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*清除该标志位，等待下一次中断喂狗,避免一直重复喂狗*/</span></span><br><span class="line">		&#125;s</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_WWDG_EarlyWakeupCallback</span><span class="params">(WWDG_HandleTypeDef *hwwdg)</span></span><br><span class="line">&#123;</span><br><span class="line">			early_wwdg_flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>设置了一个中断进入标志位，当主循环中检测到进入中断后，则喂狗，避免复位</p>
<p>烧录到开发板后可以看到，LED1亮起之后熄灭，没有再亮起，代表没有复位，实验成功。</p>
<p><strong>注意：最好不要在中断回调函数中喂狗</strong></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/99121645">【STM32】HAL库 STM32CubeMX教程五——看门狗(独立看门狗,窗口看门狗)_使用hall库程序跑飞-CSDN博客</a></p>
<h1 id="传感器模块"><a href="#传感器模块" class="headerlink" title="传感器模块"></a>传感器模块</h1><p>传感器元件(光敏电阻/热敏电阻/红外接收管等)的电阻会随外界的模拟量的变化而变化，通过与<strong>定值电阻分压即可得到模拟电压输出，再通过电压比较器进行二值化即可得到数字电压输出</strong>。</p>
<h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Analog-to-Digital Converter的缩写。指模/数转换器或者模拟/数字转换器。是指将连续变量的<strong>模拟信号</strong>转换为离散的<strong>数字信号</strong>的器件。</p>
<p>典型的模拟数字转换器将<strong>模拟信号</strong>转换为表示一定比例<strong>电压值的数字信号。</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/99627062">【STM32】HAL库 STM32CubeMX教程九—-ADC_cubemx adc-CSDN博客</a></p>
<p><strong>重要概念</strong>：</p>
<ol>
<li>转换模式：<strong>单次转换模式，连续转换模式，扫描模式，间断模式</strong>等</li>
<li>ADC单/多通道</li>
<li>数据左/右对齐</li>
<li>电压输入范围</li>
<li>ADC输入通道</li>
<li>注入通道(和中断类似)，规则通道</li>
<li>ADC时钟</li>
<li>外部触发转换(定时器、中断)</li>
<li>中断触发条件三个：<strong>规则通道转换结束</strong>、<strong>注入通道转换结束</strong>、<strong>模拟看门狗状态位被设置</strong></li>
<li>DMA触发：只有ADC1和ADC3才可，通常使用ADC都开启DMA</li>
</ol>
<h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p>CubeMX中配置</p>
<ol>
<li><blockquote>
<p><strong>ADCs_Common_Settings</strong>:<br><strong>Mode</strong>     ADC_Mode_Independent<br>这里设置为独立模式</p>
<p>独立模式模式下，双ADC不能同步，每个ADC接口独立工作。所以如果不需要ADC同步或者只是用了一个ADC的时候，应该设成独立模式，多个ADC同时使用时会有其他模式，如双重ADC同步模式，两个ADC同时采集一个或多个通道，可以提高采样率</p>
<p><strong>Data Alignment</strong> (数据对齐方式): 右对齐/左对齐</p>
<p>这个上方有讲解，数据的左右对齐</p>
<p><strong>Scan Conversion Mode</strong>( 扫描模式 ) ：   </p>
<p>如果只是用了一个通道的话，DISABLE就可以了(也只能DISABLE)，如果使用了多个通道的话，会自动设置为ENABLE。 就是是否开启扫描模式</p>
<p><strong>Continuous Conversion Mode</strong>(连续转换模式)    </p>
<p>设置为ENABLE，即连续转换。如果设置为DISABLE，则是单次转换。两者的区别在于连续转换直到所有的数据转换完成后才停止转换，而单次转换则只转换一次数据就停止，要再次触发转换才可以进行转换</p>
<p><strong>Discontinuous Conversion Mode</strong>(间断模式)    </p>
<p>因为我们只用到了1个ADC,所以这个直接不使能即可</p>
<hr>
<p><strong>ADC_RegularConversionMode(规则通道设置)</strong>:</p>
<p><strong>Enable Regular Conversions</strong> (启用常规转换模式)    </p>
<p>使能 否则无发进行下方配置</p>
<p><strong>Number OF Conversion</strong>(转换通道数)   <br>用到几个通道就设置为几<br>多个通道自动使能扫描模式</p>
<p><strong>Extenal Trigger Conversion Source</strong> (外部触发转换源)</p>
<p>设定ADC的触发方式:</p>
<ul>
<li><p>Regular Conversion launched by software 规则的软件触发 调用函数触发即可</p>
</li>
<li><p>Timer X Capture Compare X event 外部引脚触发,</p>
</li>
<li><p>Timer X Trigger Out event 定时器通道输出触发 需要设置相应的定时器设置</p>
</li>
</ul>
<hr>
<p><strong>Rank(转换顺序)</strong>：         <br>这个只修改通道Sampling Time(采样时间)即可，设置为239.5Cycles</p>
<blockquote>
<p><strong>不同的采样时间会影响到ADC的转换精度和转换速度。较长的采样时间可以提供更稳定的转换结果，适合高阻抗的信号源，但会增加总的转换时间；而较短的采样时间可以提高转换速度，但可能会降低精度，特别是在处理高阻抗信号时。</strong></p>
</blockquote>
<p>多个通道时会有多个Rank，可以设定每个通道的转换顺序<br>ADC总转换时间如下计算：</p>
<p>TCONV = 采样时间+ 12.5个周期</p>
<p>当ADCCLK=14MHz(最大)，采样时间为1.5周期(最快)时，TCONV =1.5+12.5=14周期=1μs。</p>
<p>因此，ADC的最小采样时间1us（ADC时钟=14MHz，采样周期为1.5周期下得到）</p>
<hr>
<p><strong>ADC_injected_ConversionMode</strong>(注入通道设置):<br>也就是注入通道的设置，和转换通道没啥太大区别，这里不再详解</p>
<hr>
<p><strong>WahchDog</strong>：<br>Enable Analog WatchDog Mode(使能模拟看门狗中断)</p>
<p>本质也测量值就是超出测量范围或者低于最低范围，启动看门狗</p>
</blockquote>
</li>
<li><p>ADC转换结束中断配置</p>
</li>
<li>ADC 的DMA传输配置</li>
</ol>
<h2 id="相关函数-3"><a href="#相关函数-3" class="headerlink" title="相关函数"></a>相关函数</h2><ul>
<li>开启ADC的3种模式(轮询模式 中断模式 DMA模式)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_Start(&amp;hadcx);       <span class="comment">//轮询模式开启ADC</span></span><br><span class="line">• HAL_ADC_Start_IT(&amp;hadcx);       <span class="comment">//中断轮询模式开启ADC</span></span><br><span class="line">• HAL_ADC_Start_DMA(&amp;hadcx)；       <span class="comment">//DMA模式开启ADC</span></span><br></pre></td></tr></table></figure>
<ul>
<li>关闭ADC的3种模式（轮询模式 中断模式 DMA模式）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_Stop()</span><br><span class="line">• HAL_ADC_Stop_IT()</span><br><span class="line">• HAL_ADC_Stop_DMA()</span><br></pre></td></tr></table></figure>
<ul>
<li>读取ADC转换值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_GetValue()</span><br></pre></td></tr></table></figure>
<ul>
<li>ADC校准函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADCEx_Calibration_Start()</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通常精度要求时使用，一般添加在初始化ADC之后.</span></span><br><span class="line"><span class="comment"> * 注意F4系列不支持！！！！</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>等待转换结束函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_PollForConversion(&amp;hadc1, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">第一个参数为指定的ADC,第二个参数为最大等待时间</span><br></pre></td></tr></table></figure>
<ul>
<li>ADC中断回调函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_ConvCpltCallback()</span><br><span class="line"></span><br><span class="line">转换完成后回调，DMA模式下DMA传输完成后调用</span><br></pre></td></tr></table></figure>
<ul>
<li>规则通道以及看门狗的配置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_ConfigChannel() 配置规则组通道</span><br><span class="line">• HAL_ADC_AnalogWDGConfig(）</span><br></pre></td></tr></table></figure>
<h2 id="实验-使用ADC读取电位器电压-单通道"><a href="#实验-使用ADC读取电位器电压-单通道" class="headerlink" title="实验-使用ADC读取电位器电压(单通道)"></a>实验-使用ADC读取电位器电压(单通道)</h2><h3 id="电位器介绍"><a href="#电位器介绍" class="headerlink" title="电位器介绍"></a>电位器介绍</h3><p><strong>电位器</strong>（Potentiometer）是一种三端的可调电阻器，常用于调节电压、电流或信号强度。它通过转动或滑动一个机械部件（如旋钮或滑杆）来改变电阻值，实现电路中的电压分配或控制。</p>
<blockquote>
<ol>
<li><p><strong>在stm32单片机上使用VOL标注</strong></p>
</li>
<li><p>原理图中标注为<strong>Variable resistor（可变电阻）</strong></p>
</li>
</ol>
</blockquote>
<h3 id="CubeMX配置-8"><a href="#CubeMX配置-8" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><blockquote>
<ol>
<li>配置Debug，打开外部晶振，配置时钟树。<strong>为了ADC转换结果的准确性，配置时钟树时注意分频后的ADC时钟信号最好不超过14Mhz</strong></li>
<li>从原理图中找到对应引脚，查看其对应ADC通道，然后在对应ADC中勾选通道</li>
<li><ul>
<li>ADC_Settings -&gt; Continuous Conversion Mode设为Enable，使ADC转换持续进行，不需要每次获取之前手动触发转换</li>
<li>ADC_Regular_ConversionMode -&gt; Rank -&gt; Sampling Time设为239.5 Cycles，最长采样时间，可以获得更稳定的转换结果，采样时间越长，转换结果越准确</li>
</ul>
</li>
<li><p>若有OLED显示等配置即可</p>
</li>
<li>生成项目</li>
</ol>
</blockquote>
<h3 id="业务代码-5"><a href="#业务代码-5" class="headerlink" title="业务代码"></a>业务代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> message2[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ADValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> voltage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// AHT20_Init();</span></span><br><span class="line"></span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">   <span class="comment">/*启动ADC连续转换*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*ADC读取原始值获取*/</span></span><br><span class="line">     ADValue = HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line">	<span class="comment">/*12位精度的ADC，测量范围为0~3.3V,进行电压计算*/</span></span><br><span class="line">    <span class="comment">/*该处电压范围可以在对应原理图上的VOL找到*/</span></span><br><span class="line">    voltage = ADValue * <span class="number">3.3</span> / <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;ADValue:%d&quot;</span>, ADValue);</span><br><span class="line">    <span class="built_in">sprintf</span>(message2, <span class="string">&quot;voltage:%.2fV&quot;</span>, voltage);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>,<span class="number">16</span>,message2,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验-使用NTC热敏传感器测量温度-单通道"><a href="#实验-使用NTC热敏传感器测量温度-单通道" class="headerlink" title="实验-使用NTC热敏传感器测量温度(单通道)"></a>实验-使用NTC热敏传感器测量温度(单通道)</h2><h3 id="NTC介绍"><a href="#NTC介绍" class="headerlink" title="NTC介绍"></a>NTC介绍</h3><p><strong>NTC</strong> 是指 <strong>负温度系数热敏电阻</strong>（<strong>Negative Temperature Coefficient thermistor</strong>），是一种随着<strong>温度升高电阻值下降</strong>的热敏电阻器件。它的主要特点是电阻值与温度呈反比关系。</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>NTC热敏电阻本身是一个单独的电阻。在这个电路中，通常会与一个已知电阻（如10kΩ）串联，以形成一个分压器，这样可以通过测量电压来推算出NTC的电阻值。具体来说，NTC传感器的电阻值会随着温度变化而变化，而通过这个分压器电路可以得到一个对应的电压信号。</p>
<p>单片机上的原理图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20240927235951857-17375302847795.png" alt="image-20240927235951857"></p>
<blockquote>
<p><strong>电路工作原理</strong>：</p>
<ol>
<li><strong>NTC与固定电阻串联</strong>：电路中有一个NTC热敏电阻R_ntc和一个已知固定电阻R1串联。</li>
<li>电源：整个电路连接到一个电源Vcc（例如3.3V）。</li>
<li><strong>分压器</strong>：在NTC热敏电阻上得到的电压V_ntc 。</li>
</ol>
<p><strong>计算步骤</strong>：</p>
<ol>
<li><strong>通过ADC(12位)读取电压</strong>：ADC测量得到的值adc_value 代表的是在NTC热敏电阻上的电压：V_ntc = (adc_value / 4096 )* Vcc</li>
</ol>
<ol>
<li><strong>由分压公式</strong>有: V_ntc = (R_ntc/R_ntc+R1 ) * Vcc</li>
</ol>
<p>R_ntc = R1 * (v_ntc / vcc - v_ntc)</p>
<ol>
<li><strong>将ADC的值带入后简化得到R_ntc的值</strong>：</li>
</ol>
<p><strong>R_ntc = R1 * (adc_value / 4096 - adc_value)</strong></p>
<p><strong>计算公式为</strong>：</p>
<script type="math/tex; mode=display">
R_{ntc} = R_1*\frac{adValue}{4096-adValue}</script><p>得到R_ntc的值之后，使用B值公式计算出NTC热敏电阻的阻值对应温度T_ntc</p>
<script type="math/tex; mode=display">
T_{ntc} = \frac{B}{ln\frac{R_{ntc}}{R1}+\frac{B}{T_0}}</script><p>R_ntc：T_ntc温度下通过ADC计算得到的NTC电阻(单位为Ω)</p>
<p>R1：参考温度下ntc的电阻值(常温25°c，298.15K)</p>
<p>B：给出的B值(NTC热敏电阻的材料常数，单位K)</p>
<p>T0：常温(25℃，298.15K)</p>
</blockquote>
<h3 id="CubeMX配置-9"><a href="#CubeMX配置-9" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><blockquote>
<ol>
<li>配置Debug，打开外部晶振，配置时钟树。<strong>为了ADC转换结果的准确性，配置时钟树时注意分频后的ADC时钟信号最好不超过14Mhz</strong></li>
<li>从原理图中找到对应引脚，查看其对应ADC通道，然后在对应ADC中勾选通道</li>
<li><ul>
<li>ADC_Settings -&gt; Continuous Conversion Mode设为Enable，使ADC转换持续进行，不需要每次获取之前手动触发转换</li>
<li>ADC_Regular_ConversionMode -&gt; Rank -&gt; Sampling Time设为239.5 Cycles，最长采样时间，可以获得更稳定的转换结果，采样时间越长，转换结果越准确</li>
</ul>
</li>
<li><p>若有OLED显示等配置即可</p>
</li>
<li>生成项目</li>
</ol>
</blockquote>
<h3 id="业务代码-6"><a href="#业务代码-6" class="headerlink" title="业务代码"></a>业务代码</h3><ul>
<li><strong>通过ADC值计算NTC电阻值</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">getResistance</span><span class="params">(<span class="type">uint32_t</span> adValue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (adValue / (<span class="number">4096.0f</span> - adValue)) * <span class="number">10000.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*参数adValue:ADC转换的结果*/</span></span><br><span class="line"><span class="comment">/*10000.f 为串联电阻值大小10KΩ*/</span></span><br><span class="line"><span class="comment">/*返回值：NTC电阻值，浮点数类型，单位Ω*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>通过NTC阻值计算温度</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">calTemperature</span><span class="params">(<span class="type">float</span> R)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> B = <span class="number">3950.0f</span>;</span><br><span class="line">    <span class="type">float</span> R1 = <span class="number">10000.0f</span>;</span><br><span class="line">    <span class="type">float</span> T0 = <span class="number">25.0f</span>;</span><br><span class="line">    <span class="keyword">return</span>  B /(<span class="built_in">log</span>(R/R1)+ B/(<span class="number">273.15</span>+T0)) - <span class="number">273.15</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*C语言中log函数就是以e为底数的函数，即lnx*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 参数R：通过adValue计算得到的电阻</span></span><br><span class="line"><span class="comment">  * B：手册上给出的B值常数</span></span><br><span class="line"><span class="comment">  * R1: 串联电阻大小10KΩ</span></span><br><span class="line"><span class="comment">  * T0: 常温25℃</span></span><br><span class="line"><span class="comment">  * 返回值：温度，float类型，单位摄氏度</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">getResistance</span><span class="params">(<span class="type">uint32_t</span> adValue)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">calTemperature</span><span class="params">(<span class="type">float</span> R)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> message2[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> adValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> R = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> temp = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    adValue = HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line"></span><br><span class="line">    R  = getResistance(adValue);</span><br><span class="line">    <span class="comment">/*计算当前NTC电阻*/</span></span><br><span class="line">    temp = calTemperature(R);   </span><br><span class="line">     <span class="comment">/*C语言中log函数就是以e为底数的函数，即ln*/</span></span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;ADValue:%d&quot;</span>, adValue);</span><br><span class="line">    <span class="built_in">sprintf</span>(message2, <span class="string">&quot;temp:%.2f&quot;</span>, temp);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>,<span class="number">16</span>,message2,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p><strong>DMA，全称Direct Memory Access，即直接存储器访问。</strong></p>
<p><strong>DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输，无须CPU的干预，通过DMA数据可以快速地移动。这就节省了CPU的资源来做其他操作。</strong></p>
<p><strong>DMA的作用就是实现数据的直接传输，而去掉了传统数据传输需要CPU寄存器参与的环节</strong></p>
<blockquote>
<p><strong>一般在 数据量大的时候，频繁进入中断可能会出现问题，此时采用DMA搬运</strong></p>
<p><strong>DMA是CPU的小助手</strong></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/104827639">【STM32】HAL库 STM32CubeMX教程十一—-DMA (串口DMA发送接收)_stm32h7 串口dma 发送 第一次成功-CSDN博客</a></p>
<h2 id="DMA传输方式"><a href="#DMA传输方式" class="headerlink" title="DMA传输方式"></a>DMA传输方式</h2><ul>
<li><strong>方法1</strong>：DMA_Mode_Normal，正常模式。</li>
</ul>
<p>当一次DMA数据传输完后，停止DMA传送 ，也就是只传输一次
　　</p>
<ul>
<li><strong>方法2</strong>：DMA_Mode_Circular，循环传输模式。</li>
</ul>
<p>当传输结束时，硬件自动会将传输数据量寄存器进行重装，进行下一轮的数据传输。 也就是多次传输模式</p>
<h2 id="串口DMA模式与收发不定长数据"><a href="#串口DMA模式与收发不定长数据" class="headerlink" title="串口DMA模式与收发不定长数据"></a>串口DMA模式与收发不定长数据</h2><h3 id="DMA模式"><a href="#DMA模式" class="headerlink" title="DMA模式"></a>DMA模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*只需要将串口中断发送函数改为DMA即可*/</span></span><br><span class="line"></span><br><span class="line">串口DMA发送数据：</span><br><span class="line">HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span><br><span class="line"></span><br><span class="line">串口DMA接收数据：</span><br><span class="line">HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span><br><span class="line"></span><br><span class="line">串口DMA恢复函数</span><br><span class="line">HAL_UART_DMAResume(&amp;huart1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用DMA方式时，还是有中断参与其中，RxCpltCallback函数同样是由中断触发，只不过不是串口中断，而是<strong>DMA传输完成中断</strong>，DMA还有的就是<strong>传输过半中断</strong></p>
</blockquote>
<h3 id="收发不定长数据-Idle"><a href="#收发不定长数据-Idle" class="headerlink" title="收发不定长数据-Idle"></a>收发不定长数据-Idle</h3><blockquote>
<p><strong>收发不定长数据主要依靠IDLE(串口空闲中断)</strong>，所谓<strong>串口空闲中断</strong>就是，中断触发条件与接收的字节数无关，串口无数据接收时不会触发，必须要从接收到第一个数据开售，当RX引脚上无后续数据进入，串口接收从忙碌转为空闲时才会触发。可以认为空闲中断IDLE发生时就是一帧的数据包接收完成了，此时对数据进行分析处理即可。</p>
<p>一般用于接收大量数据</p>
</blockquote>
<ul>
<li><strong>串口接收数据</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAL_UARTEx_ReceiveToIdle();<span class="comment">//阻塞</span></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_IT();<span class="comment">//中断</span></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size);<span class="comment">//DMA</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ex代表扩展，Idle代表空闲中断</span></span><br><span class="line"><span class="comment"> * 以DMA为例，参数1，2不变，参数3并不是想要接收的长度，而是一次接收的最大长度</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>空闲中断对应回调函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart2, rData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="keyword">sizeof</span>(rData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ex代表扩展，Idle代表空闲中断</span></span><br><span class="line"><span class="comment"> * 参数2：size代表接收的数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用ReceiveToIdle相关函数时，<strong>不再调用RxCpltCallback回调，而是使用了RxEventCallback进行回调</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="type">uint16_t</span> pwmVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> mode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*首先还是要以Idle，启动中断或DMA模式*/</span></span><br><span class="line">    HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// HAL_UARTEx_ReceiveToIdle_IT(&amp;huart2,rData,50);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart2, rData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="keyword">sizeof</span>(rData));<span class="comment">//再次开启串口DMA或中断接收模式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DMA传输过半中断"><a href="#DMA传输过半中断" class="headerlink" title="DMA传输过半中断"></a>DMA传输过半中断</h3><blockquote>
<p>可以使用IT或DMA方式启动空闲中断，但是使用DMA模式时，除了串口的空闲中断外，<strong>DMA的传输过半中断</strong>也会触发RxEventCallback回调函数，即接收的数据量到达我们设置的最大值的一半时，也会触发这个回调函数，一般场景不适用，但某些场景有用。</p>
<p>可以通过加大数组长度或关闭DMA传输过半中断解决</p>
<p>所以一般情况下要关闭DMA传输过半中断</p>
</blockquote>
<ul>
<li><strong>关闭DMA传输过半中断</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__HAL_DMA_DISABLE_IT(&amp;hdma_usart2_rx,DMA_IT_HT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数1：DMA通道的指针地址，上面是usart2的rx通道</span></span><br><span class="line"><span class="comment">//参数2：需要关闭的中断,DMA_IT_HT就是传输过半中断</span></span><br><span class="line"><span class="comment">//每次DMA方式启动时都需要关闭!!!!</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：如果勾选了外设.c/.h文件单独生成，那么需要在usart.h中使用extern DMA_HandleTypeDef hdma_usart2_rx,否则找不到定义</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> DMA_HandleTypeDef hdma_usart2_rx;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> pwmVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> mode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData[<span class="number">10</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);</span></span><br><span class="line"></span><br><span class="line">    HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="number">10</span>);</span><br><span class="line">    __HAL_DMA_DISABLE_IT(&amp;hdma_usart2_rx,DMA_IT_HT);</span><br><span class="line">    <span class="comment">/*关闭DMA半传输中断*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart2, rData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="keyword">sizeof</span>(rData));</span><br><span class="line">        __HAL_DMA_DISABLE_IT(&amp;hdma_usart2_rx,DMA_IT_HT);</span><br><span class="line">        <span class="comment">/*再次关闭DMA半传输中断*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="蓝牙模块与简易数据包解析"><a href="#蓝牙模块与简易数据包解析" class="headerlink" title="蓝牙模块与简易数据包解析"></a>蓝牙模块与简易数据包解析</h1><h2 id="蓝牙模块介绍"><a href="#蓝牙模块介绍" class="headerlink" title="蓝牙模块介绍"></a>蓝牙模块介绍</h2><p>蓝牙通信是其常见的无线通信方式之一。蓝牙模块可以帮助STM32实现与其他设备（如手机、电脑、其他蓝牙设备）之间的无线通信。蓝牙模块在STM32系统中可以通过<strong>UART、SPI、I2C</strong>等接口与主控制器连接。</p>
<p><strong>蓝牙主要分类是</strong>：<strong>经典蓝牙</strong>和<strong>低功耗蓝牙</strong>(Bluetooth Low Energy,<strong>简称BLE</strong>)</p>
<p><strong>经典蓝牙：一般像耳机这种持续传输数据的</strong></p>
<p><strong>低功耗蓝牙：间歇性同步数据设备常用于嵌入式，如手环</strong></p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>……</p>
<h2 id="实验-蓝牙发送数据控制LED-UART"><a href="#实验-蓝牙发送数据控制LED-UART" class="headerlink" title="实验(蓝牙发送数据控制LED-UART)"></a>实验(蓝牙发送数据控制LED-UART)</h2><h3 id="简易数据包解析"><a href="#简易数据包解析" class="headerlink" title="简易数据包解析"></a>简易数据包解析</h3><blockquote>
<p>首先三个小灯、亮灭对应：</p>
<p>0x01   0x02  0x03        0xFF      0x00</p>
<p>红灯   绿灯   蓝灯        亮           灭</p>
<p>例如： 0x01 0x00 0x03 0xFF 代表红灯熄灭，蓝灯亮</p>
<ul>
<li><p>指令一般都会有包头，表示一帧数据的开始，这里规定包头为0xAA</p>
</li>
<li><p>包头后往往有一位数据包长度，指示此数据包一共多长</p>
</li>
<li><p>最后一位为校验和，为前面所有数据的和取<strong>1字节(16进制最后两位)</strong>，当收到数据后自行计算出的结果与数据包中自带的校验位比较，相同则用，不同舍弃</p>
</li>
</ul>
<p>假定: </p>
<p>AA 09 01 FF 02 FF 03 FF </p>
<p>AA + 9 +1 + FF + 3 + FF = 3B6  故校验位为B6</p>
<p>当向蓝色发送数据为</p>
<p>AA 09 01 FF 02 FF 03 FF B6(校验位) 代表包头0xAA 长度0x09 红灯绿灯蓝灯都亮</p>
</blockquote>
<h3 id="蓝牙发送数据控制LED开关"><a href="#蓝牙发送数据控制LED开关" class="headerlink" title="蓝牙发送数据控制LED开关"></a>蓝牙发送数据控制LED开关</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1114y1D7a4/?spm_id_from=333.788&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【keysking的STM32教程】第11集 使用蓝牙模块与简易数据包解析_哔哩哔哩_bilibili</a></p>
<ul>
<li>使用<strong>DX-BT24模块(BLE5.1)，实现蓝牙透传通信</strong>，波特率设置为9600</li>
<li>使用<strong>UART</strong>连接，UARTEx扩展库，实现不定长数据快速传输，不占用CPU资源</li>
<li>使用DMA通道，实现串口数据的快速传输，不占用cpu资源</li>
</ul>
<p>CubeMX配置：<a target="_blank" rel="noopener" href="https://docs.keysking.com/docs/stm32/example/UART_BLE_ECHO">【BLE 蓝牙】蓝牙透传通信 | 波特律动 (keysking.com)</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ReceiveData[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart3,ReceiveData,<span class="keyword">sizeof</span>(ReceiveData));</span><br><span class="line">    __HAL_DMA_DISABLE_IT(&amp;hdma_usart3_rx,DMA_IT_HT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    GPIO_PinState state = GPIO_PIN_RESET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart3)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ReceiveData[<span class="number">0</span>] == <span class="number">0xAA</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ReceiveData[<span class="number">1</span>] == Size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">uint8_t</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Size<span class="number">-1</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += ReceiveData[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum == ReceiveData[Size<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;Size<span class="number">-1</span>;i+=<span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(ReceiveData[i+<span class="number">1</span>] == <span class="number">0xFF</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            state = GPIO_PIN_SET;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(ReceiveData[i] == <span class="number">0x01</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            HAL_GPIO_WritePin(LED_BLUE_GPIO_Port,LED_BLUE_Pin,state);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(ReceiveData[i] == <span class="number">0x03</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            HAL_GPIO_WritePin(LED_RED_GPIO_Port,LED_RED_Pin,state);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart3, ReceiveData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart3,ReceiveData,<span class="keyword">sizeof</span>(ReceiveData));</span><br><span class="line">        __HAL_DMA_DISABLE_IT(&amp;hdma_usart3_rx,DMA_IT_HT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后使用蓝牙调试助手蓝牙，打开微信小程序【大夏无线传输助手】，点击【搜索】，找到 BT24，连接后发送</p>
<p><strong>注意：切换16进制发送</strong></p>
</blockquote>
<h1 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p><strong>I²C(Inter－Integrated Circuit)总线</strong>是一种由<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=NXP&amp;spm=1001.2101.3001.7020">NXP</a>（原PHILIPS）公司开发的两线式串行总线，用于连接微控制器及其外围设备。多用于主控制器和从器件间的主从通信，在小数据量场合使用，传输距离短，主从模式下，任意时刻只能有一个主机等特性，可以有多个从机。</p>
<p><strong>IIC是一种低速的，半双工，同步</strong>的通信总线 ，常用于连接微控制器与各种外围设备。</p>
<p>在 STM32 中，I²C 接口可以应用于以下几种场景：</p>
<blockquote>
<ol>
<li><strong>传感器读取</strong>：许多环境传感器（如温度、湿度、加速度等）使用 I²C 作为通信方式。通过 STM32 的 I²C 接口可以轻松地与这些传感器进行数据交换。</li>
<li><strong>显示模块控制</strong>：一些小型的 <strong>OLED 或 LCD 显示屏</strong>使用 I²C 接口进行命令和数据传输。STM32 可以用来驱动这些显示模块以显示信息或图像。</li>
<li><strong>音频编解码器</strong>：部分音频编解码芯片使用 I²C 作为配置接口，STM32 可以通过 I²C 配置这些芯片的工作模式，并接收或发送音频信号。</li>
<li><strong>实时时钟模块（RTC）</strong>：某些 RTC 模块也采用 I²C 接口来同步时间和日期信息，STM32 可以用作主控来更新 RTC 或从 RTC 获取时间。</li>
<li>………………</li>
</ol>
<p><strong>这里要注意IIC是为了与低速设备通信而发明的，所以IIC的传输速率比不上SPI</strong></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/105366932">IIC原理超详细讲解—-值得一看-CSDN博客</a>！！！！！！！！</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>IIC分为软件IIC和硬件IIC</strong></p>
<p><strong>软件IIC</strong>：软件IIC通信指的是用单片机的两个I/O端口模拟出来的IIC，用软件控制管脚状态以模拟I2C通信波形，软件模拟寄存器的工作方式。</p>
<p><strong>硬件IIC</strong>：一块硬件电路，硬件I2C对应芯片上的I2C外设，有相应I2C驱动电路，其所使用的I2C管脚也是专用的，硬件（固件）I2C是直接调用内部寄存器进行配置。</p>
<p>硬件I2C的效率要远高于软件的，而软件I2C由于不受管脚限制，接口比较灵活。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>IIC一共有只有两个总线： <strong>一条是双向的串行数据线SDA，一条是串行时钟线SCL</strong>，数据线同时间只能发送或接收数据，故为<strong>半双工通信</strong>。</p>
<ul>
<li><p>SDA(Serial data)是数据线，D代表Data也就是数据，Send Data 也就是用来传输数据的。</p>
</li>
<li><p>SCL(Serial clock line)是时钟线，C代表Clock 也就是时钟 也就是控制数据发送的时序的</p>
</li>
</ul>
<blockquote>
<p>所有接到I2C总线设备上的串行数据SDA都接到总线的SDA上，各设备的时钟线SCL接到总线的SCL上。I2C总线上的每个设备都自己一个唯一的地址，来确保不同设备之间访问的准确性。</p>
</blockquote>
<h2 id="物理层与协议层"><a href="#物理层与协议层" class="headerlink" title="物理层与协议层"></a>物理层与协议层</h2><ul>
<li><strong>物理层</strong></li>
</ul>
<blockquote>
<p>I2C 总线在物理连接上非常简单，分别由<strong>SDA(串行数据线)和SCL(串行时钟线)及上拉电阻</strong>组成。</p>
<p><strong>SCL和SDA都需要接上拉电阻</strong> (大小由速度和容性负载决定一般在3.3K-10K之间) 保证数据的稳定性，减少干扰。</p>
<p>通信原理：是通过对SCL和SDA线高低电平时序的控制，来产生I2C总线协议所需要的信号进行数据的传递。<strong>在总线空闲状态时，SCL和SDA被上拉电阻Rp拉高，使SDA和SCL线都保持高电平。</strong></p>
</blockquote>
<ul>
<li><strong>协议层</strong></li>
</ul>
<blockquote>
<p>I2C 总线在传送数据过程中共有三种类型信号， 它们分别是：开始信号、结束信号和应答信号。</p>
<ul>
<li><p><strong>开始信号</strong>：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。</p>
</li>
<li><p><strong>结束信号</strong>：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。</p>
</li>
<li><p><strong>应答信号</strong>：每当主机向从机发送完一个字节的数据，主机总是需要等待从机给出一个应答信号，以确认从机是否成功接收到了数据。</p>
</li>
</ul>
<p><strong>应答信号：主机SCL拉高，读取从机SDA的电平，为低电平表示产生应答</strong></p>
<p><strong>应答信号为低电平时，规定为有效应答位（ACK，简称应答位），表示接收器已经成功地接收了该字节；</strong><br><strong>应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。</strong></p>
<p><strong>每发送一个字节</strong>（8个bit）在一个字节传输的8个时钟后的第九个时钟期间，接收器接收数据后必须回一个ACK应答信号给发送器，这样才能进行数据传输。</p>
<p>应答出现在每一次主机完成8个数据位传输后紧跟着的时钟周期，低电平0表示应答，1表示非应答。</p>
<p><strong>注意：这些信号中，起始信号是必需的，结束信号和应答信号，都可以不要。</strong></p>
</blockquote>
<ul>
<li><strong>时序图</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241103171954458-17375302847796.png" alt="image-20241103171954458"></p>
<ul>
<li><strong>应答</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241103174539094-17375302847797.png" alt="image-20241103174539094"></p>
<h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><p><strong>主机和从机的概念</strong>：</p>
<p>主机就是负责整个系统的任务协调与分配，从机一般是通过接收主机的指令从而完成某些特定的任务，主机和从机之间通过总线连接，进行数据通讯。</p>
<ul>
<li>发布主要命令的称为主机</li>
<li>接受命令的称为从机</li>
</ul>
<blockquote>
<p>I2C是一种主从通信协议，允许多个设备连接在同一条总线上。每个从设备都有一个唯一的地址，称为<strong>Slave Address</strong>，以便主设备能够与特定的从设备进行通信。</p>
<p><strong>Slave Address</strong>是由7位或10位组成的二进制数字，在通信时主设备将此地址发送到总线上，从设备根据地址进行识别。</p>
<p>当主设备想要与某个从设备通信时，它会发送从设备的地址。如果从设备检测到自己的地址匹配，它将响应通信请求。主设备可以发送读命令或写命令，以此来从从设备获取数据或向其发送数据。</p>
<p>例如，假设STM32作为I2C主设备，而一个SSD1306 OLED显示屏作为从设备。SSD1306的I2C地址为<code>0x3C</code>（或<code>0x78</code>表示为8位地址）。主设备通过发送<code>0x3C</code>的地址来选择并与这个显示屏通信。</p>
</blockquote>
<h2 id="IIC相关函数"><a href="#IIC相关函数" class="headerlink" title="IIC相关函数"></a>IIC相关函数</h2><h3 id="IIC读写"><a href="#IIC读写" class="headerlink" title="IIC读写"></a>IIC读写</h3><ul>
<li><strong>IIC写函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, <span class="type">uint16_t</span> DevAddress, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);</span><br><span class="line"></span><br><span class="line">- hi2c 设置使用的是那个IIC 例：&amp;hi2c2</span><br><span class="line">- DevAddress 写入的地址 设置写入数据的地址 例 <span class="number">0xA0</span></span><br><span class="line">- *pData 需要写入的数据</span><br><span class="line">- Size 要发送的字节数</span><br><span class="line">- Timeout 最大传输时间，超过传输时间将自动退出传输函数</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>IIC读函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, <span class="type">uint16_t</span> DevAddress, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);</span><br><span class="line"></span><br><span class="line">- 参数同上</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>IIC写数据函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, <span class="type">uint16_t</span> DevAddress, <span class="type">uint16_t</span> MemAddress, <span class="type">uint16_t</span> MemAddSize, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);</span><br><span class="line"><span class="comment">/* 第1个参数为I2C操作句柄</span></span><br><span class="line"><span class="comment">   第2个参数为从机设备地址</span></span><br><span class="line"><span class="comment">   第3个参数为从机寄存器地址</span></span><br><span class="line"><span class="comment">   第4个参数为从机寄存器地址长度</span></span><br><span class="line"><span class="comment">   第5个参数为发送的数据的起始地址</span></span><br><span class="line"><span class="comment">   第6个参数为传输数据的大小</span></span><br><span class="line"><span class="comment">   第7个参数为操作超时时间 　　*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- *hi2c： I2C设备号指针，设置使用的是那个IIC 例：&amp;hi2c2</span><br><span class="line">- DevAddress： 从设备地址 从设备的IIC地址 例E2PROM的设备地址 <span class="number">0xA0</span></span><br><span class="line">- MemAddress： 从机寄存器地址 ，每写入一个字节数据，地址就会自动+<span class="number">1</span>,如果是<span class="number">256</span>K的寄存器，那么就是<span class="number">00</span>~FF</span><br><span class="line">- MemAddSize： 从机寄存器地址字节长度 <span class="number">8</span>位或<span class="number">16</span>位</span><br><span class="line">  写入数据的字节类型 <span class="number">8</span>位还是<span class="number">16</span>位</span><br><span class="line">  <span class="number">8b</span>it:I2C_MEMADD_SIZE_8BIT</span><br><span class="line">  <span class="number">16b</span>it:I2C_MEMADD_SIZE_16BIT</span><br><span class="line">- *pData： 需要写入的的数据的起始地址</span><br><span class="line">- Size： 传输数据的大小 多少个字节</span><br><span class="line">- Timeout： 最大读取时间，超过时间将自动退出函数</span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<p><strong>8位读写</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Mem_Write(&amp;hi2c2, ADDR, i, I2C_MEMADD_SIZE_8BIT,&amp;(I2C_Buffer_Write[i]),<span class="number">8</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">HAL_I2C_Mem_Read(&amp;hi2c2, ADDR, i, I2C_MEMADD_SIZE_8BIT,&amp;(I2C_Buffer_Write[i]),<span class="number">8</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>16位读写</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Mem_Write(&amp;hi2c2, ADDR, i, I2C_MEMADD_SIZE_16BIT,&amp;(I2C_Buffer_Write[i]),<span class="number">8</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">HAL_I2C_Mem_Read(&amp;hi2c2, ADDR, i, I2C_MEMADD_SIZE_16BIT,&amp;(I2C_Buffer_Write[i]),<span class="number">8</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>与上方写函数区别</strong>： </p>
<p><strong>IIC写多个数据</strong> 该函数<strong>适用于IIC外设里面还有子地址寄存器的设备，比方说E2PROM,除了设备地址，每个存储字节都有其对应的地址</strong></p>
<p><strong>如果只往某个外设中写数据，则用Master_Transmit。　如果是外设里面还有子地址，例如我们的E2PROM，有设备地址，还有每个数据的寄存器存储地址。则用Mem_Write。<br>Mem_Write是2个地  </strong></p>
<p><strong>址，Master_Transmit只有从机地址</strong></p>
</blockquote>
<h3 id="IIC中断"><a href="#IIC中断" class="headerlink" title="IIC中断"></a>IIC中断</h3><ul>
<li><strong>中断和DMA相关函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Master_Transmit_IT(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer));</span><br><span class="line"><span class="comment">/*中断读写*/</span></span><br><span class="line">HAL_I2C_Master_Receive_IT(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Transmit_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"><span class="comment">/*DMA模式读写*/</span></span><br><span class="line">HAL_I2C_Master_Receive_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断回调函数和DMA模式下进入的回调函数相同，都是下面的函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterTxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span>;<span class="comment">//发送回调</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterRxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span>;<span class="comment">//接收回调</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h2 id="实验-读写EEPROM-AT24C02"><a href="#实验-读写EEPROM-AT24C02" class="headerlink" title="实验-读写EEPROM(AT24C02)"></a>实验-读写EEPROM(AT24C02)</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/105259075">【STM32】HAL库 STM32CubeMX教程十二—-IIC(读取AT24C02 )_hal iic-CSDN博客</a></p>
<h3 id="EEPROM介绍"><a href="#EEPROM介绍" class="headerlink" title="EEPROM介绍"></a>EEPROM介绍</h3><p>AT24C02是一个2K Bit的串行EEPROM存储器（掉电不丢失），内部含有256个字节。在<strong>24C02里面有一个8字节的页写缓冲器</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241103234626099-17375302847798.png" alt="image-20241103234626099"></p>
<blockquote>
<p>可以通过存储IC的型号来计算芯片的存储容量是多大，比如<strong>24C02后面的02表示的是可存储2Kbit的数据，转换为字节的存储量为2*1024/8 = 256byte。</strong></p>
<p>那么24C04后面的04表示的是可存储4Kbit的数据，转换为字节的储存量为41024/8 = 512byte，以此来类推其它型号的存储空间。</p>
</blockquote>
<h3 id="设备地址"><a href="#设备地址" class="headerlink" title="设备地址"></a>设备地址</h3><p><strong>下图为芯片从地址：</strong></p>
<p>可以看出对于不同大小的24Cxx，具有不同的从器件地址。由于24C02为2k容量，也就是说只需要参考图中第一行的内容：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241103234639611-17375302847799.png" alt="image-20241103234639611"></p>
<blockquote>
<p><strong>这些只需要查看对应的手册都能找到</strong></p>
</blockquote>
<p><strong>芯片的寻址</strong>：<br>AT24C设备地址为如下，前四位固定为1010，A2~A0为由管脚电平。AT24CXX EEPROM Board模块中默认为接地。所以A2~A0默认为000，最后一位表示读写操作。所以AT24Cxx的读地址为0xA1,写地址为0xA0。</p>
<p>也就是说如果是<br>写24C02的时候，从器件地址为10100000（0xA0）；<br>读24C02的时候，从器件地址为10100001（0xA1）。</p>
<p><strong>片内地址寻址</strong>：</p>
<p>芯片寻址可对内部256Byte中的任一个进行读/写操作，其寻址范围为00~FF，共256个寻址单位。</p>
<p>对应的修改 A2A1A0 三位数据即可</p>
<h3 id="写读数据"><a href="#写读数据" class="headerlink" title="写读数据"></a>写读数据</h3><blockquote>
<p><strong>注意：</strong></p>
<ol>
<li><p>在写数据的过程中，<strong>每成功写入一个字节，E2PROM存储空间的地址就会自动加1，当加到0xFF后，再写一个字节，地址就会溢出又变成0x00</strong>。</p>
</li>
<li><p><strong>写数据的时候需要注意，E2PROM是先写到缓冲区，然后再“搬运到”到掉电非易失区。所以这个过程需要一定的时间，AT24C02这个过程是不超过5ms！</strong><br>所以，当我们在写多个字节时，写入一个字节之后，再写入下一个字节之前，必须<strong>延时5ms</strong>才可以</p>
</li>
</ol>
</blockquote>
<p><strong>对应教程</strong>:<a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/105259075">https://blog.csdn.net/as480133937/article/details/105259075</a></p>
<h3 id="CubeMX配置-10"><a href="#CubeMX配置-10" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><blockquote>
<ol>
<li>查看芯片手册打开对应I2C外设，参数全部默认即可</li>
<li>启动对应的串口</li>
</ol>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-11-4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;userCode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i2c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AT24C02_ADDR_WRITE 0xA0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AT24C02_ADDR_READ 0xA1</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> message[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> sendBuffer[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> receiveBuffer[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   HAL_GPIO_WritePin(LED0_GPIO_Port,LED0_Pin,GPIO_PIN_RESET);</span><br><span class="line">   HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,GPIO_PIN_RESET);</span><br><span class="line">   HAL_GPIO_WritePin(LED2_GPIO_Port,LED2_Pin,GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// HAL_UART_Transmit(&amp;huart1,&quot;Hello World&quot;,11,1000);</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      sendBuffer[i] = i;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(HAL_I2C_Mem_Write(&amp;hi2c1,AT24C02_ADDR_WRITE,j*<span class="number">8</span>,</span><br><span class="line">         I2C_MEMADD_SIZE_8BIT,sendBuffer+j*<span class="number">8</span>,<span class="number">8</span>,<span class="number">1000</span>) == HAL_OK)</span><br><span class="line">      &#123;</span><br><span class="line">         HAL_UART_Transmit(&amp;huart1,<span class="string">&quot;Write Test OK\n&quot;</span>,<span class="number">14</span>,<span class="number">1000</span>);</span><br><span class="line">         HAL_Delay(<span class="number">20</span>);<span class="comment">//写数据的时候大于5ms的延时</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         HAL_UART_Transmit(&amp;huart1,<span class="string">&quot;Write Test Failed\n&quot;</span>,<span class="number">18</span>,<span class="number">1000</span>);</span><br><span class="line">         HAL_Delay(<span class="number">20</span>);<span class="comment">//同上</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">      // wrinte date to EEPROM   如果要一次写一个字节，写256次，用这里的代码</span></span><br><span class="line"><span class="comment">      for(i=0;i&lt;BufferSize;i++)</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">          HAL_I2C_Mem_Write(&amp;hi2c1, ADDR_24LCxx_Write, i, I2C_MEMADD_SIZE_8BIT,&amp;WriteBuffer[i],1，0xff);//使用I2C块读，出错。因此采用此种方式，逐个单字节写入</span></span><br><span class="line"><span class="comment">        HAL_Delay(5);//此处延时必加，与AT24C02写时序有关</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      printf(&quot;\r\n EEPROM 24C02 Write Test OK \r\n&quot;);</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">   HAL_I2C_Mem_Read(&amp;hi2c1,AT24C02_ADDR_READ,<span class="number">0</span>,I2C_MEMADD_SIZE_8BIT,receiveBuffer,<span class="number">256</span>,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">256</span>;k++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(message,<span class="string">&quot;0x%02X &quot;</span>,receiveBuffer[k]);</span><br><span class="line">      HAL_UART_Transmit(&amp;huart1,message,<span class="number">6</span>,<span class="number">1000</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// HAL_UART_Transmit(&amp;huart1,&quot;Hello World&quot;,11,1000);</span></span><br><span class="line">   <span class="comment">// HAL_Delay(1000);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>AT24C02的IIC每次写之后要延时一段时间才能继续写 每次写之后要delay 5ms左右 不管硬件IIC采用何种形式（DMA，IT），都要确保两次写入的间隔大于5ms;</strong></li>
</ul>
<ul>
<li><p><strong>AT24C02页写入只支持8个byte，所以需要分32次写入。这不是HAL库的bug，而是AT24C02的限制，其他的EEPROM可以支持更多byte的写入。</strong><br><strong>当然，你也可以每次写一个字节，分成256次写入，也是可以的 那就用注释了的代码即可</strong></p>
</li>
<li><p><strong>读写函数最后一个超时调整为1000以上 因为我们一次写8个字节，延时要久一点</strong></p>
</li>
</ul>
<ul>
<li><strong>注意读取AT24C02数据的时候延时也要久一点，否则会造成读的数据不完整</strong></li>
</ul>
</blockquote>
<h2 id="实验-使用AHT20温湿度传感器-轮询"><a href="#实验-使用AHT20温湿度传感器-轮询" class="headerlink" title="实验-使用AHT20温湿度传感器(轮询)"></a>实验-使用AHT20温湿度传感器(轮询)</h2><p><a target="_blank" rel="noopener" href="https://docs.keysking.com/docs/stm32/example/I2C_AHT20">【I²C总线】AHT20温湿度传感器 | 波特律动 (keysking.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1QN411D7ak/?spm_id_from=pageDriver&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32入门教程-2024】第12集 IIC通信与温湿度传感器AHT20(DHT20)_哔哩哔哩_bilibili</a></p>
<h3 id="CubeMX配置：-1"><a href="#CubeMX配置：-1" class="headerlink" title="CubeMX配置："></a>CubeMX配置：</h3><blockquote>
<ol>
<li>打开I2C外设，参数全部默认即可</li>
<li>启动对应的串口</li>
</ol>
</blockquote>
<h3 id="传感器读取流程"><a href="#传感器读取流程" class="headerlink" title="传感器读取流程"></a>传感器读取流程</h3><p>打开温湿度传感器AHT20数据手册，找到5.4传感器读取流程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20240920220016640-173753028478010.png" alt="image-20240920220016640"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*读取流程1*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer;</span><br><span class="line">    HAL_Delay(<span class="number">40</span>);</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,&amp;readBuffer,<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( (readBuffer &amp; <span class="number">0x08</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xBE</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">        HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>(readBuffer &amp; 0x08) == 0x00 这里按位与就是确定第4位Bit[3]是否为1，不为1就发送sendBuffer</strong></p>
<p>注意&amp;的优先级很低，要加括号</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AHT20_ReadData</span><span class="params">(<span class="type">float</span>* temperature, <span class="type">float</span>* humidity)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xAC</span>,<span class="number">0x33</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*流程2*/</span> HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    HAL_Delay(<span class="number">75</span>);</span><br><span class="line">    HAL_I2C_Master_Receive(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer),<span class="number">100</span>);</span><br><span class="line">    ----------------------------------------</span><br><span class="line">   <span class="comment">/*流程3*/</span></span><br><span class="line">    <span class="keyword">if</span>((readBuffer[<span class="number">0</span>] &amp; <span class="number">0x80</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> data = <span class="number">0</span>;</span><br><span class="line">        data = ((<span class="type">uint32_t</span>)readBuffer[<span class="number">1</span>] &lt;&lt; <span class="number">12</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>);</span><br><span class="line">     <span class="comment">/*流程4*/</span>   </span><br><span class="line">        *humidity = (data * <span class="number">100.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        data = ( ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>]&amp;<span class="number">0x0F</span>) &lt;&lt; <span class="number">16</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) + (<span class="type">uint32_t</span>)readBuffer[<span class="number">5</span>];</span><br><span class="line">     <span class="comment">/*流程4*/</span></span><br><span class="line">        *temperature = (data*<span class="number">200.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-50</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20240920221150638-173753028478011.png" alt="image-20240920221150638"></p>
<blockquote>
<p>上图中蓝色为从机发送给主机的数据，可得温度和湿度都是2.5个字节</p>
<p><strong>需要将其拆开后拼接起来可得到温湿度数据，使用位操作，此时注意强制转换为uint32_t避免移动时丢失数据</strong></p>
</blockquote>
<p>  <strong>最后计算</strong>：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20240920221420656-173753028478012.png" alt="image-20240920221420656"></p>
<blockquote>
<p><strong>SRH就是拼接后的湿度，ST就是拼接后的温度</strong></p>
</blockquote>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><blockquote>
<p>我们通常会为不同的模块单独建立驱动文件, <strong>新建.c/.h文件aht20.c和aht20.h，在main.c中进行获取温湿度并显示</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20240920220428021-173753028478013.png" alt="image-20240920220428021"></p>
<p>设备地址7位，但是发送时通常是8位，包括一位读写为，故要左移一位即01110000故设备地址为0x70，使用函数时会根据读或写，自动帮我们确定最后一位为0还是1，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*aht20.h文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AHT20_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHT20_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHT20_ADDRESS 0x70</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_ReadData</span><span class="params">(<span class="type">float</span>* temperature,<span class="type">float</span>* humidity)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//AHT20_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*aht20.c文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aht20.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer;</span><br><span class="line">    HAL_Delay(<span class="number">40</span>);</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,&amp;readBuffer,<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>( (readBuffer &amp; <span class="number">0x08</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xBE</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">        HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_ReadData</span><span class="params">(<span class="type">float</span>* temperature, <span class="type">float</span>* humidity)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xAC</span>,<span class="number">0x33</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    HAL_Delay(<span class="number">75</span>);</span><br><span class="line">    HAL_I2C_Master_Receive(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer),<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((readBuffer[<span class="number">0</span>] &amp; <span class="number">0x80</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> data = <span class="number">0</span>;</span><br><span class="line">        data = ((<span class="type">uint32_t</span>)readBuffer[<span class="number">1</span>] &lt;&lt; <span class="number">12</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        *humidity = (data * <span class="number">100.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        data = ( ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>]&amp;<span class="number">0x0F</span>) &lt;&lt; <span class="number">16</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) + (<span class="type">uint32_t</span>)readBuffer[<span class="number">5</span>];</span><br><span class="line">        *temperature = (data*<span class="number">200.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-50</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aht20.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> temperature;</span><br><span class="line"><span class="type">float</span> humidity;</span><br><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    AHT20_Init();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    AHT20_ReadData(&amp;temperature,&amp;humidity);</span><br><span class="line">    <span class="built_in">sprintf</span>(message,<span class="string">&quot;温度：%.lf°c 湿度: %.lf %%&quot;</span>,temperature,humidity);</span><br><span class="line">   <span class="comment">/*sprintf函数可以拼接字符串,需要包含stdio.h文件*/</span> HAL_UART_Transmit(&amp;huart2,message,<span class="keyword">sizeof</span>(message),<span class="number">1000</span>);</span><br><span class="line">	<span class="comment">/*发送到串口，使用串口调试助手*/</span></span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="IIC中断与DMA以及状态机编程"><a href="#IIC中断与DMA以及状态机编程" class="headerlink" title="IIC中断与DMA以及状态机编程"></a>IIC中断与DMA以及状态机编程</h2><blockquote>
<p> <strong>IIC中断和DMA使用方法和串口类似</strong></p>
</blockquote>
<h3 id="相关函数-4"><a href="#相关函数-4" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Master_Transmit_IT(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer));</span><br><span class="line"><span class="comment">/*中断读写*/</span></span><br><span class="line">HAL_I2C_Master_Receive_IT(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Transmit_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"><span class="comment">/*DMA模式读写*/</span></span><br><span class="line">HAL_I2C_Master_Receive_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断回调函数和DMA模式下进入的回调函数相同，都是下面的函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterTxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span>;<span class="comment">//发送回调</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterRxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span>;<span class="comment">//接收回调</span></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="状态机编程"><a href="#状态机编程" class="headerlink" title="状态机编程"></a>状态机编程</h3><blockquote>
<p> 在STM32微控制器（MCU）编程中，状态机（State Machine）是一种常用的设计模式，用来管理复杂系统的不同状态以及在状态之间进行的切换。<strong>状态机编程有助于使代码结构清晰、易于维护，特别适用于处理嵌入式系统中的顺序逻辑、通信协议、控制流程等问题</strong>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*状态机编程通常是使用枚举设定状态，例如该模块实验中可以设置如下状态*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AHT_MEASURE,</span><br><span class="line">    AHT_SEND,</span><br><span class="line">    AHT_GET,</span><br><span class="line">    AHT_RECEIVE,</span><br><span class="line">    AHT_ANALYSIS</span><br><span class="line">&#125; AHT20State;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 0:初始状态发送测量命令</span></span><br><span class="line"><span class="comment"> * 1：发送中</span></span><br><span class="line"><span class="comment"> * 2：发送完成,75ms后进行读取</span></span><br><span class="line"><span class="comment"> * 3：读取中</span></span><br><span class="line"><span class="comment"> * 4：读取完成，数据解析</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*轮询中对应处理*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">switch</span> (aht20State)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> AHT_MEASURE:</span><br><span class="line">            AHT20_Measure();</span><br><span class="line">            aht20State = AHT_SEND;</span><br><span class="line">        <span class="keyword">case</span> AHT_GET:</span><br><span class="line">            HAL_Delay(<span class="number">75</span>);</span><br><span class="line">            AHT20_Get();</span><br><span class="line">            aht20State = AHT_RECEIVE;</span><br><span class="line">        <span class="keyword">case</span> AHT_ANALYSIS:</span><br><span class="line">            AHT20_Analysis(&amp;temperature,&amp;humidity);</span><br><span class="line">            <span class="built_in">sprintf</span>(message,<span class="string">&quot;温度：%.1lf°c 湿度:%.1lf %%&quot;</span>,temperature,humidity);</span><br><span class="line"></span><br><span class="line">            HAL_UART_Transmit(&amp;huart2,message,<span class="keyword">sizeof</span>(message),<span class="number">1000</span>);</span><br><span class="line">            HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">            aht20State =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="实验-使用AHT20温湿度传感器-状态机"><a href="#实验-使用AHT20温湿度传感器-状态机" class="headerlink" title="实验-使用AHT20温湿度传感器(状态机)"></a>实验-使用AHT20温湿度传感器(状态机)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*aht20.h文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AHT20_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHT20_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHT20_ADDRESS 0x70</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AHT_MEASURE,</span><br><span class="line">    AHT_SEND,</span><br><span class="line">    AHT_GET,</span><br><span class="line">    AHT_RECEIVE,</span><br><span class="line">    AHT_ANALYSIS</span><br><span class="line">&#125; AHT20State;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 0:初始状态发送测量命令</span></span><br><span class="line"><span class="comment"> * 1：发送中</span></span><br><span class="line"><span class="comment"> * 2：发送完成,75ms后进行读取</span></span><br><span class="line"><span class="comment"> * 3：读取中</span></span><br><span class="line"><span class="comment"> * 4：读取完成，数据解析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//void AHT20_ReadData(float* temperature,float* humidity);</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Measure</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Get</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Analysis</span><span class="params">(<span class="type">float</span>* temperature, <span class="type">float</span>* humidity)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//AHT20_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*aht20.c文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aht20.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> readBuffer[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer;</span><br><span class="line">    HAL_Delay(<span class="number">40</span>);</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,&amp;readBuffer,<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>( (readBuffer &amp; <span class="number">0x08</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xBE</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">        HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Measure</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*此处的sendBuffer为了避免该函数作用域结束后回收，故设置为static方便多次测量*/</span></span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xAC</span>,<span class="number">0x33</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">    HAL_I2C_Master_Transmit_DMA(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer));<span class="comment">//或者以中断模式启动，都是非阻塞模式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Get</span><span class="params">()</span></span><br><span class="line">&#123; HAL_I2C_Master_Receive_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));<span class="comment">//或者以中断模式启动，都是非阻塞模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Analysis</span><span class="params">(<span class="type">float</span>* temperature, <span class="type">float</span>* humidity)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((readBuffer[<span class="number">0</span>] &amp; <span class="number">0x80</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> data = <span class="number">0</span>;</span><br><span class="line">        data = ((<span class="type">uint32_t</span>)readBuffer[<span class="number">1</span>] &lt;&lt; <span class="number">12</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        *humidity = (data * <span class="number">100.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        data = ( ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>]&amp;<span class="number">0x0F</span>) &lt;&lt; <span class="number">16</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) + (<span class="type">uint32_t</span>)readBuffer[<span class="number">5</span>];</span><br><span class="line">        *temperature = (data*<span class="number">200.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-50</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aht20.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> temperature;</span><br><span class="line"><span class="type">float</span> humidity;</span><br><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">AHT20State aht20State;<span class="comment">//状态机枚举变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    AHT20_Init();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">switch</span> (aht20State)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> AHT_MEASURE:</span><br><span class="line">            AHT20_Measure();</span><br><span class="line">            aht20State = AHT_SEND;</span><br><span class="line">        <span class="keyword">case</span> AHT_GET:</span><br><span class="line">            HAL_Delay(<span class="number">75</span>);</span><br><span class="line">            AHT20_Get();</span><br><span class="line">            aht20State = AHT_RECEIVE;</span><br><span class="line">        <span class="keyword">case</span> AHT_ANALYSIS:</span><br><span class="line">            AHT20_Analysis(&amp;temperature,&amp;humidity);</span><br><span class="line">            <span class="built_in">sprintf</span>(message,<span class="string">&quot;温度：%.1lf°c 湿度:%.1lf %%&quot;</span>,temperature,humidity);</span><br><span class="line"></span><br><span class="line">            HAL_UART_Transmit(&amp;huart2,message,<span class="keyword">sizeof</span>(message),<span class="number">1000</span>);</span><br><span class="line">            HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">            aht20State =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterTxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi2c == &amp;hi2c1)</span><br><span class="line">    &#123;</span><br><span class="line">        aht20State = AHT_GET;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterRxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi2c == &amp;hi2c1)</span><br><span class="line">    &#123;</span><br><span class="line">        aht20State = AHT_ANALYSIS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p><strong>SPI 是英语Serial Peripheral interface的缩写</strong>，顾名思义就是<strong>串行外围设备接口</strong>。是Motorola(摩托罗拉)首先在其MC68HCXX系列处理器上定义的。</p>
<p><strong>SPI是一种高速的，全双工，同步</strong>的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便。</p>
<p>主要应用在 EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。</p>
<blockquote>
<p> <strong>SPI是全双工且SPI没有定义速度限制，一般的实现通常能达到甚至超过10 Mbps</strong></p>
</blockquote>
<p><strong>学习资料</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/105764119">SPI原理超详细讲解—-值得一看-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/105849607?spm=1001.2014.3001.5502">【STM32】HAL库 STM32CubeMX教程十四—-SPI_cubemx spi-CSDN博客</a></p>
<h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><blockquote>
<p><strong>SPI分为主、从两种模式</strong>，一个SPI通讯系统需要包含<strong>一个（且只能是一个）主设备</strong>，一个或多个从设备。<strong>提供时钟的为主设备（Master</strong>），<strong>接收时钟的设备为从设备（Slave）</strong>。</p>
<p>SPI接口的读写操作，都是由主设备发起。当存在多个从设备时，通过各自的<strong>片选信号</strong>进行管理。</p>
</blockquote>
<h2 id="信号线"><a href="#信号线" class="headerlink" title="信号线"></a>信号线</h2><p><strong>SPI接口有四条信号线通信</strong>:</p>
<ol>
<li><p><strong>SDI(数据输入)</strong></p>
</li>
<li><p><strong>SDO(数据输出)</strong></p>
</li>
<li><p><strong>SCK(时钟)</strong></p>
</li>
<li><p><strong>CS(片选)</strong></p>
</li>
</ol>
<blockquote>
<ul>
<li><strong>MISO</strong>(Master input Slave output)： 主设备输入/从设备输出引脚。该引脚在从模式下发送数据，在主模式下接收数据。</li>
<li><strong>MOSI</strong>： 主设备输出/从设备输入引脚。该引脚在主模式下发送数据，在从模式下接收数据。</li>
<li><strong>SCLK</strong>：<strong>串行时钟信号</strong>，由主设备产生。</li>
<li><strong>CS/SS</strong>：<strong>从设备片选信号</strong>，由主设备控制。它的功能是用来作为“片选引脚”，<strong>也就是选择指定的从设备，让主设备可以单独地与特定从设备通讯，避免数据线上的冲突。</strong></li>
</ul>
</blockquote>
<p><strong>对应硬件上为4根线</strong></p>
<p><strong>SPI一对一</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241106150546130-173753028478014.png" alt="image-20241106150546130"></p>
<p><strong>SPI一对多</strong>:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241106150618856-173753028478015.png" alt="image-20241106150618856"></p>
<h2 id="数据发送和接收"><a href="#数据发送和接收" class="headerlink" title="数据发送和接收"></a>数据发送和接收</h2><blockquote>
<p><strong>SPI主机和从机都有一个串行移位寄存器(8位)，主机通过向它的SPI串行寄存器写入一个字节来发起一次传输。</strong></p>
<ol>
<li>首先拉低对应SS信号线，表示与该设备进行通信</li>
<li>主机通过发送SCLK时钟信号，来告诉从机写数据或者读数据<br>这里要注意，SCLK时钟信号可能是低电平有效，也可能是高电平有效，因为SPI有四种模式，这个我们在下面会介绍</li>
<li>主机(Master)将要发送的数据写到发送数据缓存区(Memory)，缓存区经过移位寄存器(0~7)，串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。</li>
<li>从机(Slave)也将自己的串行移位寄存器(0~7)中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，<strong>两个移位寄存器中的内容就被交换。</strong></li>
</ol>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241106151444762-173753028478016.png" alt="image-20241106151444762"></p>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><blockquote>
<p><strong>根据时钟极性（CPOL）及相位（CPHA）不同</strong>，<strong>SPI有四种工作模式</strong>。<br>时钟极性(CPOL)定义了时钟空闲状态电平：</p>
<p>CPOL=0为时钟空闲时为<strong>低电平</strong><br>CPOL=1为时钟空闲时为<strong>高电平</strong><br>时钟相位(CPHA)定义数据的采集时间。</p>
<p>CPHA=0:在时钟的<strong>第一个跳变沿</strong>（上升沿或下降沿）进行数据采样。<br>CPHA=1:在时钟的<strong>第二个跳变沿</strong>（上升沿或下降沿）进行数据采样。</p>
</blockquote>
<p><strong>对应组合四种模式为</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241106151100423-173753028478017.png" alt="image-20241106151100423"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/as480133937/article/details/105764119">SPI原理超详细讲解—-值得一看-CSDN博客</a></p>
<h2 id="W25Q128-FLASH芯片"><a href="#W25Q128-FLASH芯片" class="headerlink" title="W25Q128 FLASH芯片"></a>W25Q128 FLASH芯片</h2><p><strong>W25Q128是一款SPI通信的FLASH芯片，可以通过标准/两线/四线SPI控制</strong></p>
<p>FLASH的大小为16M，分为 256 个块（Block），每个块大小为 64K 字节，每个块又分为 16个扇区（Sector），每个扇区 4K 个字节。</p>
<p>通过SPI通信协议即可实现MCU(STM32)和 W25Q128 之间的通信。实现W25Q128的控制需要通过SPI协议发送相应的控制指令，并满足一定的时序。</p>
<p>打开芯片手册可以找到对应的操作：</p>
<ol>
<li><strong>写使能</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241106154535945-173753028478018.png" alt="image-20241106154535945"></p>
<blockquote>
<p>阅读最后一段英文可知：</p>
<p>写入使能通过将 /CS 驱动为低电平，将指令代码“06H(0x06)”在 CLK 的上升沿时移至数据输入 （DI） 引脚，然后驱动 /CS 为高电平</p>
<p><strong>即：向FLASH发送0x06 写使能命令即可开启写使能，首先CS片选拉低，控制写入字节函数写入命令，CS片选拉高。</strong></p>
</blockquote>
<ol>
<li><strong>扇区擦除指令(Sector Erase)</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241106155057196-173753028478019.png" alt="image-20241106155057196"></p>
<blockquote>
<p>第二排可以看到</p>
<p>必须先执行 Write Enable 指令，设备才会接受 Sector Erase。通过将 /CS 引脚驱动为低电平来启动该指令，再将指令代码“20H”+24为扇区地址 （A23-A0） </p>
<p>在最后一个字节的第 8 位被锁存后，必须将 /CS 引脚驱动为高电平。如果未执行此操作，则Sector Erase 指令将不会被执行。</p>
<p>即：</p>
<p><strong>扇区擦除指令，数据写入前必须擦除对应的存储单元，该指令先拉低/CS引脚电平,接着传输“20H”指令和要24位要擦除扇区的地址。</strong></p>
</blockquote>
<ol>
<li><strong>读命令</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241106175057582-173753028478120.png" alt="image-20241106175057582"></p>
<blockquote>
<p><strong>第一排：读取可以一次读取一个或多个数据字节</strong></p>
<p><strong>先拉低CS电平，再传输03H，接着通过DI管教传输24为地址，最终数据通过DO引脚引出。每传输一个字节地址自动递增，所以只要时钟继续传输，就可以不断读取出储存器中的数据。</strong></p>
</blockquote>
<ol>
<li>状态读取命令(Read Status Register)</li>
</ol>
<ol>
<li>写入命令(Page Program)</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241106175641621-173753028478121.png" alt="image-20241106175641621"></p>
<blockquote>
<p>在对W25Q128 FLASH的写入数据的操作中一<strong>定要先擦出扇区，在进行写入，否则将会发生数据错误。</strong><br>W25Q128 FLASH一次性最大写入只有256个字节。<br>在进行写操作之前，一定要开启写使能(Write Enable)。<br>当只接收数据时不但能只检测RXNE状态 ，必须同时向发送缓冲区发送数据才能驱动SCK时钟跳变。</p>
</blockquote>
<h2 id="实验读写FLASH-W25Q128"><a href="#实验读写FLASH-W25Q128" class="headerlink" title="实验读写FLASH(W25Q128)"></a>实验读写FLASH(W25Q128)</h2><h3 id="CubeMX配置-11"><a href="#CubeMX配置-11" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><p><strong>主要说SPI配置页面</strong>：</p>
<ol>
<li><strong>Mode</strong>： Full-Duplex为全双工  Half-Duplex半双工</li>
</ol>
<ul>
<li>有主机模式全双工/半双工</li>
<li>从机模式全双工/半双工</li>
<li>只接收主机模式/只接收从机模式</li>
<li>只发送主机模式</li>
</ul>
<p><strong>2. Hardware NSS Signal</strong>(硬件片选信号)：片选分为软件片选和硬件片选。STM32有硬件片选信号，可以选择使能，也可以使用其他IO口接到芯片的NSS上进行代替</p>
<p><strong>其中SIP1的片选NSS ： SPI1_NSS（PA4）<br>其中SIP2的片选NSS ： SPI2_NSS（PB12）</strong></p>
<p>如果片选引脚没有连接 SPI1_NSS（PA4）或者SPI2_NSS（PB12），则需要选择软件片选</p>
<blockquote>
<p>NSS管脚及我们熟知的片选信号，作为主设备NSS管脚为高电平，从设备NSS管脚为低电平。当NSS管脚为低电平时，该spi设备被选中，可以和主设备进行通信。在stm32中，每个spi控制器的NSS信号引脚都具有两种功能，即输入和输出。</p>
<p>所谓的输入就是NSS管脚的信号给自己。所谓的输出就是将NSS的信号送出去，给从机。</p>
<p>对于NSS的输入，又分为软件输入和硬件输入。</p>
<p><strong>软件输入</strong>：<br>NSS分为内部管脚和外部管脚，通过设置spi_cr1寄存器的ssm位和ssi位都为1可以设置NSS管脚为软件输入模式且内部管脚提供的电平为高电平，其中SSM位为使能软件输入位。SSI位为设置内部管脚电平位。同理通过设置SSM和SSI位1和0则此时的NSS管脚为软件输入模式但内部管脚提供的电平为0。若从设备是一个其他的带有spi接口的芯片，并不能选择NSS管脚的方式，则可以有两种办法：</p>
<p><strong>1. 将NSS管脚直接接低电平。</strong></p>
<p><strong>2. 通过主设备的任何一个gpio口去输出低电平选中从设备。</strong></p>
<p><strong>硬件输入</strong>：<br>主机接高电平，从机接低电平。</p>
</blockquote>
<p><strong>硬件片选信号直接配置即可，下面说软件片选</strong></p>
<blockquote>
<p>只需要对应软件片选引脚(选择硬件片选对应引脚)，选择GPIO_Output,然后设置下备注即可SPI2_CS</p>
<p> W25Q128V芯片闪存芯片进行通信，所以设置为<strong>主机全双工</strong></p>
</blockquote>
<hr>
<p>然后进行基本参数配置：</p>
<blockquote>
<p><strong>Basic Parameters</strong>:</p>
<p>Frame Format(帧格式):默认Motorola通信格式</p>
<p>Data Size: 默认8bit</p>
<p>First Bit：有MSB First(高位在前)和LSB First(低位在前)</p>
<p><strong>Clock Parameters:</strong></p>
<p>Prescaler(for Baud Rate):SPI波特率分频值，决定SPI时钟参数</p>
<p>Baud Rate：上面设置分频后得到的传输速率</p>
<p>Clock Polarity(CPOL)：时钟极性，选择是高还是低电平</p>
<p>Clock Phase(CPHA)：时钟相位，选择第几个跳变沿(上升/下降沿)采样</p>
<p><strong>Advanced Parameters</strong>:</p>
<p>CRC Calculation：CRC校验项，提高通信可靠性</p>
<p>NSS Signal Type：选择软件片选或者硬件片选</p>
<p>SPI配置中设置数据长度为8bit,MSB先输出分频为64分频，则波特率为125KBits/s。其他为默认设置。<br>Motorla格式，CPOL设置为Low,CPHA设置为第一个边沿。不开启CRC检验，NSS为软件控制。</p>
</blockquote>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>因为我们是软件使能片选，定义片选引脚，<strong>CS片选低电平为有效使能</strong>， <strong>CS片选高电平不使能</strong></p>
<p>这里用两个宏定义来代替</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以W25Q128为例</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CS_Enable() 			HAL_GPIO_WritePin(GPIOA, SPI1_CS_Pin, GPIO_PIN_RESET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CS_Disable() 		HAL_GPIO_WritePin(GPIOA, SPI1_CS_Pin, GPIO_PIN_SET)</span></span><br></pre></td></tr></table></figure>
<p>使用野火官方提供的驱动即可</p>
<h2 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h2><p>从对应SPI头文件可以看到对应<strong>轮询，中断和DMA三种方式</strong></p>
<ul>
<li><strong>SPI发送/接收数据函数</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);<span class="comment">//发送数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * hspi: 选择SPI1/2，比如&amp;hspi1，&amp;hspi2</span></span><br><span class="line"><span class="comment">  * pData ： 需要发送的数据，可以为数组</span></span><br><span class="line"><span class="comment">  * Size： 发送数据的字节数，1 就是发送一个字节数据</span></span><br><span class="line"><span class="comment">  * Timeout： 超时时间，就是执行发送函数最长的时间，超过该时间自动退出发送函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">HAL_SPI_Receive(SPI_HandleTypeDef *hspi, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);<span class="comment">//接收数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SPI中断函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　</span><br><span class="line">HAL_SPI_TransmitReceive_IT(&amp;hspi1, TXbuf,RXbuf,CommSize);</span><br><span class="line"><span class="comment">//中断启动,当SPI上接收出现了 CommSize个字节的数据后，中断函数会调用SPI回调函数：</span></span><br><span class="line">HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)</span><br><span class="line"><span class="comment">//中断回调</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="OLED"><a href="#OLED" class="headerlink" title="OLED"></a>OLED</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><p>所谓OLED，就是由一个个发光的二极管(发光小灯)组成，<strong>每个小灯称为一个像素</strong>，只要在屏幕上有选择的点亮一部分小灯，就可以显示我们想要的图案，<strong>而小灯排列的数目就是分辨率</strong>。</p>
<blockquote>
<p><strong>常见尺寸分辨率：128X64 -&gt;128列，64行小灯</strong>，此时如果再按照之前的方法一个引脚控制一个小灯的话消耗太大,显然不可能。所以我们<strong>需要屏幕驱动芯片</strong></p>
</blockquote>
<p>有了屏幕驱动芯片，我们只需要通过<strong>IIC或者SPI</strong>等通讯协议与屏幕驱动芯片进行通信，就可以操控这些小灯的亮灭。</p>
<p><strong>常见屏幕驱动芯片有SSD1306、CH1116、SH1106等</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19u4y197df/?spm_id_from=333.788&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32入门教程-2024】第14集 如何在OLED屏幕上挥毫_哔哩哔哩_bilibili</a></p>
<h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p><strong>与CH1116的通信分为两类：指令和数据</strong></p>
<p>以CH1116为例：分辨率为64X128，将64行划分为page0~page7(8页)，</p>
<p>每一个page从0到7共8行，列数为128不变。</p>
<p><strong>从芯片数据手册可以查到，CH1116的从地址为0x7A</strong></p>
<blockquote>
<p>通常在对应芯片手册(下面为CH1116芯片)中可以找到I2C地址，如下图7位为:0111100或0111101，第8位为R/W位，故为0x7A</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20240922165310629-173753028478122.png" alt="image-20240922165310629"></p>
<blockquote>
<ol>
<li><strong>指令通讯格t式</strong>：</li>
</ol>
<p><strong>0x7A + 0x00  一字节指令</strong>  </p>
<p>0x7A为IIC地址，0x00开头+一字节指令是我们需要发送的。</p>
<p>设置页地址只分为一次，例如：</p>
<p>想设置页地址为page0  0xB0   -&gt; 0x7A 0x00 0xB0  </p>
<p>想设置页地址为 page7  0xB7  -&gt; 0x7A 0x00 0xB7                   </p>
<p>设置列地址需要发送两次指令，假设我们需要设置列地址为0x5A</p>
<p>第一次发送  0x0A，将列地址低4位设置为A</p>
<p>第二次发送   0x15，将列地址高4位设置为5</p>
<p>即，低位0x0，高位0x1</p>
<ol>
<li><strong>数据通讯格式</strong>：</li>
</ol>
<p><strong>0x7A +  0x40  任意数量的数据</strong></p>
<p>0x7A为IIC地址，(0x40开头+任意数量数据)为我们发送的。</p>
<p><strong>CH1116等芯片特性</strong>：设置完一字节的8个像素后，列地址会自动+1，这样下一个数据就可以写到本页的下一列里。</p>
<p>利用这特性我们只需要将页地址和列地址都设置为0，然后一次性发送128个字节，就可以直接完成一页屏幕的像素设置</p>
<p>设置第0页: 0x7A 0x00 0xB0  -&gt;需要在循环中手动自增,遍历</p>
<p>设置第0列: 0x7A 0x00 0x0<strong>0</strong> &amp; 0x7A 0x00 0x1<strong>0</strong> -&gt;自动自增</p>
<p>发送显示数据： 0xFF 0xFF ……….共128个</p>
</blockquote>
<h2 id="驱动函数"><a href="#驱动函数" class="headerlink" title="驱动函数"></a>驱动函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*OLED在使用之前需要初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    OLED_SendCmd(<span class="number">0xAE</span>); <span class="comment">/*关闭显示 display off*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0x02</span>); <span class="comment">/*设置列起始地址 set lower column address*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x10</span>); <span class="comment">/*设置列结束地址 set higher column address*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0x40</span>); <span class="comment">/*设置起始行 set display start line*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xB0</span>); <span class="comment">/*设置页地址 set page address*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0x81</span>); <span class="comment">/*设置对比度 contract control*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0xCF</span>); <span class="comment">/*128*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xA1</span>); <span class="comment">/*设置分段重映射 从右到左 set segment remap*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xA6</span>); <span class="comment">/*正向显示 normal / reverse*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xA8</span>); <span class="comment">/*多路复用率 multiplex ratio*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x3F</span>); <span class="comment">/*duty = 1/64*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xAD</span>); <span class="comment">/*设置启动电荷泵 set charge pump enable*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x8B</span>); <span class="comment">/*启动DC-DC */</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0x33</span>); <span class="comment">/*设置泵电压 set VPP 10V */</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xC8</span>); <span class="comment">/*设置输出扫描方向 COM[N-1]到COM[0] Com scan direction*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xD3</span>); <span class="comment">/*设置显示偏移 set display offset*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x00</span>); <span class="comment">/* 0x00 */</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xD5</span>); <span class="comment">/*设置内部时钟频率 set osc frequency*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0xC0</span>);</span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xD9</span>); <span class="comment">/*设置放电/预充电时间 set pre-charge period*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x1F</span>); <span class="comment">/*0x22*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xDA</span>); <span class="comment">/*设置引脚布局 set COM pins*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x12</span>);</span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xDB</span>); <span class="comment">/*设置电平 set vcomh*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OLED_NewFrame();</span></span><br><span class="line">    <span class="comment">// OLED_ShowFrame();</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xAF</span>); <span class="comment">/*开启显示 display ON*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该函数内容一般厂商会提供，网上搜即可，当然没有的话只有自己写了*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*发送指令*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_SendCmd</span><span class="params">(<span class="type">uint8_t</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[<span class="number">2</span>] = &#123;<span class="number">0x00</span>,cmd&#125;;</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,OLED_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),HAL_MAX_DELAY);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_SendCmd(<span class="number">0xB0</span>);<span class="comment">//设置页</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x02</span>);<span class="comment">//设置列低四位</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x10</span>);<span class="comment">//设置列高四位</span></span><br><span class="line">    <span class="comment">/*发送指令，设置页和列*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[] = &#123;<span class="number">0x40</span>,<span class="number">0xAA</span>&#125;;</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,OLED_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),HAL_MAX_DELAY);</span><br><span class="line">    <span class="comment">/*发送数据，设置亮灭*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于屏幕任意点亮灭是随机的，启动时会花屏，所以需要我们利用显存刷新一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> GRAM[<span class="number">8</span>][<span class="number">128</span>];<span class="comment">//定义显存</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_NewFrame</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">memset</span>(GRAM,<span class="number">0</span>,<span class="keyword">sizeof</span>(GRAM));</span><br><span class="line">&#125;<span class="comment">//将所有像素清空</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowFrame</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[<span class="number">129</span>];</span><br><span class="line">    sendBuffer[<span class="number">0</span>] = <span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint8_t</span> j=<span class="number">0</span>;j&lt;<span class="number">128</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sendBuffer[j+<span class="number">1</span>] = GRAM[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        OLED_SendCmd(<span class="number">0xB0</span>+i);</span><br><span class="line">        OLED_SendCmd(<span class="number">0x02</span>);</span><br><span class="line">        OLED_SendCmd(<span class="number">0x10</span>);  	     HAL_I2C_Master_Transmit(&amp;hi2c1,OLED_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),HAL_MAX_DELAY);</span><br><span class="line">        <span class="comment">/*只需要对page进行增加，列由于特性会自增，故不需要增加*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_SetPixel</span><span class="params">(<span class="type">uint8_t</span> x,<span class="type">uint8_t</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*该函数作用是使指定坐标亮起*/</span></span><br><span class="line">    <span class="comment">/*描述屏幕时，使用的是下x，y坐标系第四象限,x为列坐标，y为行坐标*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">128</span> || y&gt;=<span class="number">64</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    GRAM[y/<span class="number">8</span>][x] = <span class="number">0x01</span> &lt;&lt; (y%<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_NewFrame();<span class="comment">//清空显存</span></span><br><span class="line"></span><br><span class="line">        OLED_SetPixel(<span class="number">2</span>*i,i);<span class="comment">//画点</span></span><br><span class="line">        OLED_ShowFrame();<span class="comment">//显示显存</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*你将会得到一个在屏幕上移动的点*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*OLED初始化通常前面跟一个延时,*/</span></span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line">    <span class="comment">/*STM32启动比OLED上电快, 可等待20ms再初始化OLED,避免LED比STM32启动更早*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取模-图模-字模"><a href="#取模-图模-字模" class="headerlink" title="取模(图模+字模)"></a>取模(图模+字模)</h2><h2 id="CubeMX配置-12"><a href="#CubeMX配置-12" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h2><blockquote>
<p>正常启动I2C配置，由于有大量数据，故只需要将I2C模式标准模式切换为快速模式(Fast Mode)，使用外部高速时钟即可.。</p>
</blockquote>
<h2 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h2><p>为了便于使用，驱动库可以直接移植</p>
<p><a target="_blank" rel="noopener" href="https://led.baud-dance.com/">波特律动LED字模生成器 (baud-dance.com)</a></p>
<p>图模和字模的使用方法：</p>
<blockquote>
<p>使用波特率动取模后，将取模后的代码复制到font.c文件最下方，最后再调用OLED_DrawImage或OLED_PrintString即可使用</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>STM32(HAL库)</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.thekqd.top/posts/b900f0d0.html">https://www.thekqd.top/posts/b900f0d0.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Thedi🍭</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-04-02</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-01-22</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>嵌入式</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/70b69f96.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/138.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Clion快捷键</div></div></a></div><div class="next-post pull-right"><a href="/posts/519ff8b5.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/15.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux常用指令</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/cb085122.html" title="STM32(标准库)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/21.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-01-22</div><div class="title">STM32(标准库)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%92%8C%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-text">实验和一些好用的工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%B2%E8%A7%A3%E8%A7%86%E9%A2%91"><span class="toc-text">讲解视频</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GPIO"><span class="toc-text">GPIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E4%BB%8B%E7%BB%8D"><span class="toc-text">GPIO介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">GPIO工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E7%81%AF"><span class="toc-text">点灯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STM32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">STM32启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6"><span class="toc-text">启动文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RCC"><span class="toc-text">RCC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D"><span class="toc-text">复位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F"><span class="toc-text">时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E6%BA%90"><span class="toc-text">时钟源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9FSYSCLK"><span class="toc-text">系统时钟SYSCLK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%97%B6%E9%92%9F%E6%A0%91"><span class="toc-text">配置时钟树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-text">中断和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">中断优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E7%BB%84"><span class="toc-text">优先级分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NVIC"><span class="toc-text">NVIC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXTI"><span class="toc-text">EXTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-text">实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8C%89%E9%94%AE%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6LED%E4%BA%AE%E7%81%AD"><span class="toc-text">外部按键中断控制LED亮灭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E6%B6%88%E6%8A%96"><span class="toc-text">按键消抖:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6LED%E4%BA%AE%E7%81%AD-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%8A%96"><span class="toc-text">轮询按键控制LED亮灭(延时消抖)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD-%E5%AE%9A%E6%97%B6%E5%99%A8%E6%B6%88%E6%8A%96-%E6%8E%A8%E8%8D%90"><span class="toc-text">外部中断+定时器消抖(推荐)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E7%8A%B6%E6%80%81%E6%9C%BA%E6%B6%88%E6%8A%96"><span class="toc-text">按键状态机消抖</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">volatile关键字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SysTick%E7%B3%BB%E7%BB%9F%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">SysTick系统定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-text">寄存器介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uwTick"><span class="toc-text">uwTick</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#uwTick%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">uwTick的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uwTick%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">uwTick的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8-uwTick"><span class="toc-text">如何配置和使用 uwTick</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-uwTick"><span class="toc-text">读取 uwTick</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%90%8E%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-text">获取系统启动后的时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-text">处理溢出问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HAL-Delay"><span class="toc-text">HAL_Delay</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0"><span class="toc-text">自定义延时函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uwTick%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%96%E8%AE%BE%E5%8C%BA%E5%88%AB"><span class="toc-text">uwTick与硬件定时器外设区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#uwTick-1"><span class="toc-text">uwTick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%96%E8%AE%BE"><span class="toc-text">硬件定时器外设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-text">使用场景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-uwTick-%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">使用 uwTick 的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A1%AC%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%96%E8%AE%BE%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">使用硬件定时器外设的场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-text">总结对比表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%AE%AF%E6%A6%82%E5%BF%B5"><span class="toc-text">通讯概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F"><span class="toc-text">通讯方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%AE%AF%E9%80%9F%E7%8E%87"><span class="toc-text">通讯速率</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#USART"><span class="toc-text">USART</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-text">功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%8E%A5%E5%8F%97%E4%B8%8E%E5%8F%91%E9%80%81"><span class="toc-text">串口接受与发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#USART%E4%B8%AD%E6%96%AD"><span class="toc-text">USART中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-1"><span class="toc-text">实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#USART1%E6%99%AE%E9%80%9A%E4%B8%AD%E6%96%AD%E5%9B%9E%E6%98%BE%E5%AE%9E%E9%AA%8C"><span class="toc-text">USART1普通中断回显实验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USART2%E6%8E%A7%E5%88%B6LED%E7%81%AF"><span class="toc-text">USART2控制LED灯</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HAL%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">HAL库函数的一些调用流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TIM-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">TIM(定时器)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84LED%E9%97%AA%E7%83%81"><span class="toc-text">基于定时器的LED闪烁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE"><span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81"><span class="toc-text">函数和业务代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RTC"><span class="toc-text">RTC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E6%97%B6%E9%92%9F%E9%80%89%E6%8B%A9"><span class="toc-text">RTC时钟选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E4%B8%AD%E6%96%AD"><span class="toc-text">RTC中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-1"><span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E5%AE%9E%E6%97%B6%E6%97%B6%E9%97%B4OLED%E6%98%BE%E7%A4%BA"><span class="toc-text">实验-实时时间OLED显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E6%8E%89%E7%94%B5%E9%87%8D%E7%BD%AE"><span class="toc-text">RTC掉电重置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BKP%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">BKP寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%8E%89%E7%94%B5%E9%87%8D%E7%BD%AE%E4%BB%A3%E7%A0%81"><span class="toc-text">解决掉电重置代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F%E4%B8%8E%E5%BE%AA%E8%BF%B9%E6%A8%A1%E5%9D%97"><span class="toc-text">定时器外部时钟与循迹模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E8%BF%B9%E6%A8%A1%E5%9D%97"><span class="toc-text">循迹模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%E8%84%89%E5%86%B2"><span class="toc-text">抖动脉冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="toc-text">输入滤波器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PWM"><span class="toc-text">PWM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWM%E6%8E%A7%E5%88%B6LED%E4%BA%AE%E5%BA%A6%E5%AE%9E%E7%8E%B0%E5%91%BC%E5%90%B8%E7%81%AF"><span class="toc-text">实验-PWM控制LED亮度实现呼吸灯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-2"><span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-%E8%BD%AE%E8%AF%A2%E4%BF%AE%E6%94%B9%E5%8D%A0%E7%A9%BA%E6%AF%94"><span class="toc-text">业务代码(轮询修改占空比)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BF%AE%E6%94%B9%E5%8D%A0%E7%A9%BA%E6%AF%94"><span class="toc-text">业务代码(定时器修改占空比)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWM%E6%8E%A7%E5%88%B6%E6%97%A0%E6%BA%90%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-text">实验-PWM控制无源蜂鸣器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-3"><span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81"><span class="toc-text">业务代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWM%E6%8E%A7%E5%88%B6%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA"><span class="toc-text">实验-PWM控制直流电机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DRV8833%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97"><span class="toc-text">DRV8833电机驱动模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-4"><span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-1"><span class="toc-text">业务代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%BA%93"><span class="toc-text">驱动库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7"><span class="toc-text">输入捕获</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">捕获寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D%E4%BB%8B%E7%BB%8D"><span class="toc-text">超声波测距介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D"><span class="toc-text">实验-使用超声波测距</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="toc-text">CubeMX配置：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-2"><span class="toc-text">业务代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-text">旋转编码器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%9E%8B%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-text">增量型旋转编码器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">实现思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E5%A2%9E%E9%87%8F%E5%9E%8B%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A7%E5%88%B6%E5%B0%8F%E7%81%AF%E4%BA%AE%E5%BA%A6"><span class="toc-text">实验-使用增量型旋转编码器控制小灯亮度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-5"><span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-1"><span class="toc-text">函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-3"><span class="toc-text">业务代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%88%B5%E6%9C%BA-SERVO"><span class="toc-text">舵机(SERVO)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-PWM"><span class="toc-text">原理(PWM)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A7%E5%88%B6%E8%88%B5%E6%9C%BA-SG90-%E6%97%8B%E8%BD%AC"><span class="toc-text">实验-使用旋转编码器控制舵机(SG90)旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-6"><span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-4"><span class="toc-text">业务代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-text">看门狗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-text">独立看门狗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-7"><span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-1"><span class="toc-text">相关函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-text">窗口看门狗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-text">中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-text">配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-2"><span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-2"><span class="toc-text">实验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A8%A1%E5%9D%97"><span class="toc-text">传感器模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ADC"><span class="toc-text">ADC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-text">参数配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-3"><span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8ADC%E8%AF%BB%E5%8F%96%E7%94%B5%E4%BD%8D%E5%99%A8%E7%94%B5%E5%8E%8B-%E5%8D%95%E9%80%9A%E9%81%93"><span class="toc-text">实验-使用ADC读取电位器电压(单通道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E4%BD%8D%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-text">电位器介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-8"><span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-5"><span class="toc-text">业务代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8NTC%E7%83%AD%E6%95%8F%E4%BC%A0%E6%84%9F%E5%99%A8%E6%B5%8B%E9%87%8F%E6%B8%A9%E5%BA%A6-%E5%8D%95%E9%80%9A%E9%81%93"><span class="toc-text">实验-使用NTC热敏传感器测量温度(单通道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NTC%E4%BB%8B%E7%BB%8D"><span class="toc-text">NTC介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-9"><span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81-6"><span class="toc-text">业务代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DMA"><span class="toc-text">DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="toc-text">DMA传输方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3DMA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%94%B6%E5%8F%91%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE"><span class="toc-text">串口DMA模式与收发不定长数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA%E6%A8%A1%E5%BC%8F"><span class="toc-text">DMA模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E5%8F%91%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE-Idle"><span class="toc-text">收发不定长数据-Idle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA%E4%BC%A0%E8%BE%93%E8%BF%87%E5%8D%8A%E4%B8%AD%E6%96%AD"><span class="toc-text">DMA传输过半中断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%AE%80%E6%98%93%E6%95%B0%E6%8D%AE%E5%8C%85%E8%A7%A3%E6%9E%90"><span class="toc-text">蓝牙模块与简易数据包解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D"><span class="toc-text">蓝牙模块介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-text">协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E8%93%9D%E7%89%99%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6LED-UART"><span class="toc-text">实验(蓝牙发送数据控制LED-UART)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E6%98%93%E6%95%B0%E6%8D%AE%E5%8C%85%E8%A7%A3%E6%9E%90"><span class="toc-text">简易数据包解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%93%9D%E7%89%99%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6LED%E5%BC%80%E5%85%B3"><span class="toc-text">蓝牙发送数据控制LED开关</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IIC"><span class="toc-text">IIC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8E%E5%8D%8F%E8%AE%AE%E5%B1%82"><span class="toc-text">物理层与协议层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E"><span class="toc-text">主从</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IIC%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">IIC相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IIC%E8%AF%BB%E5%86%99"><span class="toc-text">IIC读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IIC%E4%B8%AD%E6%96%AD"><span class="toc-text">IIC中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E8%AF%BB%E5%86%99EEPROM-AT24C02"><span class="toc-text">实验-读写EEPROM(AT24C02)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EEPROM%E4%BB%8B%E7%BB%8D"><span class="toc-text">EEPROM介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80"><span class="toc-text">设备地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-text">写读数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-10"><span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8AHT20%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8-%E8%BD%AE%E8%AF%A2"><span class="toc-text">实验-使用AHT20温湿度传感器(轮询)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE%EF%BC%9A-1"><span class="toc-text">CubeMX配置：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="toc-text">传感器读取流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IIC%E4%B8%AD%E6%96%AD%E4%B8%8EDMA%E4%BB%A5%E5%8F%8A%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B"><span class="toc-text">IIC中断与DMA以及状态机编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-4"><span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E7%BC%96%E7%A8%8B"><span class="toc-text">状态机编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8AHT20%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8-%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">实验-使用AHT20温湿度传感器(状态机)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SPI"><span class="toc-text">SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F"><span class="toc-text">主从模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%BA%BF"><span class="toc-text">信号线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6"><span class="toc-text">数据发送和接收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#W25Q128-FLASH%E8%8A%AF%E7%89%87"><span class="toc-text">W25Q128 FLASH芯片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%AF%BB%E5%86%99FLASH-W25Q128"><span class="toc-text">实验读写FLASH(W25Q128)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-11"><span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-2"><span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OLED"><span class="toc-text">OLED</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%87%BD%E6%95%B0"><span class="toc-text">驱动函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E6%A8%A1-%E5%9B%BE%E6%A8%A1-%E5%AD%97%E6%A8%A1"><span class="toc-text">取模(图模+字模)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE-12"><span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E6%A4%8D"><span class="toc-text">移植</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/img/avatar.webp" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.thehsp.cn/" title="thehsp"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.postimg.cc/hG3dPJgH/fda91706f29ff4047883c4b7b84449e.jpg" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2025</b></span><span><b>&nbsp;&nbsp;By Thedi🍭</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/Linux/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 Linux (9)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/嵌入式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍼 嵌入式学习笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/C/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 C++学习笔记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/数据结构与算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 数据结构与算法 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/MySQL/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 数据库笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/演示/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 Markdown (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://www.thekqd.top/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #69e8f2}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/37.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/aa76cb12.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/99.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/aa76cb12.html&quot;);" href="javascript:void(0);" alt="">线程池C++版</a><div class="blog-slider__text">线程池C++版</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/aa76cb12.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f2e69609.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/5.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f2e69609.html&quot;);" href="javascript:void(0);" alt="">MySQL通用语法及操作</a><div class="blog-slider__text">MySQL的相关知识包括基础篇、进阶篇和运维篇,学习自黑马</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f2e69609.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/174bd570.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/98.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/174bd570.html&quot;);" href="javascript:void(0);" alt="">socket</a><div class="blog-slider__text">socket网络编程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/174bd570.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/15fc6e8c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/6.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/15fc6e8c.html&quot;);" href="javascript:void(0);" alt="">多线程</a><div class="blog-slider__text">线程相关知识（pthread）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/15fc6e8c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>