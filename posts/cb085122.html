<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>STM32(标准库) | Thedi的仓库</title><meta name="keywords" content="嵌入式"><meta name="author" content="Thedi🍭"><meta name="copyright" content="Thedi🍭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="STM32标准库笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32(标准库)">
<meta property="og:url" content="https://www.thekqd.top/posts/cb085122.html">
<meta property="og:site_name" content="Thedi的仓库">
<meta property="og:description" content="STM32标准库笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.thekqd.top/assets/43.webp">
<meta property="article:published_time" content="2025-01-13T13:48:37.000Z">
<meta property="article:modified_time" content="2025-01-22T07:09:49.538Z">
<meta property="article:author" content="Thedi🍭">
<meta property="article:tag" content="嵌入式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.thekqd.top/assets/43.webp"><link rel="shortcut icon" href="https://i.postimg.cc/4xP8HS1p/Computer.png"><link rel="canonical" href="https://www.thekqd.top/posts/cb085122"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32(标准库)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-22 15:09:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Thedi的仓库" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Thedi的仓库</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">STM32(标准库)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2025-01-13T13:48:37.000Z" title="发表于 2025-01-13 21:48:37">2025-01-13</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-22T07:09:49.538Z" title="更新于 2025-01-22 15:09:49">2025-01-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">6.7w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>238分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="STM32(标准库)"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>keil配置与芯片包下载</h1>
<h2 id="固件库文件">固件库文件</h2>
<p>以F103固件库为例：</p>
<p>STM32F10x_StdPeriph_Lib_V3.5.0固件库是为STM32F1系列微控制器设计的开发辅助库，主要用于简化对STM32F1外设的控制和配置。该库封装了对各类外设（如GPIO、ADC、USART、SPI、I2C等）的控制接口，使开发者无需直接操作复杂的寄存器就能使用这些硬件外设。通过它，开发者可以轻松地进行外设的初始化、配置和数据处理。</p>
<p><strong>主要结构</strong>：</p>
<ul>
<li><strong>_htmresc</strong>：图片没什么用</li>
<li><strong>Libraries</strong>：库函数的文件，我们之后建工程时会用
<ul>
<li><strong>CMSIS</strong>：包含Cortex-Mx内核的相关定义和启动代码。
<ul>
<li>CoreSupport：包含了与Cortex-M系列内核相关的文件，主要是一些适用于ARM Cortex-M内核的通用代码和数据结构，用于管理核心处理器功能。</li>
<li>DeviceSupport：含与特定厂商的微控制器设备相关的文件，特别是该设备特定的外设寄存器定义和访问方法。它提供了Cortex-M内核之外的硬件支持，适用于具体的MCU型号。</li>
</ul>
</li>
<li><strong>STM32F10x_StdPeriph_Driver</strong>：<strong>标准外设驱动库</strong>，包含STM32F1系列的外设驱动源文件和头文件。</li>
</ul>
</li>
<li><strong>Projects</strong>：是官方提供的工程示例和模板，使用库函数时可以参考</li>
<li><strong>Utilities</strong>：是STM32官方评估板的相关例程，这个评估版就是官方用STM32做的一个小电路板用来测评STM32的，文件夹内存放的就是小电路板的测评程序</li>
<li><strong>Release_Notes.html</strong>：这个是库函数的发布文档</li>
<li><strong>stm32f10x_stdperiph_lib_um.chm</strong>：使用手册，教大家如何使用库函数</li>
</ul>
<h2 id="keil新建工程">keil新建工程</h2>
<ol>
<li>新建一个 new μVision Project，设置名称后，会出现选择芯片，如果只有ARM，则需要将官方的芯片包(在官方下载.pack文件)导入。</li>
</ol>
<blockquote>
<p>最后会弹出来Manage Run-time Environment的界面，manage run-time environment是一个新建工程的小助手也有固件库，可以帮我快速建立工程，直接勾选即可，是keil5的新功能**。今天我们创建工程的方式是自己去搬运官网给的库，加深一下理解和增加动手能力，所以没有使用manage run-time environment来添加库，直接点击OK即可**</p>
</blockquote>
<p>此时就只有一个Target里面什么都没有，我们需要给它添加一点工程的必要文件。</p>
<p>此时我们可以看到刚刚创建的项目文件夹自动生成一堆文件夹，为了便于管理<strong>我们先在工程文件夹中创建一个Startup文件夹用于存放启动文件</strong></p>
<ol start="2">
<li>此时打开固件库文件夹-&gt;“STM32F10x_StdPeriph_Lib_V3.5.0”-“Libraries”-“CMSIS”-“CM3”-“DeviceSupport”-“ST”-“STM32F10x”-“startup”，然后选中全部一起复制到刚刚我们创建的Startup文件夹中。</li>
</ol>
<blockquote>
<p>这些就是STM32的启动文件，STM32程序就是从这些启动文件开始执行的</p>
</blockquote>
<ol start="3">
<li>“Libraries”-“CMSIS”-“CM3”-“DeviceSupport”-“ST”-“STM32F10x，我们把这三个文件也复制下来粘贴到Startup文件夹下</li>
</ol>
<blockquote>
<p>我们可以看到stm32f10x.h和两个system开头的文件</p>
<p>stm32f10x.h：是STM32的<strong>外设寄存器描述文件，用来描述STM32有哪些寄存器和它对应的地址。</strong></p>
<p>system文件：这个两个system文件(system_stm32f10x.c/h)用于配置时钟，STM32F103主频72MHz就是在system文件里配置的。</p>
</blockquote>
<hr>
<p><strong>接下来，因为STM32是内核和内核外围设备(外设)组成的，而且内核的寄存器描述和外围设备的描述文件不是在一起的，所以我们还需要添加内核寄存器的描述文件</strong></p>
<ol start="4">
<li>进入“STM32F10x_StdPeriph_Lib_V3.5.0”-“Libraries”-“CMSIS”-“CM3”-“CoreSupport”。然后也把这两个相关内核相关的文件复制到Startup文件后所有的准备完成</li>
</ol>
<blockquote>
<p>里面有两个cm3(core_cm3.c和core_cm3.h)，这两个Cortex-M3文件就是<strong>内核的寄存器描述文件</strong>，还有一些内核配置函数</p>
</blockquote>
<ol start="5">
<li>返回keil中将刚刚的文件添加到工程中，在Target 1中add group然后将新建的文件夹改名为Startup，将刚刚所有的Startup文件夹中的文件添加进去。</li>
</ol>
<blockquote>
<ol>
<li>
<p>首先是启动文件的添加，有一堆startup文件，我们选择其中的一个startup_stm32f10x_md.s添加到工程中。</p>
<p><strong>有关启动文件的选择，请看下面的笔记</strong></p>
</li>
<li>
<p>然后剩下的所有.c和.h文件都要添加进去</p>
</li>
</ol>
<p>我们可以按住Ctrl键，然后依次选择他们，点击Add，Close即可</p>
<p>这里的文件都是STM32里最基本的文件，是不需要我们修改的，添加到工程即可，此时可以看到这些文件都带有钥匙图标，代表只读文件</p>
</blockquote>
<ol start="6">
<li>点击魔术棒，打开工程选项，在C/C++中找到include Paths，添加Startup文件夹的路径至其中。</li>
</ol>
<blockquote>
<p>最后我们还要在工程选项里添加上该文件夹的头文件路径，否则找不到.h文件</p>
</blockquote>
<ol start="7">
<li>回到该项目的文件夹下，新建一个User文件夹，main函数就放在其中。再回到keil中，在Target添加一个组，改名为User，对其右键创建main.c到其中，此时在main.c中创建我们的main函数，进行开发即可。</li>
</ol>
<p><code>由于此时工程还没有添加STM32的库函数，所以是基于寄存器开发工程，如果想要使用寄存器开发那么到这里就可以结束了</code></p>
<hr>
<p><code>接下来继续添加库函数</code></p>
<ol start="8">
<li>打开项目文件夹，新建Library文件夹用于存放库函数，接着打开固件库的文件夹，“STM32F10x_StdPeriph_Lib_V3.5.0”-“Libraries”-“STM32F10x_StdPeriph_Driver”-“src”，全选复制粘贴到Library中去，然后再回到Inc中去，再次将头文件全部复制粘贴到Library中去。</li>
</ol>
<blockquote>
<ol>
<li>
<p>其中misc.c是内核的库函数</p>
</li>
<li>
<p>其他的就是外设库函数</p>
</li>
</ol>
</blockquote>
<ol start="9">
<li>回到keil中，在Target下添加一个组命名为Library，再将Library文件夹中的所有文件添加到工程中去，但是此时的库函数还不能直接使用，我们还需要在添加文件。继续打开固件库文“STM32F10x_StdPeriph_Lib_V3.5.0”-“Project”-“STM32F10x_StdPeriph_Template”中，把一个conf.h文件和两个it中断文件复制粘贴到User文件下，<strong>回到keil中将这三个文件添加到User的组中</strong></li>
</ol>
<blockquote>
<p>我们可以看到一个stm32f10x_conf.h的文件，这个config文件是用来配置库函数头文件包含关系，以及用来参数检查的函数定义，这是所有库函数都需要的</p>
<p>两个stm32f10x_it.c/h文件是用来存放中断函数的</p>
</blockquote>
<ol start="10">
<li>最后我们还需要一个宏定义USE_STDPERIPH_DRIVER，我们打开<strong>b</strong>，切换到C/C++中，在Define中添加&quot;USE_STDPERIPH_DRIVER&quot;，最后别忘了在下方的include Paths再将User和Library目录的路径添加进去。</li>
</ol>
<blockquote>
<p>我们可以在stm32f10x.h文件中的最下方看到有一段</p>
<p>#ifdef USE_STDPERIPH_DRIVER<br>
#include “stm32f10x_conf.h”<br>
#endif</p>
<p>这个的意思是如果定义了USE_STDPERIPH_DRIVER(使用标准外设驱动)这个宏定义，才会包含stm32f10x_conf.h，即才会生效。</p>
<p><code>由于stm32f10x_conf.h文件包含了所有库函数的头文件，所以我们只需要include stm32f10x.h文件就可以任意调用库函数了</code></p>
</blockquote>
<p>最终我们的基本模板为：</p>
<blockquote>
<ul>
<li>DebugConfig</li>
<li>Listings</li>
<li>Objects</li>
<li>Library</li>
<li>Startup</li>
<li>User</li>
</ul>
<p>前三个为创建项目后自动生成的文件夹，后三个为我们手动创建的。</p>
</blockquote>
<p><code>一定记得将所有带有头文件的目录添加到C/C++的include Paths中以便于编译器能够找到头文件</code></p>
<h2 id="启动文件的选择">启动文件的选择</h2>
<p>我们在新建工程向Startup文件夹添加启动文件的时候，有一堆startup文件。当时我们选择其中的一个startup_stm32f10x_md.s添加到工程中。</p>
<p>现在来解释一下这个文件怎么选取：</p>
<p><strong>启动文件有很多类型，至于选择哪一个，我们要根据芯片的型号来选择</strong></p>
<p>看这张表：</p>
<blockquote>
<p>缩写                                翻译             FLASH容量        型号</p>
<p>LD(High Density)       小容量产品        16-32K             STM32F101/102/103</p>
<p>MD(Middle Density)      中容量产品      64-128K             STM32F101/102/103</p>
<p>HD(High Density)       大容量产品     256-512K             STM32F101/102/103</p>
<p>XL(Extra Large)       加大容量产品    大于512K             STM32F101/102/103</p>
<p>CL                                互联网产品       -                           STMF105/107</p>
<p>LD_VL(value line)       小容量产品超值系列        16-32K             STM32F100</p>
<p>MD_V                      中容量产品超值系列      64-128K             STM32F100</p>
<p>HD_VL                     大容量产品超值系列     256-512K             STM32F100</p>
</blockquote>
<ol>
<li><strong>先根据型号选择是哪个系列的启动文件</strong></li>
<li><strong>根据Flash容量选择对应的启动文件添加到Startup即可</strong></li>
</ol>
<h2 id="stm32f10x-h">stm32f10x.h</h2>
<p>我们可以在stm32f10x.h文件中的最下方看到有一段</p>
<p>#ifdef USE_STDPERIPH_DRIVER<br>
#include “stm32f10x_conf.h”<br>
#endif</p>
<p>这个的意思是如果定义了USE_STDPERIPH_DRIVER(使用标准外设驱动)这个宏定义，才会包含stm32f10x_conf.h，即才会生效。</p>
<p><code>由于stm32f10x_conf.h文件包含了所有库函数的头文件，所以我们只需要在编程的时候include stm32f10x.h文件就可以任意调用库函数了</code></p>
<h2 id="新建工程步骤总结">新建工程步骤总结</h2>
<ol>
<li><strong>建立工程文件夹，Keil中新建工程、选择型号</strong></li>
<li><strong>工程文件夹中建立Startup、Library、User等文件夹，复制固件库里面的文件到工程文件夹</strong></li>
<li><strong>工程里对应建立Start、Library、User等同名称的分组，并将文件夹内的文件添加到工程分组里</strong></li>
<li><strong>工程选项(魔法棒)，C/C++ Include Paths内添加所有包含头文件的文件夹</strong></li>
<li><strong>工程选项(魔法棒)，C/C++，Define中定义宏定义USE_STDPERIPH_DRIVER</strong></li>
<li><strong>工程选项(魔法棒)，Debug，下拉列表选择对应调试器，Settings，Flash，Download里勾选Reset and Run</strong></li>
</ol>
<h1>模块化编程</h1>
<p>如果我们把所有的初始化代码都写到main函数中就会显得很杂乱，为此我们单独创建一个Hardware文件夹用于存放各外设驱动(LED.c，LED.h，Key.c，Key.h等)</p>
<ol>
<li>在项目文件夹下创一个Hartware文件夹</li>
<li>回到keil中添加一个名为Hardware的组，然后添加或创建对应外设驱动的文件。</li>
<li>将Hardware添加到魔法棒中的C/C++的include Paths中</li>
</ol>
<p>最终我们的基本模板为：</p>
<blockquote>
<ul>
<li>DebugConfig</li>
<li>Listings</li>
<li>Objects</li>
<li>Library</li>
<li>Startup</li>
<li><strong>Hardware</strong></li>
<li>User</li>
</ul>
<p>前三个为创建项目后自动生成的文件夹，后四个个为我们手动创建的。</p>
</blockquote>
<p>例如在Hardware里的，LED驱动函数就是这样写的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_ON</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_OFF</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_ON</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_OFF</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Turn</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(GPIOA,GPIO_Pin_6 | GPIO_Pin_7);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_ON</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_ResetBits(GPIOC,GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Turn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(GPIO_ReadOutputDataBit(GPIOC,GPIO_Pin_2)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_SetBits(GPIOC,GPIO_Pin_2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOC,GPIO_Pin_2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有的外设都可以这样独立写成驱动函数，初始化函数等。这样使的项目更好管理</p>
</blockquote>
<h1>STM32启动文件</h1>
<p>startup_stm32xx.s就是启动文件，这是一个用汇编写的文件，定义了中断向量表和中断服务函数等。启动有个复位中断是程序的入口，当stm32按下复位或者上电的时候，程序就会进入复位中断函数执行，复位中断函数做的就是调用SystemInit函数和调用main函数。</p>
<p>我们可以在启动文件文件的注释中知道流程为：</p>
<ol>
<li>初始化堆栈指针SP</li>
<li>初始化程序计数器PC为Reset_Handler</li>
<li>初始化堆、栈的大小</li>
<li>设置中断向量表的入口地址</li>
</ol>
<p>转向Reset_Handler执行：</p>
<ol start="5">
<li>调用SystemInit()函数完成系统初始化(系统时钟、闪存接口配置等)</li>
<li>设置C库的分支入口为 __main(调用我们的main函数)</li>
</ol>
<hr>
<h1>GPIO</h1>
<ul>
<li>
<p>GPIO(General Purpose Input Output) 通用输入输出端口，可配置共8种输入输出模式。</p>
</li>
<li>
<p>引脚电平位0~3.3V，部分引脚可以容忍5V</p>
</li>
<li>
<p>输出模式下可控制端口输出高低电平，用于驱动LED，控制蜂鸣器，模拟通信协议输出时序</p>
</li>
<li>
<p>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44016222/article/details/123206403?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stm32GPIO&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-123206403.nonecase&amp;spm=1018.2226.3001.4187">STM32-GPIO介绍_stm32 gpio-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52162042/article/details/121278274?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%BC%B1%E4%B8%8A%E6%8B%89%E5%92%8C%E5%BC%BA%E4%B8%8A%E6%8B%89&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-121278274.142%5Ev100%5Epc_search_result_base6&amp;spm=1018.2226.3001.4187">上、下拉电阻（定义、强弱上拉、常见作用、吸电流、拉电流、灌电流）_弱上拉和强上拉的区别-CSDN博客</a></p>
<p><strong>操作stm32的GPIO分为三个步骤</strong>：</p>
<ol>
<li><strong>使用RCC开启GPIO时钟</strong></li>
<li><strong>使用GPIO_Init(库函数)函数初始化GPIO</strong></li>
<li><strong>使用输出或输入函数控制GPIO口</strong></li>
</ol>
<h2 id="RCC开启时钟">RCC开启时钟</h2>
<p>在stm32f10x_rcc.h中，有很多RCC相关函数但是我们最常用的是这三个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*RCC AHB总线外设时钟控制*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*RCC APB2总线外设时钟控制*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*RCC APB1总线外设时钟控制*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可以跳到这些函数的定义查看注释我们可以知道，这些时钟控制函数就是<code>使能或失能外设时钟的</code></p>
<p>参数1：选择外设</p>
<p>参数2：使能或失能</p>
<p>如果不知道该外设是否在这个总线上，我们可以在注释上面的列表看，如果出现了代表在这个总线上</p>
</blockquote>
<h2 id="GPIO标准库函数">GPIO标准库函数</h2>
<p>在stm32f10x_gpio.h中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_DeInit</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">/*指定GPIO外设被复位*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_AFIODeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*指定AFIO复位*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">/*初始化外设，为指定的GPIO初始化，使用的是我们自己创建的结构体*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_StructInit</span><span class="params">(GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">/*指定结构体赋值*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadInputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadInputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadOutputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadOutputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">/*GPIO读取函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;<span class="comment">//指定端口拉高</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;<span class="comment">//指定端口拉低</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, BitAction BitVal)</span>;<span class="comment">//端口写入指定值：Bit_SET或Bit_RESET</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> PortVal)</span>;</span><br><span class="line"><span class="comment">/*读写GPIO函数*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对应GPIO的结构体定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> GPIO_Pin;             <span class="comment">/*!&lt; Specifies the GPIO pins to be configured.</span></span><br><span class="line"><span class="comment">                                      This parameter can be any value of @ref GPIO_pins_define */</span></span><br><span class="line"></span><br><span class="line">  GPIOSpeed_TypeDef GPIO_Speed;  <span class="comment">/*!&lt; Specifies the speed for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */</span></span><br><span class="line"></span><br><span class="line">  GPIOMode_TypeDef GPIO_Mode;    <span class="comment">/*!&lt; Specifies the operating mode for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOMode_TypeDef */</span></span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>标准库的GPIO_InitTypeDef结构体参数只有三个：mode、pin、speed</strong></p>
<p><strong>这些跳转到对应定义可以知道值</strong></p>
<p>HAL库有5个参数，对比起来标准库更简单了</p>
</blockquote>
<h2 id="具体流程代码">具体流程代码</h2>
<p>假设我们需要点亮PC2的LED，查看手册后发现挂载再APB2总线上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1.开启对应外设时钟*/</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*2. 初始化GPIOC*/</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    <span class="comment">//定义GPIO_InitStructure结构体，三个参数赋值</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    <span class="comment">//调用GPIO_Init初始化对应GPIO口，函数中读取结构体自动配置写入到对应寄存器</span></span><br><span class="line">	GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验-LED流水灯">实验-LED流水灯</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_WriteBit(GPIOC,GPIO_Pin_2,Bit_RESET);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_WriteBit(GPIOC,GPIO_Pin_2,Bit_SET);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_WriteBit(GPIOC,GPIO_Pin_3,Bit_RESET);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_WriteBit(GPIOC,GPIO_Pin_3,Bit_SET);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*使用Write函数同时操控多个端口*/</span></span><br><span class="line"> <span class="comment">//		GPIO_Write(GPIOC,~0x0004);</span></span><br><span class="line"><span class="comment">//		Delay_ms(500);</span></span><br><span class="line"><span class="comment">//		GPIO_Write(GPIOC,0x0004);</span></span><br><span class="line"><span class="comment">//		Delay_ms(500);</span></span><br><span class="line"><span class="comment">//		GPIO_Write(GPIOC,~0x0008);</span></span><br><span class="line"><span class="comment">//		Delay_ms(500);</span></span><br><span class="line"><span class="comment">//		GPIO_Write(GPIOC,0x0008);</span></span><br><span class="line"><span class="comment">//		Delay_ms(500);</span></span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当有多个引脚时，我们可以使用<strong>按位或的方式同时选中多个Pin</strong>：</p>
<p>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | …;      选中了Pin2和Pin3</p>
<p>我们来看对应定义：</p>
<p>#define GPIO_Pin_0                 ((uint16_t)0x0001)<br>
#define GPIO_Pin_1                 ((uint16_t)0x0002)</p>
<p>#define GPIO_Pin_3                 ((uint16_t)0x0008)</p>
<p>…</p>
<p>#define GPIO_Pin_15                ((uint16_t)0x8000)</p>
<p>#define GPIO_Pin_All               ((uint16_t)0xFFFF)</p>
<p><code>一共16位，每一个引脚对应一个位，只需要使用按位或的操作既可以选中指定端口</code></p>
</blockquote>
<p><strong>知道这个后我们可以使用GPIO_Write函数同时操控多个端口：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*由于C语言不支持写2进制，故使用16进制来写*/</span></span><br><span class="line">		GPIO_Write(GPIOC,~<span class="number">0x0004</span>);<span class="comment">//~(0000 0000 0000 0100),pin2亮</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_Write(GPIOC,<span class="number">0x0004</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_Write(GPIOC,~<span class="number">0x0008</span>);<span class="comment">//~(0000 0000 0000 1000),pin3亮</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		GPIO_Write(GPIOC,<span class="number">0x0008</span>);</span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>使用Systick实现的延时函数，直接使用即可</strong>，使用时创建一个System文件夹，并把他们放到System文件夹下，在keil创建System组即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Delay.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint32_t</span> us)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">uint32_t</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_s</span><span class="params">(<span class="type">uint32_t</span> s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Delay.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  微秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xus 延时时长，范围：0~233015</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint32_t</span> xus)</span></span><br><span class="line">&#123;</span><br><span class="line">	SysTick-&gt;LOAD = <span class="number">72</span> * xus;				<span class="comment">//设置定时器重装值</span></span><br><span class="line">	SysTick-&gt;VAL = <span class="number">0x00</span>;					<span class="comment">//清空当前计数值</span></span><br><span class="line">	SysTick-&gt;CTRL = <span class="number">0x00000005</span>;				<span class="comment">//设置时钟源为HCLK，启动定时器</span></span><br><span class="line">	<span class="keyword">while</span>(!(SysTick-&gt;CTRL &amp; <span class="number">0x00010000</span>));	<span class="comment">//等待计数到0</span></span><br><span class="line">	SysTick-&gt;CTRL = <span class="number">0x00000004</span>;				<span class="comment">//关闭定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  毫秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xms 延时时长，范围：0~4294967295</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">uint32_t</span> xms)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(xms--)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_us(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xs 延时时长，范围：0~4294967295</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_s</span><span class="params">(<span class="type">uint32_t</span> xs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(xs--)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="输入模式">输入模式</h2>
<h2 id="GPIO相关寄存器">GPIO相关寄存器</h2>
<p>查看芯片对应参考手册，结合对应代码可以得知如何使用GPIO相关寄存器</p>
<h2 id="引脚重映射-复用功能重映像">引脚重映射(复用功能重映像)</h2>
<p>在<code>参考手册</code>中，有一节复用功能I/O和调试配置(AFIO)，这一章节专门就是讲的引脚复用重映像功能，手册描述如下：</p>
<p>为了优化64脚或100脚封装的外设数目，可以把一些复用功能重新映射到其他引脚上。设置复用重映射和调试I/O配置寄存器(AFIO_MAPR)实现引脚的重新映射。这时，复用功能不再映射到它们的原始分配</p>
<blockquote>
<p>如果多个外设需要使用同一组引脚，默认引脚的配置可能会导致冲突。引脚重映像允许开发者重新分配功能到其他引脚，避免资源冲突。<br>
<strong>实际意义：</strong><br>
在复杂系统中，可以高效利用芯片的引脚资源，而不用为了冲突放弃某些外设功能。</p>
<p>例如：</p>
<ul>
<li>需要同时使用<code>USART1</code>和<code>SPI1</code>，但两者默认引脚有重叠。</li>
<li>通过重映像将<code>USART1</code>从<code>PA9/PA10</code>移到<code>PB6/PB7</code>，释放<code>PA9/PA10</code>供其他功能使用。</li>
<li>这样我们就可以同时使用<code>USART1</code>和<code>SPI1</code>了</li>
</ul>
</blockquote>
<p><strong>对应库函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinRemapConfig</span><span class="params">(<span class="type">uint32_t</span> GPIO_Remap, FunctionalState NewState)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数1：对应外设重映射方式，一般是部分重映像或者完全重映像，具体查看对应手册</span></span><br><span class="line"><span class="comment"> * 参数2：是否是能</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><strong>使用方式</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1.开启AFIO时钟*/</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line">    <span class="comment">/*2.选择对应外设的映射，映射方式即可*/</span></span><br><span class="line">	GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2,ENABLE);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);</span></span><br><span class="line">    <span class="comment">/*接触JTAG复用，以便于TIM2能够重映射/</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意使用端口映射前，可能有些端口已经被占用了，比如调试端口JTAG，如果重映射使用的是调试端口，那么使用前需要先解除JTAG端口复用</p>
</blockquote>
<h1>EXTI(外部中断)</h1>
<h2 id="介绍">介绍</h2>
<p><strong>EXTI可以监测指定的GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序。</strong></p>
<p><strong>支持的触发方式</strong>：上升沿/下降沿/双边沿/软件触发</p>
<p><strong>支持的GPIO口</strong>：所有GPIO口，但相同的Pin不能同时触发中断(如：PA1与PB1与PC1之间)</p>
<p><strong>通道数</strong>：16个GPIO_Pin，外加PVD输出、RTC闹钟等</p>
<p><strong>触发响应的方式</strong>：<strong>中断响应/事件响应</strong></p>
<ul>
<li><strong>中断响应</strong>：正常的引脚电平变化触发中断</li>
<li><strong>事件响应</strong>：不会触发中断，而是触发别的外设操作，属于外设之间的联合工作</li>
</ul>
<h2 id="库函数">库函数</h2>
<p><code>相关的EXTI库函数去stm32f10x_exti.h中查看，这里直接使</code></p>
<h2 id="初始化配置流程">初始化配置流程</h2>
<p>只需要从GPIO到NVIC这一路出现的外设模块配置好即可，一共5步</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/98-17375297555834.png" alt="image-20241117144622580"></p>
<ol>
<li><strong>配置RCC，打开相关的外设时钟</strong>。这里涉及到的是GPIO、AFIO、EXTI、NVIC的时钟，但由于EXTI和NVIC时钟(内核外设不需要开启时钟)一直都是打开的，不需要我们开启，所以只需要开启GPIO和AFIO时钟即可。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//开启对应AFIO时钟</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>配置GPIO，配置我们的端口为输入模式</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line">	</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>在我们的手册中有对应外设每个引脚推荐配置模式，我们可以找到EXTI推荐配置为:浮空，上拉，下拉</strong></p>
</blockquote>
<ol start="3">
<li><strong>配置AFIO 通过 AFIO 外设将 PC13 引脚映射到 EXTI 外设上，以便用于外部中断</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数1：使用哪个GPIO作为外部中断源,GPIO_PortSourceGPIOx where x can be (A..G).</span></span><br><span class="line"><span class="comment"> * 参数2：指定需要配置的外部中断线, GPIO_PinSourcex where x can be (0..15).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里配置AFIO只需要这个函数即可*/</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOC,GPIO_PinSource13);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>没有单独写AFIO的库函数，与GPIO库函数放在一起的，可以去gpio的库函数中找这个函数查看对应参数。虽然写的是GPIO，但是我们查看该函数定义可以发现里面操作的是AFIO的寄存器</p>
</blockquote>
<ol start="4">
<li><strong>配置EXTI，选择边沿触发方式，比如上升沿、双边沿等，还有触发响应方式，可以选择中断响应和事件响应。</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">EXTI_InitStructure.EXTI_Line= EXTI_Line13;<span class="comment">//对应选择的外部中断线</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd= ENABLE; <span class="comment">// 使能或不使能</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode= EXTI_Mode_Interrupt ; <span class="comment">//两种模式，一种是中断响应，一种是事件响应</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger= EXTI_Trigger_Falling; <span class="comment">// 触发方式</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相关的EXTI库函数去stm32f10x_exti.h中查看，这里直接使用</p>
</blockquote>
<ol start="5">
<li><strong>配置NVIC，给我们的中断选择一个合适的优先级</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//优先级配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NVIC_PriorityGroupConfig()分组方式整个芯片只能只能用一种，按理来说这个分组的代码整个工程只需要执行一次即可。如果把这个函数放到模块里面进行分组，一定要确保每个模块分组都选的是同一个。也可以把这个代码放在主函数的开始，这样就不用每个模块分组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">// 使能</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span> ; <span class="comment">//指定抢占优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span> ;  <span class="comment">//指定子优先级</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为NVIC是内核外设，库函数被分配到了misc.h/c(杂项)文件中去了，在这里查找对应参数，对应函数用法。</p>
<p>NVIC_InitTypeDef 中查看注释我们可以知道IRQ需要到stm32f10x.h去找，我们要选择对应芯片的<strong>选择编译</strong>，这里我们是stm32f10x_MD</p>
<p>在里面的选择编译中，我们找到了EXTI15_10_IRQn = 40 (stm32的EXTI10到15都是合并到了这个通道里)</p>
<p>所以我们定义为EXTI15_10_IRQn即可</p>
<hr>
<p><code>注意:配置NVIC时，NVIC_IRQChannel只能接受一个中断通道号，不能接收多个中断通道的组合，如果有多个中断通道配置需要配置多次</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn | EXTI0_IRQn;</span><br></pre></td></tr></table></figure>
<p><code>这样配置不会报错，但是两个中断都不会生效!!!</code></p>
<p><code>需要单独调用两次NVIC_Init初始化</code></p>
<hr>
<p>对应的设置抢占优先级和子优先级设置我们可以跳转到对应定义处，继续跳转到注释中提到的中断优先级对应的优先级表查看即可</p>
</blockquote>
<p><strong>只有两个按键配置流程连起来就是</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*1.配置RCC启用对应外设时钟*/</span></span><br><span class="line">     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line">	 RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line">	 <span class="comment">/*2.配置GPIO*/</span></span><br><span class="line">     GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13|GPIO_Pin_12;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	 GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">/*3.配置AFIO*/</span>			    GPIO_EXTILineConfig(GPIO_PortSourceGPIOC,GPIO_PinSource12);	 GPIO_EXTILineConfig(GPIO_PortSourceGPIOC,GPIO_PinSource13);</span><br><span class="line">     <span class="comment">/*4.配置EXTI*/</span></span><br><span class="line">	  EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">	  EXTI_InitStructure.EXTI_Line= EXTI_Line12 | EXTI_Line13;<span class="comment">//对应选择的按键外部中断线</span></span><br><span class="line">      EXTI_InitStructure.EXTI_LineCmd= ENABLE; <span class="comment">// 使能或不使能</span></span><br><span class="line">	  EXTI_InitStructure.EXTI_Mode= EXTI_Mode_Interrupt ; <span class="comment">//两种模式，一种是中断，一种是事件</span></span><br><span class="line">      EXTI_InitStructure.EXTI_Trigger= EXTI_Trigger_Falling; <span class="comment">// 触发方式为下降沿触发</span></span><br><span class="line">	  EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line">    </span><br><span class="line">	  <span class="comment">/*5.配置NVIC*/</span></span><br><span class="line">	  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">		</span><br><span class="line">      NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;</span><br><span class="line">	  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">// 使能</span></span><br><span class="line">	  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span> ; <span class="comment">//指定抢占优先级</span></span><br><span class="line">	  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span> ;  <span class="comment">//指定子优先级</span></span><br><span class="line">	  NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中断函数">中断函数</h2>
<p><strong>完成了外部中断初始化配置后，接下来就是编写中断函数</strong></p>
<p>在启动文件的中断向量表中找到对应的中断函数的名字，这里是<code>EXTI15_10_IRQHandler</code></p>
<p>将其从启动文件中复制到对应位置进行编写，名字一定不能错，错了就无法进入了</p>
<p><strong>编写步骤如下</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*1.判断对应中断标志位是否为1(SET),如果是*/</span></span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line12) == SET)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/*2.清除对应中断标志位，否则会一直触发中断*/</span></span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line12);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*3.用户干的事情*/</span></span><br><span class="line">		        </span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line13) == SET)</span><br><span class="line">	&#123;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line13);</span><br><span class="line">         <span class="comment">/*用户干的事情*/</span></span><br><span class="line">  		...</span><br><span class="line">		        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>
<p>中断函数的返回值和参数都是void</p>
</li>
<li>
<p>此函数不用声明，中断触发自动调用</p>
</li>
<li>
<p>使用的相关函数在对应的exti标准库中去找(EXTI_GetITStatus等)，有两个获取标志位的函数，带有IT的是只能在中断中使用的，不带IT的是在中断外使用的</p>
</li>
</ol>
</blockquote>
<h2 id="实验-旋转编码器计数">实验- 旋转编码器计数</h2>
<p>旋转编码器相关知识见HAL库</p>
<p>此处旋转编码器<strong>A相对应：PB0</strong>，<strong>B相对应：PB1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Encoder.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ENCODER_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ENCODER_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int16_t</span> EncoderCount;<span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 1.打开对应外设时钟 */</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE );</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE );<span class="comment">//选择AFIO这个外设，开启时钟，通常用于启用或禁用 AFIO 外设的时钟，以便进行相应的配置操作。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 2.配置对应GPIO输入模式 */</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入，默认为高电平的输入方式</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0|GPIO_Pin_1;<span class="comment">//旋转编码器分两相，PB0 为A相，PB1为B相</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init (GPIOB ,&amp;GPIO_InitStructure);<span class="comment">//初始化GPIOB外设</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 3.AFIO配置，映射到对应EXTI线上去 */</span></span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource0);</span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource1);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 4.EXTI配置 */</span></span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">	EXTI_InitStructure.EXTI_Line=EXTI_Line0|EXTI_Line1;<span class="comment">//将第0条线路和第1条线路都初始化为中断模式，下降沿触发连线</span></span><br><span class="line">	EXTI_InitStructure.EXTI_LineCmd=ENABLE;<span class="comment">//开启中断</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt;<span class="comment">//中断模式</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling;<span class="comment">//下降沿触发，离开就+1</span></span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStructure); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 5.NVIC配置,这个地方需要两个中断初始化 */</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//选两位抢占两位响应，整个程序只需要配置一次</span></span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel=EXTI0_IRQn;<span class="comment">//外部中断0</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;/</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;<span class="comment">//响应优先级</span></span><br><span class="line">	NVIC_Init (&amp;NVIC_InitStructure);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel=EXTI1_IRQn;<span class="comment">//外部中断1</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">2</span>;<span class="comment">//响应优先级2大于1</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">	<span class="comment">//PB0和PB1为同一抢占优先级，但PB1的响应优先级比PB0大，所以PB0可以被PB1打断</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//获取中断服务函数中改变的数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int8_t</span> num;</span><br><span class="line">	num=EncoderCount;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//这个函数只有0这个引脚可以触发</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetFlagStatus (EXTI_Line0)==SET)<span class="comment">//外部中断0的线被触发，进入中断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>)<span class="comment">//A下降沿，B低电平，反转</span></span><br><span class="line">			&#123;</span><br><span class="line">				EncoderCount --;<span class="comment">//计数--</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line0);<span class="comment">//清除中断标志位，跳出中断</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//这个函数只有1这个引脚可以触发</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetFlagStatus (EXTI_Line1)==SET)<span class="comment">//外部中断1的线被触发，进入中断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)==<span class="number">0</span>)<span class="comment">//B下降沿，A低电平正转，</span></span><br><span class="line">			&#123;</span><br><span class="line">				EncoderCount ++;<span class="comment">//计数++</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line1);<span class="comment">//清除中断标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>正转编码器，counter增加，反转编码器，counter增加</strong></p>
</blockquote>
<h2 id="实验-对射式红外传感器计次">实验-对射式红外传感器计次</h2>
<h2 id="使用中断注意事项">使用中断注意事项</h2>
<ol>
<li><strong>中断函数中不要执行耗时过长的代码，不要使用延时函数</strong></li>
<li><strong>不要再中断函数中和主函数调用相同的函数或操作同一个硬件，操作用一个全局变量时要将该变量声明为volatile,避免编译器优化</strong></li>
<li><strong>中断建议操作变量或者标志位(状态位)</strong></li>
</ol>
<h1>TIM(定时器)</h1>
<h2 id="介绍-2">介绍</h2>
<ul>
<li>
<p>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断。</p>
</li>
<li>
<p>16位计数器、预分频器、自动重装载寄存器的时基单元，在72HZ计数时钟下可以实现最大59.65s((65535*65535)/72MHz)的定时时间</p>
</li>
<li>
<p>具备基本的定时中断功能，还包含内外时钟源选择、时钟捕获、输出比较、编码器接口，主从触发模式等多种功能</p>
</li>
<li>
<p>分为三种：<strong>高级定时器、通用定时器、基本定时器</strong>，难度依次递减</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/33-17375297555833.png" alt="image-20241118144626208"></p>
<h2 id="计数器模式">计数器模式</h2>
<p><strong>三种：向上计数模式、向下计数模式，中央对齐模式</strong></p>
<p><strong>基本定时器</strong>：只支持向上计数模式</p>
<p><strong>通用定时器和高级定时器</strong>：支持向上计数、向下计数、中央对齐计数</p>
<h2 id="时基单元">时基单元</h2>
<p>定时器框图中最重要的是时基单元，由三部分构成：<strong>预分频器PSC、自动重装载器ARR、计数器CNT</strong></p>
<ol>
<li>
<p><strong>Prescaler(psc)-预分频值</strong>：内部有一个预分频器PSC，内部时钟先输入到这里完成分频。简单来说就是分频值</p>
<p>时钟信号被分频后的频率 F= TCLK/(PSC+1)</p>
</li>
<li>
<p><strong>auto-reload preload(arr)-自动重装载值</strong>：内部有一个自动重装载寄存器，简单来说就是设置计数值上限，最大为65535</p>
</li>
<li>
<p><strong>CNT-计数器</strong>：内部有一个计数器自增，会与自动重装在寄存器比较，当计数值等于自动重装载值arr时，将会触发<strong>更新中断或更新事件</strong>，同时清零计数器</p>
</li>
</ol>
<p><code>定时器溢出时间 Tout =  (arr+1)/F   =   (arr+1)*(PSC+1) /TCLK</code></p>
<h2 id="时钟源">时钟源</h2>
<p><strong>在手册上我们可以看到，stm32通用定时器的时钟源有4种</strong>：</p>
<p>1、<strong>内部时钟(CK_INT)</strong></p>
<p>2、<strong>外部时钟模式1</strong>：外部输入引脚(TIx)</p>
<p>3、<strong>外部时钟模式2</strong>：外部触发输入(ETR)</p>
<p>4、<strong>内部触发输入(ITRx)</strong>：使用一个定时器作为另一个定时器的预分频器。如可以配置一个定时器Timer1而作为另一个定时器Timer2的预分频器。用于定时器级联</p>
<hr>
<p>基本定时器：只能选择内部时钟，也就是系统主频72MHz(F103)</p>
<p>通用(高级)定时器：时钟源不仅可以选择<strong>内部时钟输入</strong>，也可以选择<strong>外部时钟输入ETR</strong>(外部引脚输入)</p>
<p>在下面的<strong>参考手册通用定时器框图</strong>中可以看到通过TIMx_ETR引脚上可以外接一个外部方波时钟，在配置内部极性选择，边沿检测和预分频器，再配置一下输入滤波电路(对外部引脚输入进行滤波)，最后分为两路去<strong>ETRF(外部时钟模式2)<strong>和</strong>TRGI（外部时钟模式1）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241118151537820.png" alt="image-20241118151537820"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/0-17375297555832.png" alt="image-20241118153011362"></p>
<blockquote>
<p>总结：看上面手册中的框图</p>
<p><strong>内部时钟输入</strong>：APB1/APB2，一般为系统主频</p>
<p><strong>外部时钟输入</strong>：分为外部时钟模式1和外部时钟模式2</p>
<ol>
<li>
<p>ETR引脚(外部引脚输入)：经过一堆(极性选择、边沿检测、滤波等)后</p>
<ul>
<li>独立进入触发控制器(ETR独享)，是外部时钟模式2</li>
<li>通过触发器进入从模式控制器，是外部时钟模式1</li>
</ul>
</li>
<li>
<p>其他定时器(ITR)：是内部触发输入，来源于其他TIM，可以实现定时器级联，是外部时钟模式1</p>
</li>
<li>
<p>TIMx_CH1引脚的边沿(TI1F_ED)：外部时钟模式1</p>
</li>
<li>
<p>TIMx_CH1引脚(TI1FP1)：外部时钟模式1</p>
</li>
<li>
<p>TIMx_CH2引脚(TI2FP2)：外部时钟模式1</p>
</li>
</ol>
<p>TI1FP1：Timer Input 1 Filter Polarity 1</p>
</blockquote>
<blockquote>
<p><code>一般情况下外部时钟通过ETR引脚就可以，其他这么多输入是为了某些特定场景使用，比如：ITR是为了定时器级联设置的</code></p>
</blockquote>
<h2 id="库函数-2">库函数</h2>
<p><code>相关的库函数直接在stm32f10x_tim.h寻找使用,这里给出常用的</code></p>
<p><strong>时钟源选择</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_InternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="comment">//1.内部时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity,<span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br><span class="line"><span class="comment">//2.外部输入模式1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity, <span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br><span class="line"><span class="comment">//3.外部输入模式2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_TIxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_TIxExternalCLKSource,<span class="type">uint16_t</span> TIM_ICPolarity, <span class="type">uint16_t</span> ICFilter)</span>;</span><br><span class="line"><span class="comment">//4.外部输入模式1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITRxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_InputTriggerSource)</span>;</span><br><span class="line"><span class="comment">//5.内部触发输入，级联</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity,<span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>时基单元配置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_TimeBaseInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>中断输出控制配置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>NVIC配置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NVIC_Init</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p><strong>运行控制配置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_Cmd</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>单独更改预分频值</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_PrescalerConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Prescaler, <span class="type">uint16_t</span> TIM_PSCReloadMode)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>计数器模式配置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CounterModeConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_CounterMode)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>计数器预装载配置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ARRPreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>手动写入计数器值</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCounter</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Counter)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>手动写入ARR值</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetAutoreload</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Autoreload)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>获取计数器或预分频值</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCounter</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetPrescaler</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>中断相关函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">TIM_GetFlagStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_FLAG)</span>;<span class="comment">//中断外使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearFlag</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_FLAG)</span>;</span><br><span class="line">ITStatus <span class="title function_">TIM_GetITStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span>;<span class="comment">//中断内使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearITPendingBit</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="定时器中断-定时或计数功能">定时器中断(定时或计数功能)</h2>
<p><a target="_blank" rel="noopener" href="https://postimg.cc/kR4B9vCC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241118154510279.png" alt="image-20241118154510279.png"></a></p>
<h3 id="TIM配置流程">TIM配置流程</h3>
<p>首先新建Timer.c和Timer.h文件到Hardware中</p>
<p>我们将上方的定时中断基本结构图打通就完成了配置</p>
<p>具体流程：</p>
<ol>
<li><strong>RCC开启时钟</strong>：查看手册我们可以发现TIM2在APB1总线上，故开启APB1总线时钟</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>选择时基单元的时钟源</strong>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//上电后单片机默认使用内部时钟，这一行其实可以省略</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>配置时基单元</strong>：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode =TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>; </span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里并没有对CNT计数器的初始化，如果我们想更改，调用TIM_SetCounter函数进行更改即可</p>
<p>TIM_ClockDivision参数：与滤波器相关的分频，这里随便选</p>
<p>TIM_RepetitionCounter参数：<strong>重复计数器的值，高级定时器才有的，不用给0</strong></p>
</blockquote>
<ol start="4">
<li><strong>配置中断，即配置输出中断控制，允许更新中断输出到NVIC</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>这里的第二个参数我们选择的是更新中断，其他选择请跳转到对应函数的注释中查看</strong></p>
</blockquote>
<ol start="5">
<li><strong>配置NVIC，在NVIC中打开定时器中断的通道，并分配一个优先级</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//优先级分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//NVIC配置</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn  ;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br></pre></td></tr></table></figure>
<ol start="6">
<li><strong>运行控制，我们需要使能定时器的运行，否则不会工作</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br></pre></td></tr></table></figure>
<p><strong>连起来就是</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">/*1.RCC使能时钟*/</span></span><br><span class="line">		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">/*2.时基单元时钟源选择：此处选择内部时钟*/</span></span><br><span class="line">		TIM_InternalClockConfig(TIM2);<span class="comment">//上电后单片机默认使用内部时钟，这一行其实可以省略</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">/*3.时基单元配置*/</span></span><br><span class="line">		TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<span class="comment">//与滤波器相关的分频，这里随便选</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//计数器模式</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>; <span class="comment">//周期，也就是ARR的值</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;<span class="comment">//预分频器的值</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//重复计数器的值，高级定时器才有</span></span><br><span class="line">		TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">/*4.输出中断控制配置，允许更新中断输出到NVIC*/</span></span><br><span class="line">		TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br><span class="line">		</span><br><span class="line">    	<span class="comment">/*5.NVIC配置*/</span></span><br><span class="line">		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">		NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn  ;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">		NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">/*6.定时器运行控制，使能一下*/</span></span><br><span class="line">		TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>中断函数</strong>：同样在启动文件中寻找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update)== SET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*中间为用户代码*/</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">		TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>上方函数调用查看更新中断的标志位</strong></p>
</blockquote>
<h3 id="实验-使用定时器每秒计数-内部时钟">实验-使用定时器每秒计数(内部时钟)</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Timer.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Timer.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> Num;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">	</span><br><span class="line">		TIM_InternalClockConfig(TIM2);<span class="comment">//上电后单片机默认使用内部时钟，这一行其实可以省略</span></span><br><span class="line">		</span><br><span class="line">		TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<span class="comment">//与滤波器相关的分频，这里随便选</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//计数器模式</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>; <span class="comment">//周期，也就是ARR的值</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;<span class="comment">//预分频器的值</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//重复计数器的值，高级定时器才有</span></span><br><span class="line">		TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	    </span><br><span class="line">        TIM_ClearFlag(TIM2,TIM_FLAG_Update);<span class="comment">//避免上电立即进入中断    </span></span><br><span class="line">    </span><br><span class="line">		TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br><span class="line">		</span><br><span class="line">		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">		NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">		NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">	</span><br><span class="line">		TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update)== SET)</span><br><span class="line">	&#123;</span><br><span class="line">		Num++;</span><br><span class="line">		</span><br><span class="line">		TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Timer_Init();</span><br><span class="line">	OLED_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);</span><br><span class="line">        OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">5</span>,TIM_GetCounter(TIM2),<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有个问题，上电后我们可以发现计数器的值直接为1，这代表在上电时就已经进入了一次中断处理程序了。</p>
<p>这是由于TIM_TimeBaseInit()函数中最后一排有个TIMx-&gt;EGR = TIM_PSCReloadMode_Immediate;</p>
<p>查看注释可以知道其手动生成了一个更新事件(为了让预分频器缓冲寄存器起作用，更新才会起作用)，导致上电立即进入中断。</p>
<p>解决方案：</p>
<p>在TIM_TimeBaseInit()后，开启中断前使用手动清除标志位。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"><span class="comment">/*添加到这里即可*/</span></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);</span><br><span class="line"></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br></pre></td></tr></table></figure>
<h3 id="实验-对射式红外传感器-外部时钟模式2">实验-对射式红外传感器(外部时钟模式2)</h3>
<p><strong>参考手册查看到芯片的TIM2_CH1_ETR复用输入引脚为PA0，可以通过PA0引脚将传感器0模块的DO引脚输出波形引入到定时器TIM2中</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Timer.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> Num;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//有外部引脚输出，故先配置外部引脚</span></span><br><span class="line">		GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    <span class="comment">/*这里的GPIO输入模式在参考手册可以查到，使用TIM2外部输入，推荐为浮空输入*/</span></span><br><span class="line">		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">		GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*这里选择的外部时钟模式2，对应参数选择跳转到对应函数查看注释*/</span></span><br><span class="line">		TIM_ETRClockMode2Config(TIM2,TIM_ExtTRGPSC_OFF,TIM_ExtTRGPolarity_NonInverted,<span class="number">0x0F</span>);</span><br><span class="line">    <span class="comment">//选择的是上升沿触发，最后一个参数是外部触发滤波器，取值对应可以在参考手册中从模式控制寄存器(TIMx_SMCR)中看到，取值为0x00~0x0f,如果我们不滤波(0x00)的话就会有很多抖动脉冲，计数很多次。这里一般选择0x0F(15)即可</span></span><br><span class="line">		</span><br><span class="line">		TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10</span><span class="number">-1</span>; </span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span><span class="number">-1</span>;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">		TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">		</span><br><span class="line">		TIM_ClearFlag(TIM2,TIM_FLAG_Update);</span><br><span class="line">		TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);</span><br><span class="line">		</span><br><span class="line">		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">		NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">		NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">		NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">	</span><br><span class="line">		TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update)== SET)</span><br><span class="line">	&#123;</span><br><span class="line">		Num++;</span><br><span class="line">		</span><br><span class="line">		TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Timer_Init();</span><br><span class="line">	Key_Init();</span><br><span class="line">	LED_Init();</span><br><span class="line">	OLED_Init();</span><br><span class="line"><span class="comment">//	OLED_ShowChar(10,10,&#x27;a&#x27;);</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);</span><br><span class="line">		</span><br><span class="line">		OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">5</span>,TIM_GetCounter(TIM2),<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当我们把手放遮挡在拿开，计数器+1，计数9次后，Num+1</p>
</blockquote>
<h3 id="实验-循迹模块测量商品数量-外部时钟模式2">实验-循迹模块测量商品数量(外部时钟模式2)</h3>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1N94y1u7Uz?spm_id_from=333.788.videopod.sections&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32】动画讲解定时器外部时钟 &amp; 实战传送带测速装置_哔哩哔哩_bilibili</a></p>
<p><strong>参考手册查看到芯片的TIM2_CH1_ETR复用输入引脚为PA0，可以通过PA0引脚将传感器0模块的DO引脚输出波形引入到定时器TIM2中。</strong></p>
<p>代码与上方完全相同</p>
<p>同样也可以使用外部时钟模式1的ETR从模式、TI1F_ED、TI1FP1、TI1FP2都可以实现</p>
<blockquote>
<p>最终我们将任意物品从循迹模块下方穿过，一个物品计数+1</p>
</blockquote>
<h2 id="输出比较功能-OC">输出比较功能(OC)</h2>
<h3 id="OC简介">OC简介</h3>
<p>OC(Output Compare)--------输出比较</p>
<p>输出比较可以通过比较<strong>CNT计数器</strong>与<strong>CCR</strong>(Capture/Compare Register)值的关系进行置1、置0或者翻转的操作，用于输出一定频率和占空比的PWM波形</p>
<blockquote>
<p><strong>CCR全称：Capture/Compare Register  –   捕获/比较寄存器</strong></p>
<p><strong>使用输入捕获时：就是捕获寄存器</strong></p>
<p><strong>使用输出比较时：就是比较寄存器</strong></p>
</blockquote>
<ul>
<li>每个高级定时器和通用定时器都拥有4个输出比较通道</li>
<li>高级定时器的前三个通道额外拥有死区生成和互补输出的功能</li>
</ul>
<h3 id="PWM输出简介">PWM输出简介</h3>
<p><strong>脉冲宽度调制-PWM</strong>，是英文“Pulse Width Modulation”的缩写，简称<strong>脉宽调制</strong>，其实是在利用微控制器的<strong>定时器模块</strong>来生成一种特定频率和占空比的<strong>脉冲信号(一段高低电平)</strong>，调整脉冲的宽度从而影响功率等。PWM信号是一种周期性的脉冲信号，通过调整脉冲的宽度（高电平时间）可以模拟模拟信号，控制电机速度、LED亮度、蜂鸣器响度等。必须具有惯性的系统才能使用PWM。</p>
<p><strong>PWM参数</strong>：</p>
<ol>
<li>
<p><strong>频率</strong> = 1 / Ts</p>
</li>
<li>
<p><strong>占空比</strong> =  Ton / Ts (图中的高电平占整个周期的时间)</p>
</li>
<li>
<p><strong>分辨率</strong> = 占空比变化步距(占空比以多少百分比跳变，1%到%2到%3，分辨率就是1%)</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/1-17375297555835.png" alt="image-20241119175400365"></p>
<blockquote>
<p>PWM频率越快，等效模拟的信号也就越平稳，对应的性能开销也就越大</p>
<p><strong>一般来说PWM的频率都在几K到几十K，这个频率就足够快了</strong></p>
</blockquote>
<hr>
<p><strong>原理图：CCR=30时</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/2-17375297555836.png" alt="image-20241120214655665"></p>
<blockquote>
<p>参数计算：</p>
<p>PWM频率：Freq = CK_PSC/(PSC+1)*(ARR+1)</p>
<p>PWM占空比：Duty = CCR/(ARR+1)</p>
<p>PWM分辨率：Reso = 1 / (ARR+1)   <strong>占空比越细腻越好</strong></p>
</blockquote>
<h3 id="舵机简介">舵机简介</h3>
<p>舵机是一种根据输入<strong>PWM信号占空比来控制输出角度的装置</strong></p>
<p>常见的舵机型号有：SG90，SG92</p>
<p>输入PWM信号要求：<strong>周期为20ms</strong>，<strong>高电平时长为0.5ms~2.5ms(0~180°)，可以查看对应舵机手册得到驱动角度对应PWM的周期</strong></p>
<p>三根线：一根VCC，一根GND，一根信号线</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/3-17375297555837.png" alt="image-20241120215627230"></p>
<blockquote>
<p>给一个PWM，舵机就会固定在某一个角度，机械臂等机械机构就可以使用</p>
<p><strong>这里的PWM输出当成通信协议很常见，PWM波形通过信号线输出</strong></p>
</blockquote>
<h3 id="直流电机及驱动简介">直流电机及驱动简介</h3>
<p>直流电机是一种将电能转换为机械能的装置，有两个电极，当电极正接时，电机正转，当电极反接时，电机反转。(对应一个引脚高电平一个引脚低电平)</p>
<p><strong>直流电机属于大功率器件，GPIO口无法直接驱动，需要配合<code>电机驱动芯片</code>来操作</strong></p>
<p>TB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并控制其转速和方向，还有<strong>DRV8833驱动芯片</strong>等</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/4-17375297555838.png" alt="image-20241120221616621"></p>
<blockquote>
<p>在对应模块使用手册可以查看使用方法以及原理图，各引脚含义</p>
</blockquote>
<h3 id="库函数-3">库函数</h3>
<p>主要初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="comment">/*对应的是四个输出比较通道的输出比较单元结构体的初始化*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OCStructInit</span><span class="params">(TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="comment">/*用于为一个结构体赋初值*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="comment">/*极性配置</span></span><br><span class="line"><span class="comment"> * 对每个通道极性的单独配置 </span></span><br><span class="line"><span class="comment"> * 带N是高级定时器中互补通道的配置，OC4没有互补通道</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCxCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_CCx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCxNCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_CCxN)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单独修改输出使能参数*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectOCxM</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_OCMode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单独修改输出比较模式的函数*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare1</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare2</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare3</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare3)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare4</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare4)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单独修改CCR寄存器的函数</span></span><br><span class="line"><span class="comment"> * 可用于调整占空比</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CtrlPWMOutputs</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该函数仅高级定时器使用，在使用高级定时器输出PWM时，需要调用这个函数，使能主输出，否则PWM将不能正常输出</p>
</blockquote>
<hr>
<p><strong>一些小功能配置：使用不多</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC3Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC4Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="comment">/*配置强制输出模式：在运行中想要暂停输出波形并且强制输出高或低电平使用</span></span><br><span class="line"><span class="comment"> * 一般不怎么使用，修改占空比为0或100也能实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCPreloadControl</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="comment">/*用于配置CCR寄存器的预装功能，也就是影子寄存器</span></span><br><span class="line"><span class="comment"> * 也就是：写入的值不会立即生效，而是在更新时间才会生效</span></span><br><span class="line"><span class="comment"> * 一般不使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于配置快速使能</span></span><br><span class="line"><span class="comment"> * 功能手册中，单脉冲模式有介绍</span></span><br><span class="line"><span class="comment"> * 一般不使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC1Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC2Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC3Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC4Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外部事件时清楚REF信号</span></span><br><span class="line"><span class="comment"> * 不怎么使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="输出比较配置流程">输出比较配置流程</h3>
<ol>
<li>
<p><strong>RCC开启时钟</strong></p>
</li>
<li>
<p><strong>配置GPIO：把PWM对应的GPIO口初始化为复用推挽输出模式(TIM复用)</strong></p>
</li>
<li>
<p><strong>选择时基单元时钟源</strong></p>
</li>
<li>
<p><strong>配置时基单元</strong></p>
</li>
<li>
<p><strong>配置输出比较单元：输出比较模式、极性选择、输出状态使能、CCR的值等</strong></p>
</li>
<li>
<p><strong>运行控制：启动对应TIM</strong></p>
</li>
</ol>
<h3 id="实验-PWM呼吸灯">实验-PWM呼吸灯</h3>
<h4 id="配置流程">配置流程</h4>
<ol>
<li>
<p><strong>RCC开启时钟，开启对应GPIO和TIM时钟</strong></p>
</li>
<li>
<p><strong>配置GPIO：把PWM对应的GPIO口初始化为复用推挽输出模式(TIM复用)</strong></p>
</li>
<li>
<p><strong>选择时基单元时钟源</strong></p>
</li>
<li>
<p><strong>配置时基单元</strong></p>
</li>
<li>
<p><strong>配置输出比较单元：输出比较模式、极性选择、输出状态使能、CCR的值等</strong></p>
</li>
<li>
<p><strong>运行控制：启动对应TIM</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*PWM.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PWM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PWM_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*PWM.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="comment">//1.RCC开启时钟</span></span><br><span class="line">	 RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);</span><br><span class="line">	 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	 <span class="comment">//2.配置GPIO</span></span><br><span class="line">	 GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽模式</span></span><br><span class="line">	 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	 GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">//3.配置时基单元时钟源</span></span><br><span class="line">	 TIM_InternalClockConfig(TIM3);</span><br><span class="line">	 <span class="comment">//4.配置时基单元</span></span><br><span class="line">	 TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up ;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span><span class="number">-1</span>;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">720</span><span class="number">-1</span>;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	 TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure); </span><br><span class="line">	 <span class="comment">//5.配置输出比较单元</span></span><br><span class="line">	 TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">	 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1 ;  <span class="comment">/*PWM1模式*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High ; <span class="comment">/*极性为高：有效电平为高电平*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;  <span class="comment">/*输出状态使能*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">//配置CCR</span></span><br><span class="line">	<span class="comment">/*这里时通用定时器，只需要列举需要的参数即可，高级定时器的参数可以不用管*/</span></span><br><span class="line">	 TIM_OC2Init(TIM3,&amp;TIM_OCInitStructure);</span><br><span class="line">	 <span class="comment">//6.运行控制，TIM使能</span></span><br><span class="line">	 TIM_Cmd(TIM3,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> pwmVal = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">	PWM_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">	 </span><br><span class="line">		<span class="keyword">for</span>(;pwmVal&lt;<span class="number">100</span>;pwmVal++)</span><br><span class="line">		&#123;</span><br><span class="line">			TIM_SetCompare2(TIM3,pwmVal);</span><br><span class="line">			Delay_ms(<span class="number">10</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(;pwmVal&gt;<span class="number">0</span>;pwmVal--)</span><br><span class="line">		&#123;</span><br><span class="line">			TIM_SetCompare2(TIM3,pwmVal);</span><br><span class="line">			Delay_ms(<span class="number">10</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实验-PWM驱动舵机">实验-PWM驱动舵机</h3>
<blockquote>
<p>驱动舵机工作的频率为50HZ，也就是周期为20ms。</p>
<p>这里对应PSC设置为72-1，ARR设置为20000-1</p>
<p>舵机旋转角度对应的周期为500us~2500us(0.5ms~2.5ms)的高电平时长，对应占空比为：0.5ms/20ms = 2.5%  到    2.5ms/20 =12.5%</p>
<p>即设置ARR的范围应该是500~2500(对应0~180°)</p>
</blockquote>
<p><code>配置流程与上一个实验一样</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Servo.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SERVO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SERVO_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_SetAngle</span><span class="params">(<span class="type">float</span> Angle)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Servo.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	 RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,ENABLE);</span><br><span class="line">	 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line">	 GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽模式</span></span><br><span class="line">	 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	 GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">	 <span class="comment">/*PB8为舵机的信号线*/</span></span><br><span class="line">	</span><br><span class="line">	 TIM_InternalClockConfig(TIM4);</span><br><span class="line">	</span><br><span class="line">	 TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up ;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_Period = <span class="number">20000</span><span class="number">-1</span>;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	 TIM_TimeBaseInit(TIM4,&amp;TIM_TimeBaseInitStructure); </span><br><span class="line">	</span><br><span class="line">	 TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">	 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1 ;  <span class="comment">/*PWM1模式*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High ; <span class="comment">/*有效电平为高电平*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;  <span class="comment">/*输出状态使能*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_Pulse = <span class="number">500</span>; <span class="comment">//配置CCR</span></span><br><span class="line">	<span class="comment">/*这里时通用定时器，只需要列举需要的参数即可，高级定时器的参数可以不用管*/</span></span><br><span class="line">	 TIM_OC3Init(TIM4,&amp;TIM_OCInitStructure);</span><br><span class="line">	 </span><br><span class="line">	 TIM_Cmd(TIM4,ENABLE);</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置舵机角度*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_SetAngle</span><span class="params">(<span class="type">float</span> Angle)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIM_SetCompare3(TIM4,(Angle/<span class="number">180</span>)*(<span class="number">2000</span>)+<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Servo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">	Key_Init();</span><br><span class="line"></span><br><span class="line">	Servo_Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		 Num = Key_GetNum();</span><br><span class="line">       <span class="keyword">if</span>(Num == <span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">                <span class="type">static</span> <span class="type">float</span> angle=<span class="number">0</span>;</span><br><span class="line">                  angle+=<span class="number">30</span>;</span><br><span class="line">                  <span class="keyword">if</span>(angle &gt; <span class="number">180</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        angle = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">              Servo_SetAngle(angle);</span><br><span class="line">       &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>按键按下，舵机旋转30度</strong></p>
</blockquote>
<h3 id="实验-PWM驱动DRV8833电机">实验-PWM驱动DRV8833电机</h3>
<p>DRV8833相关知识见HAL库笔记</p>
<blockquote>
<p>DRV8833对应两个输入引脚，一个PWM输入，一个给高/低电平可以实现正反转，对应查表见HAL库对应章节。</p>
<p><strong>对应PWM占空比越高，电机转速越快</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DRV8833.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DRV8833_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DRV8833_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_SetSpeed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>这里两个输入引脚为：PA0，PA1。PA0为PWM引脚，PA1为低电平引脚</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DRV8833.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//1.</span></span><br><span class="line">	 RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">	 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">      </span><br><span class="line">     <span class="comment">//2.</span></span><br><span class="line">	 GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	 GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	 <span class="comment">/*配置PA1引脚为输出模式*/</span></span><br><span class="line">	  </span><br><span class="line">	 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽模式</span></span><br><span class="line">	 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	 GPIO_Init(GPIOA,&amp;GPIO_InitStructure); </span><br><span class="line">	 <span class="comment">/*配置PWM引脚PA0，为复用推挽输出模式*/</span> </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//3.</span></span><br><span class="line">	 TIM_InternalClockConfig(TIM2);</span><br><span class="line">	 <span class="comment">//4.</span></span><br><span class="line">	 TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up ;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span><span class="number">-1</span>;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;</span><br><span class="line">	 TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	 TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure); </span><br><span class="line">	 </span><br><span class="line">     <span class="comment">//5.</span></span><br><span class="line">	 TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">	 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1 ;  <span class="comment">/*PWM1模式*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High ; <span class="comment">/*有效电平为高电平*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;  <span class="comment">/*输出状态使能*/</span></span><br><span class="line">	 TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">//修改CCR的值可以改变转速</span></span><br><span class="line">	<span class="comment">/*这里时通用定时器，只需要列举需要的参数即可，高级定时器的参数可以不用管*/</span></span><br><span class="line">	 TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);</span><br><span class="line">	 </span><br><span class="line">     <span class="comment">//6.</span></span><br><span class="line">	 TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">   </span><br><span class="line">	 GPIO_ResetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">	 <span class="comment">/*设置PA1为低电平*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_SetSpeed</span><span class="params">(<span class="type">uint8_t</span> speed)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(speed&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TIM_SetCompare1(TIM2,speed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DRV8833.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">	DRV8833_Init();</span><br><span class="line">    DRV8833_SetSpeed(<span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>转速最大值可以设置100，为ARR最大值</strong></p>
</blockquote>
<h2 id="输入捕获功能-IC">输入捕获功能(IC)</h2>
<h3 id="IC简介">IC简介</h3>
<p><strong>IC(Input Capture)--------输入捕获</strong></p>
<p>输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR(捕获寄存器)中，<strong>可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数。</strong></p>
<blockquote>
<p><strong>CCR全称：Capture/Compare Register  –   捕获/比较寄存器</strong></p>
<p><strong>使用输入捕获时：就是捕获寄存器</strong></p>
<p><strong>使用输出比较时：就是比较寄存器</strong></p>
</blockquote>
<p>每个高级定时器和通用定时器都拥有4个输入捕获通道：</p>
<ul>
<li>
<p>可配置为<code>PWMI模式</code>，同时测量频率和占空比</p>
</li>
<li>
<p>可配合主从触发模式，实现硬件全自动测量</p>
</li>
</ul>
<h3 id="频率测量">频率测量</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/5-17375297555839.png" alt="image-20241125154510808"></p>
<blockquote>
<p><strong>测频法(测频率)</strong>：适合测量<code>高频</code>信号，<strong>计次数量多一些，有助于减小误差</strong></p>
<p><strong>特点</strong>：测量结果更新速度较慢，但是平均值，相当于均值滤波，结果比较稳定</p>
<p>fx = N / T</p>
<hr>
<p><strong>测周法(测周期)</strong>：适合测量<code>低频</code>信号，<strong>周期比较长，计次比较多，有助于减小误差</strong></p>
<p><strong>特点：只测量一个周期</strong>，测量结果更新速度较快，但结果值会受噪声的影响，波动比较大</p>
<p>fx = fc / N     fc为标准频率：标准频率就是经过PSC分频后的时钟频率</p>
<p><strong>在这里fc可以是使用输入捕获时定时器的频率，使用时需要每次触发后将CNT的值清0才是一个周期</strong></p>
<hr>
<p><strong>中界频率</strong>fm：</p>
<p>待测<code>信号频率&lt;中界频率</code>时，选用<code>测频法</code>误差更小</p>
<p>待测<code>信号频率&gt;中界频率</code>时，选用<code>测周法</code>误差更小</p>
<p>fm = 根号下(fc / T)</p>
</blockquote>
<h3 id="输入捕获通道">输入捕获通道</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/6-173752975558410.png" alt="image-20241125161551723"></p>
<blockquote>
<p>同一个引脚TIx的输入信号映射到两个输入通道IC1和IC2，且两个通道的<code>极性检测相反</code>即这里的</p>
<p><strong>TI1引脚的输入信号可以映射到TI1FP1和TI1FP2</strong></p>
<p>TI1FP1连接到的是输入通道1，TI1FP2连接到的是输入通道2，可以使用两个捕获寄存器CCR</p>
<p><strong>T2引脚的输入信号可以映射到TI2FP1和TI2FP2</strong></p>
<p>TI2FP1连接到的是输入通道1，TI2FP2连接到的是输入通道2，也可以使用两个捕获寄存器CCR</p>
<p>一共四种连接方式</p>
</blockquote>
<blockquote>
<p><code>输入捕获的直接模式和间接模式</code>：信号从TI1引入，在自己的捕获寄存器1上进行输入捕获，就叫做<strong>输入捕获的直接模式</strong>。信号从TI1引入借用捕获寄存器2进行输入捕获，则叫做<strong>输入捕获的间接模式(交叉模式)</strong>。</p>
</blockquote>
<h3 id="主从触发模式">主从触发模式</h3>
<p>主从触发模式是：<code>主模式</code>、<code>从模式</code>、<code>触发源</code>选择这三个功能的简称</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/7-173752975558411.png" alt="image-20241125162539989"></p>
<blockquote>
<p><code>主模式</code>：可以将定时器内部信号映射到TRGO 引脚，用于触发别的外设</p>
<p><code>从模式</code>：接收其他外设或者自身外设的一些信号，用于控制自身定时器的运行，也就是被别的信号控制</p>
<p><code>触发源选择</code>：就是选择从模式的触发信号源的，可以认为是从模式的一部分。选择指定的一个信号，得到TRGI，TRGI去触发从模式，在从模式列表中选择一项操作自动执行</p>
<p><strong>如：选择TI1FP1触发源，选择Reset操作就可以自动触发从模式，从模式自动清零CNT</strong></p>
</blockquote>
<blockquote>
<p><code>主模式选择</code>可以在对应手册<strong>TIMx_CRx控制寄存器</strong>中查看</p>
<p><code>从模式选择</code>可以在对应手册<strong>TIMx_SMCR从模式控制寄存器</strong>中查看</p>
</blockquote>
<h3 id="输入捕获和PWMI基本结构图">输入捕获和PWMI基本结构图</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/8-173752975558412.png" alt="image-20241125163454859"></p>
<blockquote>
<p><strong>特点</strong>：只使用了一个通道，<code>只能测量频率</code>，使用的是测周法测量频率，所以需要每次触发后将CNT的值清0，使用从模式实现信号触发后自动清0</p>
<p><strong>F = fc / N</strong></p>
<p><strong>fc为标准频率：标准频率就是经过PSC分频后的时钟频率</strong></p>
<p><strong>因为CNT要自增，所以ARR的值要设置的足够大，设置为上限65535</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/9-173752975558413.png" alt="image-20241125164342932"></p>
<blockquote>
<p><code>PWMI模式（PWM输入模式）</code>：<strong>使用两个通道来捕获，可以测量<code>频率</code>和<code>占空比</code>，使用的是测周法测量频率，所以需要每次触发后将CNT的值清0，使用从模式实现信号触发后自动清0</strong></p>
<p><strong>下面部分</strong>：</p>
<p>TI1FP1和TI1FP2以相反的极性检测(TI1FP1检测上升沿，TI1FP2检测下降沿)</p>
<p>CCR1：一整个周期的计数值，每一次上升沿到来时对应CNT都会清零</p>
<p>CCR2：高电平期间的计数值</p>
<p>占空比：duty = CCR2 / CCR1</p>
<p><strong>因为CNT要自增，所以ARR的值要设置的足够大，设置为上限65535</strong></p>
<hr>
<p><strong>上面部分</strong>：选择TI1FP1触发源，使用从模式配合输入捕获，实现CNT自动清零(Reset)，完成硬件自动化</p>
</blockquote>
<p><code>相关介绍对应在参考手册的输入捕获和PWM输入模式对应部分</code></p>
<h3 id="库函数-4">库函数</h3>
<p><code>初始化函数：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ICInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;</span><br><span class="line"><span class="comment">/*配置输入捕获单元函数，输出比较是四个通道分别有一个函数，而输入捕获配置是4个通道共用一个函数，具体通道选择在结构体中*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_PWMIConfig</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;</span><br><span class="line"><span class="comment">/* 也是配置输入捕获单元的函数，但是这个函数可以快速配置两个通道，将外设电路配置为PWMI模式</span></span><br><span class="line"><span class="comment"> * 传入一个结构体之后，该函数会根据传入结构体通道配置自动初始化另外一个通道为相反的配置</span></span><br><span class="line"><span class="comment"> * 比如：传入结构体配置为通道1，上升沿触发，直接模式，调用该函数就会配置通道2为下降沿触发，且为交叉模式(间接模式)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 该函数只支持通道1和通道2，不能传入通道3和通道4!!!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ICStructInit</span><span class="params">(TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;</span><br><span class="line"><span class="comment">/*输入捕获结构体初始化，一般在某些参数不用初始化的时后调用，防止没有初始化某些值造成意外错误*/</span></span><br></pre></td></tr></table></figure>
<p><code>主从模式相关函数</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectOutputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_TRGOSource)</span>;</span><br><span class="line"><span class="comment">/*选择输出触发源TRGO，对应主模式输出的触发源*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectInputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_InputTriggerSource)</span>;</span><br><span class="line"><span class="comment">/*选择输入触发源TRGI，对应从模式的触发源选择*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectSlaveMode</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_SlaveMode)</span>;</span><br><span class="line"><span class="comment">/*选择从模式，对应从模式执行操作*/</span></span><br></pre></td></tr></table></figure>
<p><code>预分频配置</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC1Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC2Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC3Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC4Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="comment">/*分别配置通道1~4的预分频值，这个参数可以在结构体中配置*/</span></span><br></pre></td></tr></table></figure>
<p><code>获取捕获寄存器值</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture1</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture2</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture3</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture4</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="comment">/*分别获取四个通道的捕获寄存器CCR的值*/</span></span><br></pre></td></tr></table></figure>
<h3 id="输入捕获配置流程">输入捕获配置流程</h3>
<p><code>根据上面的结构图可以得到输入捕获配置流程:</code></p>
<ol>
<li>
<p><strong>RCC开启时钟，将GPIO和TIM的时钟打开</strong></p>
</li>
<li>
<p><strong>GPIO初始化，配置GPIO为输入模式(上拉或者浮空)</strong></p>
</li>
<li>
<p><strong>配置时基单元的时钟源</strong></p>
</li>
<li>
<p><strong>配置时基单元，让CNT计数器在内部时钟的驱动下自增运行</strong></p>
</li>
<li>
<p><strong>配置输入捕获单元，包括滤波器、极性、直连通道还是交叉通道、分频器等参数</strong></p>
</li>
<li>
<p><strong>配置从模式触发源，触发源选择TI1FP1等</strong> (调用库函数)</p>
</li>
<li>
<p><strong>配置从模式执行的操作</strong>（调用库函数）</p>
</li>
<li>
<p><strong>运行控制，开启定时器TIM</strong></p>
</li>
</ol>
<h3 id="实验-输入捕获模式测频率-输入捕获直接模式">实验-输入捕获模式测频率(输入捕获直接模式)</h3>
<blockquote>
<p>这个地方没有信号发生器，选择将另外一个引脚TIM输出信号输入到该TIM引脚。从PB8输入到PA0</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __IC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IC_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.开启对应GPIO和TIM时钟</span></span><br><span class="line">	  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"> 	<span class="comment">//2.配置GPIO为</span></span><br><span class="line">	  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_0;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">      GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	<span class="comment">//3.时基单元时钟源配置	</span></span><br><span class="line">	  TIM_InternalClockConfig(TIM2);</span><br><span class="line">	<span class="comment">//4.时基单元配置</span></span><br><span class="line">      TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>;<span class="comment">//ARR</span></span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;<span class="comment">//PSC,标准频率fc = 72M/72 = 1MHz</span></span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span> ;</span><br><span class="line">		TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	  </span><br><span class="line">	<span class="comment">//5.输入捕获单元配置</span></span><br><span class="line">	  TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">	  TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; <span class="comment">//CH1</span></span><br><span class="line">	  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; <span class="comment">//滤波值，越大滤波效果越好</span></span><br><span class="line">	  TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//上升沿捕获</span></span><br><span class="line">	  TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; <span class="comment">//对应触发信号分频器，不分频DIV1就是每次触发都有效，2分频就是每隔一次生效一次</span></span><br><span class="line">      TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;<span class="comment">//输入捕获直接模式</span></span><br><span class="line">	  TIM_ICInit(TIM2,&amp;TIM_ICInitStructure);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">//6.从模式触发源配置</span></span><br><span class="line">		TIM_SelectInputTrigger(TIM2,TIM_TS_TI1FP1);<span class="comment">//配置从模式输入触发源</span></span><br><span class="line">    <span class="comment">//7.从模式执行操作</span></span><br><span class="line">		TIM_SelectSlaveMode(TIM2,TIM_SlaveMode_Reset);<span class="comment">//配置从模式操作</span></span><br><span class="line">	<span class="comment">//8.运行控制，启动TIM</span></span><br><span class="line">		TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1000000</span>/TIM_GetCapture1(TIM2)<span class="number">-1</span>; <span class="comment">//这里的-1是为了弥补+-1的误差</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个地方标准频率fc = 72MHz / 72 = 1MHz = 1000000</p>
<p>fc即为经过PSC分频过后的频率</p>
<p>测量最低频率为：1MHz / 65535 = 15Hz，再低会溢出。</p>
<p><strong>如果想要降低最低频率，只需要增大PSC的值</strong></p>
<p><strong>如果想要增大最低频率，只需要减小PSC的值</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">	  PWM_Init();<span class="comment">//输出PWM信号</span></span><br><span class="line">	  PWM_SetPrescaler(<span class="number">720</span><span class="number">-1</span>);</span><br><span class="line">	  PWM_SetCompare3(<span class="number">25</span>);<span class="comment">//CCR = 25</span></span><br><span class="line">	   </span><br><span class="line">	  IC_Init();<span class="comment">//输入捕获</span></span><br><span class="line">	</span><br><span class="line">	  OLED_Init();</span><br><span class="line">	  OLED_ShowString(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&quot;Freq:00000HZ&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		OLED_ShowNum(<span class="number">5</span>,<span class="number">6</span>,IC_GetFreq(),<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实验-PWMI模式测频率和占空比-输入捕获交叉-间接模式">实验-PWMI模式测频率和占空比(输入捕获交叉/间接模式)</h3>
<blockquote></blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __IC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IC_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.开启对应GPIO和TIM时钟</span></span><br><span class="line">	  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"> 	<span class="comment">//2.配置GPIO为</span></span><br><span class="line">	  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_0;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">      GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">	<span class="comment">//3.时基单元时钟源配置	</span></span><br><span class="line">	  TIM_InternalClockConfig(TIM2);</span><br><span class="line">	<span class="comment">//4.时基单元配置</span></span><br><span class="line">      TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>;<span class="comment">//ARR</span></span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;<span class="comment">//PSC,标准频率fc = 72M/72 = 1MHz</span></span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span> ;</span><br><span class="line">		TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	  </span><br><span class="line">	<span class="comment">//5.输入捕获单元配置</span></span><br><span class="line">	  TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">		TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; <span class="comment">//CH1</span></span><br><span class="line">	  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; <span class="comment">//滤波值，越大滤波效果越好</span></span><br><span class="line">		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//上升沿捕获</span></span><br><span class="line">		TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; <span class="comment">//对应触发信号分频器，不分频DIV1就是每次触发都有效，2分频就是每隔一次生效一次</span></span><br><span class="line">		TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;<span class="comment">//输入捕获直接模式</span></span><br><span class="line">	    TIM_PWMIConfig(TIM2,&amp;TIM_ICInitStructure);</span><br><span class="line">        <span class="comment">/*输入捕获模式和PWMI模式差别就在这里*/</span></span><br><span class="line"><span class="comment">//	  TIM_ICInit(TIM2,&amp;TIM_ICInitStructure);</span></span><br><span class="line"><span class="comment">//	  TIM_ICInitStructure.TIM_Channel = TIM_Channel_2; //CH2</span></span><br><span class="line"><span class="comment">//	  TIM_ICInitStructure.TIM_ICFilter = 0xF; </span></span><br><span class="line"><span class="comment">//		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling ;//下降沿捕获，与通道一相反</span></span><br><span class="line"><span class="comment">//		TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; </span></span><br><span class="line"><span class="comment">//		TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_IndirectTI;//输入捕获交叉模式</span></span><br><span class="line"><span class="comment">//		TIM_ICInit(TIM2,&amp;TIM_ICInitStructure);</span></span><br><span class="line">		</span><br><span class="line">    <span class="comment">//6.从模式触发源配置</span></span><br><span class="line">		TIM_SelectInputTrigger(TIM2,TIM_TS_TI1FP1);<span class="comment">//配置从模式输入触发源</span></span><br><span class="line">    <span class="comment">//7.从模式执行操作</span></span><br><span class="line">		TIM_SelectSlaveMode(TIM2,TIM_SlaveMode_Reset);<span class="comment">//配置从模式操作</span></span><br><span class="line">	<span class="comment">//8.运行控制，启动TIM</span></span><br><span class="line">		TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取频率*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1000000</span>/TIM_GetCapture1(TIM2)<span class="number">-1</span>; <span class="comment">//这里的-1是为了弥补+-1的误差</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取占空比*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetDuty</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> TIM_GetCapture2(TIM2)*<span class="number">100</span>/TIM_GetCapture1(TIM2)+<span class="number">1</span>;<span class="comment">//弥补误差</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>
<p><strong>使用TIM_PWMIConfig(TIM2,&amp;TIM_ICInitStructure)函数可以快速配置两个通道，见源码可知，该函数自动初始化该通道和初始化另外一个通道为相反的配置。</strong></p>
</li>
<li>
<p><strong>不使用该函数，就配置两次即可，即上方注释部分，通道1配置为上升沿捕获，直接模式，通道2就配置为下降沿捕获，交叉模式，调用两次初始化函数即可。</strong></p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">	  PWM_Init();<span class="comment">//输出PWM信号</span></span><br><span class="line">	  PWM_SetPrescaler(<span class="number">720</span><span class="number">-1</span>);</span><br><span class="line">	  PWM_SetCompare3(<span class="number">25</span>);<span class="comment">//CCR = 25</span></span><br><span class="line">	   </span><br><span class="line">	  IC_Init();<span class="comment">//输入捕获</span></span><br><span class="line">	</span><br><span class="line">	  OLED_Init();</span><br><span class="line">	  OLED_ShowString(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&quot;Freq:00000HZ&quot;</span>);</span><br><span class="line">	  OLED_ShowString(<span class="number">10</span>,<span class="number">1</span>,<span class="string">&quot;Duty:00%&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		OLED_ShowNum(<span class="number">5</span>,<span class="number">6</span>,IC_GetFreq(),<span class="number">5</span>);</span><br><span class="line">		OLED_ShowNum(<span class="number">10</span>,<span class="number">6</span>,IC_GetDuty(),<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编码器接口">编码器接口</h2>
<h3 id="编码器接口简介">编码器接口简介</h3>
<p>Encoder Interface - 编码器接口</p>
<p>编码器接口可接收增量(正交编码器)的信号，根据编码器旋转产生的正交信号脉冲，自动控制<code>CNT</code>自增或自减，从而指示编码器的位置、<strong>旋转方向和旋转速度</strong></p>
<ul>
<li>
<p>每个高级定时器和通用定时器都拥有1个编码器接口，基本定时器没有编码器接口</p>
</li>
<li>
<p>两个输入引脚(CH1、CH2)借用了输入捕获通道的<code>通道1</code>和<code>通道2</code></p>
</li>
</ul>
<blockquote>
<p>之前我们使用了编码器中断来手动计次，使用编码器接口可以实现自动计次，减少资源浪费，避免频繁中断</p>
</blockquote>
<h3 id="正交编码器介绍">正交编码器介绍</h3>
<p>拥有A相和B相，输出的两个<code>正交方波信号</code>，相位相差90°，超前90°和滞后90°代表正传和反转。</p>
<p>编码器测速使用的是<code>测频法</code>测量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/10-173752975558414.png" alt="image-20241126213304783"></p>
<blockquote>
<p><code>编码器的上升沿和下降沿都有效</code></p>
<p>正传CNT自增</p>
<p>反转CNT自减</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/12-173752975558415.png" alt="image-20241126222220541"></p>
<blockquote>
<p><strong>三种工作方式</strong>：</p>
<p>1.仅在T1计数</p>
<p>2.仅在T2计数</p>
<p>3.在T1和T2都计数</p>
<p><code>一般我们使用第三种</code></p>
<p><strong>编码器接口执行逻辑总结下来就一句话</strong>：</p>
<p>正转的时候向上计数，反转的时候向下计数</p>
</blockquote>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/13-173752975558416.png" alt="image-20241126222801623"></p>
<blockquote>
<p><code>正交编码器是抗噪声的原理</code>：</p>
<p>当遇到毛刺现象时，CNT的值会来回跳动，一会自增一会自减，但最终的值保持不变。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/14-173752975558417.png" alt="image-20241126223216790"></p>
<blockquote>
<p>当TI极性选择反相时，需要将图中TI的波形反向后才能得到正确的计数方向。</p>
<p>当我实际使用过程中如果出现想要正传计数+1，但是却出现-1的情况，我们把任意一个引脚极性反相，就能反转计数方向了。或者直接交换A、B相引脚即可</p>
</blockquote>
<h3 id="应用">应用</h3>
<p>比较常见的应用场景：</p>
<p>编码器测速一般应用在电机控制的项目上，使用PWM驱动电机，再使用编码器测量电机的速度，然后再用PID算法进行闭环控制。</p>
<p>一般电机旋转速度较高，会使用无接触式的霍尔传感器或者光栅进行测速。</p>
<p>这里为了方便，我们使用触点式的旋转编码器。电机旋转呢，我们就用人工旋转来模拟，但实际上旋转编码器和电机的霍尔，光栅编码器都是一样的效果</p>
<h3 id="编码器接口基本结构图">编码器接口基本结构图</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/11-173752975558418.png" alt="image-20241126221118178"></p>
<blockquote>
<p>对应CH1的TI1FP1和CH2的TI2FP2，与CH3和CH4无关。</p>
<p>ARR是有效的，一般设置为65535，利用补码的特性可以CNT从0自减时得到的是65535、65534…</p>
<p><code>编码器的时钟会直接托管驱动计数器，所以在编码器接口模式下时基单元不需要配置内部时钟并且计数模式无效</code></p>
<hr>
<p><code>同时输入捕获单元并没有完全使用，只需要配置滤波器和极性选择即可</code></p>
</blockquote>
<p><code>更多内容可以在参考手册中的TIM编码器接口模式中查看</code></p>
<h3 id="库函数-5">库函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_EncoderInterfaceConfig</span></span><br><span class="line"><span class="params">(TIM_TypeDef* TIMx,</span></span><br><span class="line"><span class="params"> <span class="type">uint16_t</span> TIM_EncoderMode,</span></span><br><span class="line"><span class="params"> <span class="type">uint16_t</span> TIM_IC1Polarity, </span></span><br><span class="line"><span class="params"> <span class="type">uint16_t</span> TIM_IC2Polarity)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**配置编码器接口的函数</span></span><br><span class="line"><span class="comment"> * 参数1：哪个定时器</span></span><br><span class="line"><span class="comment"> * 参数2：编码器模式,三种：1.仅在T1计数 2.仅在TI2计数 3.T1和T2都计数</span></span><br><span class="line"><span class="comment"> * 一般我们使用第三种T1,T2都计数</span></span><br><span class="line"><span class="comment"> * 参数3：通道1极性,Rising为不反相，Falling为反相</span></span><br><span class="line"><span class="comment"> * 参数4：通道2极性,Rising为不反相，Falling为反相</span></span><br><span class="line"><span class="comment"> * 参数3和参数4根据实际情况选择</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="编码器接口配置流程">编码器接口配置流程</h3>
<ol>
<li>
<p><strong>RCC开启时钟，开启GPIO和对应TIM的时钟</strong></p>
</li>
<li>
<p><strong>配置GPIO，将对应引脚配置为输入模式</strong></p>
</li>
<li>
<p><strong>配置时基单元，预分频器不分频，ARR设置为65535</strong>(不用配置时基单元的内部时钟，编码器会托管相当于外部时钟)</p>
</li>
<li>
<p><strong>配置输入捕获单元，此处输入捕获单元只有滤波器和极性两个参数有用，其他参数没用到</strong></p>
</li>
<li>
<p><strong>配置编码器接口模式</strong></p>
</li>
<li>
<p><strong>运行控制，启动定时器</strong></p>
</li>
</ol>
<blockquote>
<p>初始化完成后，CNT就会随着编码器旋转而自增自减。</p>
<p>如果想要读出编码器位置，直接读出CNT的值就行了</p>
<p>如果想要测量编码器的速度和方向，就需要每隔一定阀门时间，取出一次CNT，然后再把CNT清零，即<code>测频法</code>测量速度</p>
</blockquote>
<h3 id="实验-正交编码器测速">实验-正交编码器测速</h3>
<p>我们使用的是A相：PA8，B相PA9，对应定时器TIM1_CH1和TIM1_CH2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Encoder.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ENCODER_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ENCODER_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Encoder.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	  <span class="comment">//1.配置RCC，开启GPIO和对应TIM </span></span><br><span class="line">		RCC_APB1PeriphClockCmd(RCC_APB2Periph_TIM1,ENABLE);</span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">    </span><br><span class="line">	  <span class="comment">//2.GPIO端口配置，配置A，B相端口为输入</span></span><br><span class="line">	  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_8 | GPIO_Pin_9;</span><br><span class="line">	  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//	  TIM_InternalClockConfig(TIM1); </span></span><br><span class="line">	  <span class="comment">/*编码器接口就不用这个，因为编码器接口就是一个带方向控制的外部时钟，内部时钟没有用了*/</span></span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">//3.时基单元配置</span></span><br><span class="line">		TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//参数无效，编码器托管</span></span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>;<span class="comment">//ARR</span></span><br><span class="line">		TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span><span class="number">-1</span>;<span class="comment">//不分频，编码器的时钟直接驱动计数器</span></span><br><span class="line">	  TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span> ;</span><br><span class="line">		TIM_TimeBaseInit(TIM1,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">//4.输入捕获单元配置</span></span><br><span class="line">	  TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">		TIM_ICStructInit(&amp;TIM_ICInitStructure);<span class="comment">//部分参数未使用，调用该函数防止未初始化参数产生影响</span></span><br><span class="line">		TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; </span><br><span class="line">	  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; </span><br><span class="line">		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//编码器上升沿和下降沿都有效，所以此处代表极性不反转</span></span><br><span class="line">	  TIM_ICInit(TIM1,&amp;TIM_ICInitStructure);</span><br><span class="line">		 </span><br><span class="line">		TIM_ICInitStructure.TIM_Channel = TIM_Channel_2; </span><br><span class="line">	  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; </span><br><span class="line">		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//编码器上升沿和下降沿都有效，所以此处代表极性不反转</span></span><br><span class="line">    TIM_ICInit(TIM1,&amp;TIM_ICInitStructure);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5.编码器接口配置</span></span><br><span class="line">		TIM_EncoderInterfaceConfig(TIM1,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);<span class="comment">//这里的极性与上方极性配置的同一个寄存器，可以删除上方极性配置</span></span><br><span class="line">    <span class="comment">//6.运行控制TIM使能</span></span><br><span class="line">		TIM_Cmd(TIM1,ENABLE);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int16_t</span> speed = TIM_GetCounter(TIM1);</span><br><span class="line">	TIM_SetCounter(TIM1,<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> speed;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*放到缓存的speed当中，再清零CNT即可，最终在主循环中实现延时即可*/</span></span><br><span class="line"></span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Encoder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		 OLED_Init();</span><br><span class="line">		 Encoder_Init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>,<span class="number">5</span>,Encoder_Get(),<span class="number">5</span>);</span><br><span class="line">        Delay_ms(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">/*1s测一次速*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果实现效果与想要的不符合，修改编码器接口配置中任意一个引脚的极性参数即可</p>
<p><code>此处在循环中使用了Delay函数，影响了效率，更加好的办法是开启一个1s的定时器中断，在定时器中断中更新speed的值即可</code></p>
</blockquote>
<h1>ADC</h1>
<h2 id="ADC简介">ADC简介</h2>
<p>ADC(Analog-Digital Converter)模拟-数字转换器</p>
<p>ADC可以将引脚上连续变化的模拟电压转换为内存中储存的数字变量，建立模拟电路到数字电路的桥梁</p>
<p>12位逐次逼近型ADC，1us的转换时间(ADC转化频率为1MHz)</p>
<p><strong>输入电压范围：0~3.3V，转化结果范围：0~4095(2的12次方)</strong></p>
<p>一共<code>18个输入通道</code>，可测量<code>16个外部信号</code>和<code>2个内部信号源</code><strong>(内部温度传感器和内部参考电压，不随外部电压变化)</strong></p>
<p>分为<code>规则组(规则通道)</code>和<code>注入组(注入通道)</code>两个转换单元</p>
<p>可模拟看门狗自动监测输入电压范围</p>
<p>STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p>
<p><code> 对应所有的知识都能在芯片参考手册中查看</code></p>
<h2 id="ADC内部结构">ADC内部结构</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/15-173752975558419.png" alt="image-20241127201536862"></p>
<blockquote>
<p>逐次逼近型通过二分法给DAC值进行比较，直到找到未知电压编码</p>
<p>比如8位：0~255，先给128，再给64…相当于二进制的高位到低位</p>
<p>对于8位ADC，高位到低位判断8次即可找到位置电压编码</p>
<p>对于12位ADC，高位到低位判断12次即可找到位置电压编码</p>
</blockquote>
<hr>
<p><code>STM32的ADC</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/16-173752975558420.png" alt="image-20241127202456782"></p>
<blockquote>
<p>ADCx_IN0~15 就是对应的16个外部信号</p>
<p>温度传感器和Vrefint就是内部2个信号源</p>
<hr>
<p>通道分为<strong>注入通道(注入组)<strong>和</strong>规则通道(规则组)</strong></p>
<p><code>规则通道</code>：可以同时转选择16个通道，但是对于转化结果，因为<strong>规则通道只有一个数据寄存器</strong>，所以存在<code>数据覆盖问题</code>。如果不想结果被覆盖，需要在转换完成后尽快把数据拿走。此时一般配合DMA进行搬运</p>
<p><code>注入通道</code>：可以同时选择4个通道，拥有四个数据寄存器，不用担心数据被覆盖</p>
<p><code>对应规则通道和注入通道可以在参考手册中找到对应介绍</code></p>
<hr>
<p><code>流程</code>：</p>
<p>前面的通道选择后到模拟至数字转换器，</p>
<p>然后模拟至数字转换器中就执行逐次比较的过程，最终结果放在了注入通道/规则通道数据寄存器中。</p>
<p><strong>转换结束后会有一个EOC信号，该信号是规则组或注入组的完成信号，还有个JEOC是注入组完成的信号，会置状态寄存器标志位，可以读取该标志位判断是否转换完成</strong></p>
<p><strong>同时这两个标志位也可以去到NVIC申请中断，如果开启对应NVIC通道就可以触发中断</strong></p>
</blockquote>
<hr>
<p><strong>触发转换部分</strong>：对应START信号启动ADC的转换</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/17-173752975558421.png" alt="image-20241127203720470"></p>
<blockquote>
<p>对应STM32ADC，触发ADC开始转换的信号有两种：<code>软件触发</code>和<code>硬件触发</code></p>
<p><code>硬件触发</code>：对应图中注入组的触发源和规则组的触发源，主要来自<strong>定时器</strong>，在定时器章节中我们知道，定时器可以通向ADC、DAC外设，用于触发转换。也可以使用<strong>外部中断引脚</strong>触发</p>
<p>比如图中我们给TIM3指定1ms时间，将TIM3的更新事件选择为TIM3_TRGO输出，再把ADC选择开始触发信号为TIM3_TRGO，这样TIM3的更新事件就能通过硬件自动触发ADC转换了，不需要进中断</p>
<p><code>软件触发</code>：程序中调用代码完成ADC转换触发。</p>
</blockquote>
<hr>
<p><code>ADC时钟</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/18-173752975558422.png" alt="image-20241127204615868"></p>
<blockquote>
<p>ADC时钟来自RCC，经过ADC预分频器到达，注意此处最大位14MHz，2分频和4分频结果超过了最大值，不建议使用，这里<strong>至少6分频</strong></p>
<p>ADC预分频器小于14MHz即可</p>
</blockquote>
<p><code>模拟看门狗</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/19-173752975558424.png" alt="image-20241127204756265"></p>
<blockquote>
<p><strong>模拟看门狗用于监测转换结果的范围</strong>，其中可以存一个阈值高限和阈值低限，如果启动了看门狗并且设定了通道，该看门狗就会关注看门的通道，一旦超过阈值范围就可以申请一个通向NVIC的ADC中断。</p>
</blockquote>
<h2 id="ADC输入通道">ADC输入通道</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/21-173752975558423.png" alt="image-20241127210445125"></p>
<blockquote>
<p>我们可以在引脚定义表中找到对应ADC通道0~9的通道对应引脚，这代表该芯片只有10个通道</p>
<p>同时我们可以发现ADC12_INx 这样写代表ADC1和ADC2都是这个引脚。我们可以单独使用一个ADC，也可以同时使用。</p>
<p><strong>ADC还有一种高级模式叫双ADC模式，就是ADC1和ADC2一起配贼和使用，可以配合组成同步、交叉模式等，可以进一步提高采样率</strong></p>
</blockquote>
<h2 id="ADC转换模式">ADC转换模式</h2>
<p><strong>一共有四种转换方式：多通道只能使用后面两种模式，必须开启扫描模式</strong></p>
<ol>
<li><code>单次转换，非扫描模式</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/22-173752975558525.png" alt="image-20241127211229845"></p>
<blockquote>
<p>只会转换第一个序列的通道，每次转换都需要触发一次</p>
<p>想要更换通道转换只需要更改序列1的通道即可</p>
</blockquote>
<ol start="2">
<li><code>连续转换，非扫描模式</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/23-173752975558526.png" alt="image-20241127211310674"></p>
<blockquote>
<p>只会转换第一个序列的通道，但触发转换后不会停止，会一直持续转换。只需要第一次触发即可</p>
</blockquote>
<ol start="3">
<li><code>单次转换，扫描模式</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/24-173752975558527.png" alt="image-20241127211656061"></p>
<blockquote>
<p><strong>按顺序依次转换一组通道</strong>，可以指定通道数目，指定的所有通道转换完成后才会触发EOC信号。每次转换都需要触发</p>
</blockquote>
<ol start="4">
<li><code>连续转换，扫描模式</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/25-173752975558528.png" alt="image-20241127211932067"></p>
<blockquote>
<p><strong>按顺序依次转换一组通道</strong>，可以指定通道数目，指定的所有通道转换完成后才会触发EOC信号。只需要一次触发就可以一直转换</p>
</blockquote>
<p><code>其实还有个间断模式</code>：可以说是对扫描模式的补充</p>
<blockquote>
<p>触发一次，转换一个通道，在触发，在转换。在所选转换通道循环，**由触发信号启动新一轮的转换，直到转换完成为止。**例如：可以把0,1,4,5这四个通道进行分组。可以分成0,1一组，4,5一组。也可以每个通道单独配置为一组。这样每一组转换之前都需要先触发一次。</p>
</blockquote>
<h2 id="ADC触发控制">ADC触发控制</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/26-173752975558529.png" alt="image-20241127212108346"></p>
<h2 id="ADC数据对齐">ADC数据对齐</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/27-173752975558531.png" alt="image-20241127212138053"></p>
<blockquote>
<p>寄存器总共16位需要对齐，高位或低位补0</p>
<p><strong>一般使用右对齐，可以直接读取寄存器就是结果</strong></p>
<p>左对齐得到的结果比实际值偏大16倍，对于裁剪分辨率使用</p>
</blockquote>
<h2 id="ADC转换时间">ADC转换时间</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/28-173752975558530.png" alt="image-20241127212422377"></p>
<blockquote>
<p><code>量化、编码</code>：就是ADC逐次比较的过程，位数越多花费时间越长</p>
<p><code>采样、保持</code>：量化编码需要时间，通过开启采样开关，一段时间后断开后使电压在量化编码时保持不变</p>
<hr>
<p><strong>ADC总转换时间中</strong>：</p>
<p><code>采样时间：</code>就是采样保持时间，采样时间可以在程序中配置，时间越长越能避免毛刺信号的干扰，但会导致转换时间延长。</p>
<p><code>12.5个ADC周期：</code>量化编码所花费时间，因为是12位，所以需要12个周期，多余的0.5周期可能做了一些其他事情</p>
<p>14个周期：14/14MHz = 1μs</p>
<hr>
<p><code>采样时间选择</code>：</p>
<p><strong>需要更快的转换，就选小的参数，但容易受干扰</strong></p>
<p><strong>需要更稳定的转换，就选大的参数，转换时间长</strong></p>
</blockquote>
<h2 id="ADC校准">ADC校准</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/29-173752975558532.png" alt="image-20241127220041612"></p>
<blockquote>
<p><strong>校准过程我们不需要理解，校准过程固定，只需要在ADC初始化的最后，加几行代码就行了，至于怎么计算、怎么校准的，我们不需要管</strong></p>
<hr>
<p><strong>流程</strong>：</p>
<p><code>复位校准</code>-<code>等待复位校准(判断标志位)</code>-<code>开始校准</code>-<code>等待校准(判断标志位)</code></p>
</blockquote>
<h2 id="硬件电路">硬件电路</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/30-173752975558533.png" alt="image-20241127220346370"></p>
<blockquote>
<p>第一个是电位器产生可调电路，通过滑动变阻器可以调节电压0~3.3V</p>
<hr>
<p>第二个是传感器输出电压电路，光敏电阻、热敏电阻等都可等效为一个可变电阻，电阻阻值没法直接测量，<strong>一般直接通过和一个固定电阻串联分压来得到反应电阻值电压</strong>的电路。</p>
<p><code>固定电阻一般可以选择和传感器阻值相近的电阻较好</code></p>
<p>传感器阻值变小时，下拉作用变强，输出端电压就下降，传感器阻值变大时，下拉作用变弱，输出端受上拉作用电压就会升高</p>
<hr>
<p>第三个是一个简易电压转换电路，使用电阻分压。根据分压公式可以得到中间的电压位(VIN/50K) * 33K，高电压一般不适用比较危险，高电压一般使用一些采集芯片，做好高低电压的隔离</p>
</blockquote>
<h2 id="ADC基本结构图">ADC基本结构图</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/20-173752975558534.png" alt="image-20241127205844255"></p>
<h2 id="库函数-6">库函数</h2>
<p><code>配置ADCCLK分频器</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_ADCCLKConfig</span><span class="params">(<span class="type">uint32_t</span> RCC_PCLK2)</span>;</span><br><span class="line"><span class="comment">/*在stm32f10x_rcc.h中可以找到，该函数用于配置ADCCLK分频器，可以对APB2的72MHz时钟选择2、4、6、8分频，输入到ADCCLK*/</span></span><br></pre></td></tr></table></figure>
<p><code>ADC初始化:stm32f10x_adc.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_DeInit</span><span class="params">(ADC_TypeDef* ADCx)</span>;<span class="comment">//恢复缺省配置</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Init</span><span class="params">(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_StructInit</span><span class="params">(ADC_InitTypeDef* ADC_InitStruct)</span>;</span><br></pre></td></tr></table></figure>
<p><code>ADC启动</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_Cmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;<span class="comment">//开启ADC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DMACmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;<span class="comment">//开启DMA输出信号，使用DMA需要调用</span></span><br></pre></td></tr></table></figure>
<p><code>ADC通道配置</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_RegularChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel, <span class="type">uint8_t</span> Rank, <span class="type">uint8_t</span> ADC_SampleTime)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 规则组通道配置，为序列添加通道</span></span><br><span class="line"><span class="comment"> * 参数1：对应ADC</span></span><br><span class="line"><span class="comment"> * 参数2：指定ADC通道</span></span><br><span class="line"><span class="comment"> * 参数3：对应序列号</span></span><br><span class="line"><span class="comment"> * 参数4：指定通道采样时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多个通道指定时，多次调用该函数配置即可</span></span><br></pre></td></tr></table></figure>
<p><code>ADC外部触发转换控制</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*是否允许外部触发转换*/</span></span><br></pre></td></tr></table></figure>
<p><code>ADC中断</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_ITConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*用于控制某个中断，能否通往NVIC*/</span></span><br></pre></td></tr></table></figure>
<p><code>ADC控制校准：在ADC初始化完成后依次调用即可</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_ResetCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*复位校准*/</span></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetResetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*获取复位校准状态*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_StartCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*开始校准*/</span></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*获取开始校准复位状态*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>ADC触发控制</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_SoftwareStartConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*ADC软件触发控制，调用即可设置为软件触发*/</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetSoftwareStartConvStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*ADC获取软件开始转换状态，返回SWSTART状态，与转换是否结束无关，一般不适用*/</span></span><br></pre></td></tr></table></figure>
<p><code>ADC间断模式配置</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_DiscModeChannelCountConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> Number)</span>;</span><br><span class="line"><span class="comment">/*ADC间断模式配置，设置Number可以设置每隔几个通道间断一次*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DiscModeCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*使能间断模式*/</span></span><br></pre></td></tr></table></figure>
<p><code>ADC转换结束判断</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">ADC_GetFlagStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;</span><br><span class="line"><span class="comment">/*参数给EOC标志位可以判断是否转换完成*/</span></span><br></pre></td></tr></table></figure>
<p><code>ADC获取转换值</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetConversionValue</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">//获取AD转换数据寄存器，读取转换结果</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ADC_GetDualModeConversionValue</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//双ADC模式读取转换结果</span></span><br></pre></td></tr></table></figure>
<p><code>ADC注入组</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_AutoInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedDiscModeCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigInjectedConvConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint32_t</span> ADC_ExternalTrigInjecConv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_SoftwareStartInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line">FlagStatus <span class="title function_">ADC_GetSoftwareStartInjectedConvCmdStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel, <span class="type">uint8_t</span> Rank, <span class="type">uint8_t</span> ADC_SampleTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedSequencerLengthConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_SetInjectedOffset</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_InjectedChannel, <span class="type">uint16_t</span> Offset)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetInjectedConversionValue</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_InjectedChannel)</span>;</span><br></pre></td></tr></table></figure>
<p><code>ADC模拟看门狗</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogCmd</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint32_t</span> ADC_AnalogWatchdog)</span>;</span><br><span class="line"><span class="comment">/*是否启动看门狗*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogThresholdsConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> HighThreshold, <span class="type">uint16_t</span> LowThreshold)</span>;</span><br><span class="line"><span class="comment">/*配置看门狗高低阈值*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogSingleChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel)</span>;</span><br><span class="line"><span class="comment">/*配置看门通道*/</span></span><br></pre></td></tr></table></figure>
<p><code>ADC内部信号配置</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_TempSensorVrefintCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*ADC温度传感器，内部参考电压控制，用于开启内部两个通道，需要使用时调用开启即可*/</span></span><br></pre></td></tr></table></figure>
<p><code>ADC标志位</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">ADC_GetFlagStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ClearFlag</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;</span><br><span class="line"></span><br><span class="line">ITStatus <span class="title function_">ADC_GetITStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ClearITPendingBit</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT)</span>;</span><br><span class="line"><span class="comment">//常用的标志位相关函数，带IT的应该在中断服务函数中使用</span></span><br></pre></td></tr></table></figure>
<h2 id="ADC配置流程">ADC配置流程</h2>
<p>打通上方ADC基本结构图即可：</p>
<ol>
<li>
<p><strong>RCC开启时钟，开启ADC和GPIO时钟，配置ADCCLK分频器</strong></p>
</li>
<li>
<p><strong>配置GPIO，配置对应GPIO为<code>模拟输入</code>的模式</strong></p>
</li>
<li>
<p><strong>配置多路开关，将左边对应通道接入规则组/注入组中(规则/注入通道配置)</strong></p>
</li>
<li>
<p><strong>配置ADC转换器，结构体(单次转换/连续转换、扫描/非扫描，几个通道等)</strong></p>
</li>
<li>
<p>如果需要模拟看门狗，配置阈值和监测通道，没有就跳过</p>
</li>
<li>
<p>如果想要使用中断，使用ADITConfig开启对应中断输出，配置NVIC即可，没有跳过</p>
</li>
<li>
<p><strong>开启ADC，调用ADC_Cmd函数</strong></p>
</li>
<li>
<p><strong>校准ADC，减小误差</strong></p>
</li>
</ol>
<h2 id="实验-ADC读取电位器电压-ADC单通道">实验-ADC读取电位器电压(ADC单通道)</h2>
<p>对应引脚定义可知电位器PA5对应通道为ADC_IN5，选择ADC_Channel_5即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*AD.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __AD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __AD_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetValue</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*AD.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1.开启RCC时钟，ADC和GPIO</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.ADC预分频器配置，72Mhz / 6 =12Mhz，不能超过14Mhz，至少6分频</span></span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.GPIO配置为模拟输入</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4.规则通道配置,将通道5写入规则通道的第一个位置(序列1)</span></span><br><span class="line">  ADC_RegularChannelConfig(ADC1,ADC_Channel_5,<span class="number">1</span>,ADC_SampleTime_239Cycles5);</span><br><span class="line"><span class="comment">//	ADC_RegularChannelConfig(ADC1,ADC_Channel_1,2,ADC_SampleTime_55Cycles5); 如果还有其他通道，继续调用配置即可</span></span><br><span class="line"><span class="comment">//	ADC_RegularChannelConfig(ADC1,ADC_Channel_2,3,ADC_SampleTime_239Cycles5); 如果还有其他通道，继续调用配置即可</span></span><br><span class="line">	<span class="comment">//5.ADC转换器配置</span></span><br><span class="line">	ADC_InitTypeDef ADC_InitStruct;</span><br><span class="line">	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; <span class="comment">//ADC转换模式，该参数为独立ADC工作，剩余的其他参数都是双ADC模式</span></span><br><span class="line">	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;<span class="comment">//数据右对齐</span></span><br><span class="line">	ADC_InitStruct.ADC_ExternalTrigConv =ADC_ExternalTrigConv_None;<span class="comment">//这里选择软件触发，剩下的都为硬件触发</span></span><br><span class="line">	ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;<span class="comment">//启动连续转换模式</span></span><br><span class="line">	ADC_InitStruct.ADC_ScanConvMode = DISABLE;<span class="comment">//是否启动扫描模式</span></span><br><span class="line">	ADC_InitStruct.ADC_NbrOfChannel = <span class="number">1</span>; <span class="comment">// 指定扫描模式下总共使用的通道数</span></span><br><span class="line">	ADC_Init(ADC1,&amp;ADC_InitStruct);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">//5.开启ADC</span></span><br><span class="line">	ADC_Cmd(ADC1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//6.ADC校准</span></span><br><span class="line">	ADC_ResetCalibration(ADC1);<span class="comment">//复位校准</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1)== SET)&#123;&#125;;<span class="comment">//RSTCAL寄存器由软件置1后开始复位校准，完成后硬件自动清0该位</span></span><br><span class="line">	ADC_StartCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET)&#123;&#125;;<span class="comment">//CAL寄存器由软件置1后开始校准，校准结束后硬件自动清0该位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ADC_SoftwareStartConvCmd(ADC1, ENABLE);在启动连续转换模式时，只需要在这里触发转换一次即可，不需要每次获取值都调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  获取ADC值流程：</span></span><br><span class="line"><span class="comment">	 *  1.触发转换</span></span><br><span class="line"><span class="comment">	 *  2.判断标志位等待转换完成</span></span><br><span class="line"><span class="comment">	 *  3.读取转换结果</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.触发转换,上面没开启连续转换模式，开启连续转换模式只需要启动一次即可</span></span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1, ENABLE);<span class="comment">//启动软件触发转换,也可以使用硬件触发</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2.判断标志位,等待转换完成</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC) == RESET)&#123;&#125;;<span class="comment">//在手册中有介绍，转换完成前为0，转换完成后自动置1</span></span><br><span class="line">		<span class="comment">/*等待转换时间为上面设置的采样周期，239+12.5=251.5个周期，时间为251.5/12Mhz=20.9us*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.读取转换结果</span></span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC1);<span class="comment">//读取DR寄存器时自动清除EOC位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"><span class="type">float</span> Voltage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">		 OLED_Init();</span><br><span class="line">		 AD_Init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="type">uint16_t</span> adValue = ADC_GetValue();</span><br><span class="line">		Voltage = (<span class="type">float</span>)adValue / <span class="number">4095</span> * <span class="number">3.3</span>;<span class="comment">//根据精度对应计算出电压值</span></span><br><span class="line">		OLED_ShowNum(<span class="number">5</span>,<span class="number">5</span>,adValue,<span class="number">4</span>);</span><br><span class="line">		OLED_ShowNum(<span class="number">10</span>,<span class="number">5</span>,Voltage,<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意实验中OLED得到的AD值末尾持续抖动，这是正常波动</p>
<p><strong>但是如果我们需要对该AD值进行判断，再执行一些操作时，比如AD值大于某一值开灯，小于某一值就关灯。此时由于AD值存在波动就可能会来回开灯关灯。</strong></p>
<p><code>解决方法</code>：</p>
<ol>
<li><strong>使用迟滞比较法，设置上下阈值，高于上阈值开灯，低于下阈值关灯，类似于施密特触发器</strong></li>
<li><strong>如果数据跳变太厉害，可以使用均值滤波的方式，读取10~20个值取平均值作为输出结果</strong></li>
<li><strong>还可以裁剪分辨率去掉数据的尾数，也可以避免跳动</strong></li>
</ol>
</blockquote>
<h2 id="实验-ADC多通道采集">实验- ADC多通道采集</h2>
<blockquote>
<p>多通道采集，我们想到的是启动扫描模式，但是存在<code>数据覆盖</code>的问题。扫描模式是会一次将所有通道全部转换完之后才会发出EOC信号，每一个通道单独转换完成不会产生任何标志位，也不会有中断，同时AD转换很快，所以我们很难做到在一个通道转换完成后将数据手动转移。</p>
<p>但是很难不是不行，我们可以使用间断模式，扫描时没转换一个通道就暂停一次，我们此时可以转移数据，再继续触发，继续下一次转换。由于没有单个通道转换完成后没有标志位，我们只能通过Delay的方式延时等待转换时间，所以这种方式不推荐</p>
<p><strong>所以如果我们想用扫描模式实现多通道，最好配合DMA来实现</strong></p>
<p><code>扫描模式+DMA搬运实现ADC多通道采集见下一节DMA实验</code></p>
</blockquote>
<p>其实我们可以使用<strong>单次转换非扫描模式</strong>实现，只需要为AD_GetValue添加一个ADC_Channel的参数，调用时都重新配置规则通道再触发转换即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    adValue1 = ADC_GetValue(ADC_Channel_0);</span><br><span class="line">    adValue2 = ADC_GetValue(ADC_Channel_1);</span><br><span class="line">    adValue3 = ADC_GetValue(ADC_Channel_2);</span><br><span class="line">    adValue4 = ADC_GetValue(ADC_Channel_3);</span><br><span class="line">    Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>DMA</h1>
<h2 id="DMA简介">DMA简介</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/31-173752975558535.png" alt="image-20241128195544055"></p>
<blockquote>
<p><strong>DMA-直接内存访问，是一个数据转运小助手，主要是协助CPU完成数据转运的工作，无须CPU干预，CPU就可以干其他更重要的事</strong></p>
<p>这里的<code>外设</code>一般指<code>外设数据寄存器</code>，<code>存储器</code>一般指<code>运行内存SRAM和程序存储器</code>(存储变量数组和程序代码的地方)</p>
<hr>
<p><strong>存储器到存储器</strong>的数据转运，一般使用<code>软件触发</code>，比如从FLASH到SRAM，因为软件触发是以最快的方式一股脑搬运过去，越快越好</p>
<p><strong>存储器到外设</strong>的数据转运，一般使用<code>特定硬件触发</code>(每个外设对应DMA通道)，比如ADC一个通道转换完成后，硬件触发一次DMA，DMA再转运。这样得到的值才正确</p>
</blockquote>
<blockquote>
<p><code>常见的用途：</code></p>
<ul>
<li><strong>最常见：配合ADC的扫描模式，解决ADC数据覆盖问题</strong></li>
<li><strong>各外设提高效率</strong></li>
</ul>
</blockquote>
<p><code>阅读参考手册获得所有介绍!!!</code></p>
<h2 id="STM32存储器映像">STM32存储器映像</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/32-173752975558536.png" alt="image-20241128201135199"></p>
<blockquote>
<p><code>FLASH：</code>存放我们编译后的程序以及常量数据(const等)</p>
<p><code>SRAM：</code>程序的临时变量存储，变量地址都是以20开头</p>
<p><code>外设寄存器：</code>对应每个外设的寄存器</p>
<p><code>内核外设</code>：<strong>只有NVIC和Systick</strong>，与其他外设不是一个厂家设计的，所以地址被分开了</p>
<hr>
<p><code>1.在STM32的数据手册，也会有个存储器映像的图,里面可以查看各外设起始地址等</code></p>
<p><code>2.在对应代码的宏定义不断跳转我们可以看到定义的SRAM、外设等基地址也是上表中给出的地址，通过基地址+偏移量可以得到各外设地址等</code></p>
</blockquote>
<h2 id="DMA框图">DMA框图</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241129210721223-173752975558537.png" alt="image-20241129210721223"></p>
<p><strong>主要包括</strong>：</p>
<ul>
<li>
<p><strong>用于访问各个存储器的DMA总线</strong></p>
</li>
<li>
<p><strong>内部的多个通道，可以进行独立的数据转运</strong></p>
</li>
<li>
<p><strong>仲裁器，用于调度各个通道，防止产生冲突</strong></p>
</li>
<li>
<p><strong>AHB从设备：是DMA自身的寄存器，用于配置DMA参数</strong></p>
</li>
<li>
<p><strong>DMA请求，用于硬件触发DMA的数据转运</strong></p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/34-173752975558538.png" alt="image-20241129204758768"></p>
<blockquote>
<p><code>寄存器：</code></p>
<p>各个外设都可以看成是寄存器，也是一种SRAM存储器，寄存器是一种特殊的存储器，一方面，CPU可以对寄存器进行读写，另一方面寄存器的每一位背后，都连接了一个线，这些线可以用于控制外设电路的状态，比如设置引脚高低电平，导通和断开开关等，或者多位组合起来当做计数器、数据寄存器等</p>
<p>寄存器是连接软件和硬件的桥梁，软件读写寄存器就相当在控制硬件的执行</p>
<hr>
<p>外设寄存器，有些是只读的，有些是可读可写的，具体看参考手册上的介绍</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241129205958030-173752975558539.png" alt="image-20241129205958030"></p>
<blockquote>
<p><code>DMA请求：</code></p>
<p>请求就是触发的意思，DMA请求线路的触发源是各个外设，DMA请求就是DMA的硬件触发源，比如ADC转换完成、串口接收到数据时，需要触发DMA转运数据时，就会通过这条线路向DMA发出硬件触发信号，之后DMA就可以在执行数据转运的工作了。</p>
</blockquote>
<blockquote>
<p><code>FLASH :</code></p>
<p>这里是ROM只读存储器的一种，如果通过总线直接访问，无论是CPU还是DMA都是只读的，如果DMA转运的目的地址填写的是FLASH就会出错。</p>
<p><code>SRAM:</code>可以任意读写</p>
</blockquote>
<h2 id="DMA-基本结构图">DMA 基本结构图</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241129213600867-173752975558540.png" alt="image-20241129213600867"></p>
<blockquote>
<p><code>图中所有参数都是使用结构体配置</code></p>
<p>有个方向控制的参数可以控制外设寄存器到存储器的方向</p>
<p>外设寄存器和存储器(Flash、SRAM)都有三个参数：</p>
<ol>
<li>起始地址</li>
<li>数据宽度</li>
<li>地址是否自增</li>
</ol>
<hr>
<p><code>传输计数器：</code>用于指定转运次数，是一个自建计数器，每转运一次，值减1，直到减小到0之后DMA停止转运，对应自增过后的地址恢复到起始地址的位置，以方便DMA开始新一轮转换</p>
<p><strong>注意：不能在DMA开启时，写传输计数器，这是手册的规定！！！</strong></p>
<p><strong>需要写计数器时按照即可：DMA失能–写传输计数器–DMA使能</strong></p>
<p><code>自动重装器：</code>传输计数器减小到0之后是否需要恢复到最初的值，指定重装就是循环模式</p>
<hr>
<p><strong>触发控制</strong>：决定DMA什么时间进行转运，由M2M(Memory to Memory)参数决定软件触发还是硬件触发</p>
<p><code>软件触发：</code><strong>一般用于存储器到存储器的转运，这些转运不需要一定时机</strong>，参数<code>M2M为1时</code>为软件触发，并不是调用一个函数一次就触发一次，而是以最快的速度，连续不断的触发DMA，以最快速度将传输计数器减少到0，与外部中断和ADC的软件触发可能不太一样，可以理解为<strong>自动连续触发</strong></p>
<p><strong>软件触发和循环模式不能同时使用，因为软件触发是想把计数器清0，而循环模式会重载，DMA就停不下来了</strong></p>
<p><code>硬件触发：</code><strong>一般用于与外设有关的转运，转运需要一定时机当硬件达到这些时机时传一个信号，触发DMA进行转运，比如ADC转换完成等</strong>，<code>参数M2M为0</code>时为硬件触发，触发源可以选择ADC、串口、定时器等等</p>
<hr>
<p><code>开关控制</code>：</p>
<p>DMA_Cmd函数</p>
</blockquote>
<blockquote>
<p><code>DMA转运需要有三个条件：</code></p>
<ol>
<li>使能DMA，开关控制</li>
<li>传输计数器不为0</li>
<li>必须要有触发源</li>
</ol>
</blockquote>
<h2 id="DMA请求映像">DMA请求映像</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241129223925869-173752975558541.png" alt="image-20241129223925869"></p>
<blockquote>
<p>每个通道有一个数据选择器，选择硬件触发或者软件触发，EN位决定数据选择器是否工作</p>
<p><code>硬件触发注意</code>：<strong>M2M = 0</strong></p>
<p><strong>每个外设触发通道都不一样，所以我们在选择硬件触发源时，一定要先找到对应通道触发</strong>，比如ADC1在通道1，定时器更新事件(TIM2_UP)在通道2</p>
<p>对应的有ADC_DMACmd、TIM_DMACmd函数等</p>
<p><code>软件触发</code>：<strong>M2M = 1</strong></p>
<p><strong>DMA和通道任意选择，每个通道软件触发都是一样的</strong></p>
<hr>
<p><code>优先级:</code></p>
<p>类似与中断优先级判断，通道号越小优先级越高，也可在程序中配置</p>
</blockquote>
<h2 id="数据宽度与对齐">数据宽度与对齐</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241129224639834-173752975558542.png" alt="image-20241129224639834"></p>
<blockquote>
<p><code>源端宽度</code>和<code>目标宽度</code>相同时和不同时的数据传输处理：与变量赋值类似</p>
<p>源端宽度=目标宽度，不变</p>
<p>源端宽度&lt;目标宽度，高位补0</p>
<p>源端宽度&gt;目标宽度，高位舍弃</p>
</blockquote>
<h2 id="例子">例子</h2>
<h3 id="数据转运-DMA-存储器到存储器转运">数据转运+DMA(存储器到存储器转运)</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241129225329602-173752975558543.png" alt="image-20241129225329602"></p>
<blockquote>
<p>不需要转运时间同步等，使用软件触发即可</p>
</blockquote>
<h3 id="ADC扫描模式-DMA-外设到存储器">ADC扫描模式+DMA(外设到存储器)</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241129225519836-173752975558544.png" alt="image-20241129225519836"></p>
<blockquote>
<p>我们需要在每个单独的通道转换完成后，进行一个DMA转运，并且使目的地址自增，源地址不自增，方向为外设到存储器，传输计数器7次</p>
<p>ADC连续扫描，DMA可以使用自动重装，使ADC和DMA同时工作</p>
<p>DMA转运时机需要和ADC单个通道转换同步，所以DMA触发要选择ADC硬件触发。</p>
<p><strong>单个通道转换完成时应该可以触发DMA传输，否则无法完成</strong></p>
</blockquote>
<h2 id="库函数-7">库函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化相关函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_DeInit</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Init</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_StructInit</span><span class="params">(DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使能DMA对应通道,第一个参数不再是DMAx，而是DMAy_x,即选择了哪个DMA，又选择了DMA的通道，DMA几的通道几</span></span><br><span class="line"><span class="comment">  * 软件触发随意选择通道</span></span><br><span class="line"><span class="comment">  * 硬件触发，先查看手册找到对应外设的通道在设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Cmd</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA中断输出使能*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ITConfig</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="type">uint32_t</span> DMA_IT, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*传输计数器值设置和获取*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_SetCurrDataCounter</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="type">uint16_t</span> DataNumber)</span>; </span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">DMA_GetCurrDataCounter</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关函数*/</span></span><br><span class="line">FlagStatus <span class="title function_">DMA_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> DMAy_FLAG)</span>;<span class="comment">//获取标志位状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> DMAy_FLAG)</span>;<span class="comment">//清除标志位</span></span><br><span class="line">ITStatus <span class="title function_">DMA_GetITStatus</span><span class="params">(<span class="type">uint32_t</span> DMAy_IT)</span>;<span class="comment">//获取中断状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ClearITPendingBit</span><span class="params">(<span class="type">uint32_t</span> DMAy_IT)</span>;<span class="comment">//清除中断挂起位</span></span><br></pre></td></tr></table></figure>
<h2 id="DMA配置流程">DMA配置流程</h2>
<p><code>根据DMA基本结构图配置如下：</code></p>
<ol>
<li><strong>RCC开启DMA时钟</strong></li>
<li><strong>配置DMA，调用DMA_Init，初始化各个参数(外设和存储器站点的起始地址、数据宽度、地址是否自增、方向、传输计数器、是否需要自动重装、选择触发源等参数)</strong></li>
<li>如果需要DMA中断，调用DMA_ITConfig开启中断输出，配置NVIC各个参数，写好对应中断服务函数即可，<strong>不用中断可以直接跳过</strong></li>
<li><strong>DMA使能，DMA_Cmd函数(别忘了对应在外设XXX_DMACmd开启触发信号输出)</strong></li>
</ol>
<h2 id="实验-DMA数据转运-存储器到存储器">实验-DMA数据转运(存储器到存储器)</h2>
<p><code>DMA不涉及外围硬件电路，故.c/.h文件放在System文件夹中</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DMA.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DMA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DMA_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMAInit</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint32_t</span> Size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Transfer</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DMA.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> DMA_Size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMAInit</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint32_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1.RCC开启DMA时钟</span></span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.配置DMA</span></span><br><span class="line">	DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line">	DMA_InitStruct.DMA_PeripheralBaseAddr = AddrA;<span class="comment">//外设站点起始地址</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;	<span class="comment">//外设站点数据宽度,这里以字节传输</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Enable;<span class="comment">//地址是否自增(Increment)，这里启用</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryBaseAddr = AddrB;<span class="comment">//存储器站点起始地址</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;<span class="comment">//存储器站点数据宽度</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//地址是否自增</span></span><br><span class="line">	DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC ; <span class="comment">// 传输方向(direction),这里选择的是外设站点作为数据源</span></span><br><span class="line">	DMA_InitStruct.DMA_BufferSize = Size; <span class="comment">// 传输计数器的值,其实就是传输次数,一次传输上面设置的数据宽度的值</span></span><br><span class="line">	DMA_InitStruct.DMA_Mode = DMA_Mode_Normal; <span class="comment">// 传输模式，就是是否使用自动重装。Normal不重装，circular是循环重装</span></span><br><span class="line">	DMA_InitStruct.DMA_M2M = DMA_M2M_Enable; <span class="comment">//配置软件触发还是硬件触发位(0,1),Enable是软件触发</span></span><br><span class="line">	DMA_InitStruct.DMA_Priority = DMA_Priority_Medium; <span class="comment">// 配置优先级，选择中等</span></span><br><span class="line">	DMA_Init(DMA1_Channel1,&amp;DMA_InitStruct);<span class="comment">//软件触发使用任意通道都可</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.DMA使能</span></span><br><span class="line">	DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">	</span><br><span class="line">	DMA_Size = Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改传输计数器的值，使DMA能循环传输*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Transfer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">	DMA_SetCurrDataCounter(DMA1_Channel1,DMA_Size); </span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET)&#123;&#125;;<span class="comment">//等待转换完成</span></span><br><span class="line">	</span><br><span class="line">	DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DMA.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> DataA[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x04</span>&#125;;<span class="comment">//加上const发现存储在FLASH区</span></span><br><span class="line"><span class="type">uint8_t</span> DataB[] =  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		OLED_Init();</span><br><span class="line">		DMAInit((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		OLED_ShowString(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;DataA:&quot;</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataA,<span class="number">8</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">5</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">8</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">2</span>,<span class="number">11</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">		OLED_ShowString(<span class="number">3</span>,<span class="number">2</span>,<span class="string">&quot;DataB:&quot;</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">3</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataB,<span class="number">8</span>);</span><br><span class="line">	  	OLED_ShowHexNum(<span class="number">4</span>,<span class="number">2</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">5</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">8</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>,<span class="number">11</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="comment">//DataA[0]++;</span></span><br><span class="line">			<span class="comment">//DataA[1]++;</span></span><br><span class="line">			<span class="comment">//DataA[2]++;</span></span><br><span class="line">			<span class="comment">//DataA[3]++;</span></span><br><span class="line">			</span><br><span class="line">			OLED_ShowString(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;DataA:&quot;</span>);</span><br><span class="line"></span><br><span class="line">			OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">2</span>,<span class="number">5</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">2</span>,<span class="number">8</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">2</span>,<span class="number">11</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">      </span><br><span class="line">			Delay_ms(<span class="number">1000</span>);</span><br><span class="line">			</span><br><span class="line">			DMA_Transfer();</span><br><span class="line">			</span><br><span class="line">			OLED_ShowString(<span class="number">3</span>,<span class="number">2</span>,<span class="string">&quot;DataB:&quot;</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">4</span>,<span class="number">2</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">4</span>,<span class="number">5</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">4</span>,<span class="number">8</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">			OLED_ShowHexNum(<span class="number">4</span>,<span class="number">11</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">			</span><br><span class="line">			Delay_ms(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实验-DMA-ADC多通道采集">实验-DMA+ADC多通道采集</h2>
<p><code>ADC多通道(连续转换+扫描模式+DMA循环转移):</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*AD.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __AD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __AD_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> ADValue[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void ADC_GetValue();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> ADValue[<span class="number">2</span>];<span class="comment">//有几个通道的结果长度就设定为几</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1.开启RCC时钟，ADC和GPIO,以及DMA</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.ADC预分频器配置，72Mhz / 6 =12Mhz，不能超过14Mhz，至少6分频</span></span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.GPIO配置为模拟输入</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_4;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4.规则通道配置,将通道4,5,分贝写入规则通道的第一个位置和第二个位置(序列1，序列2)</span></span><br><span class="line">  ADC_RegularChannelConfig(ADC1,ADC_Channel_4,<span class="number">1</span>,ADC_SampleTime_239Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1,ADC_Channel_5,<span class="number">2</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line"><span class="comment">//  ADC_RegularChannelConfig(ADC1,ADC_Channel_6,3,ADC_SampleTime_55Cycles5); 	还有通道继续配置即可</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//5.ADC转换器配置</span></span><br><span class="line">	ADC_InitTypeDef ADC_InitStruct;</span><br><span class="line">	ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; <span class="comment">//ADC转换模式，该参数为独立ADC工作，剩余的其他参数都是双ADC模式</span></span><br><span class="line">	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;<span class="comment">//数据右对齐</span></span><br><span class="line">	ADC_InitStruct.ADC_ExternalTrigConv =ADC_ExternalTrigConv_None;<span class="comment">//这里选择软件触发，剩下的都为硬件触发</span></span><br><span class="line">	ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;<span class="comment">//启动连续转换模式</span></span><br><span class="line">	ADC_InitStruct.ADC_ScanConvMode = ENABLE;<span class="comment">//是否启动扫描模式,这里多通道启动</span></span><br><span class="line">	ADC_InitStruct.ADC_NbrOfChannel = <span class="number">2</span>; <span class="comment">// 指定扫描模式下总共使用的通道数，使用了几个通道就填几</span></span><br><span class="line">	ADC_Init(ADC1,&amp;ADC_InitStruct);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//6.配置DMA</span></span><br><span class="line">	DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line">	DMA_InitStruct.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//ADC1寄存器地址</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	<span class="comment">//ADC选择半字16位传输,对于12位，舍弃4位</span></span><br><span class="line">	DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增(Increment)，这里对同一个地方的值运输，不启用</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)ADValue;<span class="comment">//存放到SRAM中的数组中</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;<span class="comment">//以半字16位传输</span></span><br><span class="line">	DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//由于多个值，需要移动数组的地址，需要自增</span></span><br><span class="line">	DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC ; <span class="comment">// 传输方向(direction),这里选择的是外设站点作为数据源</span></span><br><span class="line">	DMA_InitStruct.DMA_BufferSize = <span class="number">2</span>; <span class="comment">//其实就是传输次数,一次传输上面设置的数据宽度的值，这里两个通道一共传输2次</span></span><br><span class="line">	DMA_InitStruct.DMA_Mode = DMA_Mode_Circular; <span class="comment">// 传输模式，就是是否使用自动重装。Normal不重装，circular是循环重装</span></span><br><span class="line">	DMA_InitStruct.DMA_M2M = DMA_M2M_Disable; <span class="comment">// 配置硬件触发，M2M位为0</span></span><br><span class="line">	DMA_InitStruct.DMA_Priority = DMA_Priority_Medium; <span class="comment">// 配置优先级，选择中等</span></span><br><span class="line">	DMA_Init(DMA1_Channel1,&amp;DMA_InitStruct);<span class="comment">//查看手册得到ADC1通道为1，只能使用通道1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//7.使能DMA和开启ADC到DMA输出	</span></span><br><span class="line">	DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">	ADC_DMACmd(ADC1,ENABLE);<span class="comment">//必须在ADC使能之前开启输出到DMA</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//8.使能ADC</span></span><br><span class="line">	ADC_Cmd(ADC1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//9.ADC校准</span></span><br><span class="line">	ADC_ResetCalibration(ADC1);<span class="comment">//复位校准</span></span><br><span class="line">	<span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1)== SET)&#123;&#125;;<span class="comment">//RSTCAL寄存器由软件置1后开始复位校准，完成后硬件自动清0该位</span></span><br><span class="line">	ADC_StartCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET)&#123;&#125;;<span class="comment">//CAL寄存器由软件置1后开始校准，校准结束后硬件自动清0该位</span></span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//10.ADC触发转换</span></span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1, ENABLE);</span><br><span class="line">    <span class="comment">/*连续转换，扫描模式下，DMA循环模式下只需要触发一次，ADC和DMA都不用等待，ADC和DMA就同时开始持续协同工作了*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里是触发使用单次转换时需要的*/</span></span><br><span class="line"><span class="comment">//void ADC_GetValue()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	DMA_Cmd(DMA1_Channel1,DISABLE);</span></span><br><span class="line"><span class="comment">//	DMA_SetCurrDataCounter(DMA1_Channel1,2); </span></span><br><span class="line"><span class="comment">//	DMA_Cmd(DMA1_Channel1,ENABLE);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	ADC_SoftwareStartConvCmd(ADC1, ENABLE);//启动软件触发转换</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	/*不需要等待ADC转换完成了，只需要等待DMA*/</span></span><br><span class="line"><span class="comment">//	while(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET)&#123;&#125;;//等待DMA传输完成</span></span><br><span class="line"><span class="comment">//	DMA_ClearFlag(DMA1_FLAG_TC1);//清除标志位</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Voltage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">		OLED_Init();</span><br><span class="line">		AD_Init();</span><br><span class="line">	  </span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			</span><br><span class="line">		Voltage = (<span class="type">float</span>)ADValue[<span class="number">1</span>] / <span class="number">4095</span> * <span class="number">3.3</span>;<span class="comment">//根据精度对应计算出电压值</span></span><br><span class="line">			</span><br><span class="line">		OLED_ShowNum(<span class="number">5</span>,<span class="number">5</span>,ADValue[<span class="number">0</span>],<span class="number">4</span>);</span><br><span class="line">		OLED_ShowNum(<span class="number">10</span>,<span class="number">5</span>,ADValue[<span class="number">1</span>],<span class="number">4</span>);</span><br><span class="line">		OLED_ShowNum(<span class="number">15</span>,<span class="number">5</span>,Voltage,<span class="number">4</span>);</span><br><span class="line">		</span><br><span class="line">		Delay_ms(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>ADC连续转换+扫描模式下，配合DMA，只需要触发ADC转换后，每当有一个通道转换完成，DMA迅速将值转运到ADValue中，我们直接对ADValue的值进行读取即可</strong></p>
<hr>
<p><strong>这里我们其实还可以再加一个定时器，ADC用单次扫描，再用定时器去定时触发</strong></p>
<p><code>即：定时器触发ADC-&gt;ADC触发DMA</code></p>
<p><strong>这样的好处就是整个过程完全自动，不需要手动进行操作，节省软件资源，实现硬件自动化</strong></p>
</blockquote>
<h1>通信接口</h1>
<h2 id="接口简介">接口简介</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241130220652564-173752975558545.png" alt="image-20241130220652564"></p>
<blockquote>
<p><strong>这里列举的是最常用，最简单的配置，还有很多配置没有列出</strong></p>
<p><strong>全双工一般都有两根数据线，比如串口、SPI</strong></p>
</blockquote>
<h2 id="串口通信">串口通信</h2>
<h3 id="介绍-3">介绍</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241201171647997-173752975558546.png" alt="image-20241201171647997"></p>
<blockquote>
<p><strong>串口是点对点通信，就是一对一之间通讯</strong></p>
<p><strong>图一</strong>：<strong>USB转串口模块</strong>，上面是<strong>CH340芯片</strong>，可以将串口协议转换为USB协议，USB端可以接在电脑上，另一端串口引脚接在支持串口的芯片上</p>
<p><strong>图二</strong>：<strong>陀螺仪传感器模块</strong>，测量加速度，角速度，一边是串口引脚，一边是I2C引脚</p>
<p><strong>图三</strong>：<strong>蓝牙串口模块</strong>，上面的芯片可以和手机互联，实现手机遥控单片机的功能</p>
</blockquote>
<h3 id="CH340串口驱动">CH340串口驱动</h3>
<p>CH340芯片作为USB和串行通信之间的桥梁，它允许你的电脑通过USB端口与仅支持串行通信协议的设备（如许多基于STM32的开发板）进行通信。安装了正确的驱动后，电脑上的应用程序（例如串口调试工具、编程软件等）才能通过这个虚拟出来的COM端口与STM32开发板交换数据。</p>
<p><strong>串口连接我们电脑时，对应设备管理器中找到是否有CH340的驱动，没有的安装即可，有的话就可以使用了。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241203185913944-173752975558547.png" alt="image-20241203185913944"></p>
<h3 id="硬件电路-2">硬件电路</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241201172828258-173752975558548.png" alt="image-20241201172828258"></p>
<blockquote>
<p><strong>一般串口通信模块有四个引脚：VCC、TX、RX、GND</strong></p>
<p><strong>简单的串口通信只有RX和TX两个信号线，复杂的还有时钟线</strong></p>
<p>TX和RX是单端信号，它们的高低电平都是相对于GND，所以串口通信的RX、TX、GND是必须接的</p>
<p>对于VCC，如果两个设备都有独立供电，VCC可以不用接。如果其中一个设备没有供电，比如设备1是STM32，设备2是蓝牙串口模块，STM32有独立供电，蓝牙串口模块没有独立供电，此时就需要把蓝牙串口的VCC和STM32的VCC接在一起</p>
<hr>
<p><strong>两根通信线为全双工，只接一根通信线的情况下就变成了单工通信</strong></p>
<hr>
<p><strong>电平标准不一致需要加电平转换芯片才能通信，一般设备直接出来的是TTL电平，需要另外一个也是TTL电平才能通信</strong></p>
</blockquote>
<h3 id="电平标准">电平标准</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241201173753315-173752975558549.png" alt="image-20241201173753315"></p>
<blockquote>
<p><code>TTL电平</code>：单片机这种低压小型设备，使用的都是TTL电平，最远几十米。所以在单片机中如果线路对地是3.3V，就代表发送了逻辑1，对地是0V，就代表发送了逻辑0</p>
<p><code>RS232</code>：最远几十米。</p>
<p><code>RS485</code>：两线压差，所以电平是差分信号，差分信号的抗干扰能力非常强，使用RS485电平标准，通讯距离可以达到上千米</p>
<p><strong>不同的电平间，加上电平转换芯片即可使用</strong></p>
</blockquote>
<h3 id="串口参数及时序">串口参数及时序</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241201174831622-173752975558550.png" alt="image-20241201174831622"></p>
<blockquote>
<p><code>波特率</code>：每秒传送码元的个数，单片机中的话一个码元对应一位，码元/s对应bit/s</p>
<p><code>起始位</code>：空闲状态时为<strong>高电平</strong>，起始位为<strong>低电平</strong>产生一个下降沿，标志数据发送的开始</p>
<p><code>数据位</code>：<strong>低位先行</strong>，从数据的低位开始发送。可以把校验位算在数据位中，也可以把校验位单独出来</p>
<p><code>校验位</code>：三种方式，无校验，奇校验，偶校验，根据数据来决定是0还是1</p>
<p><code>停止位</code>：固定为<strong>高电平</strong>为下个起始位做准备</p>
<hr>
<p><code>数据帧格式：</code></p>
<p>&lt;--------10位/11位 -----------&gt;</p>
<p><strong>起始位(低电平)+数据位+停止位(高电平)</strong></p>
<p>​            1位               8/9位        1 位</p>
<p>8位数据位：不含有奇偶校验位</p>
<p>9位数据为：最后一位添加了一位奇偶校验位</p>
<hr>
</blockquote>
<h3 id="USART简介">USART简介</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241201231743375-173752975558551.png" alt="image-20241201231743375"></p>
<blockquote>
<p><strong>一般串口很少使用同步功能，只是多了个时钟输出，只支持输出不支持输入，同步模式更多是为了兼容别的协议和其他用途，并不支持两个USART之间进行同步通信</strong></p>
<hr>
<p><code>硬件流控制:</code>在A、B之间有一根单独的一根线，高低电平可以决定接收方是否准备好，准备好了再发送，可以防止接收方处理慢而导致数据丢失的问题。我们一般不使用</p>
<p><code>DMA:</code>串口有大量的数据时，可以使用DMA，减小CPU负担，提高效率</p>
</blockquote>
<h3 id="USART框图">USART框图</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241202174332315-173752975558552.png" alt="image-20241202174332315"></p>
<blockquote>
<p><code>发送数据寄存器TDR</code>：只写，当数据从TDR全部到发送移位寄存器中后，<code>TXE标志位</code>(TX Empty)-<strong>发送数据寄存器为空</strong>，会置1，此时检查这个标志位为1的话就可以就可以写入下一个数据到TDR</p>
<p><code>发送移位寄存器</code>：把一个字节的数据一位一位地移出去，正好对应串口协议的波形数据位。通过下方发送器控制，向右移位，一位一位地把数据输出到TX引脚，正好对应串口的低位先行，当数据移位完成后，新的数据会再次自动的从TDR移动到发送移位寄存器中(移位未完成时TDR会等待完成)。</p>
<p>发送整个过程连续，效率高</p>
<hr>
<p><code>接收数据寄存器RDR</code>：只读</p>
<p><code>接收移位寄存器</code>：数据从RX引脚通向接收移位寄存器，在接受器控制下，一位一位地读取RX电平，先放在最高位，然后向右移。当这一个字节数据移位完成后，整体全部转移到<strong>接收数据寄存器RDR</strong>中，此时将<code>RXNE</code>(RX Not Empty )-<strong>接收数据寄存器非空</strong>，检测到RXNE置1之后，就可以将数据从RDR读走</p>
<hr>
<p><code>硬件数据流控(流控)</code>：<strong>如果发送设备发得太快，接收设备来不及处理，就会出现丢弃或覆盖数据得现象，有了流控就可以避免这个问题。一般不使用！！！</strong></p>
<p>对应有两个引脚：</p>
<p><code>nRTS(Request To Send)：</code>请求发送，是输出脚，告诉别人当前是否能接收，n代表低电平有效</p>
<p><code>nCTS(Clear To Send)：</code>是清除发送，是输入脚，用于接收别人nRTS信号b，n代表低电平有效</p>
<p>两个有流控的设备RTS和CTS交叉连接即可，CTS引脚接对方RTS引脚，用于判断对方能否接收，RTS引脚接对方CTS引脚，用于告诉对方我能不能接收</p>
<hr>
<p><code>右边边的SCLK</code>：</p>
<p>产生同步的时钟信号，用于配合发送移位寄存器输出。只支持输出不支持输入，两个USART之间不能实现同步的串口通信。我们一般不使用</p>
<p>作用：</p>
<ol>
<li>兼容别的协议，串口加上时钟后和SPI很像，所以可以兼容SPI协议</li>
<li>自适应波特率</li>
</ol>
<hr>
<p><code>唤醒单元：</code></p>
<p>实现多设备功能，一般不使用</p>
<hr>
<p><code>中断控制：</code></p>
<p>两个标志位比较重要，<code>TXE</code>(发送中断标志位)和<code>RXNE</code>(接收中断标志位)，这两个标志位可以去申请接收中断和发送中断，就可以在接收或者发送数据时，直接进入中断服务函数</p>
<p><strong>其他的标志位看手册可以知道有什么作用</strong></p>
<hr>
<p><code>波特率发生器：</code></p>
<p>波特率发生器其实就是<strong>分频器</strong>，对APB时钟进行分频，得到发送器和接收器的时钟</p>
</blockquote>
<p><code>对应所有的寄存器等更多知识都能在参考手册中查看！！！！</code></p>
<h3 id="USART基本结构">USART基本结构</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241202164204771-173752975558553.png" alt="image-20241202164204771"></p>
<blockquote>
<p><code> 波特率发生器</code>：用于产生约定的通信速率</p>
<p><code>对于TDR和RDR</code>：在软件层面，只有一个DR寄存器可以让我们读写，只不过是在接收或者发送时走上面或者下面这条路</p>
<p><code>开关控制</code>：对应的Cmd函数</p>
</blockquote>
<h3 id="数据帧">数据帧</h3>
<p><code>发送电路：</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241202164659015-173752975558554.png" alt="image-20241202164659015"></p>
<blockquote>
<p><strong>四种选择：</strong></p>
<p><strong>8位字长，无校验</strong></p>
<p><strong>8位字长，有校验</strong></p>
<p><strong>9位字长，无校验</strong></p>
<p><strong>9位字长，有校验</strong></p>
</blockquote>
<h3 id="起始位侦测">起始位侦测</h3>
<p><code>接收电路:</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241202165836050-173752975558655.png" alt="image-20241202165836050"></p>
<blockquote>
<p><strong>以波特率的16倍进行采样，一位的长度中，每三位至少有2个0，否则认为是噪声。</strong></p>
<p><strong>采样位设置在8，9，10，之后也这样采样就能保证在数据中间</strong></p>
</blockquote>
<h3 id="数据采样">数据采样</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241202170417412-173752975558656.png" alt="image-20241202170417412"></p>
<blockquote>
<p><strong>连续采样三次，无噪声下三次采样都为0或1</strong></p>
<p><strong>如果有噪声，以2:1进行确定，2次0，数据就为0，2次1，采样的数据就为1。此时会对噪声标志位NE置1，告诉收到数据，但有噪声</strong></p>
</blockquote>
<h3 id="波特率发生器">波特率发生器</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241202170724981-173752975558657.png" alt="image-20241202170724981"></p>
<blockquote>
<p><strong>DIV(分频系数)分为整数部分和小数部分，可以实现更细腻的分频</strong></p>
<p>16是因为内部有一个16倍波特率的采样时钟，所以**（fpclk2/1 / DIV)= 16  * 波特率(16倍波特率)**，最终计算波特率要多除以一个16</p>
<p><strong>例：配置9600波特率</strong></p>
<p>带公式：9600 = 72MHz /(16*DIV) ，得到DIV = 468.75</p>
<p>然后将DIV写入到该波特比率寄存器USART_BRR中，转换为2进制写入，有整数位和小数位</p>
<p><code>我们使用库函数直接输入需要的波特率9600即可，自动计算配置完成</code></p>
</blockquote>
<h3 id="数据模式">数据模式</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241203190308931-173752975558658.png" alt="image-20241203190308931"></p>
<blockquote>
<p><strong>通过串口助手显示的数据有以上两种方式：HEX和ASCII</strong></p>
<p>HEX：以原始数据(0x41等)的形式显示，为十六进制</p>
<p>ASCII：将原始数据(0x41)按照ASCII编码码表对应显示(0x41对应编码为‘A’)</p>
</blockquote>
<h3 id="库函数-8">库函数</h3>
<p>stm32f10x_usart.h中找到</p>
<p><code>初始化函数：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_DeInit</span><span class="params">(USART_TypeDef* USARTx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_Init</span><span class="params">(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_StructInit</span><span class="params">(USART_InitTypeDef* USART_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这两个函数用于配置同步时钟输出的，包括时钟使能，极性，相位等参数使用结构体*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClockInit</span><span class="params">(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClockStructInit</span><span class="params">(USART_ClockInitTypeDef* USART_ClockInitStruct)</span>;</span><br></pre></td></tr></table></figure>
<p><code>中断配置：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_ITConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>
<p><code>USART相关使能：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_Cmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*使能USART*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_DMACmd</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_DMAReq, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*开启对应的USART到DMA的触发通道*/</span></span><br></pre></td></tr></table></figure>
<p><code>USART发送和接收数据：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_SendData</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="comment">//写DR寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">USART_ReceiveData</span><span class="params">(USART_TypeDef* USARTx)</span>;</span><br><span class="line"><span class="comment">//读DR寄存器</span></span><br></pre></td></tr></table></figure>
<p><code>标志位相关：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">USART_GetFlagStatus</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClearFlag</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_FLAG)</span>;</span><br><span class="line"><span class="comment">/*终端外使用的标志位函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断服务程序中使用的标志位函数*/</span></span><br><span class="line">ITStatus <span class="title function_">USART_GetITStatus</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClearITPendingBit</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT)</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>不常用</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_SetAddress</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint8_t</span> USART_Address)</span>;<span class="comment">//设置地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_WakeUpConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_WakeUp)</span>;<span class="comment">//唤醒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ReceiverWakeUpCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_LINBreakDetectLengthConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_LINBreakDetectLength)</span>;<span class="comment">//LIN</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_LINCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一大段函数，智能卡、IrDA等相关函数不怎么使用*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendBreak</span><span class="params">(USART_TypeDef* USARTx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SetGuardTime</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint8_t</span> USART_GuardTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SetPrescaler</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint8_t</span> USART_Prescaler)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SmartCardCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SmartCardNACKCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_HalfDuplexCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_OverSampling8Cmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_OneBitMethodCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_IrDAConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IrDAMode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_IrDACmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="USART配置流程">USART配置流程</h3>
<ol>
<li>
<p><strong>RCC开启时钟，打开需要的USART和GPIO时钟</strong></p>
</li>
<li>
<p><strong>配置GPIO，对应TX配置为复用输出，RX配置为上拉或浮空输入</strong></p>
</li>
<li>
<p><strong>配置USART，使用结构体配置即可</strong></p>
</li>
<li>
<p>如果需要接收中断，加上ITConfig和NVIC配置即可。如果不需要中断跳过配置即可</p>
</li>
<li>
<p><strong>使能USART，USART_Cmd</strong></p>
</li>
</ol>
<h3 id="实验-串口发送和串口接收">实验-串口发送和串口接收</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*包括对Usart的初始化，和对一些常用的函数封装*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSend</span><span class="params">(<span class="type">uint8_t</span> Data)</span>;<span class="comment">//发送一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendArray</span><span class="params">(<span class="type">uint8_t</span>* Array,<span class="type">uint8_t</span> Length)</span>;<span class="comment">//发送数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendString</span><span class="params">(<span class="type">char</span>* String)</span>;<span class="comment">//发送字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">UsartPow</span><span class="params">(<span class="type">uint32_t</span> x,<span class="type">uint8_t</span> y)</span>;<span class="comment">//幂函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendNum</span><span class="params">(<span class="type">uint32_t</span> Num,<span class="type">uint8_t</span> Length)</span>;<span class="comment">//发送数字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1. RCC开启时钟，打开需要的USART和GPIO时钟</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.配置GPIO，对应TX配置为复用输出，RX配置为上拉或浮空输入，如果只选择一种模式，那么就只配置一个引脚即可</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//TX引脚配置</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//RX引脚配置</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">//3.配置USART，使用结构体配置即可</span></span><br><span class="line">	USART_InitTypeDef USART_InitStruct;</span><br><span class="line">	USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;<span class="comment">//波特率配置</span></span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//硬件流控配置,这里不适用</span></span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; <span class="comment">//这里配置串口接收和发送模式都使用，可以只配置一个</span></span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No; <span class="comment">//校验位，不使用校验</span></span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1; <span class="comment">//停止位配置1位</span></span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b;<span class="comment">//数据位长度，没有奇偶校验位，所以选择8位数据位</span></span><br><span class="line">	USART_Init(USART2,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*如果需要使用中断，需要在此处调用USART_ITConfig函数，然后再配置NVIC即可*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//4.使能USART，USART_Cmd</span></span><br><span class="line">	USART_Cmd(USART2,ENABLE);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSend</span><span class="params">(<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	USART_SendData(USART2,Data);</span><br><span class="line">	<span class="keyword">while</span>(USART_GetFlagStatus(USART2,USART_FLAG_TXE) == RESET);<span class="comment">//等待数据移动到移位寄存器中，避免发生数据覆盖</span></span><br><span class="line">	<span class="comment">/*手册中可以知道，下一次调用SendData时该TXE标志位会自动清0*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendArray</span><span class="params">(<span class="type">uint8_t</span>* Array,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		UsartSend(Array[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendString</span><span class="params">(<span class="type">char</span>* String)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;String[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		UsartSend(String[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">UsartPow</span><span class="params">(<span class="type">uint32_t</span> x,<span class="type">uint8_t</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> result = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(y--)</span><br><span class="line">	&#123;</span><br><span class="line">		result*=x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendNum</span><span class="params">(<span class="type">uint32_t</span> Num,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		UsartSend((Num/UsartPow(<span class="number">10</span>,Length-i<span class="number">-1</span>))%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);<span class="comment">//加上一个字符0得到对应数字的ascii码</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> myArray[] = &#123;<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>&#125;;</span><br><span class="line"></span><br><span class="line">	  	UsartInit();</span><br><span class="line">    </span><br><span class="line">	  	UsartSend(<span class="number">0x41</span>);</span><br><span class="line">		</span><br><span class="line">		UsartSendArray(myArray,<span class="number">4</span>);</span><br><span class="line">		</span><br><span class="line">		UsartSendString(<span class="string">&quot;hello\r\nworld&quot;</span>);<span class="comment">//需要两个转义字符才能换行，\r代表回车，\n代表换行</span></span><br><span class="line">		</span><br><span class="line">		UsartSendNum(<span class="number">65535</span>,<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			<span class="keyword">if</span>()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实验-串口接收单字节-轮询-中断">实验-串口接收单字节(轮询+中断)</h3>
<p><code>在while循环中轮询读取：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;	</span><br><span class="line">	   <span class="keyword">if</span>(USART_GetFlagStatus(USART2,USART_FLAG_RXNE)== SET)<span class="comment">//手册可知该RXNE标志位再下方调用读取时会自动清0</span></span><br><span class="line">		&#123;</span><br><span class="line">				rData = USART_ReceiveData(USART2);</span><br><span class="line">		&#125;</span><br><span class="line">      OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,rData,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>使用中断:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSend</span><span class="params">(<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendArray</span><span class="params">(<span class="type">uint8_t</span>* Array,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendString</span><span class="params">(<span class="type">char</span>* String)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">UsartPow</span><span class="params">(<span class="type">uint32_t</span> x,<span class="type">uint8_t</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendNum</span><span class="params">(<span class="type">uint32_t</span> Num,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetFlag</span><span class="params">()</span>;<span class="comment">//自定义标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetData</span><span class="params">()</span>;<span class="comment">//自定义Get方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData;</span><br><span class="line"><span class="type">uint8_t</span> rFlag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1. RCC开启时钟，打开需要的USART和GPIO时钟</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.配置GPIO，对应TX配置为复用输出，RX配置为上拉或浮空输入，如果只选择一种模式，那么就只配置一个引脚即可</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//TX引脚配置</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//RX引脚配置</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">//3.配置USART，使用结构体配置即可</span></span><br><span class="line">	USART_InitTypeDef USART_InitStruct;</span><br><span class="line">	USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;<span class="comment">//波特率配置</span></span><br><span class="line">	USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//硬件流控配置,这里不适用</span></span><br><span class="line">	USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; <span class="comment">//这里配置串口接收和发送模式都使用，可以只配置一个</span></span><br><span class="line">	USART_InitStruct.USART_Parity = USART_Parity_No; <span class="comment">//校验位，不使用校验</span></span><br><span class="line">	USART_InitStruct.USART_StopBits = USART_StopBits_1; <span class="comment">//停止位配置1位</span></span><br><span class="line">	USART_InitStruct.USART_WordLength = USART_WordLength_8b;<span class="comment">//数据位长度，没有奇偶校验位，所以选择8位数据位</span></span><br><span class="line">	USART_Init(USART2,&amp;USART_InitStruct);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*如果需要使用中断，需要在此处调用USART_ITConfig函数，然后再配置NVIC即可*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4.配置中断和NVIC</span></span><br><span class="line">	USART_ITConfig(USART2,USART_IT_RXNE,ENABLE);</span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannel = USART2_IRQn;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">	NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//5.使能USART，USART_Cmd</span></span><br><span class="line">	USART_Cmd(USART2,ENABLE);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetData</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> rData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用extern也是同样的效果’</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetFlag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(rFlag == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rFlag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//自定义清除标志位</span></span><br><span class="line">	</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(USART_GetITStatus(USART2,USART_IT_RXNE)== SET)</span><br><span class="line">	&#123;</span><br><span class="line">	  	rData = USART_ReceiveData(USART2);</span><br><span class="line">	  	rFlag = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">		USART_ClearITPendingBit(USART2,USART_IT_RXNE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中断服务函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="type">uint8_t</span> Data;</span><br><span class="line">		OLED_Init();</span><br><span class="line"></span><br><span class="line">	  	UsartInit();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">	    	<span class="keyword">if</span>(UsartGetFlag()== <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Data = UsartGetData();</span><br><span class="line">				UsartSend(Data);</span><br><span class="line">			&#125;</span><br><span class="line">      	OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,Data,<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>该实验只能实现对单字符的接收</strong></p>
</blockquote>
<h3 id="实验-USART串口数据包">实验-USART串口数据包</h3>
<h3 id="实验-printf函数的移植">实验-printf函数的移植</h3>
<blockquote>
<p><strong>在Keil中，使用printf函数之前我们需要打开工程选项，找到Target，勾选Use MicroLIB(使用微库)</strong></p>
<p>MicroLIB：是Keil为嵌入式平台优化的一个精简库</p>
</blockquote>
<p><code>方法1：printf的重定向：</code>printf默认输出到屏幕，但是单片机没有屏幕，所以需要我们重定向到串口</p>
<p>在对应串口模块中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*该定义usart.c的结尾加上*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//该stdio.h头文件在usart.h中再进行引用一次，即可在调用usart.h时使用printf了</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE* f)</span></span><br><span class="line">&#123;</span><br><span class="line">    UsartSend(ch);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*fputc是printf函数底层，使用printf时，是不断调用fputc进行打印的，我们把fputc函数重定向到串口，printfzi*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c中*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    UsartInit();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Num=%d\r\n&quot;</span>,<span class="number">66666</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种方法只能将printf输出到调用串口发送函数的那一个串口当中，无法在其他串口中使用。</p>
<p>解决方法：使用标准库函数sprintf</p>
</blockquote>
<p><code>方法2：sprintf函数使用</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c中*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    UsartInit();</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line"> 	<span class="built_in">sprintf</span>(String,<span class="string">&quot;Num=%d\r\n&quot;</span>,<span class="number">99999</span>);</span><br><span class="line">	UsartSendString(String);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>sprintf的作用是：发动格式化字符串到指定str中，可以实现拼接字符串，这样即可实现每个串口的格式化打印</strong></p>
</blockquote>
<p><code>方法三：使用可变参数封装sprintf</code></p>
<p>使用头文件<code>&lt;stdarg.h&gt;</code></p>
<p>具体封装过程百度即可</p>
<h3 id="数据包">数据包</h3>
<h4 id="数据包介绍">数据包介绍</h4>
<p><strong>数据包分为</strong>：<code>HEX数据包</code>和<code>文本数据包</code>，分别对应<strong>文本模式和HEX模式</strong></p>
<p><strong>作用</strong>：将属于同一批的数据进行打包和分割。</p>
<ol>
<li><code>HEX数据包:</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241204165308342-173752975558659.png" alt="image-20241204165308342"></p>
<blockquote>
<p>通过添加包头包尾分割数据</p>
<p>数据包头：0xFF</p>
<p>数据包尾：0xFE</p>
<hr>
<p><code>优点:</code><strong>传输最直接，解析数据非常简单，比较适合一些模块发送原始的数据，比如一些使用串口通信的陀螺仪、温湿度传感器数据</strong></p>
<p><code>缺点：</code>灵活性不足，载荷容易和包头包尾重复(可能传输的数据是包头包尾的数据)</p>
<p><code>解决方案：</code></p>
<ol>
<li><strong>限制载荷数据的范围，在发送时对数据变化范围显示</strong></li>
<li><strong>如果无法避免载荷数据和包头包尾重复，我们就尽量使用固定长度的数据包，经过几个数据包的数据对齐后，剩下的数据包应该就没有问题了</strong></li>
<li><strong>增加包头包尾的数量，并且尽量呈现出载荷数据出现不了的状态</strong></li>
</ol>
<hr>
<p><code>HEX数据包格式选择</code>：</p>
<ol>
<li>如果数据容易出现与包头包尾重复的情况，就最好选择固定包长</li>
<li>如果数据不容易出现与包头包尾重复的情况，可以选择可变包长，这样就非常的灵活，只需要确定唯一的包头包尾就知道数据包长度</li>
</ol>
</blockquote>
<ol start="2">
<li><code>文本数据包:</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241204184721167-173752975558661.png" alt="image-20241204184721167"></p>
<blockquote>
<p>在HEX数据包中，数据是以原始字节数据本身呈现，而在文本数据包中，每个字节都经过了编码和译码，表现出的就是文本格式，但实际上都还是一个字节的HEX数据</p>
</blockquote>
<blockquote>
<p><strong>文本数据包基本不用担心载荷和包头包尾重复的问题</strong></p>
<p><strong>包头：‘@’</strong></p>
<p><strong>包尾：‘\r’  ‘\n’</strong></p>
<p><strong>载荷数据：除了包头包尾的数据</strong></p>
<hr>
<p><code>优点:</code><strong>数据直观易理解，非常灵活，比较适合一些输入指令进行人机交互的场合，比如蓝牙模块常用的AT指令，CNC和3D打印机常用的G代码</strong></p>
<p><code>缺点：</code>解析效率低，比如100，HEX发送的就是一个字节100，文本数据包却是三个字符’1’，‘1’，‘0’。</p>
</blockquote>
<h4 id="数据包的发送和接收">数据包的发送和接收</h4>
<ol>
<li>
<p><code>数据包的发送:</code>使用串口对应发送**数组(HEX数据包)<strong>或者</strong>字符串函数(文本数据包)**即可</p>
</li>
<li>
<p><code>数据包的接收</code>：</p>
</li>
</ol>
<ul>
<li>固定包长HEX数据包接收</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241204190804966-173752975558660.png" alt="image-20241204190804966"></p>
<blockquote>
<p><strong>使用状态机编程思想</strong>：先根据项目要求定义状态，画几个圈，然后考虑号各个状态会在什么情况下会进行转移，如何转移，画好线和转移条件，最后根据这个来编程</p>
</blockquote>
<ul>
<li>可变包长文本数据包接收</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241204192226109-173752975558662.png" alt="image-20241204192226109"></p>
<h3 id="实验-串口收发HEX数据包">实验-串口收发HEX数据包</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*此处只列举出了新添加的变量和函数，具体的见上方*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> RxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> TxPacket[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendPacket</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*发送数据包,包头包尾自定义*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendPacket</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	UsartSend(<span class="number">0xFF</span>);<span class="comment">//包头</span></span><br><span class="line">	UsartSendArray(TxPacket,<span class="number">4</span>);<span class="comment">//固定长度为4的数据</span></span><br><span class="line">  	UsartSend(<span class="number">0xFE</span>);<span class="comment">//包尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用状态机的编程思想，每次中断接收一个字节数据*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(USART_GetITStatus(USART2,USART_IT_RXNE)== SET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">uint8_t</span> RxData = USART_ReceiveData(USART2);</span><br><span class="line">		</span><br><span class="line">	  <span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(RxData == <span class="number">0xFF</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			RxPacket[count++] = RxData;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(count&gt;=<span class="number">4</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(RxData == <span class="number">0xFE</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">0</span>;</span><br><span class="line">				rFlag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		USART_ClearITPendingBit(USART2,USART_IT_RXNE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		LED_Init();</span><br><span class="line">		Key_Init();</span><br><span class="line">		OLED_Init();</span><br><span class="line"></span><br><span class="line">	  	UsartInit();</span><br><span class="line">		</span><br><span class="line">	  </span><br><span class="line">	  	</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(UsartGetFlag()== <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">                UsartSendPacket(TxPacket);</span><br><span class="line">				OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">				OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">				OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">				OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用串口助手发送FF 05 06 07 08 FE，可以发现串口回显FF 05 06 07 08 FE，OLED上显示05 06 07 08的数据</p>
</blockquote>
<h3 id="实验-串口收发文本数据包">实验-串口收发文本数据包</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> RxTextPacket[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> rFlag=<span class="number">0</span>;<span class="comment">//接受完成标志,还可以避免接收太快来不及使用数据就被覆盖了</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(USART_GetITStatus(USART2,USART_IT_RXNE)== SET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">uint8_t</span> RxData = USART_ReceiveData(USART2);</span><br><span class="line">		</span><br><span class="line">	  <span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(RxData == <span class="string">&#x27;@&#x27;</span>&amp;&amp;rFlag == <span class="number">0</span>)<span class="comment">//接收慢一点，等主函数使用完,避免主函数中的数据可能是上一个数据包和这个数据包中的内容</span></span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(RxData == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				RxTextPacket[count++] = RxData;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(RxData == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxTextPacket[count] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//组成完成字符串</span></span><br><span class="line">				count = <span class="number">0</span>;</span><br><span class="line">				</span><br><span class="line">				RxState = <span class="number">0</span>;</span><br><span class="line">				rFlag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		USART_ClearITPendingBit(USART2,USART_IT_RXNE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		LED_Init();</span><br><span class="line">		OLED_Init();</span><br><span class="line">	  	UsartInit();</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">	    </span><br><span class="line">			<span class="keyword">if</span>(rFlag == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				 <span class="keyword">if</span>(<span class="built_in">strcmp</span>(RxTextPacket,<span class="string">&quot;LED_ON&quot;</span>)== <span class="number">0</span>)</span><br><span class="line">				 &#123;</span><br><span class="line">					 LED1_ON();</span><br><span class="line">					 UsartSendString(<span class="string">&quot;LED1_ON_OK\r\n&quot;</span>);</span><br><span class="line">				 &#125;</span><br><span class="line">				 <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(RxTextPacket,<span class="string">&quot;LED_OFF&quot;</span>)== <span class="number">0</span>)</span><br><span class="line">				 &#123;</span><br><span class="line">					 LED1_OFF();</span><br><span class="line">					 UsartSendString(<span class="string">&quot;LED1_OFF_OK\r\n&quot;</span>);</span><br><span class="line">				 &#125;</span><br><span class="line">				 </span><br><span class="line">				 <span class="keyword">else</span></span><br><span class="line">				 &#123;</span><br><span class="line">					 UsartSendString(<span class="string">&quot;ERROR\r\n&quot;</span>);</span><br><span class="line">				 &#125;</span><br><span class="line">				</span><br><span class="line">				 rFlag = <span class="number">0</span>;<span class="comment">//使用完成数据标志，可以避免接收太快，之前那种方式可能会造成接收过快数据覆盖问题</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>使用串口助手发送@LED_ON + 换行回车，LED灯亮起</strong></p>
<p><strong>使用串口助手发送@LED_OFF + 换行回车，LED灯熄灭</strong></p>
</blockquote>
<h2 id="I2C">I2C</h2>
<h3 id="I2C介绍">I2C介绍</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241206141429374-173752975558663.png" alt="image-20241206141429374"></p>
<blockquote>
<p><strong>SPI特点</strong>：同步、半双工，两根通信线SCL和SDA</p>
<hr>
<p>第1个模块：MPU6050模块，进行姿态测量，使用I2C通信协议</p>
<p>第2个模块：OLED模块，显示图片，字符灯信息，使用I2C协议</p>
<p>第3个模块：AT24C02，存储器模块，使用I2C协议</p>
<p>第4个模块：DS3231，实时时钟模块，使用I2C协议</p>
<hr>
<p>I2C多主多从：相当于发生总线冲突，I2C协议会进行仲裁，胜利的一方取得总线控制权，失败的一方变回从机。同时在多主机的模型下，还要进行时钟同步</p>
</blockquote>
<h3 id="硬件电路与优缺点">硬件电路与优缺点</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241206144150840-173752975558664.png" alt="image-20241206144150840"></p>
<blockquote>
<p><code>一主多从模式：</code></p>
<p>SCL上挂载多个从设备，任何情况下从机不允许控制SCL，对于SDA数据线，从机不允许主动发起对SDA的控制，只有等待主机发送请求时，从机响应才能短暂获取</p>
<hr>
<p><strong>I2C采用外置<code>弱上拉电阻加开漏输出</code>的电路结构</strong>：</p>
<p><code>1.选择开漏输出，而不选择推挽输出：</code></p>
<p>如果使用推挽输出，如果总线时序没调整好，可能主机和从机都处于输出状态，且一个输出高电平，一个输出低电平，此时就会出现电源短路的问题。</p>
<p>而开漏输出只能直接输出低电平，高电平下没有驱动能力，输出取决于外部电路。</p>
<p>这样的话，就保证了所有设备都只能输出低电平而不能输出高电平</p>
<p><code>2.加上拉电阻:</code></p>
<p>为了避免开漏输出高电平时造成的引脚浮空，同时I2C通信需要输出高电平的能力，由于开漏输出下不能直接输出高电平，此时需要在外部加一个上拉电阻，此时为弱上拉，使能被外部拉高</p>
<p><code>这样设计电路的好处:</code></p>
<ol>
<li>完全杜绝电源短路现象，保证电路安全</li>
<li>避免引脚模式的频繁切换，开漏加弱上拉的模式，同时兼具了输入和输出的功能</li>
<li><strong>开漏模式下具有&quot;线与&quot;的特性，即：只要有任意一个或多个设备输出了低电平，总线就处于低电平，只有所有的设备输出高电平，总线才输出高电平。I2C可以利用这个特性，执行多主机模式下的时钟同步和总线仲裁。</strong></li>
</ol>
<p><code>限制：</code></p>
<p>​	<strong>由于I2C开漏外加上拉电阻的电路结构，使得通信线高电平的驱动能力比较弱，导致通信线由低电平转换为高电平时，上升沿耗时会比较长，这样就限制了I2C的最大通信速度，所以I2C标准模式为100Khz，快速模式也只有400Khz，一般来说我们就认为I2C最快速度为400khz，相对于SPI的速度来说慢了许多</strong></p>
</blockquote>
<h3 id="I2C时序基本单元">I2C时序基本单元</h3>
<ul>
<li><code>1.起始条件和终止条件:</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241206170442283-173752975558665.png" alt="image-20241206170442283"></p>
<blockquote>
<p><strong>正常情况下：SCL和SDA都处于高电平</strong></p>
<p><strong>起始条件：S/Sr</strong></p>
<p><strong>终止条件：P</strong></p>
<p>从机收到起始条件后，自身复位，等待主机发送信息</p>
</blockquote>
<ul>
<li><code>2.主机发送字节时序</code>：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241206170806836-173752975558666.png" alt="image-20241206170806836"></p>
<blockquote>
<p><strong>I2C发送字节与串口不同，I2C是高位先行，串口是低位先行</strong></p>
<p><code>发送字节过程总结下来就是</code>：</p>
<p><strong>时钟线SCL处于低电平时，主机设置数据线SDA的电平</strong></p>
<p><strong>时钟线SCL处于高电平时，从机读取数据线SDA的电平。</strong></p>
<p>显然，从机读取到的电平就是主机在时钟线低电平时设置的电平</p>
<hr>
<p><code>对中断处理：</code></p>
<p>如果主机一个字节发送一半，突然进中断了，那么此时SCL和SDA上的电平暂停变化，会不断拉长，传输完全暂停，等中断结束后，主机回来继续操作</p>
<hr>
<p><code>SCL和SDA控制权：</code></p>
<p><strong>该过程中，SCL和SDA都由主机掌控，从机只能被动读取</strong></p>
</blockquote>
<ul>
<li><code>主机接收字节时序:</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241206172222919-173752975558667.png" alt="image-20241206172222919"></p>
<blockquote>
<p><code>发送字节过程总结下来就是</code>：</p>
<p><strong>时钟线SCL处于低电平时，从机设置数据线SDA的电平</strong></p>
<p><strong>时钟线SCL处于高电平时，主机读取数据线SDA的电平。</strong></p>
<p>显然，主机读取到的电平就是从机在时钟线低电平时设置的电平</p>
<hr>
<p><code>SCL和SDA控制权:</code></p>
<p>SCL全程由主机控制</p>
<p><strong>主机在接收之前，需要释放SDA(SDA拉高)，此时让从机获得SDA控制权才能将数据放到SDA上!!!</strong></p>
</blockquote>
<ul>
<li><code>3.应答机制:</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241206172908982-173752975558668.png" alt="image-20241206172908982"></p>
<blockquote>
<p>根据应答机制，可以判断对方是否接收到了该数据</p>
<p>0：表示从机应答</p>
<p>1：表示从机非应答</p>
</blockquote>
<h3 id="I2C从机地址">I2C从机地址</h3>
<blockquote>
<p><code>从机地址介绍:</code></p>
<p>从机地址，每个从机设备出厂时都会分配一个7位或者10位地址，对应地址是什么可以在对应模块找到地址，比如MPU6050的7位地址为1101 000，AT24C02的7位地址为1010 000</p>
<hr>
<p><code>相同芯片挂载时对地址的处理:</code></p>
<p>一般不同芯片地址不同，相同型号芯片地址相同。</p>
<p>当相同芯片挂载在同一条总线时，此时需要用到地址中的可变部分，一般地址最后几位是可以在电路中改变的，比如MPU6050，最后一位由芯片上的AD0引脚决定，当该引脚接低电平就是1101 000，接高电平就是1101 001。而AT24C02地址的最后三位分明由引脚A0,A1,A2决定</p>
<p>一般I2C的从机设备地址，高位都是厂商确定，低位可以由不同引脚切换，这样就可以保证多个相同芯片挂载时地址都不一样</p>
</blockquote>
<h3 id="I2C时序">I2C时序</h3>
<p><code>时序1：指定地址写(常用)</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241206174948487-173752975558669.png" alt="image-20241206174948487"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241206175159856-173752975558670.png" alt="image-20241206175159856"></p>
<blockquote>
<p><strong>该时序是对指定设备的指定寄存器写入指定数据的操作</strong></p>
<p>上图为逻辑分析仪的结果：</p>
<ol>
<li>
<p><strong>最开始为起始条件</strong></p>
</li>
<li>
<p><strong>之后，必须是发送一个字节的时序，内容为从机地址+读写位(7+1共8位)</strong></p>
</li>
</ol>
<p>上图对应为：1101 000 0(前七位为MPU6050地址，最后一位为0代表写入操作)</p>
<ol start="3">
<li><strong>紧跟着的单元就是，接收从机的应答位(ACK，RA)。RA之后有个上升沿，代表从机释放SDA产生，交出了SDA控制权。</strong></li>
</ol>
<p>上图对应为：高电平器件，主机读取SDA，发现是0，代表主机进行寻址，有人应答了</p>
<ol start="4">
<li><strong>然后的一个字节为寄存器地址。</strong></li>
</ol>
<p>上图为00011001(0x19)，即操作0x19地址的寄存器</p>
<ol start="5">
<li>
<p><strong>紧接着又是从机应答位</strong></p>
</li>
<li>
<p><strong>然后发送写入寄存器的内容</strong></p>
</li>
</ol>
<p>上图为10101010，即发送数据为0xAA</p>
<ol start="7">
<li>
<p><strong>又是一个从机应答位</strong></p>
</li>
<li>
<p><strong>最后一个为终止条件</strong></p>
</li>
</ol>
<hr>
<p><code>指定地址连续写入多个字节：</code></p>
<p><strong>如果想要发送多个字节，只需要将第6步发送写入字节和接收应答重复N次即可，写入几个字节就重复几次。</strong></p>
<p><strong>因为地址指针会在写入一个数据后自动+1，所以不用移动地址指针</strong></p>
</blockquote>
<p><code>时序2：当前地址读(不怎么使用):</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241206213240665-173752975558671.png" alt="image-20241206213240665"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241206213259135-173752975558672.png" alt="image-20241206213259135"></p>
<blockquote>
<ol>
<li><strong>起始条件</strong></li>
<li><strong>主机发送一个字节(从机地址+读写位)，发送完后紧跟一个从机应答ACK</strong></li>
</ol>
<p><strong>图上为1101000 1 表示读取1101000的数据</strong></p>
<ol start="3">
<li><strong>然后SDA控制权移交给从机，主机开始读取从机发送数据(不用发送读取寄存器地址，从机会将当前地址指针指向的寄存器的值发送)，不能指定读的地址。接收完后紧跟发送一个非应答(SA:1)，这样从机读取到主机非应答后，就知道主机不想要继续了，交还SDA控制权</strong></li>
</ol>
<p><strong>图上接收的数据为00001111(0x0F)</strong></p>
<ol start="4">
<li><strong>结束条件</strong></li>
</ol>
<p><code>由于不能指定读的地址。所以该时序(当前地址读)用的不多</code></p>
<hr>
<p><code>当前地址连续读多个字节：</code></p>
<p><strong>如果想要读取多个字节，3处的读取一个字节后，就应该发送<code>应答</code>(RA:0)，然后重复读取字节，发送应答，最后一个字节读取完后，跟上一个<code>非应答</code>就可以结束读取</strong></p>
<p><strong>因为地址指针也会在读取一个数据后自动+1，所以不用移动地址指针</strong></p>
</blockquote>
<p><code>时序3：指定地址读(常用):</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241206214232444-173752975558673.png" alt="image-20241206214232444"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241206214817354-173752975558674.png" alt="image-20241206214817354"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241206214842186-173752975558675.png" alt="image-20241206214842186"></p>
<blockquote>
<p><strong>指定地址读为复合格式，是指定地址写和当前地址读的混合</strong></p>
<p>复合格式：前面部分为指定地址写(写的数据的前面)，后面部分为当前地址读</p>
<hr>
<ol>
<li><strong>起始条件</strong></li>
<li><strong>发送一个字节，从机地址+读写位(此处应为写位为0)，然后是从机应答位ACK(RA:0)</strong></li>
<li><strong>在发送一个字节，指定写入的地址，指定完成后从机寄存器指针就指向该地址，然后是从机应答位ACK(RA:0</strong>)</li>
</ol>
<p><code>该部分为指定地址写前面部分</code></p>
<hr>
<ol start="4">
<li><strong>(这里前面可以加一个停止，也可以不加)不发送写入的内容，而重复起始条件Sr(Start Repeat)，相当于另起一个时序</strong></li>
<li><strong>重新发送一个字节，从机地址+读写位(此处应为读位为0），从机应答位ACK(RA:0)</strong></li>
<li><strong>主机接收一个字节，主机接收到的数据就是指定写入地址处的数据，然后发送一个非应答(SA:1)</strong></li>
<li><strong>停止条件</strong></li>
</ol>
<p><strong>连起来就是：先起始，写入地址，停止。再起始，读当前位置，停止</strong></p>
<hr>
<p><code>指定地址连续读多个字节：</code></p>
<p><strong>如果想要读取多个字节，6处的读取一个字节后，就应该发送<code>应答</code>(RA:0)，然后重复读取字节，发送应答，最后一个字节读取完后，跟上一个<code>非应答</code>就可以结束读取</strong></p>
<p><strong>因为地址指针也会在读取一个数据后自动+1，所以不用移动地址指针</strong></p>
</blockquote>
<h3 id="MPU6050">MPU6050</h3>
<h4 id="MPU6050简介">MPU6050简介</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241207201409336-173752975558676.png" alt="image-20241207201409336"></p>
<blockquote>
<p><code>6轴姿态传感器：</code>3轴加速度(加速度计) + 3轴角速度(陀螺仪传感器)</p>
<p><code>9轴姿态传感器：</code>3轴加速度 + 3轴角速度 + 3轴磁场强度(磁力计)</p>
<p><code>10轴姿态传感器：</code>3轴加速度 + 3轴角速度 + 3轴磁场强度 + 1个气压强度(气压计)</p>
</blockquote>
<blockquote>
<p><code>一些术语：</code></p>
<p><code>加速度计：</code>简称为Accel或者Acc或A，X,Y,Z三轴都有一个测量加速度。<strong>上面第二幅图就是加速度计</strong>，实际上加速度就是一个就是一个测力计。</p>
<p>使用加速度计求角度的时候只能在物体静止的时候使用，当物体运动起来时，这个角度会受运动加速度的影响而变得不准确。</p>
<p><code>即特性：</code>加速度计具有静态稳定性，不具有动态稳定性</p>
<hr>
<p><code>陀螺仪传感器：</code>简称为Gyro或者G，可以测量三轴的角速度值，分别表示芯片绕X轴、Y轴、Z轴旋转的角速度，<strong>对应上面第三幅图，为陀螺仪的机械模型</strong>。该芯片只能测得角速度，而不能直接测得角度，通过对角速度积分可以得到角度</p>
<p>当物体静止时，角速度的值会因为噪声无法完全归零，经过积分的不断累积，小噪声就会导致计算出来的角度产生缓慢的漂移，角速度积分得到的角度经不起时间的考验，但角度无论是运动还是静止都是没问题的</p>
<p><code>特性：</code>陀螺仪具有动态稳定性，不具有静态稳定性</p>
<hr>
<p><code>姿态解算：</code></p>
<p>这两个传感器特性刚好互补，通过互补滤波就能融合得到静态和动态都稳定的姿态角了。</p>
<hr>
<p><code>了解姿态角/欧拉角:</code></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinolover/article/details/90671784">什么是欧拉角/姿态角？_欧拉角和姿态角区别-CSDN博客</a></p>
</blockquote>
<h4 id="MPU6050参数">MPU6050参数</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241207205112946-173752975558677.png" alt="image-20241207205112946"></p>
<blockquote>
<p><code>部分重要参数，具体参数清查看MPU6050手册</code></p>
<p>芯片输出的是一个随姿态变化而变化的电压，要想量化电压那么就需要AD转换器，芯片自带16位ADC，输出结果是有符号数</p>
<hr>
<p><code>满量程：</code>决定对应16位ADC值达到最大值时对应的物理参量，具有多个选择，根据具体物体运动的剧烈程度(实际情况)选择，避免超过满量程。</p>
<p>量程越小，分辨率越高，量程越大，范围越广</p>
<hr>
<p><code>低通滤波:</code>如果输出数据抖动很厉害，可以加一点低通滤波，这样就会更平缓</p>
<p><code>可配置时钟源和采样分频:</code>两个参数配合使用，时钟源通过采样分频为AD转换和内部其他电路提供时钟，控制分频系数就可以控制AD转换的快慢了</p>
<hr>
<p><code>对从机地址的处理</code>：</p>
<p>第一种从机地址：110 1000(0x68)</p>
<p>第二种从机地址(读写位)：1101 0000(0xD0)或者1101 0001(0xD1)</p>
<p>所以这两种从机地址说法都是正确的，一个是没带上读写位的从机地址，一个是带上从机位的地址。</p>
<p>实际发送一个字节时，只需要不带读写为的从机地址左移1位，再或上读写位即可</p>
<p>(0x68 &lt;&lt; 1 ) |   1/0</p>
<p>也可以直接就写融入读写位的从机地址</p>
<p>0xD1/0xD0</p>
</blockquote>
<h4 id="硬件电路-3">硬件电路</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241207221537437-173752975558678.png" alt="image-20241207221537437"></p>
<blockquote>
<p><strong>最右边的是MPU6050的芯片</strong>：</p>
<p>芯片本身引脚非常多，包括I2C通信引脚，供电，帧同步等，很多引脚用不到，还有些引脚是芯片最小系统里的固定连接，一般手册中有</p>
<hr>
<p><strong>左下角是8针的排针</strong>：</p>
<ul>
<li><strong>VCC和GND</strong>：电源供电</li>
<li><strong>SCL和SDA</strong>：I2C通信引脚，可以看到外部电路已经内置两个4.7K上拉电阻了，直接接即可，不用再接上拉电阻了</li>
<li><strong>XCL、XDA</strong>：主机I2C引脚，设计是为了扩展芯片功能，6轴传感器不够时，这个XCL和XDL用于外接磁力计或者气压计扩展为9轴传感器等，接上后MPU6050主机接口可以直接访问这些扩展芯片的数据，将数据读入MPU6050,里面有DMP单元进行数据融合和姿态解算。</li>
</ul>
<p>如果不需要解算功能，可以直接把磁力计或气压计挂载到SCL和SDA上，因为I2C本来就可以挂载多设备</p>
<ul>
<li><strong>AD0</strong>：7位从机地址最低位，电路中可以看到默认若下拉到低电平所以悬空状态下为0。对应从机地址为1101 000，接VCC的话就是1101 001</li>
<li><strong>INT</strong>：中断输出引脚，可以配置芯片内部事件触发中断引脚输出，如：数据准备好了、I2C主机错误等，不使用可以不配置</li>
</ul>
<p>除此之外，芯片内部还内置了一些实用的小功能：自由落体监测、运动监测、零运动监测等，这些信号都可以触发INT引脚产生电平跳变，可以进行中断信号的配置</p>
<hr>
<p><strong>左上角是LDO，低压差线性稳压器</strong>：</p>
<p>这部分是供电的逻辑，手册中可以看到MPU6050的VDD供电为2.375~3.46V，属于3.3V供电设备，不能直接接5V，为了扩大供电范围，就加了个3.3V的稳压器，使输入端电压VCC_5V可以再3.3V到5V之间，经过3.3V的稳压器给芯片端供电。最后跟上的是一个电源知识灯，如果有点就会亮。</p>
<p>这一模块是否需要可以根据需求来，如果已经有稳定的3.3V的电源就不需要这部分了</p>
</blockquote>
<h4 id="MPU6050框图">MPU6050框图</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241207225256921-173752975558679.png" alt="image-20241207225256921"></p>
<blockquote>
<p><strong>时钟部分</strong>：一般使用内部时钟，硬件电路上也是直接接地和没有引出</p>
<hr>
<p><strong>灰色部分</strong>：</p>
<p>是芯片内部传感器，包括XYZ轴的加速度计(X Accel等)，XYZ轴的角速度计(X Gyro等)</p>
<p>还内置了一个温度传感器(Temp Sensor)，也可用于测量温度。</p>
<p>这些传感器转换完成后，数据统一放在传感器寄存器(Sensor Register)中，读取该数据寄存器就能得到传感器测量的值。</p>
<p>芯片内部转换都是全自动进行(类似与AD连续转换+DMA转运)，每个ADC输出对应都是16位数据寄存器，不存在数据覆盖问题。需要数据直接读取即可</p>
<hr>
<p><strong>最左边Self test</strong>：</p>
<p>这是芯片的自测单元，当启动自测后，芯片内部会模拟一个外力施加在传感器上，这个外力导致传感器数据会比平时大一些。</p>
<p><strong>自测方法：先使能自测，读取数据，再失能自测，读取数据。两个数据相减得到的数据叫做自测响应，芯片手册中给出了一个范围，如果在这个范围内，代表芯片没问题。如果不在，就说明芯片可能坏了，使用的话就要小心点。</strong></p>
<p><code>手册找到自测范围如下：在这个范围内就代表芯片正常</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241207235118026-173752975558680.png" alt="image-20241207235118026"></p>
<hr>
<p><strong>最下方Charge Pump</strong>：电荷泵，进行升压操作</p>
<hr>
<p><strong>最右边是寄存器和通信接口部分：</strong></p>
<p>很多寄存器：配置寄存器等</p>
<p>通信接口：从机I2C和SPI接口，主机I2C接口用于扩展设备通信</p>
<p>里面有个Digital Motion Processor-数字运动处理器简称DMP，是芯片内部自带的一个姿态解算的硬件算法，配合官方DMP库可以进行姿态解算</p>
<hr>
<p><strong>右下角为供电部分</strong>：按照手册电压要求和参考电路接线即可</p>
</blockquote>
<h4 id="MPU6050产品手册">MPU6050产品手册</h4>
<p>I2C通信，电气特性等知识均可查看</p>
<h4 id="MPU6050寄存器映像手册">MPU6050寄存器映像手册</h4>
<p>所有的寄存器都在里面，但是不需要全部了解</p>
<p><strong>需要了解的如下：每个寄存器具体介绍在手册向下翻即可</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241207233440068-173752975558681.png" alt="image-20241207233440068"></p>
<blockquote>
<p><code>SMPLRT_DIV</code>：<strong>采样频率分频寄存器</strong>，配置采样寄存器的分频系数，分频越小，内部AD转换越快，数据刷新越快。</p>
<p>采样频率 = (陀螺仪晶振)陀螺仪输出时钟频率/(1+分频值)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241218223941780-173752975558682.png" alt="image-20241218223941780"></p>
<p>Bit7~Bit0：值越小，越快，根据实际需求来</p>
<p><strong>对应配置：0x09 (对应10分频)</strong></p>
<hr>
<p><code>CONFIG</code>：<strong>配置寄存器</strong>，分为外部同步设置和低通滤波器配置，外部同步这里不使用不看。低通滤波器可以使输出数据更平滑，选择值为0~7，数值越大，抖动越下，0代表不滤波</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241218224001365-173752975558683.png" alt="image-20241218224001365"></p>
<p>Bit7~6：无关位</p>
<p>Bit5~3：外部同步，不需要，给0即可</p>
<p>Bit2~0：数字低通滤波器，也是根据需求配置。我们给个110，比较平滑的配置</p>
<p><strong>对应配置为：0x06</strong></p>
<hr>
<p><code>GYRO_CONFIG</code>：<strong>陀螺仪配置寄存器</strong>，高3位是XYZ轴的自测使能位，中间两位是满量程选择位，最后三位没使用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241218224017264-173752975558684.png" alt="image-20241218224017264"></p>
<p>Bit7~Bit5：自测使能位，不自测给0即可</p>
<p>Bit4~Bit3:	满量程选择，根据实际需求选择。我们给11为最大量程</p>
<p>Bit2~Bit0：无关位</p>
<p><strong>对应配置为：0x18</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241207235348661-173752975558685.png" alt="image-20241207235348661"></p>
<hr>
<p><code>ACCEL_CONFIG</code>：<strong>加速度计配置寄存器</strong>，高3位是XYZ轴的自测使能位，中间两位是满量程选择位，最后三位用于配置高通滤波器(内置小功能会用到)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241218224036938-173752975558686.png" alt=""></p>
<p>Bit7~Bit5：自测使能位，不自测给0即可</p>
<p>Bit4~Bit3:	满量程选择，根据实际需求选择。我们给11为最大量程</p>
<p>Bit2~Bit0：高通滤波器，不使用给00</p>
<p><strong>对应配置为：0x18</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241207233637672-173752975558687.png" alt="image-20241207233637672"></p>
<blockquote>
<p><code>加速度计XYZ轴寄存器：</code>_L 表示低8位，_H表示高8位</p>
<p>ACCEL_XOUT_H ：</p>
<p>ACCEL_XOUT_L ：</p>
<p>ACCEL_YOUT_H ：</p>
<p>ACCEL_YOUT_L ：</p>
<p>ACCEL_ZOUT_H ：</p>
<p>ACCEL_ZOUT_L ：</p>
<p><code>加速度计XYZ轴寄存器：</code>_L 表示低8位，_H表示高8位</p>
<p>GYRO_XOUT_H：</p>
<p>GYRO_XOUT_L ：</p>
<p>GYRO_YOUT_H ：</p>
<p>GYRO_YOUT_L ：</p>
<p>GYRO_ZOUT_H ：</p>
<p>GYRO_ZOUT_L ：</p>
<p><code>温度传感器寄存器：</code></p>
<p>TEMP_OUT_H ：</p>
<p>TEMP_OUT_L ：</p>
<p><code>查看对应手册的寄存器讲解部分即可</code></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241207234205598-173752975558688.png" alt="image-20241207234205598"></p>
<blockquote>
<p><code>具体某位干什么查看手册对应寄存器功能</code></p>
<p><code>PWR_MGMT_1：电源管理寄存器1:</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241208000537943-173752975558689.png" alt="image-20241208000537943"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241218222543311-173752975558790.png" alt="image-20241218222543311"></p>
<p>Bit7(DEVICE)：设备复位，配置给0不复位</p>
<p>Bit6(SLEEP)：设备睡眠，配置时给0不睡眠</p>
<p>Bit5(CYCLE)：循环模式，配置给0不循环</p>
<p>Bit4(无关位)：配置给0即可</p>
<p>Bit3(温度传感器失能)：配置给0，不失能</p>
<p>Bit2~0(选择时钟)：000选择内部时钟，手册非常建议选择陀螺仪时钟，我们配置为001，选择X轴陀螺仪时钟</p>
<p><strong>对应配置为：0x01</strong></p>
<hr>
<p><code>PWR_MGMT_2：电源管理寄存器2:</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241218223451238-173752975558791.png" alt="image-20241218223451238"></p>
<p>Bit7~6：循环模式唤醒频率，给00，不需要</p>
<p>Bit5~0：后六位为每个轴的待机位，不需要待机，全部给0即可</p>
<p><strong>对应配置为：0x00</strong></p>
<hr>
<p><code>WHO_AM_I：器件ID号:</code>只读的，中间六位固定为110100</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241208000027373-173752975558792.png" alt="image-20241208000027373"></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241208000214450-173752975558893.png" alt="image-20241208000214450"></p>
<blockquote>
<p>注意这里写的是：所有寄存器上电后默认都是0x00，除了107号寄存器和117号寄存器</p>
<p><strong>107号</strong>：<strong>电源管理寄存器1</strong>，默认为0x40(01000000)，可以看到SLEEP位为1，及<strong>上电默认睡眠模式，使用时记得解除睡眠模式，否则操作其他寄存器是无效的</strong></p>
</blockquote>
<blockquote>
<p><strong>117号</strong>：器件ID寄存器配置初始化值为0x68</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241208000407336-173752975558894.png" alt="image-20241208000407336"></p>
</blockquote>
<h3 id="软件模拟I2C读写">软件模拟I2C读写</h3>
<blockquote>
<p><strong>使用任意GPIO口模拟即可，步骤为：</strong></p>
<ol>
<li><strong>开启对应RCC时钟</strong></li>
<li><strong>配置GPIO口为开漏输出</strong></li>
<li><strong>配置SCL和SDA引脚默认高电平</strong></li>
</ol>
</blockquote>
<h4 id="软件I2C代码实现">软件I2C代码实现</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyI2C.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYI2C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYI2C_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元1：起始条件SCL高电平期间，SDA从高电平切换到低电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元1：结束条件SCL高电平期间，SDA从低电平切换到高电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：发送一个字节，1位1位的发送，从最高位开始*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：接收一个字节，SCL低从机设置，SCL高主机读取*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveByte</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：发送应答，逻辑和发送字节类似*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendAck</span><span class="params">(<span class="type">uint8_t</span> AckBit)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：接收应答，逻辑和接收字节类似*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveAck</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyI2C.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SCL</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	 GPIO_WriteBit(GPIOA,GPIO_Pin_2,(BitAction)BitVal);</span><br><span class="line">	 Delay_ms(<span class="number">10</span>);<span class="comment">//延时用于控制每个时序步骤之间的时间，确保I2C时序的稳定性。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SDA</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	 GPIO_WriteBit(GPIOA,GPIO_Pin_3,(BitAction)BitVal);</span><br><span class="line">	 Delay_ms(<span class="number">10</span>);<span class="comment">//延时用于控制每个时序步骤之间的时间，确保I2C时序的稳定性。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_R_SCL</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="type">uint8_t</span> bitValue;</span><br><span class="line">   bitValue = GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2);</span><br><span class="line">	 Delay_ms(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> bitValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_R_SDA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="type">uint8_t</span> bitValue;</span><br><span class="line">   bitValue = GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_3);</span><br><span class="line">	 Delay_ms(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> bitValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通过前面几个函数的封装我们实现了函数名称、端口号的替换，需要替换端口或者移植时就只需要对前四个函数修改即可,这样编程很方便*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">		</span><br><span class="line">		GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">	  GPIO_SetBits(GPIOA,GPIO_Pin_2 | GPIO_Pin_3);</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元1：起始条件SCL高电平期间，SDA从高电平切换到低电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//Sr重复起始条件时SCL是低电平，SDA高低电平不确定，所以先拉高SDA再拉高SCL确保都能回归高电平</span></span><br><span class="line">	 MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">	 </span><br><span class="line">	 MyI2C_W_SDA(<span class="number">0</span>);<span class="comment">//SDA先拉低</span></span><br><span class="line">	 MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*基本单元1：结束条件SCL高电平期间，SDA从低电平切换到高电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 MyI2C_W_SDA(<span class="number">0</span>);<span class="comment">//SCL一定为低电平，SDA高低电平不确定，为了确保释放SDA时能产生上升沿，要先拉低SDA</span></span><br><span class="line">	</span><br><span class="line">	 MyI2C_W_SCL(<span class="number">1</span>);<span class="comment">//SCL先拉高</span></span><br><span class="line">	 MyI2C_W_SDA(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：发送一个字节，1位1位的发送，从最高位开始*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123; </span><br><span class="line">	</span><br><span class="line"><span class="comment">//	 /*发送最高位*/</span></span><br><span class="line"><span class="comment">//   进来时SCL为低电平</span></span><br><span class="line"><span class="comment">//	 MyI2C_W_SDA(Byte &amp; 0x80);//因为保证了SCL是低电平，所以此时直接放入数据即可</span></span><br><span class="line"><span class="comment">//	 MyI2C_W_SCL(1);//SCL先拉高后从机会立刻读取刚刚放入的数据</span></span><br><span class="line"><span class="comment">//	 MyI2C_W_SCL(0);//SCL拉低完成一个脉冲</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	 /*发送次高位*/</span></span><br><span class="line"><span class="comment">//	 MyI2C_W_SDA(Byte &amp; 0x40);</span></span><br><span class="line"><span class="comment">//	 MyI2C_W_SCL(1);</span></span><br><span class="line"><span class="comment">//	 MyI2C_W_SCL(0);</span></span><br><span class="line"><span class="comment">//	 </span></span><br><span class="line"><span class="comment">//	 .......</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*这里使用循环直接实现8个字节的发送，SCL低主机设置，SCL高从机读取*/</span></span><br><span class="line">		 <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">		  MyI2C_W_SDA(Byte &amp; (<span class="number">0x80</span> &gt;&gt; i));</span><br><span class="line">			MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">			MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：接收一个字节，SCL低从机设置，SCL高主机读取*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveByte</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">		<span class="type">uint8_t</span> Byte = <span class="number">0x00</span>;</span><br><span class="line">	  </span><br><span class="line">		MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//主机在接受数据前需要将SDA释放让从机获取SDA控制权，使从机能够将数据放入SDA</span></span><br><span class="line">	  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(MyI2C_R_SDA()==<span class="number">1</span>) <span class="comment">//从机发送的数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				Byte |= (<span class="number">0x80</span> &gt;&gt; i); <span class="comment">// 设置第i位为1,否则为0</span></span><br><span class="line">			&#125;</span><br><span class="line">			MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">return</span> Byte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：发送应答，逻辑和发送字节类似*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendAck</span><span class="params">(<span class="type">uint8_t</span> AckBit)</span></span><br><span class="line">&#123; </span><br><span class="line">			<span class="comment">//进来时SCL为低电平</span></span><br><span class="line">			MyI2C_W_SDA(AckBit);<span class="comment">//主机发送ACK</span></span><br><span class="line">			MyI2C_W_SCL(<span class="number">1</span>);<span class="comment">//SCL为高，从机接收ACK</span></span><br><span class="line">			MyI2C_W_SCL(<span class="number">0</span>);<span class="comment">//结束一个脉冲</span></span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：接收应答，逻辑和接收字节类似*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveAck</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">			<span class="type">uint8_t</span> AckBit = <span class="number">0x00</span>;</span><br><span class="line">	  </span><br><span class="line">	    <span class="comment">//进来时SCL为低电平</span></span><br><span class="line">			MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//释放SDA使从机能操控SDA线(使其具有能拉高或拉低SDA的能力)，在SCL置高电平之前，从机将ACK放到SDA线上</span></span><br><span class="line"></span><br><span class="line">			MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">			AckBit = MyI2C_R_SDA();<span class="comment">//读取ACK</span></span><br><span class="line">			MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">			<span class="keyword">return</span> AckBit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyI2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	  UsartInit();</span><br><span class="line">	  MyI2C_Init();</span><br><span class="line">    </span><br><span class="line">	  MyI2C_Start();</span><br><span class="line">	  MyI2C_SendByte(<span class="number">0xD0</span>); <span class="comment">// 1101000 0 MPU6050地址+写位</span></span><br><span class="line">   <span class="comment">//  MyI2C_SendByte(0xB0); // 1101000 0 MPU6050地址+写位</span></span><br><span class="line">	  <span class="type">uint8_t</span> ack = MyI2C_ReceiveAck();</span><br><span class="line">	  MyI2C_Stop();</span><br><span class="line">	</span><br><span class="line">	 </span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			UsartSend(ack);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试是否能收到ACK，改变对应从机地址后是否应答</p>
</blockquote>
<h4 id="MPU6050-测试读写">MPU6050-测试读写</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyI2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		MyI2C_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	  <span class="comment">/*1.起始，对应从机地址MPU6050，应答*/</span></span><br><span class="line">		MyI2C_Start();</span><br><span class="line">	  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">		MyI2C_ReceiveAck();<span class="comment">//可以对应答位判断是否收到从机数据进行处理，这里默认应答</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	  <span class="comment">/*2.发送要写入的寄存器地址，应答*/</span></span><br><span class="line">	  MyI2C_SendByte(RegAddress);</span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">	</span><br><span class="line">	  <span class="comment">/*3.发送写入数据*/</span></span><br><span class="line">		MyI2C_SendByte(Data);</span><br><span class="line">		MyI2C_ReceiveAck(); <span class="comment">//这里只发送一个字节</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">//		  MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">	    <span class="comment">/*当要写入多个字节时，使用循环依次将数组的各个字节发送出去*/</span></span><br><span class="line">	  </span><br><span class="line">		<span class="comment">/*4.结束*/</span></span><br><span class="line">	  MyI2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> Data;</span><br><span class="line">	</span><br><span class="line">		MyI2C_Start();</span><br><span class="line">	  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">		</span><br><span class="line">	  MyI2C_SendByte(RegAddress);</span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*前一半为写的时序*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*后一半为读的时序*/</span></span><br><span class="line">	  MyI2C_Start();<span class="comment">//Sr</span></span><br><span class="line">	  MyI2C_SendByte(MPU6050_ADDRESS|<span class="number">0x01</span>);<span class="comment">//最后一位改成读</span></span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*接收从机数据*/</span></span><br><span class="line">	  Data = MyI2C_ReceiveByte();</span><br><span class="line">		MyI2C_SendAck(<span class="number">1</span>);<span class="comment">//想继续读数据给应答，这里只读一位，直接不应答了</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//		    Datas[i] = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">//        if(i==7)</span></span><br><span class="line"><span class="comment">//				&#123;</span></span><br><span class="line"><span class="comment">//					MyI2C_SendAck(1);//最后一位读取后不应答</span></span><br><span class="line"><span class="comment">//					break;</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line"><span class="comment">//				MyI2C_SendAck(0);//读取多个数据给应答</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		多个数据读取</span></span><br><span class="line">    </span><br><span class="line">	  MyI2C_Stop();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="读功能">读功能</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> Id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	 UsartInit();</span><br><span class="line">	 MPU6050_Init();</span><br><span class="line">    </span><br><span class="line">	  <span class="comment">/*读取寄存器*/</span></span><br><span class="line">    Id = MPU6050_ReadReg(<span class="number">0x75</span>);<span class="comment">//WHO_AM_I，ID寄存器</span></span><br><span class="line">	 </span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			UsartSend(Id);</span><br><span class="line">			Delay_ms(<span class="number">2000</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241218220447684-173752975558895.png" alt="image-20241218220447684"></p>
<blockquote>
<p>读读取0x75后，得到的结果是0x68，与手册对应代表一字节时序正确</p>
</blockquote>
<h5 id="写功能">写功能</h5>
<p><code>在使用写功能是必须先接触睡眠模式，否则操控其他寄存器无效</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241218220917107-173752975558996.png" alt="image-20241218220917107"></p>
<blockquote>
<p>睡眠模式由该电源资源管理寄存器的SLEEP位控制，对应寄存器地址为0x6B，初始值为0x40(0100000)，SLEEP位为1</p>
<p><strong>只需要对该寄存器写入0x00即可</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	  <span class="type">uint8_t</span> Data = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		LED_Init();</span><br><span class="line"></span><br><span class="line">	  UsartInit();</span><br><span class="line">	  MPU6050_Init();</span><br><span class="line">	  </span><br><span class="line">	  MPU6050_WriteReg(<span class="number">0x6B</span>,<span class="number">0x00</span>);<span class="comment">//电源资源管理寄存器，必选先接触睡眠模式</span></span><br><span class="line">	  </span><br><span class="line">	  MPU6050_WriteReg(<span class="number">0x19</span>,<span class="number">0xAA</span>);<span class="comment">//采样分频寄存器</span></span><br><span class="line">    </span><br><span class="line">	  Data = MPU6050_ReadReg(<span class="number">0x19</span>);</span><br><span class="line">	   </span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			UsartSend(Data);</span><br><span class="line">			Delay_ms(<span class="number">2000</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试发现对应寄存器值修改成功，串口显示AA</p>
</blockquote>
<h4 id="MPU6050-读取加速度-角速度">MPU6050-读取加速度/角速度</h4>
<blockquote>
<p>当需要使用的寄存器宏定义比较多时，建议单独创建头文件管理。</p>
<p>该头文件为MPU6050部分寄存器，从MPU6050寄存器手册搬过来即可</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_REG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_REG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_SMPLRT_DIV		0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_CONFIG			0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_CONFIG		0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_CONFIG	0x1C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_XOUT_H	0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_XOUT_L	0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_YOUT_H	0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_YOUT_L	0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_ZOUT_H	0x3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_ACCEL_ZOUT_L	0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_TEMP_OUT_H		0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_TEMP_OUT_L		0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_XOUT_H		0x43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_XOUT_L		0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_YOUT_H		0x45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_YOUT_L		0x46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_ZOUT_H		0x47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_GYRO_ZOUT_L		0x48</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_PWR_MGMT_1		0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_PWR_MGMT_2		0x6C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MPU6050_WHO_AM_I		0x75</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ, <span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">()</span></span><br><span class="line"><span class="comment">/*读取对应MPU6050ID*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyI2C.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_Reg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0 <span class="comment">//1101000 0</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	  <span class="comment">/*1.起始，对应从机地址MPU6050，应答*/</span></span><br><span class="line">		MyI2C_Start();</span><br><span class="line">	  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">		MyI2C_ReceiveAck();<span class="comment">//可以对应答位判断是否收到从机数据进行处理，这里默认应答</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	  <span class="comment">/*2.发送要写入的寄存器地址，应答*/</span></span><br><span class="line">	  MyI2C_SendByte(RegAddress);</span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">	</span><br><span class="line">	  <span class="comment">/*3.发送写入数据*/</span></span><br><span class="line">		MyI2C_SendByte(Data);</span><br><span class="line">		MyI2C_ReceiveAck(); <span class="comment">//这里只发送一个字节</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">//		  MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">	    <span class="comment">/*当要写入多个字节时，使用循环依次将数组的各个字节发送出去*/</span></span><br><span class="line">	  </span><br><span class="line">		<span class="comment">/*4.结束*/</span></span><br><span class="line">	  MyI2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> Data;</span><br><span class="line">	</span><br><span class="line">		MyI2C_Start();</span><br><span class="line">	  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">		</span><br><span class="line">	  MyI2C_SendByte(RegAddress);</span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*前一半为写的时序*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*后一半为读的时序*/</span></span><br><span class="line">	  MyI2C_Start();<span class="comment">//Sr</span></span><br><span class="line">	  MyI2C_SendByte(MPU6050_ADDRESS|<span class="number">0x01</span>);<span class="comment">//最后一位改成读</span></span><br><span class="line">		MyI2C_ReceiveAck();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*接收从机数据*/</span></span><br><span class="line">	  Data = MyI2C_ReceiveByte();</span><br><span class="line">		MyI2C_SendAck(<span class="number">1</span>);<span class="comment">//想继续读数据给应答，这里只读一位，直接不应答了</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//		    Datas[i] = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">//        if(i==7)</span></span><br><span class="line"><span class="comment">//				&#123;</span></span><br><span class="line"><span class="comment">//					MyI2C_SendAck(1);//最后一位读取后不应答</span></span><br><span class="line"><span class="comment">//					break;</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line"><span class="comment">//				MyI2C_SendAck(0);//读取多个数据给应答</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		多个数据读取</span></span><br><span class="line">    </span><br><span class="line">	  MyI2C_Stop();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主要修改如下*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		MyI2C_Init();</span><br><span class="line">	  MPU6050_WriteReg(MPU6050_PWR_MGMT_1,<span class="number">0x01</span>);<span class="comment">//配置电源管理寄存器1,解除睡眠选择陀螺仪时钟</span></span><br><span class="line">	  MPU6050_WriteReg(MPU6050_PWR_MGMT_2,<span class="number">0x00</span>);<span class="comment">//配置电源管理寄存器2,6个轴均不待机</span></span><br><span class="line">	</span><br><span class="line">	  MPU6050_WriteReg(MPU6050_SMPLRT_DIV,<span class="number">0x09</span>);<span class="comment">//配置采样分频寄存器，选择10分频，滤波参数给最大</span></span><br><span class="line">		MPU6050_WriteReg(MPU6050_CONFIG	,<span class="number">0x06</span>);<span class="comment">//配置寄存器，滤波参数110</span></span><br><span class="line">	  MPU6050_WriteReg(MPU6050_GYRO_CONFIG	,<span class="number">0x18</span>);<span class="comment">//陀螺仪最大量程</span></span><br><span class="line">	  MPU6050_WriteReg(MPU6050_ACCEL_CONFIG,<span class="number">0x18</span>);<span class="comment">//加速度计最大量程</span></span><br><span class="line">	<span class="comment">/*这里配置完后，陀螺仪内部就在不停的转换了，对应数据存放在对应各轴数据寄存器中*/</span></span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对应6轴的数据都是16位，分为高8位和低8位，分别读取高8位和低8位拼接后*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,<span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint16_t</span> DataH,DataL;</span><br><span class="line">	</span><br><span class="line">		DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">	  </span><br><span class="line">		*AccX =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">	  DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">	</span><br><span class="line">	  *AccY =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	  </span><br><span class="line">	  DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">	</span><br><span class="line">	  *AccZ =    (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">	  DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">	</span><br><span class="line">	  *GyroX = 	(DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">	  </span><br><span class="line">		DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">		</span><br><span class="line">	  *GyroY =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">		DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">		</span><br><span class="line">	  *GyroZ =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里的读取分为12次，我们可以改进，使用连续读取的时序，大大提升效率*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"><span class="type">int16_t</span> AX=<span class="number">0</span>,AY=<span class="number">0</span>,AZ=<span class="number">0</span>,GX=<span class="number">0</span>,GY=<span class="number">0</span>,GZ=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">	  <span class="type">uint8_t</span> Data = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	  LED_Init();</span><br><span class="line">   </span><br><span class="line">	  UsartInit();</span><br><span class="line">	</span><br><span class="line">	  MPU6050_Init();</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">			MPU6050_GetData(&amp;AX,&amp;AY,&amp;AZ,&amp;GX,&amp;GY,&amp;GZ);</span><br><span class="line">			UsartSend(AX);</span><br><span class="line">			UsartSend(AY);</span><br><span class="line">			UsartSend(AZ);</span><br><span class="line">			UsartSend(GX);</span><br><span class="line">			UsartSend(GY);</span><br><span class="line">			UsartSend(GZ);</span><br><span class="line">			Delay_ms(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>对应数据：</code></p>
<p>X轴加速度：水平基本没加速度</p>
<p>Y轴加速度：水平基本没加速度</p>
<p>Z轴加速度：平放在水面通过得到AZ，我们选择的是满量程16g(看手册上)</p>
<p>对应加速度计算公式为 AZ / 32768 =  x / 16g ，解方程的得到的x为Z轴方向加速度，这个值理论上来说应该是重力加速度g</p>
<hr>
<p>X轴角速度：</p>
<p>Y轴角速度：</p>
<p>Z轴角速度：</p>
<hr>
<p><strong>上方所有数据计算的公式为：</strong></p>
<p><strong>（读取的数据）/（32768） = （x）  /（ 满量程）</strong></p>
<p><strong>解出对应x的值即可</strong></p>
</blockquote>
<h3 id="I2C外设-硬件读写I2C">I2C外设(硬件读写I2C)</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241220151445355-173752975558997.png" alt="image-20241220151445355"></p>
<blockquote>
<p>由硬件电路自动实现引脚电平反转，软件只需要写入<strong>控制寄存器CR</strong>和<strong>数据寄存器DR</strong>即可。</p>
<p>为了监控时序状态，软件还得读取<strong>状态寄存器SR</strong>来了解当前的外设电路处于什么状态</p>
<p><strong>这就像开车一样：写入控制寄存器CR，就像是踩油门、打方向盘来控制汽车的运行，读取状态寄存器SR，就像是观看仪表盘，来了解汽车的运行状态。</strong></p>
<p>使用库函数封装后，有了I2C外设，硬件就可以自动实现时序，就可以减轻CPU的负担，节省软件资源</p>
<hr>
<p><strong>一主多从</strong>：一个主机多个从设备…</p>
<p><strong>多主机模式</strong>：分为固定多主机和可变多主机</p>
<ul>
<li>固定多主机：固定有几个主机，多个主机控制产生冲突时需要仲裁</li>
<li>可变多主机：总线上无固定主机和从机，任何设备可以在总线空闲时主动跳出作为主机与其他从机通信，通信完成后回归从机</li>
</ul>
<p><code>对于STM32使用的是可变多主机模型</code></p>
<hr>
<p><strong>地址模式</strong>：7/10位</p>
<p>7位：一个字节中的前7位为设备地址，最后一位是读写位。</p>
<p>10位：使用两个字节，如果第二个字节也是寻址的话，第一个字节的前5位必须是11110<code>(10位地址标志位)</code>，第一个字节剩下2位和第二个字节的8位一共10位作为寻址</p>
<p>7位与10位区别：前5位是否为11110</p>
<hr>
<p><strong>通讯速度</strong>：</p>
<ul>
<li>
<p>标准速度：100KHz</p>
</li>
<li>
<p>快速速度：400KHz</p>
</li>
</ul>
<hr>
<p><strong>DMA</strong>：…</p>
<hr>
<p><strong>兼容SMBus：System Management Bus-系统管理总线</strong></p>
<p>类似于I2C，是兼容的另一种总线</p>
</blockquote>
<p><strong>对应寄存器，标志位查看芯片参考手册的I2C接口模块阅读即可!!!</strong></p>
<h4 id="I2C框图">I2C框图</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241221144132847-173752975558998.png" alt="image-20241221144132847"></p>
<blockquote>
<p><strong>对应使用时一般是GPIO口复用，查询对应引脚定义表即可，使用<code>硬件I2C时只能使用指定的引脚</code>，不能像<code>软件I2C那样引脚任意指定</code></strong></p>
<hr>
<p>由于I2C是半双工，只有<code>一组移位寄存器和数据寄存器</code>，接收和发送都是使用这组，而串口有两组</p>
<hr>
<p><code>比较器和地址寄存器：</code>从机模式使用，支持同时响应两个从机地址，在多主机模式下使用</p>
<hr>
<p><code>帧错误校验PEC计算</code>：CRC校验算法，数据有效性验证，对应数据错误标志位置位</p>
<hr>
<p><code>中断</code>：某个紧急事件发生后可以申请中断</p>
<hr>
<p><code>DMA</code>：配合提高效率</p>
</blockquote>
<blockquote>
<p>SMBALERT是SMBus相关，I2C使用时不用管它</p>
</blockquote>
<h4 id="I2C基本结构">I2C基本结构</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241221150048169-173752975558999.png" alt="image-20241221150048169"></p>
<blockquote>
<p>图中是简化的一主多从结构，如果是多主机应该还有时钟输入</p>
<p>图中的两个GPIO：一个是复用输入，另一个是复用输出</p>
<hr>
<p><strong>移位寄存器和数据寄存器DR</strong>：</p>
<p><code>发送时数据先写入数据寄存器DR，如果移位寄存器没有数据，就会转到移位寄存器进行发送</code></p>
</blockquote>
<h4 id="主机发送流程">主机发送流程</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241221162408618-1737529755589100.png" alt="image-20241221162408618"></p>
<blockquote>
<p><code>EV事件</code> 是多个标志位的集合，所有标志位在手册中都可以找到</p>
<p>EV5,EV6,EV8…</p>
<p>流程简化下来就是：操作-等待-操作-等待…</p>
</blockquote>
<h4 id="主机接收流程">主机接收流程</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241221162433975-1737529755590101.png" alt="image-20241221162433975"></p>
<blockquote>
<p>图中给的时序是当前地址读的，想要指定地址读数据需要组合一下即可</p>
<p>具体的流程见下面的代码</p>
</blockquote>
<h4 id="从机发送接收">从机发送接收</h4>
<p>见手册！！！</p>
<h4 id="库函数-9">库函数</h4>
<p><code>初始化函数：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_DeInit</span><span class="params">(I2C_TypeDef* I2Cx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Init</span><span class="params">(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_StructInit</span><span class="params">(I2C_InitTypeDef* I2C_InitStruct)</span>;</span><br></pre></td></tr></table></figure>
<p><code>起始条件和终止条件：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_GenerateSTART</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//调用该函数生成起始条件，对I2C_CR1寄存器中的START位置1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_GenerateSTOP</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//调用该函数生成终止条件，对I2C_CR1寄存器中的STOP位置1</span></span><br></pre></td></tr></table></figure>
<p><code>应答ACK：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_AcknowledgeConfig</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//手动ACK配置，在收到一个字节后，是否给从机应答</span></span><br></pre></td></tr></table></figure>
<p><code>发送和接收数据：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_SendData</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint8_t</span> Data)</span>;<span class="comment">//写入数据到数据寄存器DR</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">I2C_ReceiveData</span><span class="params">(I2C_TypeDef* I2Cx)</span>;<span class="comment">//读取数据寄存器DR作为返回值，接收到下一个字节之前读出数据寄存器，防止数据覆盖，实现连续数据流</span></span><br></pre></td></tr></table></figure>
<p><code>发送地址专用函数:</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_Send7bitAddress</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint8_t</span> Address, <span class="type">uint8_t</span> I2C_Direction)</span>;<span class="comment">//主要用于设置自动设置读写位</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个函数可以不使用，而是自己确定读写位的最后一位，直接使用SendData函数进行发送</p>
</blockquote>
<p><code>中断配置：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_ITConfig</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint16_t</span> I2C_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>
<p><code>DMA相关：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_DMACmd</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_DMALastTransferCmd</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>
<p><code>使能函数：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_Cmd</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>
<p><code>标志位：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">I2C_GetFlagStatus</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_ClearFlag</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_FLAG)</span>;</span><br><span class="line"><span class="comment">/*中断外使用*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ITStatus <span class="title function_">I2C_GetITStatus</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_ClearITPendingBit</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_IT)</span>;</span><br><span class="line"><span class="comment">/*中断中使用*/</span></span><br></pre></td></tr></table></figure>
<p><code>状态监控：给了三种方法</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一种：基本状态监控，同时判断一个或多个标志位，来确定EV几EV几这个状态是否发生,对应发送接收流程*/</span></span><br><span class="line">ErrorStatus <span class="title function_">I2C_CheckEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span>;<span class="comment">//推荐使用！！！,第二个参数为监测的事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第二种：高级状态监控，实际上并不高级，对应库函数注释可以找到是将SR1和SR2这两个状态寄存器拼接成16位数据然后给你就完了*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">I2C_GetLastEvent</span><span class="params">(I2C_TypeDef* I2Cx)</span>;。<span class="comment">//一般不使用，了解即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三种：基于标志位的状态监控，我们一直使用的判断某个标志位方法*/</span></span><br><span class="line">FlagStatus <span class="title function_">I2C_GetFlagStatus</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_FLAG)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="I2C外设配置">I2C外设配置</h4>
<p><code>参考上方I2C框图和基本结构进行配置：</code></p>
<ol>
<li><strong>开启I2C外设和对应GPIO口的时钟</strong></li>
<li><strong>结构体配置对应GPIO口为复用开漏输出模式(区别：软件模拟I2C是直接开漏没有复用开漏)</strong></li>
<li><strong>结构体配置I2C</strong></li>
<li><strong>使能I2C，I2C_Cmd</strong></li>
</ol>
<h4 id="实验-硬件I2C读取MPU6050数据">实验-硬件I2C读取MPU6050数据</h4>
<blockquote>
<p>部分与软件I2C相同，去掉了软件I2C最底层的部分，使用库函数代替</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,<span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;MyI2C.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_Reg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0 <span class="comment">//1101000 0</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序中出现大量while等待的情况比较危险，容易发生卡死的现象，所以我们需要让它超时退出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	不必使用定时器，我们只需要简单用一个计数值循环判断即可，该Timeout值根据实际情况更改大小，while循环正常不会执行到Timeout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="type">uint32_t</span> Timeout;</span><br><span class="line">	 Timeout = <span class="number">10000</span>;</span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2Cx,I2C_EVENT)!=SUCCESS)</span><br><span class="line">	 &#123;</span><br><span class="line">		 Timeout --;</span><br><span class="line">		 <span class="keyword">if</span>(Timeout ==<span class="number">0</span>)</span><br><span class="line">		 &#123;</span><br><span class="line">			 <span class="keyword">break</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该函数为CheckEvent的封装</span></span><br><span class="line"><span class="comment"> * 下方没有替换，该函数使用时只需要将使用while循环的部分直接使用该函数全部替换即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*软件I2C代码：*/</span></span><br><span class="line"><span class="comment">//	  /*1.起始，对应从机地址MPU6050，应答*/</span></span><br><span class="line"><span class="comment">//		MyI2C_Start();</span></span><br><span class="line"><span class="comment">//	  MyI2C_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">//		MyI2C_ReceiveAck();//可以对应答位判断是否收到从机数据进行处理，这里默认应答</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	  /*2.发送要写入的寄存器地址，应答*/</span></span><br><span class="line"><span class="comment">//	  MyI2C_SendByte(RegAddress);</span></span><br><span class="line"><span class="comment">//		MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	  /*3.发送写入数据*/</span></span><br><span class="line"><span class="comment">//		MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">//		MyI2C_ReceiveAck(); //这里只发送一个字节</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">////	  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">////		&#123;</span></span><br><span class="line"><span class="comment">////			MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">////		  MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">////		&#125;</span></span><br><span class="line"><span class="comment">//	    /*当要写入多个字节时，使用循环依次将数组的各个字节发送出去*/</span></span><br><span class="line"><span class="comment">//	  </span></span><br><span class="line"><span class="comment">//		/*4.结束*/</span></span><br><span class="line"><span class="comment">//	  MyI2C_Stop();</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">	 <span class="comment">/*硬件I2C下使用的都是非阻塞的函数，需要等待标志位结束才能保证对应波形执行完成*/</span></span><br><span class="line">	 <span class="comment">/*对应等待的事件根据硬件I2C发送流程中来写*/</span></span><br><span class="line">	 </span><br><span class="line">	 I2C_GenerateSTART(I2C1,ENABLE);<span class="comment">//1.发送起始条件</span></span><br><span class="line">		<span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)!=SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;<span class="comment">//等待EV5事件完成</span></span><br><span class="line">	 </span><br><span class="line">	 I2C_Send7bitAddress(I2C1,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//2.发送从机地址，第三个参数自动置读写位,应答位会自动处理</span></span><br><span class="line">		<span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)!=SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;<span class="comment">//等待发送模式的EV6事件完成</span></span><br><span class="line">		 </span><br><span class="line">	 I2C_SendData(I2C1,RegAddress);<span class="comment">//3.发送指定寄存器地址</span></span><br><span class="line">		<span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTING)!=SUCCESS)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;<span class="comment">//等待EV8事件</span></span><br><span class="line">		 </span><br><span class="line">	 <span class="comment">/*发送多个字节数据时，中间的数据发送完成后等待EV8事件，而最后一个字节变为等待EV8_2事件*/</span></span><br><span class="line">	 </span><br><span class="line">	 I2C_SendData(I2C1,Data);<span class="comment">//4.发送要写入的数据</span></span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)!=SUCCESS)	</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;<span class="comment">//发送最后一个字节完成后，等待EV8_2事件</span></span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">	 I2C_GenerateSTOP(I2C1,ENABLE);<span class="comment">//5.终止条件</span></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> Data;</span><br><span class="line">	</span><br><span class="line">			<span class="comment">/*软件模拟I2C:*/</span></span><br><span class="line"><span class="comment">//		MyI2C_Start();</span></span><br><span class="line"><span class="comment">//	  MyI2C_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">//		MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	  MyI2C_SendByte(RegAddress);</span></span><br><span class="line"><span class="comment">//		MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	/*前一半为写的时序*/</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	/*后一半为读的时序*/</span></span><br><span class="line"><span class="comment">//	  MyI2C_Start();//Sr</span></span><br><span class="line"><span class="comment">//	  MyI2C_SendByte(MPU6050_ADDRESS|0x01);//最后一位改成读</span></span><br><span class="line"><span class="comment">//		MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//	/*接收从机数据*/</span></span><br><span class="line"><span class="comment">//	  Data = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">//		MyI2C_SendAck(1);//想继续读数据给应答，这里只读一位，直接不应答了</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">////	  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">////		&#123;</span></span><br><span class="line"><span class="comment">////		    Datas[i] = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">////        if(i==7)</span></span><br><span class="line"><span class="comment">////				&#123;</span></span><br><span class="line"><span class="comment">////					MyI2C_SendAck(1);//最后一位读取后不应答</span></span><br><span class="line"><span class="comment">////					break;</span></span><br><span class="line"><span class="comment">////				&#125;</span></span><br><span class="line"><span class="comment">////				MyI2C_SendAck(0);//读取多个数据给应答</span></span><br><span class="line"><span class="comment">////		&#125;</span></span><br><span class="line"><span class="comment">////		多个数据读取</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//	  MyI2C_Stop();</span></span><br><span class="line">		</span><br><span class="line">	 <span class="comment">/*硬件I2C:实现指定地址接收一个字节，使用的是复合形式*/</span>	</span><br><span class="line">	 I2C_GenerateSTART(I2C1,ENABLE);<span class="comment">//1.发送起始条件</span></span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)!=SUCCESS);<span class="comment">//起始条件等待EV5事件完成</span></span><br><span class="line">	 </span><br><span class="line">	 I2C_Send7bitAddress(I2C1,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//2.发送从机地址，第三个参数自动置读写位,应答位会自动处理</span></span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)!=SUCCESS)<span class="comment">//等待发送模式的EV6事件完成</span></span><br><span class="line">		 </span><br><span class="line">	 I2C_SendData(I2C1,RegAddress);<span class="comment">//3.发送指定寄存器地址</span></span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)!=SUCCESS)<span class="comment">//这里因为是数据流最后一个字节所以变成了等待EV8_2事件</span></span><br><span class="line">		</span><br><span class="line">	 <span class="comment">/*前一半为写的时序*/</span></span><br><span class="line">	</span><br><span class="line">   <span class="comment">/*后一半为读的时序*/</span></span><br><span class="line">	 </span><br><span class="line">	 I2C_GenerateSTART(I2C1,ENABLE);<span class="comment">//4.重复起始条件。这个地方会等待上方字节发送完成后才会产生，所以上方用TRANSMITTING或TRANSMITTED都可以</span></span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)!=SUCCESS);<span class="comment">//起始条件等待EV5事件完成</span></span><br><span class="line">		</span><br><span class="line">	 I2C_Send7bitAddress(I2C1,MPU6050_ADDRESS,I2C_Direction_Receiver);<span class="comment">//2.发送从机地址，这个地方应变成读的方向，第三个参数修改</span></span><br><span class="line">	 <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)!=SUCCESS)<span class="comment">//等待接收模式的EV6事件完成，与上方EV6事件不同</span></span><br><span class="line">		</span><br><span class="line">	 	 </span><br><span class="line">	 <span class="comment">//如果只需要读取一个字节，需要恰好在EV6之后，立刻把ACK置0，STOP置1，避免在本次ACK发送之后才去置0，这样时序会多一个字节</span></span><br><span class="line">		</span><br><span class="line">	 <span class="comment">//如果是需要读取多个字节，直接等待EV7事件，读取DR,就能收到数据，依次接收，直到最后一个字节之前也就是EV7_1事件(EV7_1不用等待)，提前把ACK置0，STOP置1</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	 	I2C_AcknowledgeConfig(I2C1, DISABLE);</span><br><span class="line">		I2C_GenerateSTOP(I2C1,ENABLE);<span class="comment">//STOP置1后该终止条件不会截断当前字节，会等当前字节接收完成后，再产生终止条件波形</span></span><br><span class="line">	 </span><br><span class="line">		<span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)!=SUCCESS)<span class="comment">//等待EV7事件完成</span></span><br><span class="line">		Data = I2C_ReceiveData(I2C1);<span class="comment">//5.接收从机数据</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"><span class="comment">//     for(int i=0;i&lt;N;i++)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			</span></span><br><span class="line"><span class="comment">//			if(i==N-1)</span></span><br><span class="line"><span class="comment">//			I2C_AcknowledgeConfig(I2C1, DISABLE);</span></span><br><span class="line"><span class="comment">//			I2C_GenerateSTOP(I2C1,ENABLE);//STOP置1后该终止条件不会截断当前字节，会等当前字节接收完成后，再产生终止条件波形</span></span><br><span class="line"><span class="comment">//		 </span></span><br><span class="line"><span class="comment">//			while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)!=SUCCESS)//等待EV7事件完成</span></span><br><span class="line"><span class="comment">//			Data = I2C_ReceiveData(I2C1);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//   接收多个字节:使用循环处理，最后一个字节前执行一次ACK=0和STOP</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		I2C_AcknowledgeConfig(I2C1, ENABLE);<span class="comment">//最后再恢复默认ACK=1，方便收多个字节</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*软件I2C:*/</span></span><br><span class="line"><span class="comment">//		MyI2C_Init();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*硬件I2C:*/</span></span><br><span class="line">	  <span class="comment">/*第1步*/</span></span><br><span class="line">	  RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1,ENABLE);</span><br><span class="line">	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">    </span><br><span class="line">	  <span class="comment">/*第2步*/</span></span><br><span class="line">	  GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">		GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2|GPIO_Pin_3;</span><br><span class="line">		GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	  </span><br><span class="line">		<span class="comment">/*第3步*/</span></span><br><span class="line">	  I2C_InitTypeDef I2C_InitStruct;</span><br><span class="line">		I2C_InitStruct.I2C_Mode = I2C_Mode_I2C ;</span><br><span class="line">		I2C_InitStruct.I2C_Ack = I2C_Ack_Enable;<span class="comment">//确认要发送应答位</span></span><br><span class="line">		I2C_InitStruct.I2C_ClockSpeed = <span class="number">100000</span>;<span class="comment">//最大为400KHZ，0~100KHZ为标准速度，100~400khz为快速</span></span><br><span class="line">	  I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_2;<span class="comment">//时钟占空比参数，用与快速模式，只有当时钟频率大于100Khz才有效，小于100Khz是占空比固定为1：1</span></span><br><span class="line">		I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;<span class="comment">//响应7或10位地址，stm32作为从机时才使用。作为主机随便给</span></span><br><span class="line">		I2C_InitStruct.I2C_OwnAddress1 = <span class="number">0x00</span>;	<span class="comment">//自身地址1，stm32作为从机才使用，方便别的主机呼叫，指定地址位数=上一个参数选择响应的位数。作为主机随便给</span></span><br><span class="line">	 </span><br><span class="line">	  <span class="comment">/*第4步*/</span></span><br><span class="line">	  I2C_Cmd(I2C1,ENABLE);</span><br><span class="line">  </span><br><span class="line">		MPU6050_WriteReg(MPU6050_PWR_MGMT_1,<span class="number">0x01</span>);<span class="comment">//配置电源管理寄存器1,解除睡眠选择陀螺仪时钟</span></span><br><span class="line">	  MPU6050_WriteReg(MPU6050_PWR_MGMT_2,<span class="number">0x00</span>);<span class="comment">//配置电源管理寄存器2,6个轴均不待机</span></span><br><span class="line">	</span><br><span class="line">	  MPU6050_WriteReg(MPU6050_SMPLRT_DIV,<span class="number">0x09</span>);<span class="comment">//配置采样分频寄存器，选择10分频，滤波参数给最大</span></span><br><span class="line">		MPU6050_WriteReg(MPU6050_CONFIG	,<span class="number">0x06</span>);<span class="comment">//配置寄存器，滤波参数110</span></span><br><span class="line">	  MPU6050_WriteReg(MPU6050_GYRO_CONFIG	,<span class="number">0x18</span>);<span class="comment">//陀螺仪最大量程</span></span><br><span class="line">	  MPU6050_WriteReg(MPU6050_ACCEL_CONFIG,<span class="number">0x18</span>);<span class="comment">//加速度计最大量程</span></span><br><span class="line">	<span class="comment">/*这里配置完后，陀螺仪内部就在不停的转换了，对应数据存放在对应各轴数据寄存器中*/</span></span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对应6轴的数据都是16位，分为高8位和低8位，分别读取高8位和低8位拼接后*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,</span></span><br><span class="line"><span class="params">										 <span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint16_t</span> DataH,DataL;</span><br><span class="line">	</span><br><span class="line">		DataH =  MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">	  </span><br><span class="line">		*AccX =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">	  DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">	  DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">	</span><br><span class="line">	  *AccY =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	  </span><br><span class="line">	  DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">	</span><br><span class="line">	  *AccZ =    (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">	  DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">	</span><br><span class="line">	  *GyroX = 	(DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">	  </span><br><span class="line">		DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">		</span><br><span class="line">	  *GyroY =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">		DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">	  DataL =  MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">		</span><br><span class="line">	  *GyroZ =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里的读取分为12次，我们可以改进，使用连续读取的时序，大大提升效率*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序中出现大量while等待的情况比较危险，容易发生卡死的现象，所以我们需要让它超时退出。</p>
<p>不必使用定时器，我们只需要简单用一个计数值循环判断即可，该Timeout值根据实际情况更改大小，while循环正常不会执行到Timeout</p>
</blockquote>
<h3 id="软件和硬件I2C对比">软件和硬件I2C对比</h3>
<p><code>波形对比：</code></p>
<p><strong>上方是软件波形，下方是硬件波形</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20241221171144668-1737529755590102.png" alt=""></p>
<blockquote>
<p><strong>从时钟线的规整程度上看：</strong></p>
<p>硬件I2C：SCL波形会更加规整，每个时钟的周期、占空比都非常一致</p>
<p>软件I2C：由于操作引脚后都加了延时，有时候加的多有时候加的少，所以软件时序的时钟周期、占空比可能不规整，但由于是同步时序不规整也不会影响通信</p>
<hr>
<p>在SCL低电平写，高电平读的时候，可以在整个电平的任意时候都可以读写，但是一般要求保证尽早原则，所以可以认为SCL下降沿写，上升沿读。</p>
<p>软件波形中，因为操作端口后有延时，所以都是等了一会在写的</p>
<p>硬件波形中，可以看到SCL下降沿的时候，SDA也立马切换数据。读写都是紧贴上下沿进行</p>
<hr>
<p><strong>应答结束时最为明显：</strong></p>
<p>从机在SCL下降沿立刻释放SDA，但是软件I2C由于有延时，所以在应答结束后主机等了一会才变换数据，所以在软件I2C中有一个短暂的高电平后才拉低SDA。</p>
<p>硬件I2C中应答结束后，从机在SCL下降沿立刻释放SDA，同时主机也立刻拉低SDA，所以就是直接一个小尖峰。</p>
</blockquote>
<blockquote>
<p><code>软件模拟I2C (Bit-Banging)：</code></p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>灵活性高</strong>：可以完全控制每个I2C数据位的发送和接收过程，适用于没有硬件I2C模块的STM32型号，或者需要多个I2C总线时，可以通过软件模拟多个I2C设备。</li>
<li><strong>成本低</strong>：不依赖硬件I2C外设，因此适合成本敏感的应用。</li>
<li><strong>可以在任意GPIO上运行</strong>：可以自定义SCL和SDA引脚，不需要专用的硬件I2C引脚。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>效率低</strong>：每个数据位的发送和接收都需要进行软件延时处理，导致比硬件I2C慢得多。对于高速通信，可能无法满足实时性要求。</li>
<li><strong>占用CPU资源</strong>：模拟I2C需要CPU不断参与数据的传输，可能影响系统其他任务的执行，尤其是当系统负载较高时。</li>
<li><strong>稳定性差</strong>：如果系统中有其他任务需要占用大量CPU时间，可能会导致I2C通信不稳定，或者丢失数据。</li>
</ul>
<hr>
<p><code>硬件I2C (利用硬件I2C模块)：</code></p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>高效</strong>：硬件I2C通过专用的I2C控制器进行数据传输，不需要CPU参与数据位的传送，速度快且稳定，通常能够提供更高的传输速率。</li>
<li><strong>节省CPU资源</strong>：硬件I2C控制器可以自动完成数据传输任务，释放CPU处理其他任务，特别适合多任务或实时系统。</li>
<li><strong>稳定性强</strong>：硬件I2C模块有专门的硬件实现，避免了由于软件延迟或CPU占用过高导致的通信不稳定问题。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>硬件资源有限</strong>：不同型号的STM32有不同数量的硬件I2C模块，因此可用的硬件I2C通道有限。如果需要多个I2C总线，可能无法满足需求。</li>
<li><strong>引脚固定</strong>：硬件I2C通常需要专用的引脚（SCL和SDA），不能任意选择GPIO。如果这些引脚已被占用或在项目设计中不方便，可能会限制设计的灵活性。</li>
<li><strong>复杂性较高</strong>：硬件I2C需要配置硬件相关的寄存器和管理中断等，比软件模拟I2C配置复杂一些。</li>
</ul>
<hr>
<p><strong>使用场景总结</strong>：</p>
<p>**软件模拟I2C：**灵活、成本低，但效率低、占用CPU资源。不受限制，引脚够基本上就是想开几路就是几路</p>
<p>硬件I2C不足时可以使用软件I2C</p>
<p>**硬件I2C：**效率高、稳定，节省CPU资源，但受硬件资源和引脚限制。</p>
<p>对性能指标要求比较高，实时性、多任务等时使用硬件I2C</p>
</blockquote>
<h2 id="SPI">SPI</h2>
<h3 id="SPI介绍">SPI介绍</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101153932297-1737529755591103.png" alt="image-20250101153932297"></p>
<blockquote>
<p>图中的四种使用SPI通信的芯片：引脚名称可能不标注，可以查看对应手册了解</p>
<ol>
<li>W25QXX，FLASH存储芯片，作为从机，引脚写的DI和DO</li>
<li>OLED屏幕</li>
<li>2.4G无线通信模块，芯片型号为NRF24L01</li>
<li>Micro SD卡：官方通信协议为SDIO，但也支持SPI协议，可以对其进行读写操作</li>
</ol>
</blockquote>
<blockquote>
<p><strong>SPI特点：同步，全双工，四根通信线</strong></p>
<hr>
<p><code>SPI的四根线：</code></p>
<ol>
<li><strong>SCK(Serial Clock)</strong>：时钟线，也叫做SCLK、CLK、CK等</li>
<li><strong>MOSI(Master Output Slave Input)</strong>：主机输出从机输入线，也叫做DI(Data Output-对应从机输入)</li>
<li><strong>MISO(Master Output Slave Input)</strong>：主机输入从机输出线，也叫做DO(Data Input-对应从机输出))</li>
<li><strong>SS(Slave Select)</strong>：从机选择线，片选，也叫做NSS(Not Slave Select)、CS(Chip Select-片选)，有几个从机就用几条线。这样以后就不用像I2C那样先发送一个字节寻址、分配地址等操作</li>
</ol>
<p>注意：主机和从机不能同时配置为输入或输出</p>
<hr>
<p><strong>SPI没有应答位，SPI是不管你有没有收到信息的</strong></p>
<hr>
<p><code>SPI相对于I2C的优缺点：</code></p>
<ul>
<li>
<p><code>速度上：</code>SPI传输比I2C更快，SPI协议并没有严格规定最大传输速度，最大传输速度一般由芯片厂商的设计需求，如W25Q64存储器芯片，手册中写的是最大可达80MHz</p>
</li>
<li>
<p><code>设计上：</code>SPI设计比较简单粗暴，实现的功能没有I2C那么多，<strong>仅支持一主多从，不支持多主机</strong></p>
</li>
<li>
<p><code>开销上：</code>SPI的硬件开销比较大，通信线的个数比较多，通信过程中经常会有资源浪费的情况</p>
</li>
</ul>
</blockquote>
<h3 id="硬件电路-4">硬件电路</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101165230579-1737529755591104.png" alt="image-20250101165230579"></p>
<blockquote>
<p>主机一般是STM32，从机一般是存储器、显示屏、通信 模块、传感器等，对应有几个从设备就有几个SS线</p>
<hr>
<p><code>SCK：</code>时钟线完全由主机掌控，对于主机来说时钟线为输出，对于从机来说时钟线为输入</p>
<p><code>MOSI：</code>主机输出从机输入，左边主机对应MO，主机输出，右边从机SI，从机输入。数据从MOSI输出，所有从机从MOSI输入</p>
<p><code>MISO：</code>主机输入从机输入，与MOSI类似</p>
<p><code>SS：</code>从机选择线，低电平有效，主机初始化后所有的SS都输出高电平，代表都不指定，需要与谁通信，就将对应的SS线拉低即可，当对应从机通信完之后，对应SS线就重新置回高电平。同一时间只能选择一个从机(只能置一个为低电平)</p>
<hr>
<p><strong>输出引脚配置为推挽输出</strong>：高低电平均有很强驱动能力，使得SPI信号引脚上升沿和下降沿信号非常迅速，不像I2C那样下降沿迅速上升沿缓慢，所以SPI信号变化的快所以SPI具有更快的传输速度，一般的SPI信号都能轻松达到Mhz的速度级别。</p>
<p><code>输出引脚为：SCK、MOSI、SS</code></p>
<p><strong>输入引脚配置为浮空或上拉输入</strong></p>
<p><code>输入引脚为：MISO</code></p>
<p><code>SPI可能存在的冲突</code>：</p>
<p>​	对于SPI的从机MISO引脚，当某个从机的SS引脚被选择后，其他从机的SS引脚会被保持为高阻态，相当于断开不输出，这样可以防止一条线有多个输出而导致的电平冲突的问题</p>
</blockquote>
<h3 id="数据移位示意图">数据移位示意图</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101173950632-1737529755591105.png" alt="image-20250101173950632"></p>
<blockquote>
<p><strong>SPI数据是高位先行，通信基础是<code>交换一个字节</code>，数据收发都是基于<code>字节交换</code>这个基本单元进行</strong>。主机要发送的数据跑到从机，从机要发送的数据跑到主机，这样就可以实现发送一个字节、接收一个字节、发送同时接收一个字节<code>三种功能</code></p>
<p><strong>对于只想接收数据时</strong>：我们会随便发送数据(一般统一为0x00或0xFF)，把数据置换过来即可</p>
<p><strong>对于只想发送数据时</strong>：只需要把数据发送过去，对方置换过来的数据不管即可</p>
<hr>
<p><strong>这里波特率发生器就是时钟</strong></p>
<p>主机移位寄存器左边出去的数据通过MOSI引脚，输入到从机移位寄存器的右边，从机移位寄存器左边移出去的数据通过MISO引脚，输入到主机移位寄存器的右边，形成一个环</p>
<p><strong>每当规定的时钟沿(上升沿/下降沿)到来时，对应移位寄存器的最高位分别移动，分别放到MOSI和MISO的通信线上，然后对应的时钟沿(上升沿或下降沿)再次到来时，数据分别从MOSI和MISO线上，采样到从机和主机的最低位。这样就完成了一个时钟</strong></p>
<p>例：规定上升沿数据移动，下降沿数据采集。就是在上升沿时移位寄存器的最高位到对应的线上。下降沿时，会采样输入到对应的最低位。</p>
<hr>
</blockquote>
<h3 id="SPI时序基本单元">SPI时序基本单元</h3>
<ul>
<li><code>起始条件和终止条件:</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101174746261-1737529755591106.png" alt="image-20250101174746261"></p>
<blockquote>
<p>起始条件：SS由高到低，代表选中从机通信开始</p>
<p>结束条件：SS由低到高，代表结束选中从机通信结束</p>
<p>所以SS低电平期间就代表正在通信</p>
</blockquote>
<hr>
<p>​	<strong>SPI中有两个可以配置的位，每一位可以配置为1或0，组合起来就有模式0、模式1、模式2、模式共四种模式，但功能实际都是一样的，任意选择一种使用即可。</strong></p>
<p><code>CPOL(Clock Polarity)：</code><strong>时钟极性</strong>，决定空闲时SCK的低电平，值为0或1</p>
<p><code>CPHA(Clock Phase)：</code><strong>时钟相位</strong>，决定第一个时钟采样移入还是第二时钟采样移入，并不是规定上升沿采样还是下降沿采样，值为0或1</p>
<hr>
<ul>
<li><code>模式0：使用最多重点掌握！！！</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101175308487-1737529755591107.png" alt="image-20250101175308487"></p>
<blockquote>
<p>CPOL = 0：代表空闲状态SCK低电平</p>
<p>CPHA = 0：SCK<code>第一个</code>边沿<code>移入数据</code>，<code>第二个</code>边沿<code>移出数据</code>。</p>
<p><strong>由于数据需要先移出来，才能移入，所以SCK第一个边沿之前就要提前开始移出数据了。</strong></p>
<p>​	这里把SS当作了时钟下降沿所以要移出数据，MOSI就提前移出数据，等SCK上升沿来到，两个数据B7分别移入到主机和从机。然后SCK到下降沿，两个B6数据就移出，上升沿的两个B6数据采样输入到主机和从机…一直到B0最后一位，SS拉高，MOSI任意，MISO高阻态，这样一个字节的交换就完成。</p>
<p><strong>如果想要交换多个字节，只需要在B0最后继续紧跟第二个字节的B7重复前述过程即可</strong></p>
<hr>
<p><strong>总结交换字节步骤</strong>：</p>
<ol>
<li>SS拉低后，主机和从机立刻移出数据(主机移出它的数据最高位放到MOSI上，从机移出它的最高位数据放到MISO上)。从机的事主机不管，所以我们直接写MOSI即可</li>
<li>SCK上升沿，主机和从机同时移入数据(从机会自动把这位数据读走)，主机只需要读入MISO的数据位即可</li>
<li>SCK下降沿，主机和从机同时移出次高位数据，开始循环8次，共1字节8bit</li>
</ol>
</blockquote>
<ul>
<li><code>模式1：与上方的移位过程相同</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101180327881-1737529755591108.png" alt="image-20250101180327881"></p>
<blockquote>
<p><strong>模式1与模式0的区别：模式0把数据变化的实际提前了，而模式1没有</strong></p>
<hr>
<p>CPOL = 0：代表空闲状态SCK低电平</p>
<p>CPHA = 1：SCK<code>第一个</code>边沿<code>移出数据</code>，<code>第二个</code>边沿<code>移入数据</code>。</p>
<p>也能表述为：CPHA=1表示SCK的第二个边沿进行数据采样，或SCK的偶数边沿进行数据采样</p>
<p>MOSI为主机发送的B7，B6…，默认状态下没有规定高低电平(均可)</p>
<p>MISO为从机发送的B7，B6…，默认状态下应为高阻态</p>
</blockquote>
<ul>
<li><code>模式2：</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101183828210-1737529755591109.png" alt="image-20250101183828210"></p>
<blockquote>
<p><strong>模式2与模式0区别：就把SCK极性取反即可</strong></p>
</blockquote>
<ul>
<li><code>模式3：</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101183921953-1737529755592110.png" alt="image-20250101183921953"></p>
<blockquote>
<p><strong>模式1与模式3区别：就把SCK极性取反即可</strong></p>
</blockquote>
<h3 id="SPI时序">SPI时序</h3>
<p>​		SPI对字节流功能的规定与I2C不同，I2C是有效数据流第一个字节是寄存器地址，之后依次是读写的数据，<strong>使用的是读写寄存器的模型</strong>。</p>
<p>​		而在SPI中，通常<strong>采用指令码加读写数据的模型</strong>，即SPI第一个发送给从机的数据叫做指令码，在从机中对应的会定义一个指令集，只需要发送指令集中对应的数据即可指定想要完成的功能。</p>
<p>​		不同的指令，可以有不同的数据个数，有的指令只需要一个字节的指令码就可以完成，比如：W25Q64的写使能失能等。而写数据时，包含指令码+在哪里写+写的数据</p>
<p>​       <code>对应的指令集都会在SPI从机芯片手册中可以找到！！！！</code></p>
<p><strong>时序举例</strong>：</p>
<ul>
<li><code>写使能</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101184358794-1737529755592112.png" alt="image-20250101184358794"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101185239046-1737529755592111.png" alt="image-20250101185239046"></p>
<blockquote>
<p>在W25Q64中0x06代表写使能。</p>
<p><strong>这里使用SPI模式0，SS拉低后，立马准备移出数据，这里数据第一个Bit为0，所以没有变化，SCK第一个上升沿采样移入数据，从机采样输入(MOSI)得到0，主机采样输入(MISO)得到1。然后第一个下降沿移除数据…一直到最后一位交换完成一个字节。SS置回高电平结束</strong></p>
<p><code>结果：</code>主机用收到从机的0xFF，即从机输出不使用(0xFF为默认值)，从机收到主机的0x06，就会进行写使能</p>
<p><strong>由于使用软件模拟时序有延时，所以图中的MOSI数据变化有些延迟，没有紧贴SCK的下降沿是正常的</strong></p>
</blockquote>
<ul>
<li><code>指定地址写一个/多个字节</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101191437487-1737529755592114.png" alt="image-20250101191437487"></p>
<blockquote>
<p>由于W25Q64有8M的存储空间，一个字节的8位地址不够，所以这里的指定地址使用24位分成3个字节发送</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101191742942-1737529755592113.png" alt="image-20250101191742942">`</p>
<blockquote>
<p><strong>在0x123456的地址下写入0x55数据</strong>：</p>
<p><code>指令码</code></p>
<p>第一个字节：主机先发送0x02指令代表写数据，收到从机数据为0xFF不使用</p>
<hr>
<p><code>指定地址</code></p>
<p>第二个字节：主机发送地址前8位(第23~16位)为0x12，收到从机数据0xFF</p>
<p>第三个字节：主机发送地址中8位(第15~8位)为0x34，收到从机数据0xFF</p>
<p>第四个字节：主机发送地址后8位(第7~0位)为0x56，收到从机数据0xFF</p>
<p><strong>从机收到的地址为0x123456</strong></p>
<hr>
<p><code>发送的数据</code></p>
<p>第五个字节：主机写入的数据0x55，收到从机数据0xFF</p>
<p>到这里便写入一个字节，没有应答位，一个接一个交换字节即可</p>
<hr>
<p><code>如果想指定地址，写入多个字节：</code></p>
<p>SPI中也有类似于I2C中的地址指针，每读写一个字节，地址指针自动+1，如果发送一个字节后不停止，继续发送的字节就会依次写入到后续的存储空间里，这样即实现多个字节写入</p>
</blockquote>
<ul>
<li><code>指定地址读一个/多个字节：</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101193028026-1737529755592115.png" alt="image-20250101193028026"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101193633764-1737529755592116.png" alt="image-20250101193633764"></p>
<blockquote>
<p><strong>和指定地址写时序差不多</strong></p>
<p>指令码：0x03</p>
<p>地址三个字节：0x123456</p>
<p>读取的数据：主机随便发送数据0xFF，交换数据后得到0x55。</p>
<p>这样就读取到了0x123456地址的数据为0x55</p>
<hr>
<p><code>实现读取指定地址的多个字节：</code></p>
<p>也是有地址指针，读取自动+1，实现连续读取即可</p>
<hr>
<p><strong>时序细节</strong>：</p>
<p>图中MISO是硬件控制波形，所以数据变化紧贴下降沿</p>
</blockquote>
<h3 id="W25Q64介绍">W25Q64介绍</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101193816880-1737529755592117.png" alt="image-20250101193816880"></p>
<blockquote>
<p><code>容量：</code></p>
<p>该芯片存储为M级别，在手机可能很小，但是在嵌入式领域还是挺大的</p>
<p>还有的芯片是KB级别的，例如AT24C02芯片，使用的I2C通信的E2PROM芯片</p>
<hr>
<p><code>存储器分类：</code></p>
<p>分为非易失性存储器(FLASH、E2PROM)和易失性存储器(SRAM、DRAM)</p>
<p>该芯片是非易失性存储器，数据掉电不丢失，存储介质为Nor Flash</p>
<hr>
<p><code>通信协议：</code></p>
<p>使用SPI串行通信，SCK时钟线频率最大为80MHz，双重SPI模式等效频率为160Mhz，四重SPI模式等效的频率为320MHz</p>
<p>频率相对于stm32非常快</p>
<hr>
<p><code>应用：</code></p>
<p>数据存储：</p>
<p>字库存储：可以存放中文字库等，使用时读取数据后显示中文</p>
<hr>
<p><code>型号：</code></p>
<p><strong>芯片使用24位地址，3个字节</strong></p>
<p>2的24方 = 16MB，所以24位地址的最大寻址空间为16MB，所W25Q40~W25Q128都是够用的，但是W25Q256是32MB的存储不够用</p>
<p>W25Q256分为3字节地址模式和4字节地址模式，使用3字节模式下只能读写到前16MB地址，而要想读写所有的地址进入4字节地址模式即可</p>
<p>更换芯片型号，硬件电路和底层驱动程序都不用更改</p>
</blockquote>
<h4 id="硬件电路-5">硬件电路</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250101233710004-1737529755592118.png" alt="image-20250101233710004"></p>
<blockquote>
<p>该芯片的供电VCC接3.3V</p>
<hr>
<p>WP：写保护，低电平不允许写，高电平可以写</p>
<p>HOLD：数据保持，低电平有效</p>
<p>作用：在正常读写时突然产生中断，然后想用SPI通信线去操控其他器件，此时如果把CS置回高电平，那时序就会终止，但如果不想终止总线又想操作其他器件，此时就可以将HOLD引脚置低电平，芯片释放总线，芯片的时序也不会终止，会记住当前的状态，操作完后可以回来HOLD置高电平，继续之前的时序。</p>
<p>相当于SPI总线进了一次中断</p>
<p><strong>HOLD和WP如果想用就接到GPIO引脚上，如果不想用就直接接VCC即可</strong></p>
<hr>
<p>IO1 、IO2与双重SPI和四重SPI有关</p>
</blockquote>
<h4 id="框图">框图</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250102170255168-1737529755592120.png" alt="image-20250102170255168"></p>
<blockquote>
<p><code>几个基本概念：块、扇区、页:</code></p>
<p><code>块大小：</code>64KB</p>
<p><code>扇区大小：</code>4KB</p>
<p><code>页大小：</code>256B</p>
<p>8MB的地址空间从0x000000到0x7FFFFF</p>
<p><strong>右边</strong>：以64KB为一个基本单元块划分为若干个块Block  8MB/64KB = 128块(块0~127)</p>
<p><strong>左上</strong>：以4KB为一个基本单元再将每个Block划分为若干个单元，每个单元叫做Sector-扇区 64KB/4KB = 16个扇区(扇区0~15)</p>
<p>我们在写入数据时其实还有一个划分叫做页，是对扇区进行的一个更细的划分，一页为256字节 4KB/256 = 16页(0~15页)</p>
<hr>
<p><strong>左下角：芯片的控制逻辑</strong></p>
<p>芯片内部的地址锁存、数据读写等操作都由控制逻辑自动完成</p>
<p>控制逻辑的左边连接的是SPI的引脚</p>
<p>控制逻辑上方是状态寄存器，可以知道芯片是否处于忙状态、是否写使能等</p>
<p>状态寄存器上方是写控制逻辑与WP引脚连接，实现硬件写保护</p>
<p>内部集成了高电压发生器(High Voltage Generators)，用于实现掉电不丢失</p>
<hr>
<p><strong>最下方：字节地址锁存/计数器</strong></p>
<p>用于指定地址，SPI放过来3个字节的地址，前2个字节进到<strong>页地址锁存计数器</strong>，最后一个字节进入<strong>字节地址锁存计数器</strong>中</p>
<p>然后页地址锁存计数器通过写保护和行解码选择操作的哪一页</p>
<p>字节地址锁存计数器通过列解码和256字节页缓存来进行指定字节的读写操作</p>
<p>其中的计数器与地址指针自动+1有关</p>
<hr>
<p><strong>右下方：列解码和256Byte 页缓冲区</strong></p>
<p>实际上是个RAM缓冲区，写入数据时先放到这个RAM缓冲区，时序结束后，芯片对应状态BUSY会置1，芯片再将缓冲区的数据复制到对应的Flash中，此时不会响应新的写入</p>
<p><strong>缓冲区作用</strong>：SPI的写入频率是非常高的，而Flash的写入速度比较慢(掉电不丢失特性)，所以需要使用一个RAM页缓存区来存储写入的数据，从而可以跟得上SPI总线的速度。</p>
</blockquote>
<h4 id="Flash操作注意事项">Flash操作注意事项</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250102173909328-1737529755592119.png" alt="image-20250102173909328"></p>
<blockquote>
<p>第1条规定：直接使能即可</p>
<p>第2条规定：不擦除写入数据可能会与实际不符，实际值为(写入数据&amp;芯片内数据)</p>
<p><code>第3条规定：</code>是为了弥补第2条规定设立，保证每次写入数据不出错，由专门的擦除电路自动进行，我们只需要发送擦除的指令即可</p>
<p><code>一定要在每次写入前擦除数据!!!</code></p>
<p>第4条规定：擦除时只能选择整个芯片擦除、按块擦除、按扇区擦除，所以最小的擦除单元是一个扇区为4KB-4096字节。不能指定对某个字节擦除，如果想要擦除某一个字节，只能对该字节所在的扇区的4096个字节进行擦除</p>
<p>为了弥补这个缺点，我们需要在程序逻辑上进行一些优化：比如上电后先将Flash备份一份到RAM中</p>
<p>第5条规定：一次性不能写太多，一个写入时序最多写256字节(由缓冲区限制)</p>
<p>第6条规定：写入时序结束或者擦除芯片之后，芯片进入忙状态(BUSY位=1)，当状态寄存器BUSY位为0后才会继续响应</p>
<p>第7条规定：读取时序基本没有限制，唯一就是不能在忙状态时读取</p>
<hr>
<p>由于Flash掉电不丢失的特性，成本低，存储量大，所以在操作的便携性上不是很友好，以及速度不是很快。但在非易失性存储器中速度却是很快的。</p>
<p>与RAM想在哪些就在哪写，想写多少就写多少不同，且可以覆盖写入区别较大</p>
</blockquote>
<h4 id="芯片手册">芯片手册</h4>
<p>主要包含写保护配置表、状态寄存器、指令集，以及对每条指令的详细解释。还有芯片电器特性(供电电压范围等)</p>
<ul>
<li><code>状态寄存器:</code></li>
</ul>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250102191517893-1737529755592121.png" alt="image-20250102191517893"></p>
<p><code>BUSY位：</code></p>
<p>当设备执行页编程（Page Program）、扇区擦除（Sector Erase）、块擦除（Block Erase）、芯片擦除（Chip Erase）或写状态寄存器指令时会被设置为1。在该位为1时，表示设备正在忙碌，不会响应其他指令，除了读取状态寄存器和进入/擦除挂起操作的指令。程序、擦除或写状态寄存器操作完成后，“BUSY”位会清零，表明设备已准备好接收新的指令。</p>
<p><code>WEL位(写使能锁存位)：</code></p>
<p>WEL 是一个状态寄存器（Status Register）中的位，仅在执行了 Write Enable 指令后被设置为。在数据写入完成后，该位会被清零以禁用写操作。 当电源关闭或者执行以下任一指令时，WEL也会被禁用：Write Disable、Page Program(页编程)、Sector Erase（扇区擦除）、Block Erase（块擦除）、Chip Erase(芯片擦除) 和 <strong>Write Status Register(写入数据后会自动进行写使能)。</strong></p>
<p>例子说明： 假设你有一块闪存芯片，在你想要向其写入数据之前，必须先发送 Write Enable 指令来激活WEL位。只有当这个位是激活状态（即值为1），才能对芯片进行编程或擦除操作。一旦这些操作完成或者直接通过发送特定指令显式地禁用它（比如Write Disable），WEL会回到未激活状态（即值为0），从而防止意外改变数据。</p>
<p><code>注意：一条写指令只能保证后续的一条写指令可以执行，所以每次写入都要进行写使能</code></p>
<hr>
<p><code>其他的位请自行查看手册！！</code></p>
</blockquote>
<ul>
<li><code>指令集(Instruction):</code></li>
</ul>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250102193355258-1737529755592122.png" alt="image-20250102193355258"></p>
<p>厂商ID是：0xEF</p>
<p>设备ID：</p>
<p>0x16 (如果使用0xAB和0x90来读)</p>
<p>0x4017 (使用0x9F来读)</p>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250102193817312-1737529755592123.png" alt="image-20250102193817312"></p>
<p><code>Write Enable：</code>写使能，发送0x06</p>
<p><code>Write Disable：</code>写失能，发送0x04</p>
<hr>
<p><code>Read Status Register-1：</code>读取状态寄存器第1位，发送0x05，用于查看忙状态，S0是BUSY位，S1是WEL位</p>
<hr>
<p><code>Page Program：</code>页编程就是写数据，发送0x02，然后继续发送地址23-16位，15-8位，7-0位三个字节，然后发送写入的数据</p>
<p><strong>注意：该芯片不能跨页写入，在执行跨页写入时，多出来的数据会从页首的地方覆盖写入，一页为256B对应16进制为0x000000~0x0000FF。</strong></p>
<p><strong>若确实需要跨页写入，需要连续写入很大的数组，只能从软件上进行分批次写入，先计算数组要跨多少也，擦除对应区域,最后分批次一页一页写，最后封装成一个函数</strong></p>
<hr>
<p><code>Block Erase：</code>块擦除，包括按64KB的块擦除、32KB的块擦除、4KB的扇区擦除。发送0xD8/0x62，再发送三个字节的地址即可</p>
<p><code>Sector Erase：</code>扇区擦除，包括4KB的扇区擦除。发送0x20，再发送三个字节的地址即可，对应一个扇区为0x000000~0x000FFF</p>
<p><code>Chip Erase：</code>发送0xC7或0x60h即可</p>
<hr>
<p><code>JEDEC ID：</code>读取ID指令，发送0x9F，然后连续交换三个字节数据，得到的第一个字节是厂商ID，后两个字节是设备ID</p>
</blockquote>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250102195113035-1737529755592124.png" alt="image-20250102195113035"></p>
<p><code>Read Data：</code>读取数据，发送0x03，之后交换发送3个字节地址，接下来读取的就是该地址下的数据</p>
</blockquote>
<ul>
<li><code>执行所用时间：</code></li>
</ul>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250102200118784-1737529755592125.png" alt="image-20250102200118784"></p>
<p>页编程以及各种擦除所用时间，基本都是ms级别</p>
</blockquote>
<ul>
<li><code>dummy数据：</code></li>
</ul>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250104225524682-1737529755592126.png" alt="image-20250104225524682"></p>
<p><strong>手册中可以看到发送的数据为dummy，这个dummy就代表无用数据，发送0xFF即可此时发送和接收的数据都没有意义。</strong></p>
<p><strong>作用：可能是做一些延时</strong></p>
</blockquote>
<h3 id="软件SPI读写W25Q64">软件SPI读写W25Q64</h3>
<h4 id="软件SPI底层代码">软件SPI底层代码</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MySPI.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSPI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSPI_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//void MySPI_W_SS(uint8_t BitVal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void MySPI_W_SCK(uint8_t BitVal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void MySPI_W_MOSI(uint8_t BitVal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//uint8_t MySPI_W_MISO()；</span></span><br><span class="line"><span class="comment">/*上面四个函数只有MySPI.c中会使用，所以我们不用放在头文件中，保持模块的独立，封装！！！！！！*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写SS</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SS</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写SCK</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SCK</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_5,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写MOSI</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_MOSI</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_7,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读MISO</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_R_MISO</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_6);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*由于SPI速度很快，操作引脚后就不用加延时了*/</span></span><br><span class="line"><span class="comment">/*上面这样单独对写入引脚的封装，有利于单片机移植或者添加延时*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  <span class="comment">//1.开启对应引脚RCC</span></span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	   </span><br><span class="line">	  <span class="comment">//2.配置GPIO</span></span><br><span class="line">	  <span class="comment">/*三个推挽输出引脚*/</span></span><br><span class="line">	  GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	  </span><br><span class="line">		<span class="comment">/*一个上拉/浮空输入引脚*/</span></span><br><span class="line">	  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">		GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//3.配置默认电平：初始化SS引脚为高电平，由于使用模式0，所以初始化SCK引脚为低电平</span></span><br><span class="line">	  MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">		MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI起始条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	MySPI_W_SS(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI终止条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI字节交换,由于是交换1字节，所以需要有返回值得到从机发送的1字节</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> ByteReceive = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/*1.依次1位，1位操作*/</span></span><br><span class="line"><span class="comment">//		MySPI_W_MOSI(ByteSend &amp;= 0x80); //移出第一位数据</span></span><br><span class="line"><span class="comment">//	  MySPI_W_SCK(1);</span></span><br><span class="line"><span class="comment">//		if(MySPI_W_MISO() == 1)  //接收从机发送的第一位数据(最高位)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			ByteReceive |= 0x80;   </span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		MySPI_W_SCK(0);</span></span><br><span class="line"><span class="comment">//		/*一个时序的结束*/</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		MySPI_W_MOSI(ByteSend &amp;= 0x40);//移出第二位数据</span></span><br><span class="line"><span class="comment">//		MySPI_W_SCK(1);</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		if(MySPI_W_MISO() == 1)  //接收从机发送的第二位数据(次高位)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			ByteReceive |= 0x40;   </span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		.....一位一位发送，可以简化为循环</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">/*2.通过掩码，依次挑出每一位进行操作*/</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			MySPI_W_MOSI(ByteSend &amp; (<span class="number">0x80</span> &gt;&gt; i)); <span class="comment">//移出第i位数据，每次只发送了1bit</span></span><br><span class="line">			MySPI_W_SCK(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(MySPI_R_MISO() == <span class="number">1</span>)  <span class="comment">//接收从机发送的第i位数据(i=0时为最高位)，每次只接收了1bit</span></span><br><span class="line">			&#123;</span><br><span class="line">				ByteReceive |= (<span class="number">0x80</span> &gt;&gt; i);   </span><br><span class="line">			&#125;</span><br><span class="line">			MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*3.通过SPI中主机和从机移位寄存器交换字节的方式，更加契合SPI的移位模型讲解*/</span></span><br><span class="line"><span class="comment">//			for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//		&#123;</span></span><br><span class="line"><span class="comment">//			MySPI_W_MOSI(ByteSend &amp;= 0x80); //移出第i位数据，每次只发送了1bit</span></span><br><span class="line"><span class="comment">//			ByteSend &lt;&lt;= 1 ; //最高位发送后，左移1位后最低位为0，空出最低为</span></span><br><span class="line"><span class="comment">//			MySPI_W_SCK(1);</span></span><br><span class="line"><span class="comment">//			if(MySPI_W_MISO() == 1)  //接收从机发送的第i位数据(i=0时为最高位)，每次只接收了1bit</span></span><br><span class="line"><span class="comment">//			&#123;</span></span><br><span class="line"><span class="comment">//				ByteSend |= 0x01; //主机发送数据的移位寄存器最后1bit置为从机移位发送的1bit</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//			MySPI_W_SCK(0);</span></span><br><span class="line"><span class="comment">//			</span></span><br><span class="line"><span class="comment">//			//最终得到的ByteSend就是移位交换后的数据，就可以不用定义ByteReceive,提高效率</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> ByteReceive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面演示的是SPI模式0的时序，如果需要修改模式，只需要对照时序图进行修改即可</p>
<p>比如修改为模式1，对照模式1的时序图只需要将for循环中的前两行代码交换顺序即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span> </span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">         MySPI_W_SCK(<span class="number">1</span>);</span><br><span class="line">         <span class="comment">/*这两行*/</span></span><br><span class="line">			MySPI_W_MOSI(ByteSend &amp;= (<span class="number">0x80</span> &gt;&gt; i)); </span><br><span class="line">			<span class="keyword">if</span>(MySPI_W_MISO() == <span class="number">1</span>)  </span><br><span class="line">			&#123;</span><br><span class="line">				ByteReceive |= (<span class="number">0x80</span> &gt;&gt; i);   </span><br><span class="line">			&#125;</span><br><span class="line">			MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>这里的模式0和模式1的时钟极性相同，如果改为模式2或模式3时，只需要将所有出现SCK的地方电平全部翻转一下即可</code></p>
</blockquote>
<h4 id="W25Q64测试代码">W25Q64测试代码</h4>
<p><code>由于指令码直接书写不太美观，也不够清楚，所以我们可以对指令集进行宏定义。新建一个头文件，单独存放指令集的宏定义！！！</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64_Ins*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q64_INS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q64_INS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据W25Q64的手册将所有的指令码抄过来*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_ENABLE							0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_DISABLE						0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_STATUS_REGISTER_1				0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_STATUS_REGISTER_2				0x35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_STATUS_REGISTER				0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_PAGE_PROGRAM							0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_QUAD_PAGE_PROGRAM					0x32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_BLOCK_ERASE_64KB						0xD8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_BLOCK_ERASE_32KB						0x52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_SECTOR_ERASE_4KB						0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_CHIP_ERASE							0xC7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_ERASE_SUSPEND						0x75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_ERASE_RESUME							0x7A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_POWER_DOWN							0xB9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_HIGH_PERFORMANCE_MODE				0xA3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_CONTINUOUS_READ_MODE_RESET			0xFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_RELEASE_POWER_DOWN_HPM_DEVICE_ID		0xAB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_MANUFACTURER_DEVICE_ID				0x90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_UNIQUE_ID						0x4B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_JEDEC_ID								0x9F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_DATA							0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ							0x0B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_DUAL_OUTPUT				0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_DUAL_IO					0xBB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_QUAD_OUTPUT				0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_QUAD_IO					0xEB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_OCTAL_WORD_READ_QUAD_IO				0xE3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_DUMMY_BYTE							0xFF</span></span><br><span class="line"><span class="comment">//用于表示接受时交换过去的无用数据</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q64_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q64_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySPI.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  MySPI_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看芯片手册对应指令集编写时序*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span></span><br><span class="line">&#123;</span><br><span class="line">	  MySPI_Start();</span><br><span class="line">	</span><br><span class="line">		MySPI_SwapByte(<span class="number">0x9F</span>);<span class="comment">//发送读取厂商ID和设备ID的指令码</span></span><br><span class="line">	</span><br><span class="line">		*mId = MySPI_SwapByte(<span class="number">0xFF</span>);<span class="comment">//交换数据得到从机返回的第一个字节厂商ID，主机随便发送什么默认0xFF</span></span><br><span class="line">	</span><br><span class="line">		*dId = MySPI_SwapByte(<span class="number">0xFF</span>);<span class="comment">//交换数据得到从机返回的第二个字节设备ID(前8bit为存储器类型，后8bit为存储器大小)，主机随便发送什么默认0xFF</span></span><br><span class="line">		*dId &lt;&lt;= <span class="number">8</span>; <span class="comment">//设置16bit高8位</span></span><br><span class="line">	</span><br><span class="line">		*dId |= MySPI_SwapByte(<span class="number">0xFF</span>);<span class="comment">//设置16bit低8位，不能直接等于，否则高八位会被置0</span></span><br><span class="line">		</span><br><span class="line">	  MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>测试代码：先使用该读取ID的代码测试是否能使用SPI</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c业务代码*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> mid=<span class="number">0x00</span>;</span><br><span class="line">		<span class="type">uint16_t</span> did=<span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">	  	UsartInit();</span><br><span class="line"></span><br><span class="line">		W25Q64_Init();</span><br><span class="line"></span><br><span class="line">		W25Q64_ReadID(&amp;mid,&amp;did);</span><br><span class="line">	  	UsartSendNum(mid,<span class="number">2</span>);</span><br><span class="line">	  	UsartSendNum(did,<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们读取的指令码为0x9F，对应手册上收到的应该是</p>
<p>厂商ID：0xEF</p>
<p>设备ID：0x4017</p>
<p>将OLED上显示或者串口发送的结果对比发现正确</p>
</blockquote>
<h4 id="W25Q64完整代码">W25Q64完整代码</h4>
<blockquote>
<p><strong>由于每次操作需要我们判断是否芯片是否处于BUSY，所有我们可以在每次写操作的时候进行等待BUSY位。等待分为事前等待和事后等待</strong></p>
<p><code>事前等待</code>：在写操作开始前调用W25Q64_WaitBusy等待BUSY位置0</p>
<p><code>事后等待</code>：在写操作结束后需要调用W25Q64_WaitBusy</p>
<p><strong>两者区别：</strong></p>
<ol>
<li>
<p><strong>事后等待比事前等待更保险，事后等待可以保证在进行写操作之外的地方芯片肯定不处于BUSY状态，保证安全。</strong></p>
</li>
<li>
<p><strong>事前等待效率比事后等待效率高，可以在执行完写操作后执行其他代码，刚好可以利用这段代码来消耗等待时间</strong></p>
</li>
<li>
<p><strong>事前等待需要在读取和写入前都要调用。因为读的时候也需要在BUSY位不为1的时候。而事后等待只需要在写入后调用</strong></p>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q64_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q64_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_PageProgram</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint16_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_SectorErase</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadData</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint32_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void W25Q64_WriteEnble();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void W25Q64_WaitBusy();</span></span><br><span class="line"><span class="comment">/*这两个函数为了模块化，不用外部调用了*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySPI.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64_Ins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  MySPI_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看芯片手册对应指令集编写时序！！！*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span></span><br><span class="line">&#123;</span><br><span class="line">	  MySPI_Start();</span><br><span class="line">	</span><br><span class="line">		MySPI_SwapByte(W25Q64_JEDEC_ID);<span class="comment">//发送读取厂商ID和设备ID的指令码</span></span><br><span class="line">	</span><br><span class="line">		*mId = MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//交换数据得到从机返回的第一个字节厂商ID，主机随便发送什么默认0xFF</span></span><br><span class="line">	</span><br><span class="line">		*dId = MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//交换数据得到从机返回的第二个字节设备ID(前8bit为存储器类型，后8bit为存储器大小)，主机随便发送什么默认0xFF</span></span><br><span class="line">		*dId &lt;&lt;= <span class="number">8</span>; <span class="comment">//设置16bit高8位</span></span><br><span class="line">	</span><br><span class="line">		*dId |= MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//设置16bit低8位，不能直接等于，否则高八位会被置0</span></span><br><span class="line">		</span><br><span class="line">	  MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次写之前都要写使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WriteEnble</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">		MySPI_Start();</span><br><span class="line">		</span><br><span class="line">		MySPI_SwapByte(W25Q64_WRITE_ENABLE);</span><br><span class="line">		</span><br><span class="line">		MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待状态寄存器BUSY位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WaitBusy</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint32_t</span> Timeout=<span class="number">100000</span>;</span><br><span class="line">		MySPI_Start();</span><br><span class="line">	</span><br><span class="line">		MySPI_SwapByte(W25Q64_READ_STATUS_REGISTER_1);</span><br><span class="line">		<span class="keyword">while</span>((MySPI_SwapByte(W25Q64_DUMMY_BYTE) &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>) <span class="comment">//状态寄存器有8位，最低位代表BUSY位，读取判断BUSY位若为1就一直等待</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*状态寄存器可以被连续读取，如果不停止就会一直发送状态寄存器当前的值*/</span></span><br><span class="line">			Timeout--;</span><br><span class="line">			<span class="keyword">if</span>(Timeout == <span class="number">0</span>)<span class="comment">//超时退出避免程序卡死</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页编程，也就是写入数据到W25Q64。需要先写使能！！</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_PageProgram</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint16_t</span> count)</span><span class="comment">//读取最大值count为256，所以要定义为uint16，uint8=255</span></span><br><span class="line">&#123;</span><br><span class="line">		W25Q64_WriteEnble();<span class="comment">//每次写入数据前都要进行写使能！！！，在这里可以方便我们避免每次都要手动写使能</span></span><br><span class="line">		MySPI_Start();</span><br><span class="line">		MySPI_SwapByte(W25Q64_PAGE_PROGRAM);</span><br><span class="line">	  MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);<span class="comment">//取高8位</span></span><br><span class="line">		MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>); <span class="comment">//取中8位该函数只会发送8bit数据，高位会舍弃</span></span><br><span class="line">		MySPI_SwapByte(Address);<span class="comment">//取低8位发送</span></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			MySPI_SwapByte(DataArray[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		MySPI_Stop();</span><br><span class="line">		</span><br><span class="line">		W25Q64_WaitBusy();<span class="comment">//写操作进行事后等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扇区擦除，其他擦除同理,Address为指定擦拭的4个字节，也就是1个扇区。需要先写使能！！</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_SectorErase</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	  W25Q64_WriteEnble(); <span class="comment">//每次写入数据前都要进行写使能！！！，在这里可以方便我们避免每次都要手动写使能</span></span><br><span class="line">		MySPI_Start();</span><br><span class="line">		MySPI_SwapByte(W25Q64_SECTOR_ERASE_4KB);</span><br><span class="line">	  MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);<span class="comment">//取高8位</span></span><br><span class="line">		MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>); <span class="comment">//取中8位该函数只会发送8bit数据，高位会舍弃</span></span><br><span class="line">		MySPI_SwapByte(Address);<span class="comment">//取低8位发送</span></span><br><span class="line">		MySPI_Stop();</span><br><span class="line">	</span><br><span class="line">		W25Q64_WaitBusy();<span class="comment">//写操作进行事后等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadData</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint32_t</span> count)</span><span class="comment">//读取时数量没有限制</span></span><br><span class="line">&#123;</span><br><span class="line">		MySPI_Start();</span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">//1.发送读取数据指令码</span></span><br><span class="line">		MySPI_SwapByte(W25Q64_READ_DATA);</span><br><span class="line">	  </span><br><span class="line">		<span class="comment">//2.发送读取的24位地址</span></span><br><span class="line">		MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);<span class="comment">//取高8位</span></span><br><span class="line">		MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>); <span class="comment">//取中8位该函数只会发送8bit数据，高位会舍弃</span></span><br><span class="line">		MySPI_SwapByte(Address);<span class="comment">//取低8位发送</span></span><br><span class="line">	  </span><br><span class="line">		<span class="comment">//3.置换得到数据</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			DataArray[i]= MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//发送0xFF将数据置换过来</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">uint8_t</span> mid=<span class="number">0x00</span>;</span><br><span class="line">		<span class="type">uint16_t</span> did=<span class="number">0x00</span>;</span><br><span class="line">	</span><br><span class="line">	  	<span class="type">uint8_t</span> ArrayWrite[] = &#123;<span class="number">0xA1</span>,<span class="number">0xB2</span>,<span class="number">0xC3</span>,<span class="number">0xD4</span>&#125;;</span><br><span class="line">		<span class="type">uint8_t</span> ArrayRead[<span class="number">4</span>]; </span><br><span class="line"></span><br><span class="line">		W25Q64_Init();</span><br><span class="line">	  </span><br><span class="line">		W25Q64_ReadID(&amp;mid,&amp;did);</span><br><span class="line">	   </span><br><span class="line">		W25Q64_SectorErase(<span class="number">0x000000</span>);<span class="comment">//指定擦除扇区起始地址，后3位代表一个扇区内地址，6位代表块地址</span></span><br><span class="line">		W25Q64_PageProgram(<span class="number">0x000000</span>,ArrayWrite,<span class="number">4</span>);</span><br><span class="line">		</span><br><span class="line">		W25Q64_ReadData(<span class="number">0x000000</span>,ArrayRead,<span class="number">4</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="comment">//			OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>1.每次写入数据前要先写使能!!!</code></p>
<p><code>2.每次写入前一定要记得擦除!!!</code></p>
<p><strong>最终OLED上显示发送和读取的数据相同，断电后不写入直接读取数据也不变</strong></p>
</blockquote>
<h3 id="硬件SPI外设-硬件读写">硬件SPI外设(硬件读写)</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250105141343897-1737529755592127.png" alt="image-20250105141343897"></p>
<blockquote>
<p>SPI最常用配置就是8位数据帧，高位先行。16位和低位先行用的很少</p>
<hr>
<p><code>时钟频率：</code><strong>SPI的时钟由PCLK(外设时钟)分频得来</strong>，可以2~256分频，时钟频率越快，对应传输速率越快。</p>
<p>频率不能任意指定，也就是说SPI的时钟频率只能是对面8种分频后对应的时钟频率，且对于SPI1和SPI2来说，PCLK也不相同，SPI1挂载在APB2，PCLK是72MHz，SPI2挂载在APB1，PCLK是36MHz</p>
<hr>
<p><code>多主机模型：</code>使用较少，可以看手册学习</p>
<p><code>主机或从机：</code>通常作为主机</p>
<hr>
<p><code>精简为半双工/单工通信：</code></p>
<p>可以节省一条数据线，半双工或单工通信。一般不适用</p>
<hr>
<p><code>DMA:</code>大量数据传输时使用</p>
<hr>
<p><code>兼容I2S协议：</code>数字音频传输专用协议，与SPI有一些共同特征</p>
<hr>
<p><code>以上所有内容都可以查看参考手册进行学习！！！</code></p>
</blockquote>
<h4 id="SPI框图">SPI框图</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250108114540986-1737529755592128.png" alt="image-20250108114540986"></p>
<blockquote>
<p>与对应寄存器描述结合理解</p>
<hr>
<p><code>左上角：</code>通过LSBFIRST控制位控制低位先行还是高位先行，移位寄存器通过MOSI和MISO，分别移动和接收一位位数据。SPI发送和接收可以同时进行</p>
<p>接收缓冲区：就是RDR寄存器</p>
<p>发送缓冲区：就是TDR寄存器</p>
<p>TDR和RDR占用同一个地址，统一叫作DR，写入经过RDR，发送数据经过TDR，对应也是TXE(发送寄存器空)和RXNE(接收寄存器非空)两个标志位</p>
<p><strong>移位寄存器配合数据寄存器实现连续数据流</strong>：</p>
<p>发送数据先写入TDR，再转到移位寄存器发送，发送的同时接收数据，接收的同时转到RDR，我们再从RDR读取数据</p>
<hr>
<p><code>左下角：</code></p>
<p>波特率发生器：内部有一个分频器，输入时钟为PCLK，72M或36M，经过分频器后输出到SCK，生成时钟与移位寄存器同步</p>
<hr>
<p><code>右下角:</code></p>
<p>LSBFIRST：用于控制高位先行还是低位先行</p>
<p>SPE：SPI使能位</p>
<p>BR2，BR1，BR0：用于控制分频系数</p>
<p>MSTR：配置主从模式</p>
<p>CPOL和CPHA：选择SPI四种模式</p>
<hr>
<p><code>右上角：</code></p>
<p>一些使能位与控制位，重要的是TXE和RXNE</p>
<hr>
<p><code>NSS引脚：</code>与多主机有关</p>
</blockquote>
<p><code>SPI外设基本结构:</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250108122752353-1737529755592129.png" alt="image-20250108122752353"></p>
<blockquote>
<p><strong>TDR整体转入移位寄存器的时刻，置TXE标志位为1</strong></p>
<p><strong>移位寄存器数据整体转入RDR的时刻，置RXNE标志位为1</strong></p>
<hr>
<p><strong>图中没画出SS引脚，我们使用普通的GPIO口来模拟</strong></p>
</blockquote>
<h4 id="主模式全双工连续传输">主模式全双工连续传输</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250108172721631-1737529755592130.png" alt="image-20250108172721631"></p>
<blockquote>
<p>这里演示的是模式3，低位先行的模式：</p>
<p><strong>首先等待TXE=1后就软件写入数据到SPI_DR(TDR)，TXE也就变为0，转入完成后，立马将数据再移动到移位寄存器，转入到移位寄存器瞬间把TXE置为1，表示发送寄存器空，波形产生开始传输，但此时又要立马把下个数据写入到TDR中</strong></p>
<hr>
<p>流程简述下来就是：</p>
<p>发送数据1、发送数据2-- 接收数据1 --发送数据3 – 接收数据2 - 发送数据4 – 接收数据3</p>
<p>数据交换的流程是交叉的，要求很严格，对程序设计不太友好</p>
<p><strong>如果对效率要求很高，就可以研究这个</strong></p>
</blockquote>
<h4 id="非连续传输">非连续传输</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250108174720946-1737529755592131.png" alt="image-20250108174720946"></p>
<blockquote>
<p>这里演示的是模式3，低位先行的模式：</p>
<p><strong>接收时序与发送时序是同步的，具体见连续传输的图，因为是主机和从机交换字节发送所以发送的同时也在接收。但是必须先发送才会产生时序，然后才会有接收！！！</strong></p>
<p>首先等待TXE=1后就软件写入数据到SPI_DR(TDR)，TXE也就变为0，转入完成后，立马将数据再移动到移位寄存器，转入到移位寄存器瞬间把TXE置为1，表示发送寄存器空，一旦移位寄存器有数据了，<strong>时序波形会自动产生</strong>，开始交换数据</p>
<p><strong>此时不立马将下个数据写入TDR，而是等待第一个字节时序结束，意味着接收第一个字节也结束了，RXNE置1，先把第一个接收到的数据读出来，之后再写入数据2</strong></p>
<p><strong>流程即：四行代码完成任务</strong></p>
<p>第1步：等待TXE为1</p>
<p>第2步：写入发送的数据至TDR</p>
<p>第3步：等待RXNE为1</p>
<p>第4步：读取RDR接收的数据</p>
<p>然后重复第2、3、…字节</p>
<p>所以我们只需要将这四步封装到一个函数中就可以实现字节的交换，与软件SPI的流程基本上是一样的。</p>
<hr>
<p><code>非连续与连续传输的区别：</code>没有及时将数据送入TDR寄存器，等到第一个字节时序完成后，第二个字节还没有送过来，数据传输就会等候，所以时钟和数据的时序在字节与字节之间产生了间隙，拖慢了整体数据传输的速度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250108175801926-1737529755592132.png" alt="image-20250108175801926"></p>
<p>间隙在SCK频率低时影响不大，但在非常高时就非常严重</p>
<p>频率在2分频下的波形：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250108181920148-1737529755592134.png" alt="image-20250108181920148"></p>
<p>可以看到等待时间都远大于数据交换时间了</p>
<p><code>所以我们要在想在极限频率下，进一步提高数据传输速率，我们需要使用连续传输模式，或者使用DMA</code></p>
</blockquote>
<h4 id="TXE和RXNE标志位清除问题">TXE和RXNE标志位清除问题</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250108211408772-1737529755592133.png" alt="image-20250108211408772"></p>
<blockquote>
<p><strong>手册上的描述，TXE和RXNE会在写入DR和读DR的时候由硬件清除</strong></p>
<p><strong>所以我们不需要手动调用ClearFlag清除标志位</strong></p>
</blockquote>
<h4 id="连续和非连续的优缺点">连续和非连续的优缺点</h4>
<blockquote>
<p><code>非连续传输：</code></p>
<p>好处：容易封装，好理解，好用</p>
<p>缺点：会损失一点点性能</p>
<hr>
<p><code>连续传输:对传输效率有要求的话可以使用</code></p>
<p>好处：传输更快</p>
<p>缺点：操作起来相对复杂，对软件的需求较高，每个标志位产生后数据都要及时处理</p>
</blockquote>
<h4 id="软件硬件波形对比">软件硬件波形对比</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250108182601125-1737529755592136.png" alt="image-20250108182601125"></p>
<blockquote>
<p><code>区别：</code></p>
<p>下降沿和低电平期间，都可以作为数据变化的时刻，只是硬件波形一般会紧贴边沿，软件波形，一般只能在电平期间，无论哪种方式都不会影响数据传输。</p>
<p>对于软件波形，尽量要贴近边沿，否则等待太久贴近下一个边沿了数据也会容易出错</p>
</blockquote>
<h4 id="SPI库函数">SPI库函数</h4>
<p><strong>标准库函数中包含的SPI很多名称中带有I2S相关的函数，因为I2S与SPI共用一套电路。直接使用即可</strong></p>
<ul>
<li><code>初始化：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_DeInit</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2S_Init</span><span class="params">(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2S_StructInit</span><span class="params">(I2S_InitTypeDef* I2S_InitStruct)</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_Init</span><span class="params">(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_StructInit</span><span class="params">(SPI_InitTypeDef* SPI_InitStruct)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>外设使能：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_Cmd</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2S_Cmd</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>中断配置：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_ITConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_I2S_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>DMA：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_DMACmd</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_I2S_DMAReq, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>发送和接收数据：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_SendData</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="comment">//数据到DR</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_I2S_ReceiveData</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br><span class="line"><span class="comment">//从DR读数据</span></span><br></pre></td></tr></table></figure>
<hr>
<p><code>不常用函数：</code></p>
<ul>
<li><code>NSS引脚配置：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_NSSInternalSoftwareConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_NSSInternalSoft)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_SSOutputCmd</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>数据帧位数配置：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_DataSizeConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_DataSize)</span>;</span><br><span class="line"><span class="comment">//8位或16为数据帧配置</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>CRC校验配置：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_TransmitCRC</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_CalculateCRC</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_GetCRC</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_CRC)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_GetCRCPolynomial</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>半双工时双向线的方向配置：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_BiDirectionalLineConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_Direction)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>标志位：</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">SPI_I2S_GetFlagStatus</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_I2S_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_ClearFlag</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_I2S_FLAG)</span>;</span><br><span class="line">ITStatus <span class="title function_">SPI_I2S_GetITStatus</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_I2S_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_ClearITPendingBit</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_I2S_IT)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="硬件SPI初始化流程">硬件SPI初始化流程</h4>
<blockquote>
<p>根据SPI框图：</p>
<ol>
<li>开启RCC对应SPI和GPIO口的时钟</li>
<li>初始化GPIO口，SCK和MOSI是硬件控制输出的信号，配置为<strong>复用推挽输出</strong>。MISO是，是硬件外设配置的输入信号，配置为<strong>上拉输入</strong>。还有一个SS引脚，使用软件模拟控制的输出信号，配置为<strong>通用推挽输出</strong>即可</li>
<li>配置SPI外设，调用SPI_Init配置各参数即可</li>
<li>使能，开关控制，调用SPI_Cmd即可</li>
<li>默认SS为高电平，不使用从机</li>
</ol>
</blockquote>
<h4 id="硬件SPI读写W25Q64">硬件SPI读写W25Q64</h4>
<blockquote>
<p>对于W25Q64Q驱动层的代码我们不需要修改，我们只需要修改底层SPI代码即可</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MySPI.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSPI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSPI_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MySPI.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写SS</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SS</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	  <span class="comment">//1.开启对应引脚RCC</span></span><br><span class="line">		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);</span><br><span class="line">	</span><br><span class="line">	  <span class="comment">//2.配置GPIO</span></span><br><span class="line">		<span class="comment">/*SCK和MOSI复用推挽输出引脚*/</span></span><br><span class="line">	  GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_7;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">/*使用软件模拟SS，SS通用推挽输出引脚*/</span>  </span><br><span class="line">	  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_4;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">/*MISO上拉输入引脚*/</span></span><br><span class="line">	  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">		GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">	  </span><br><span class="line">		<span class="comment">//3.配置SPI</span></span><br><span class="line">	  SPI_InitTypeDef SPI_InitStruct;</span><br><span class="line">	  SPI_InitStruct.SPI_Mode = SPI_Mode_Master;<span class="comment">//选择主机</span></span><br><span class="line">	  SPI_InitStruct.SPI_Direction = SPI_Direction_2Lines_FullDuplex;<span class="comment">//选择全双工</span></span><br><span class="line">	  SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b;</span><br><span class="line">	  SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB;<span class="comment">//8位先行</span></span><br><span class="line">	  SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;<span class="comment">//频率为72Mhz/128 = 500多khz</span></span><br><span class="line">	  SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge;</span><br><span class="line">	  SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low;</span><br><span class="line">	  SPI_InitStruct.SPI_NSS = SPI_NSS_Soft;<span class="comment">//我们使用的GPIO引脚模拟，使用软件NSS</span></span><br><span class="line">	  SPI_InitStruct.SPI_CRCPolynomial = <span class="number">7</span>;<span class="comment">//我们不使用CRC校验，只需要随便给个值即可</span></span><br><span class="line">	  SPI_Init(SPI1,&amp;SPI_InitStruct);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4.使能</span></span><br><span class="line">	  SPI_Cmd(SPI1,ENABLE);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5.默认不选中从机</span></span><br><span class="line">	  MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI起始条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	MySPI_W_SS(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI终止条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	 MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI字节交换，硬件自动控制SCK、MOSI、MISO引脚</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span></span><br><span class="line">&#123;   </span><br><span class="line">	<span class="comment">/*对应非连续传输的四个步骤*/</span></span><br><span class="line">		<span class="comment">//1.等待TXE为1，代表发送数据寄存器为空，可以写入数据了</span></span><br><span class="line">		<span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) != SET)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.写入发送数据到TDR(发送数据寄存器)，同时自动清除TXE</span></span><br><span class="line">		SPI_I2S_SendData(SPI1,ByteSend);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3.等待RXNE为1，接收数据寄存器非空，代表接收完成</span></span><br><span class="line">		<span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE) != SET)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4.从RDR(接收数据寄存器)读取接收到的数据，同时自动清除RXNE</span></span><br><span class="line">		<span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>RTC</h1>
<h2 id="常识">常识</h2>
<h3 id="Unix时间戳">Unix时间戳</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250109131815285-1737529755592135.png" alt="image-20250109131815285"></p>
<blockquote>
<p><code>时间戳：</code>1970年1月1日0时0分0秒开始所经过的秒数，没有进位，不同时区通过对秒计数器添加偏移就可以得到当地时间</p>
<p>计算机底层使用时间戳会很方便，只需要一个很大的寄存器存储秒数即可</p>
<p>给人类观看的时候，只需要将时间戳转换为对应的日期即可</p>
<p>但是，时间戳比较占用软件资源，在每次进行秒计数器和日期时间转换时，软件都需要经过比较复杂的运算</p>
</blockquote>
<h3 id="RTC-GMT">RTC/GMT</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250109133115489-1737529755593137.png" alt="image-20250109133115489"></p>
<blockquote>
<p><code>闰秒：</code>由于地球自转会越转越慢，地球自转一周的时间会变化，当地球自转一周的时间与原子钟计时一天的时间相差超过0.9s时，UTC就会执行闰秒操作，即多走1s来等等地球，1分钟可能会出现61s。、</p>
<p>现在世界使用的就是UTC</p>
</blockquote>
<h3 id="时间戳转换">时间戳转换</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250109134112560-1737529755593138.png" alt="image-20250109134112560"></p>
<blockquote>
<p>localtime是在gmtime的基础上，加一个时区偏移得到</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250109134249030-1737529755593139.png" alt="image-20250109134249030"></p>
<h2 id="BKP简介">BKP简介</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250109135916881-1737529755593140.png" alt="image-20250109135916881"></p>
<blockquote>
<p>BKP其实就是一个存储器，只有当VDD和VBAT都断电了数据才会清零</p>
<hr>
<p>TAMPER引脚：侵入事件将所有备份寄存器内容清除，用于安全等</p>
<hr>
<p>RTC引脚：输出RTC校准时钟，或输出RTC闹钟脉冲</p>
<hr>
<p>BKP20字节：中容量和小容量</p>
<p>BKP84字节：大容量和互联型</p>
</blockquote>
<h3 id="基本结构">基本结构</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250109142941243-1737529755593141.png" alt="image-20250109142941243"></p>
<blockquote>
<p>橙色部分叫后备区域，BKP处于后备区域，但后备区域不只有BKP，还有RTC相关电路</p>
<p><code>后备区域特性：</code>当VDD主电源掉电时，后备区域仍可以由VBAT的备用电池供电，当VDD主电源上电时，后备区域供电会由VBAT切换到VDD，也就是在主电源有电时，VBAT不会用到，这样可以节省电池电量。</p>
<p>每个数据寄存器空间为2个字节</p>
<hr>
<p><code>BKP的几个功能：</code></p>
<ul>
<li><strong>侵入检测</strong>：可以从PC13位置的TAMPER引脚引入一个检测信号，当TAMPER产生上升沿或者下降沿时，清除BKP所有的内容，以保证安全</li>
<li><strong>时钟输出</strong>：可以从PC13位置的RTC引脚输出出去，供外部使用，其中输出RTC校准时钟时配合校准寄存器可以对RTC的误差进行校准</li>
</ul>
</blockquote>
<h3 id="BKP库函数">BKP库函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BKP_DeInit</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//手动清空bkp所有寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_TamperPinLevelConfig</span><span class="params">(<span class="type">uint16_t</span> BKP_TamperPinLevel)</span>;</span><br><span class="line"><span class="comment">//配置tamper引脚有效电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_TamperPinCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//是否开启侵入检测功能</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_ITConfig</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//BKP中断配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_RTCOutputConfig</span><span class="params">(<span class="type">uint16_t</span> BKP_RTCOutputSource)</span>;</span><br><span class="line"><span class="comment">//BKP时钟输出配置，可选择输入RTC校准时钟，RTC闹钟脉冲或秒脉冲</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_SetRTCCalibrationValue</span><span class="params">(<span class="type">uint8_t</span> CalibrationValue)</span>;</span><br><span class="line"><span class="comment">//设置RTC校准值，写入RTC校准寄存器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_WriteBackupRegister</span><span class="params">(<span class="type">uint16_t</span> BKP_DR, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="comment">//写备份寄存器</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">BKP_ReadBackupRegister</span><span class="params">(<span class="type">uint16_t</span> BKP_DR)</span>;</span><br><span class="line"><span class="comment">//读备份寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关函数*/</span></span><br><span class="line">FlagStatus <span class="title function_">BKP_GetFlagStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ITStatus <span class="title function_">BKP_GetITStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_ClearITPendingBit</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="读写BKP">读写BKP</h3>
<blockquote>
<ul>
<li><code>使用BKP或RTC必须先执行前两步：</code></li>
</ul>
<ol>
<li>开启PWR和BKP时钟</li>
<li>设置PWR，使能BKP和RTC的访问</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> test = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1.开启对应BKP和PWR时钟</span></span><br><span class="line">	  		RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP,ENABLE);</span><br><span class="line">		<span class="comment">//2.使能PWR，使能BKP和RTC的访问</span></span><br><span class="line">	  PWR_BackupAccessCmd(ENABLE);</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//3.写bkp寄存器</span></span><br><span class="line">	  BKP_WriteBackupRegister(BKP_DR1,<span class="number">0x1234</span>);<span class="comment">//写入DR1寄存器，uint16_t</span></span><br><span class="line">    </span><br><span class="line">	    <span class="comment">//4.读bkp寄存器</span></span><br><span class="line">	  test = BKP_ReadBackupRegister(BKP_DR1);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line">				 </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RTC外设">RTC外设</h2>
<h3 id="RTC简介">RTC简介</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250109144513674-1737529755593142.png" alt="image-20250109144513674"></p>
<blockquote>
<p>其中计数都是用一个秒计数器，对应Unix的时间戳，使用c库中的time.h库中localtime函数可以得到年月日时分秒信息了。</p>
<hr>
<p>RTC可选三种时钟源输入：HSE、LSE、LSI</p>
<p><strong>一般都使用LSE：32.768KHz 提供给RTC时钟</strong></p>
<p>特殊情况下，HSE和LSI为备选时钟</p>
<p><code>选择LSE原因：</code><strong>HSE和LSI都有自己的用途，而LSE是专用，同时只有LSE时钟可以通过VBAT备用电池供电，HSE和LSI在主电源掉电后是停止运行的。</strong></p>
<p><code>所以要想实现RTC主电源掉电继续走时的功能，必须选择RTC专用时钟LSE</code></p>
<hr>
<p><code>BKP和RTC内容都可以在参考手册中查看！！！</code></p>
</blockquote>
<h3 id="RTC框图">RTC框图</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250109145649841-1737529755593143.png" alt="image-20250109145649841"></p>
<blockquote>
<p><strong>图中灰色部分都处于后备区域，主电源掉电后，可以使用备用电池供电</strong></p>
<p><code>左边：核心的分频和计数计时部分</code></p>
<p><strong>RTCCLK</strong>：为时钟来源在RCC配置，主要选择LSE</p>
<p><strong>RTC预分频器</strong>：实际上就是一个计数器，计几个数就溢出1次就是几分频。由重装载寄存器RTC_PRL(相当于ARR)，和余数寄存器RTC_DIV(相当于CNT计数器，但是为自减计数器)。</p>
<p>若RTC_PRL=32768，来一个输入时钟RTC_DIV自减一次，直到变为0，然后再来一个输入时钟就会产生一个溢出信号，同时DIV变回32767。也就是每来32768个输入脉冲计数器就溢出一次，产生一个输出脉冲，也就是产生了32768分频，分频后输出的时钟频率为1Hz，也就是1s提供给后续</p>
<p><strong>RTC_CNT</strong>：就是Unix时间戳的秒计数器</p>
<p><code>RTC_ALR：</code>闹钟寄存器RTC_ALR，32位值，可以在其写入一个秒数，设定闹钟，当RTC_CNT == RTC_ALR，这时闹钟响了就会产生RTC_Alarm信号，通往右边的中断系统，执行对应操作，同时闹钟信号RTC_Alarm可以让STM32退出待机模式。</p>
<p><strong>可以实现定时唤醒待机芯片采集数据，完成后继续待机，以节省电源的作用</strong></p>
<hr>
<p><code>右边：中断使能和NVIC部分</code></p>
<p><strong>RTC_Second</strong>：秒信号，触发秒中断，每秒触发一次中断</p>
<p><strong>RTC_Overflow</strong>：溢出信号，触发溢出中断，计数值溢出触发一次中断，这个一般不会触发</p>
<p><strong>RTC_Alarm</strong>：闹钟信号，触发闹钟中断，可以设定闹钟或者唤醒待机设备</p>
<hr>
<p><code>上边：AP1总线相关部分</code></p>
<p>读写寄存器可以通过APB1总线完成，且RTC是APB1总线上的设备</p>
<hr>
<p><code>下边：PWR关联的部分</code></p>
</blockquote>
<h3 id="RTC基本结构">RTC基本结构</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250109151703477-1737529755593144.png" alt="image-20250109151703477"></p>
<h3 id="硬件电路-6">硬件电路</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250109151911012-1737529755593145.png" alt="image-20250109151911012"></p>
<blockquote>
<p>在最小系统的电路上需要额外添加两个部分：</p>
<ol>
<li>
<p>**备用电池电路：**根据数据手册得到简单连接，参考手册得到推荐连接</p>
<p>图右上角：使用3V纽扣电池充当备用电池，型号位CR2032/CR1220等，有字的那面为正极</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250109152015914-1737529755593146.png" alt="image-20250109152015914"></p>
<p><strong>画板子设计产品应该选择推荐连接方案更保险</strong></p>
<ol start="2">
<li>**外部低速晶振：**根据参考手册设计</li>
</ol>
<p>图右下角：黑色的为外部低速晶振32.768khz，白色的为外部高速8Mhz晶振</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250109152430959-1737529755593147.png" alt="image-20250109152430959"></p>
</blockquote>
<h3 id="RTC操作注意事项">RTC操作注意事项</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250109152914363-1737529755593148.png" alt="image-20250109152914363"></p>
<blockquote>
<ul>
<li><code>使用BKP或RTC必须先执行前两步：</code></li>
</ul>
<ol>
<li>开启PWR和BKP时钟</li>
<li>设置PWR，使能BKP和RTC的访问</li>
</ol>
<hr>
<ul>
<li>由于APB1和RTC_CRL使用的是不同时钟，面临着同步问题，所以需要在初始化时，调用一个等待同步的函数</li>
</ul>
<hr>
<ul>
<li>RTC有一个进入配置模式的标志位，必须先将RTC中的RTC_CRL中的CNF标志位置1才能进入配置模式。</li>
</ul>
<p>当然，在每个写入寄存器的库函数中都自动加上了这个操作，我们可以不用写</p>
<hr>
<ul>
<li>每次写入操作，都需要等待RTC_CR中的RTOFF标志位，只有为1时才能写入RTC寄存器。也就是调用一个等待上一个任务函数</li>
</ul>
<p>原因：因为PCLK1和RTCCLK时钟频率不一样，使用PCLK1的频率写入后，这个值不能直接更新到RTC寄存器中，因为RTC是由RTCCLK驱动，所以PCLK1写完后需要等一下RTCCLK时钟，RTCCLK来一个上升沿使值更新到RTC寄存器中</p>
</blockquote>
<h3 id="RCC库函数">RCC库函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_LSEConfig</span><span class="params">(<span class="type">uint8_t</span> RCC_LSE)</span>;<span class="comment">//配置LSE外部低速时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_LSICmd</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//配置LSI内部低速时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_RTCCLKConfig</span><span class="params">(<span class="type">uint32_t</span> RCC_RTCCLKSource)</span>;<span class="comment">//RTCCLK配置，配置时钟源选择</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_RTCCLKCmd</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//在调用上面的RTCCLK配置函数后，需要再次调用该函数使能</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">RCC_GetFlagStatus</span><span class="params">(<span class="type">uint8_t</span> RCC_FLAG)</span>;<span class="comment">//调用时钟启动函数后需要该函数等待LSERDY标志位置1，时钟才算启动完成稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_GetClocksFreq</span><span class="params">(RCC_ClocksTypeDef* RCC_Clocks)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphResetCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphResetCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_BackupResetCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClockSecuritySystemCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_MCOConfig</span><span class="params">(<span class="type">uint8_t</span> RCC_MCO)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ITStatus <span class="title function_">RCC_GetITStatus</span><span class="params">(<span class="type">uint8_t</span> RCC_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClearITPendingBit</span><span class="params">(<span class="type">uint8_t</span> RCC_IT)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="RTC库函数">RTC库函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RTC_ITConfig</span><span class="params">(<span class="type">uint16_t</span> RTC_IT, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_EnterConfigMode</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//RTC进入配置模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ExitConfigMode</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//RTC退出配置模式</span></span><br><span class="line"><span class="type">uint32_t</span>  <span class="title function_">RTC_GetCounter</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//RTC获取CNT计数器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetCounter</span><span class="params">(<span class="type">uint32_t</span> CounterValue)</span>;<span class="comment">//写入CNT</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetPrescaler</span><span class="params">(<span class="type">uint32_t</span> PrescalerValue)</span>;<span class="comment">//写入预分频器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetAlarm</span><span class="params">(<span class="type">uint32_t</span> AlarmValue)</span>;<span class="comment">//RTC写入闹钟值,该该寄存器是只写的不可读</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span>  <span class="title function_">RTC_GetDivider</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//读取预分频器种的DIV余数寄存器，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意事项中的两个等待函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_WaitForLastTask</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//等待上次操作完成，循环直到RTOFF状态位为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_WaitForSynchro</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//等待同步，等待RSF置1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关函数*/</span></span><br><span class="line">FlagStatus <span class="title function_">RTC_GetFlagStatus</span><span class="params">(<span class="type">uint16_t</span> RTC_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearFlag</span><span class="params">(<span class="type">uint16_t</span> RTC_FLAG)</span>;</span><br><span class="line">ITStatus <span class="title function_">RTC_GetITStatus</span><span class="params">(<span class="type">uint16_t</span> RTC_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearITPendingBit</span><span class="params">(<span class="type">uint16_t</span> RTC_IT)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="RTC配置">RTC配置</h3>
<ol>
<li><strong>开启PWR和BKP时钟，设置PWR，使能BKP和RTC的访问</strong></li>
<li><strong>使用RCC开启LSE时钟(LSE不行的话换成40khz的LSI)，且使用RCC开启LSE时钟(LSE省电默认关闭)，且等待LSERDY标志位为1</strong></li>
<li><strong>配置RTCCLK时钟源，指定LSE为RTCCLK时钟源，并且调用RTCCLK_Cmd使能</strong></li>
<li><strong>调用两个等待函数，注意事项中的等待同步与等待上一次操作完成</strong></li>
<li><strong>配置预分频器，RTC_SetPrescaler，并且再调用等待上一次操作完成函数</strong></li>
<li><strong>配置CNT,并且再调用等待上一次操作完成函数</strong></li>
<li>如果有闹钟值则配置闹钟</li>
<li>如果有中断就配置中断</li>
</ol>
<blockquote>
<p>RTC没有结构体进行配置，且没有Cmd函数，开启时钟后就会运行</p>
</blockquote>
<h3 id="RTC显示当前时间">RTC显示当前时间</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyRTC.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYRTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYRTC_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> MyRTC_Time[];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_SetTime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_ReadTime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyRTC.C*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> MyRTC_Time[] = &#123;<span class="number">2025</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1.开启BKP和PWR时钟,设置PWR，使能BKP和RTC的访问</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP|RCC_APB1Periph_PWR,ENABLE);</span><br><span class="line">	PWR_BackupAccessCmd(ENABLE);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.使用RCC开启LSE时钟,等待LSERDY标志位为1</span></span><br><span class="line">	RCC_LSEConfig(RCC_LSE_ON);<span class="comment">//使用LSI修改处1：RCC_LSICmd(ENABLE);</span></span><br><span class="line">  <span class="keyword">while</span>(RCC_GetFlagStatus(RCC_FLAG_LSERDY)!= SET)<span class="comment">//使用LSI修改处2：RCC_FLAG_LSIRDY</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3.配置RTCCLK数据选择器，指定LSE为RTCCLK，并且调用RTCCLK_Cmd使能</span></span><br><span class="line">	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);<span class="comment">//使用LSI修改处3：RCC_FLAG_LSERDY</span></span><br><span class="line">	RCC_RTCCLKCmd(ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4.调用两个等待函数，注意事项中的等待同步与等待上一次操作完成</span></span><br><span class="line">	RTC_WaitForSynchro();</span><br><span class="line">	RTC_WaitForLastTask();</span><br><span class="line">	<span class="comment">//这两行代码是安全保障措施，防止因为时钟不同步而出现bug</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//5.配置预分频器，RTC_SetPrescaler，并且再调用等待上一次操作完成函数</span></span><br><span class="line">	RTC_SetPrescaler(<span class="number">32768</span><span class="number">-1</span>);<span class="comment">//LSE频率为32768HZ，32768分频后可以使频率为1hz</span></span><br><span class="line">	<span class="comment">//使用LSI修改处4：40KHz对应40000-1分频得到1hz</span></span><br><span class="line">	RTC_WaitForLastTask();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//6.配置CNT,并且再调用等待上一次操作完成函数</span></span><br><span class="line">	RTC_SetCounter(<span class="number">1672588795</span>);</span><br><span class="line">	RTC_WaitForLastTask();</span><br><span class="line">   </span><br><span class="line">	MyRTC_SetTime();<span class="comment">//设置起始时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_SetTime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">time_t</span> time_cnt;<span class="comment">//unsigned int类型数据</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_date</span>;</span></span><br><span class="line">		<span class="comment">//1.数组指定时间填充到struct tm结构体中</span></span><br><span class="line">	  time_date.tm_year = MyRTC_Time[<span class="number">0</span>]<span class="number">-1900</span>;</span><br><span class="line">		time_date.tm_mon = MyRTC_Time[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">		time_date.tm_mday = MyRTC_Time[<span class="number">2</span>];	</span><br><span class="line">		time_date.tm_hour = MyRTC_Time[<span class="number">3</span>];</span><br><span class="line">		time_date.tm_min = MyRTC_Time[<span class="number">4</span>];</span><br><span class="line">		time_date.tm_sec = MyRTC_Time[<span class="number">5</span>];</span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">//2.使用mktime得到秒数</span></span><br><span class="line">		time_cnt = mktime(&amp;time_date) - <span class="number">8</span>*<span class="number">60</span>*<span class="number">60</span>;<span class="comment">//此处是北京时间转为伦敦时间，因为RTC中的秒数是以伦敦时间计算的，写入到CNT中也应该是伦敦时间</span></span><br><span class="line">		</span><br><span class="line">	  <span class="comment">//3.写入RTC的CNT中</span></span><br><span class="line">	  RTC_SetCounter(time_cnt);</span><br><span class="line">	  RTC_WaitForLastTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_ReadTime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">time_t</span> time_cnt;<span class="comment">//unsigned int类型数据</span></span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_date</span>;</span></span><br><span class="line">		</span><br><span class="line">	  time_cnt = RTC_GetCounter()+ <span class="number">8</span>*<span class="number">60</span>*<span class="number">60</span>;<span class="comment">//此处是伦敦时间转换为北京时间，东8区，要多8个小时，对应8个小时的秒数</span></span><br><span class="line">    </span><br><span class="line">	  time_date = *localtime(&amp;time_cnt);</span><br><span class="line">	  </span><br><span class="line">	  	MyRTC_Time[<span class="number">0</span>] = time_date.tm_year+<span class="number">1900</span>;</span><br><span class="line">		MyRTC_Time[<span class="number">1</span>] = time_date.tm_mon+<span class="number">1</span>;</span><br><span class="line">		MyRTC_Time[<span class="number">2</span>] = time_date.tm_mday;</span><br><span class="line">		MyRTC_Time[<span class="number">3</span>] = time_date.tm_hour ;</span><br><span class="line">		MyRTC_Time[<span class="number">4</span>] = time_date.tm_min;</span><br><span class="line">		MyRTC_Time[<span class="number">5</span>] = time_date.tm_sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>在程序中由于F103芯片等的BUG，可能使用LSE时不会起振，此时函数会卡死在初始化中，我们可以用示波器观察是否产生波形判断一下</strong></p>
<p><code>解决方案：</code></p>
<p><strong>此时我们可以使用LSI作为时钟源，但是就不能实现掉电时间不重置了因为LSI不像LSE一样可以由VBat备用电池供电</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	MyRTC_Init();		<span class="comment">//RTC初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Date:XXXX-XX-XX&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Time:XX:XX:XX&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;CNT :&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;DIV :&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		MyRTC_ReadTime();							<span class="comment">//RTC读取时间，最新的时间存储到MyRTC_Time数组中</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, MyRTC_Time[<span class="number">0</span>], <span class="number">4</span>);		<span class="comment">//显示MyRTC_Time数组中的时间值，年</span></span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">11</span>, MyRTC_Time[<span class="number">1</span>], <span class="number">2</span>);		<span class="comment">//月</span></span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">14</span>, MyRTC_Time[<span class="number">2</span>], <span class="number">2</span>);		<span class="comment">//日</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, MyRTC_Time[<span class="number">3</span>], <span class="number">2</span>);		<span class="comment">//时</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">9</span>, MyRTC_Time[<span class="number">4</span>], <span class="number">2</span>);		<span class="comment">//分</span></span><br><span class="line">		OLED_ShowNum(<span class="number">2</span>, <span class="number">12</span>, MyRTC_Time[<span class="number">5</span>], <span class="number">2</span>);		<span class="comment">//秒</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowNum(<span class="number">3</span>, <span class="number">6</span>, RTC_GetCounter(), <span class="number">10</span>);	<span class="comment">//显示32位的秒计数器</span></span><br><span class="line">		OLED_ShowNum(<span class="number">4</span>, <span class="number">6</span>, RTC_GetDivider(), <span class="number">10</span>);	<span class="comment">//显示余数寄存器</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="BKP寄存器解决掉电时间不丢失问题">BKP寄存器解决掉电时间不丢失问题</h3>
<blockquote>
<p><strong>在对RTC的初始化中，我们要有判断的去执行</strong>：</p>
<ol>
<li>
<p>当系统完全断电了，备用电池也断电了，我们就执行初始化</p>
</li>
<li>
<p>当系统只是主电源断电，备用电池没断的话，LSE一直都在运行，就不用执行初始化</p>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*我们只需要修改MyRTC_Init()的代码即可，为其添加一个BKP寄存器自定义标志位的判断*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		<span class="comment">//开启PWR的时钟</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);		<span class="comment">//开启BKP的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*备份寄存器访问使能*/</span></span><br><span class="line">	PWR_BackupAccessCmd(ENABLE);							<span class="comment">//使用PWR开启对备份寄存器的访问</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (BKP_ReadBackupRegister(BKP_DR1) != <span class="number">0xAAAA</span>)			<span class="comment">//通过写入备份寄存器的标志位，判断RTC是否是第一次配置</span></span><br><span class="line">															<span class="comment">//if成立则执行第一次的RTC配置</span></span><br><span class="line">	&#123;</span><br><span class="line">		RCC_LSEConfig(RCC_LSE_ON);							<span class="comment">//开启LSE时钟</span></span><br><span class="line">		<span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSERDY) != SET);	<span class="comment">//等待LSE准备就绪</span></span><br><span class="line">		</span><br><span class="line">		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);				<span class="comment">//选择RTCCLK来源为LSE</span></span><br><span class="line">		RCC_RTCCLKCmd(ENABLE);								<span class="comment">//RTCCLK使能</span></span><br><span class="line">		</span><br><span class="line">		RTC_WaitForSynchro();								<span class="comment">//等待同步</span></span><br><span class="line">		RTC_WaitForLastTask();								<span class="comment">//等待上一次操作完成</span></span><br><span class="line">		</span><br><span class="line">		RTC_SetPrescaler(<span class="number">32768</span> - <span class="number">1</span>);						<span class="comment">//设置RTC预分频器，预分频后的计数频率为1Hz</span></span><br><span class="line">		RTC_WaitForLastTask();								<span class="comment">//等待上一次操作完成</span></span><br><span class="line">		</span><br><span class="line">		MyRTC_SetTime();									<span class="comment">//设置时间，调用此函数，全局数组里时间值刷新到RTC硬件电路</span></span><br><span class="line">		</span><br><span class="line">		BKP_WriteBackupRegister(BKP_DR1, <span class="number">0xAAAA</span>);			<span class="comment">//在备份寄存器写入自己规定的标志位，用于判断RTC是不是第一次执行配置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>													<span class="comment">//RTC不是第一次配置</span></span><br><span class="line">	&#123;</span><br><span class="line">		RTC_WaitForSynchro();								<span class="comment">//等待同步</span></span><br><span class="line">		RTC_WaitForLastTask();								<span class="comment">//等待上一次操作完成</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如果LSE无法起振导致程序卡死在初始化函数中,可将初始化函数替换为下述代码，使用LSI当作RTCCLK</strong></p>
<p><code>LSI无法由备用电源供电，故主电源掉电时，RTC走时会暂停</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);</span><br><span class="line">    </span><br><span class="line">    PWR_BackupAccessCmd(ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (BKP_ReadBackupRegister(BKP_DR1) != <span class="number">0xA5A5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       RCC_LSICmd(ENABLE);</span><br><span class="line">       <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET);</span><br><span class="line">       </span><br><span class="line">       RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);</span><br><span class="line">       RCC_RTCCLKCmd(ENABLE);</span><br><span class="line">       </span><br><span class="line">       RTC_WaitForSynchro();</span><br><span class="line">       RTC_WaitForLastTask();</span><br><span class="line">       </span><br><span class="line">       RTC_SetPrescaler(<span class="number">40000</span> - <span class="number">1</span>);</span><br><span class="line">       RTC_WaitForLastTask();</span><br><span class="line">       </span><br><span class="line">       MyRTC_SetTime();</span><br><span class="line">       </span><br><span class="line">       BKP_WriteBackupRegister(BKP_DR1, <span class="number">0xA5A5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       RCC_LSICmd(ENABLE);             <span class="comment">//即使不是第一次配置，也需要再次开启LSI时钟</span></span><br><span class="line">       <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET);</span><br><span class="line">       </span><br><span class="line">       RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);</span><br><span class="line">       RCC_RTCCLKCmd(ENABLE);</span><br><span class="line">       </span><br><span class="line">       RTC_WaitForSynchro();</span><br><span class="line">       RTC_WaitForLastTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>PWR电源控制</h1>
<h2 id="PWR简介">PWR简介</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250110170201038-1737529755593150.png" alt="image-20250110170201038"></p>
<blockquote>
<p>实现<code>可编程电压检测器</code>和<code>低功耗模式</code></p>
<p>**可编程电压检测器PVD：**监视VDD电压，在供电电压下降到PVD阀值以下时或上升到PVD阈值以上时，产生一个中断，通知软件做紧急处理</p>
<p>**低功耗模式：**睡眠模式Sleep、停机模式stop、待机模式standby。在空闲状态时关闭不必要的硬件，比如把CPU断电或关闭时钟，但需要保留必要的唤醒电路</p>
</blockquote>
<p><code>所有知识在手册上可以找到</code></p>
<h2 id="电源框图">电源框图</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250110170713455-1737529755593149.png" alt="image-20250110170713455"></p>
<blockquote>
<p>STM32内部供电方案图可分为三个部分：</p>
<p><code>模拟部分供电：</code>VDDA(VDD Analog)</p>
<p>包括A/D转换器、温度传感器、复位模块、PLL</p>
<p>供电正极为：VDDA</p>
<p>供电负极为：VSSA</p>
<p>其中还有两个参考电压供电脚：VREF- 和VREF+</p>
<p>在该芯片中直接接入了VSSA和VDDA，也可能会单独引出去</p>
<hr>
<p><code>数字部分供电：</code>VDD供电区域和1.8V供电区域</p>
<p><strong>VDD供电区域</strong>：I/O电路、待机电路、电压调节器(为1.8V区域供电)</p>
<p><strong>1.8V供电区域</strong>：CPU、存储器、外设</p>
<p>我们可以看到CPU、存储器和外设都是以1.8V的低电压运行的，当需要与外界交流时，才会通过I/O电路转换为3.3V</p>
<hr>
<p><code>后备供电区域：</code>VBAT为以下供电</p>
<p>LSE 32K晶体振荡器后备寄存器</p>
<p>RCC BDCR寄存器，即备份域控制寄存器</p>
<p>RTC</p>
<p>低电压检测器：控制开关，VDD有电时由VDD供电，VDD没电时由VBAT供电</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250110171925509-1737529755593151.png" alt="image-20250110171925509"></p>
</blockquote>
<h2 id="上电复位和掉电复位-POR-PDR">上电复位和掉电复位(POR/PDR)</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250110181242741-1737529755593153.png" alt="image-20250110181242741"></p>
<blockquote>
<p>设置了阈值电压：40mV迟滞避免电压来回波动，造成输出也来回抖动</p>
<p>Reset：低电平有效</p>
<p>对应滞后时间在stm32数据手册可以找到</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250110181444794-1737529755593152.png" alt="image-20250110181444794"></p>
</blockquote>
<h2 id="可编程电压检测器PVD">可编程电压检测器PVD</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250110181535199-1737529755593154.png" alt="image-20250110181535199"></p>
<blockquote>
<p><strong>PVD-(Programmable Votage Detector)作用</strong>：</p>
<p>监视VDD电压，在供电电压下降到PVD阀值以下时或上升到PVD阈值以上时，产生一个中断，通知软件做紧急处理。</p>
<p>PVD在电压过低时为1，正常时输出0</p>
<p>PVD在上升沿或下降沿时触发中断，通过<strong>外部中断</strong>实现，提醒用户处理。</p>
<hr>
<p>PVD的阈值电压可以使用程序指定，配置PLS寄存器3位，迟滞电压上限为100mV</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250110181653488-1737529755593155.png" alt="image-20250110181653488"></p>
</blockquote>
<h2 id="低功耗模式介绍">低功耗模式介绍</h2>
<p><code>手册中的低功耗模式介绍：</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250110182653384-1737529755593156.png" alt="image-20250110182653384"></p>
<blockquote>
<p>三种模式从上到下：<code>睡眠</code>、<code>停机(止)</code>、<code>待机</code></p>
<ol>
<li>关闭的电路越来越多</li>
<li>越来越省电</li>
<li>越来越难唤醒</li>
</ol>
<p>图中可以知道关闭电路通常由两个做法：<code>关闭时钟</code>或<code>关闭电源</code></p>
<p><strong>关闭时钟</strong>：所有的运算和涉及时序的操作都会暂停，寄存器和存储器保存的数据可以维持不会消失</p>
<p><strong>关闭电源</strong>：电路直接断电，电路操作和寄存器数据都丢失，比关闭时钟更省电</p>
<hr>
<p><code>睡眠模式：一般省电</code></p>
<p>**WFI(wait for interrupt)：**等待中断，对应唤醒条件为<code>中断唤醒</code>，意思就是处于睡眠状态，如果有中断发生再叫我起来。</p>
<p>调用WFI进入的睡眠模式，<strong>任何外设发生任何中断时</strong>，芯片都会立刻醒来，进入中断处理程序</p>
<p>**WFE(wait for event)：**等待事件，对应唤醒条件为<code>唤醒事件</code>，可以是外部中断配置为事件模式，也可以是使能了中断但没有配置NVIC</p>
<p>调用WFE进入的睡眠模式，产生唤醒事件时，会立刻醒来。一般不需要进中断函数</p>
<p><code>对电路影响：</code>只关闭了CPU时钟，其他电路没有影响。<strong>看上图中描述</strong></p>
<hr>
<p><code>停机模式：非常省电</code></p>
<p><strong>SLEEPDEEP位</strong>：置1进入深度睡眠</p>
<p><strong>PDDS位</strong>：区分停机和待机。PDDS=0，进入停机模式，PDDS=1，进入待机模式</p>
<p><strong>LPDS位</strong>：<strong>设置电压调节器</strong>，开启或进入低功耗模式。LPDS=0,电压调节器开启LPDS=1，电压调节器进入低功耗(更省电但唤醒延迟更高)。</p>
<p><strong>设置流程：SLEEPDEEP=1，PDDS=0，LPDS=0/1，再调用WFI或WFE，芯片就可以进入停止模式了</strong></p>
<p><strong>唤醒条件</strong>：只有任一的外部中断能唤醒，其他中断不能唤醒</p>
<p>WFI用外部中断中断模式唤醒，WFE用外部中断事件唤醒</p>
<p><code>对电路影响：</code>关闭所有1.8V区域的时钟(CPU、AD、外设)，以及HSI和HSE振荡器，但不会关闭LSI和LSE，电压调节器开启(1.8V区域电源仍开启)。<strong>看上图中描述</strong></p>
<hr>
<p><code>待机模式:极为省电</code></p>
<p><strong>设置流程：SLEEPDEEP=1，PDDS=1，再调用WFI或WFE，芯片就可以进入停止模式了</strong></p>
<p>**唤醒条件：**普通外设中断或外部中断都无法唤醒待机模式，只能由以下四个信号唤醒</p>
<ol>
<li>WKUP引脚上升沿(如PA0-Wakeup，即PA0)</li>
<li>RTC闹钟事件</li>
<li>NRST引脚的外部复位(Reset一下)</li>
<li>IWDG复位</li>
</ol>
<p><code>对电路影响：</code>关闭所有1.8V区域的时钟(CPU、AD、外设)，两个高速时钟关闭，两个低速时钟不会关闭，电压调节器关闭(即1.8V区域电源关闭)。<strong>看上图中描述</strong></p>
</blockquote>
<h2 id="模式选择的图">模式选择的图</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250110195522341-1737529755593157.png" alt="image-20250110195522341"></p>
<blockquote>
<p>配置其他寄存器在执行WFI或WFE之前。</p>
<p>图中最左边是执行WFI/WFE后，根据各个寄存器判断启动什么模式的流程</p>
</blockquote>
<h2 id="三种模式特性及注意事项">三种模式特性及注意事项</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250110211426203-1737529755593158.png" alt="image-20250110211426203"></p>
<blockquote>
<p><strong>GPIO高低电平保持睡眠前运行时的状态，唤醒后程序从暂停的地方继续运行</strong></p>
<p>手册对事件唤醒描述：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250110211647415-1737529755593159.png" alt="image-20250110211647415"></p>
<p>比较麻烦所以还是使用中断唤醒吧</p>
</blockquote>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250110211742039-1737529755593161.png" alt="image-20250110211742039"></p>
<blockquote>
<p><strong>GPIO高低电平保持睡眠前运行时的状态，唤醒后程序从暂停的地方继续运行</strong></p>
<p><strong>注意：</strong></p>
<p>停止模式唤醒时，因为HSI被选为了系统时钟，所以变成了8MHz的主频，<code>所以我们在停止模式唤醒后第一时间应该重新启动HSE，配置主频为72MHz(调用SystemInit即可)</code></p>
</blockquote>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250110212325583-1737529755593162.png" alt="image-20250110212325583"></p>
<blockquote>
<p><strong>待机模式下，GPIO输出引脚变为高阻态(浮空输入)，唤醒后程序从头开始运行</strong></p>
<p>仅备份寄存器和待机电路供电</p>
<p>仅四种方式退出待机模式</p>
</blockquote>
<h2 id="节电方法">节电方法</h2>
<p>在数据手册工作条件的供电电流特性测试电流部分可以得到省电方法</p>
<ol>
<li><strong>关闭不需要的外设对应时钟</strong></li>
<li><strong>降低主频，耗电电流下降，对于省电也挺划算的。设备需要连续运行，但是对于主频和性能没这么高要求的话，就可以选择降低主频</strong></li>
</ol>
<blockquote>
<p>产品使用电池的话低功耗模式也是很必要使用的</p>
</blockquote>
<h2 id="SLEEPDEEP和SLEEPONEXIT位配置">SLEEPDEEP和SLEEPONEXIT位配置</h2>
<blockquote>
<p>这两个位位于内核系统控制块，没有提供什么简单的配置方法，只能通过操作寄存器来配置，默认值为0</p>
<p>我们需要打开Cortex-M3编程手册，第4章内核外设的系统控制块SCB中找到寄存器介绍</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250111155405959-1737529755593160.png" alt="image-20250111155405959"></p>
<p>对应SCB-&gt;SCR寄存器等按照配置编程手册上的位配置即可</p>
</blockquote>
<h2 id="修改主频">修改主频</h2>
<p>在system_stm32f10x.c文件中可以看到的描述是有两个函数和一个变量与系统主频有关</p>
<p>在system_stm32f10x.h文件中也可以找到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> SystemCoreClock;<span class="comment">//系统时钟</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//系统时钟初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">SystemCoreClockUpdate</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//系统时钟更新</span></span><br></pre></td></tr></table></figure>
<p>在system_stm32f10x.c文件中，对应部分找到自己的型号然后进行修改主频即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250111152640885-1737529755593165.png" alt="image-20250111152640885"></p>
<blockquote>
<p>修改主频后，使用主频的地方需要修改，比如Delay函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250111152842134-1737529755593163.png" alt="image-20250111152842134"></p>
<p>在72Mhz下是正确延时指定时间，但是变为36Mhz后，就会变为原来的1/2。所以最好将SystemCoreClock变量带入计算中做自适应</p>
<hr>
<p><code>所以一般条件下不推荐修改主频，除非有需求</code></p>
</blockquote>
<h2 id="睡眠模式实例">睡眠模式实例</h2>
<p>睡眠模式使用寄存器都是内核中的，与PWR没什么关系，所以没使用PWR库函数</p>
<h3 id="串口收发">串口收发</h3>
<blockquote>
<p><strong>对于这种靠任意中断触发，没中断就没什么事的，平时主循环会耗电</strong></p>
<p><strong>我们就可以给它加入低功耗模式</strong></p>
<p><code>根据分析，这种情况下串口只能使用睡眠模式</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Serial.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RxData;			<span class="comment">//定义用于接收串口数据的变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;RxData:&quot;</span>);	<span class="comment">//显示静态字符串</span></span><br><span class="line">	</span><br><span class="line">	Serial_Init();		<span class="comment">//串口初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Serial_GetRxFlag() == <span class="number">1</span>)			<span class="comment">//检查串口接收数据的标志位</span></span><br><span class="line">		&#123;</span><br><span class="line">			RxData = Serial_GetRxData();		<span class="comment">//获取串口接收的数据</span></span><br><span class="line">			Serial_SendByte(RxData);			<span class="comment">//串口将收到的数据回传回去，用于测试</span></span><br><span class="line">			OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, RxData, <span class="number">2</span>);	<span class="comment">//显示串口接收的数据</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);		<span class="comment">//OLED闪烁Running，指示当前主循环正在运行</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		__WFI();								<span class="comment">//执行WFI指令，CPU睡眠，并等待中断唤醒</span></span><br><span class="line">        <span class="comment">//__WFE();WFE,事件唤醒</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>对于睡眠模式我们在while循环中加入WFI或WFE即可实现睡眠模式，唤醒后继续执行上一次执行的操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__WFI();<span class="comment">//执行WFI指令，CPU睡眠，并等待中断唤醒</span></span><br><span class="line">__WFE();<span class="comment">//WFE,事件唤醒</span></span><br></pre></td></tr></table></figure>
<p><code>现象：</code></p>
<p>OLED上不再持续显示Running，此时用串口助手发送信息，每发送一次，Running闪烁显示一次，说明只有接收中断后才会唤醒工作一次，然后立马睡眠</p>
</blockquote>
<h2 id="停机模式实例">停机模式实例</h2>
<h3 id="库函数-10">库函数</h3>
<p>停机模式涉及内核外的电路操作，需要使用库函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWR_DeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_BackupAccessCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//使能后备区域的访问，在RTC初始化时需要使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_PVDCmd</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//PVD使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_PVDLevelConfig</span><span class="params">(<span class="type">uint32_t</span> PWR_PVDLevel)</span>;<span class="comment">//PVD阈值电压配置</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_WakeUpPinCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//WKUP引脚唤醒功能使用需要调用此函数开启</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_EnterSTOPMode</span><span class="params">(<span class="type">uint32_t</span> PWR_Regulator, <span class="type">uint8_t</span> PWR_STOPEntry)</span>;</span><br><span class="line"><span class="comment">//停机模式：调用该函数就可以进入停止模式了</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_EnterSTANDBYMode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//待机模式：调用该函数就可以进入待机模式了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//PWR标志位相关函数</span></span><br><span class="line">FlagStatus <span class="title function_">PWR_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> PWR_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> PWR_FLAG)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="对射式红外传感器外部中断-停机模式">对射式红外传感器外部中断(停机模式)</h3>
<blockquote>
<p>使用<strong>外部中断触发</strong>的可以考虑使用<strong>更省电的停机模式</strong></p>
<p>虽然停机模式关闭了外设时钟，但是外部中断使用不需要时钟就能工作</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CountSensor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();			<span class="comment">//OLED初始化</span></span><br><span class="line">	CountSensor_Init();		<span class="comment">//红外计数传感器初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		<span class="comment">//开启PWR的时钟！！！</span></span><br><span class="line">															<span class="comment">//停止模式和待机模式一定要记得开启</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Count:&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">7</span>, CountSensor_Get(), <span class="number">5</span>);			<span class="comment">//OLED不断刷新显示CountSensor_Get的返回值</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);					<span class="comment">//OLED闪烁Running，指示当前主循环正在运行</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI);	<span class="comment">//STM32WFI指令进入停止模式，并等待中断唤醒</span></span><br><span class="line">        </span><br><span class="line">		SystemInit();											<span class="comment">//唤醒后，要重新配置时钟</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI):</code></p>
<p>该函数最后调用了WFI或WFE指令之后就进入了静止模式</p>
<hr>
<p><code>SystemInit()：</code>唤醒后时钟变为了HSI的8M，需要我们重新启动HSE，配置72M的主频，调用该函数即可</p>
</blockquote>
<blockquote>
<p><code>现象：</code>红外传感器计数一次，Running闪烁一次，确实进入了停机模式</p>
</blockquote>
<h2 id="待机模式实例">待机模式实例</h2>
<h3 id="RTC闹钟-待机模式">RTC闹钟(待机模式)</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();		<span class="comment">//OLED初始化</span></span><br><span class="line">	MyRTC_Init();		<span class="comment">//RTC初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);		<span class="comment">//开启PWR的时钟</span></span><br><span class="line">															<span class="comment">//停止模式和待机模式一定要记得开启时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;CNT :&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;ALR :&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;ALRF:&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*使能WKUP引脚*/</span></span><br><span class="line">	PWR_WakeUpPinCmd(ENABLE);						<span class="comment">//使能位于PA0的WKUP引脚，WKUP引脚上升沿唤醒待机模式,接上VCC即可唤醒</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*设定闹钟：由于该寄存器是只写的不可读，所以我们使用变量显示*/</span></span><br><span class="line">	<span class="type">uint32_t</span> Alarm = RTC_GetCounter() + <span class="number">10</span>;			<span class="comment">//闹钟为唤醒后当前时间的后10s</span></span><br><span class="line">	RTC_SetAlarm(Alarm);							<span class="comment">//写入闹钟值到RTC的ALR寄存器</span></span><br><span class="line">	OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, Alarm, <span class="number">10</span>);					<span class="comment">//显示闹钟值</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, RTC_GetCounter(), <span class="number">10</span>);	<span class="comment">//显示32位的秒计数器</span></span><br><span class="line">		OLED_ShowNum(<span class="number">3</span>, <span class="number">6</span>, RTC_GetFlagStatus(RTC_FLAG_ALR), <span class="number">1</span>);		<span class="comment">//显示闹钟标志位</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);			<span class="comment">//OLED闪烁Running，指示当前主循环正在运行</span></span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">9</span>, <span class="string">&quot;STANDBY&quot;</span>);			<span class="comment">//OLED闪烁STANDBY，指示即将进入待机模式</span></span><br><span class="line">		Delay_ms(<span class="number">1000</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">9</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		OLED_Clear();								<span class="comment">//OLED清屏，模拟关闭外部所有的耗电设备，以达到极度省电</span></span><br><span class="line">		</span><br><span class="line">		PWR_EnterSTANDBYMode();						<span class="comment">//STM32进入停止模式，并等待指定的唤醒事件（WKUP上升沿或RTC闹钟）</span></span><br><span class="line">		<span class="comment">/*待机模式唤醒后，程序会重头开始运行*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>PWR_EnterSTANDBYMode():</code></p>
<p>该函数最后统一调用WFI指令进入待机模式</p>
<hr>
<p><strong>待机模式下只有这四种可以唤醒</strong>：</p>
<ol>
<li>WKUP引脚上升沿(如PA0-Wakeup，即PA0)：手册中对应描述不需要GPIO初始化，被强制下拉，只需要接VCC即可唤醒</li>
<li>RTC闹钟事件</li>
<li>NRST引脚的外部复位(Reset一下)</li>
<li>IWDG复位</li>
</ol>
</blockquote>
<blockquote>
<p><code>现象：</code>等待10s后，Running闪烁一下后消失，CNT和ALR的值都更新，说明待机模式下唤醒后，程序从头开始运行，所以我们不用重新调用SystemInit了。</p>
</blockquote>
<p><code>最大化省电：</code><strong>进入待机模式前把外接的模块能关的全关，需要精心设计电路。否则待机模式无法做到真正的极度省电！！！</strong></p>
<h1>看门狗WDG</h1>
<h2 id="看门狗简介">看门狗简介</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250111173313542-1737529755593164.png" alt="image-20250111173313542"></p>
<blockquote>
<p><code>看门狗</code>：由于程序出现漏洞、硬件故障、电磁干扰等原因出现卡死或跑飞现象时可以及时复位程序。</p>
<p>本质是一个<strong>定时器</strong>，在指定时间范围内，程序没有执行<strong>喂狗</strong>(手动重装计数器)操作时，看门狗硬件电路就自动产生复位信号。</p>
<p><code>作用：</code>提高系统的可靠性和健壮性，避免程序陷入长时间罢工状态</p>
<p>可以预料的漏洞应该尽量解决，开门狗只是一个复位的作用，可能会出现复位也不能解决的问题</p>
<hr>
<p>STM32内置两个看门狗：独立看门狗(IWDG)和窗口看门狗(WWDG)</p>
<p><strong>独立看门狗(IWDG)</strong>：使用专门的LSI时钟，即使主时钟出现问题，独立看门狗也能正常工作，这就是<strong>独立的命名</strong>。对时间精度要求较低，只有一个喂狗最晚界限。</p>
<p><strong>窗口看门狗(WWDG)</strong>：使用APB1时钟，要求看门狗在精确的计时窗口作用，有喂狗最早界限和最晚界限，必须在这个界限窗口内喂狗，这就是窗口的命名。喂早和喂晚都会发生复位</p>
<p><code>对应更多内容请查看参考手册!!!</code></p>
</blockquote>
<h2 id="独立看门狗IWDG">独立看门狗IWDG</h2>
<h3 id="IWDG框图">IWDG框图</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250112155237497-1737529755593166.png" alt="image-20250112155237497"></p>
<blockquote>
<p>IWDG_PR：其实就是定时器中的预分频Prescaler缩写，8位，最大为256</p>
<p>IWDG_RLR：就是定时器中的ARR=Auto Reloader，RLR = Reloader，12位最大为4096</p>
<p>IWDG_SR：状态寄存器</p>
<p><strong>工作流程</strong>：计数器为递减计数器，自减到0之前执行喂狗操作，重置计数器为4096-1，当计数器自减到0时，就会进行复位</p>
<hr>
<p>上面寄存器处于1.8V供电区，而下面的电路处于VDD供电区，所以在停机和待机模式下只会关闭1.8V时钟，所以可以在停机和待机模式下可以运行。</p>
<p>待机模式下的唤醒条件之一就包含看门狗</p>
</blockquote>
<h3 id="IWDG键寄存器">IWDG键寄存器</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250112160401346-1737529755593167.png" alt="image-20250112160401346"></p>
<blockquote>
<p><strong>在多个位确定代替一位的情况下，该寄存器就算值变化，也很难恰巧出现以上的值，这样就更保险。</strong></p>
<p>同时对IWDG_PR、IWDG_RLR设计了写保护，只有写入键寄存器的值为0x5555时才会解除写保护，其他情况下都不允许写入</p>
<p>IWDG_SR由于是只读的就不用管</p>
</blockquote>
<h3 id="IWDG超时时间">IWDG超时时间</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250112160724383-1737529755593168.png" alt="image-20250112160724383"></p>
<blockquote>
<p>就是定时器溢出时间，和定时器溢出时间相同</p>
<p>最大值只能是</p>
<p>PR[2:0]：写入0~7，固定上面几个分频系数</p>
</blockquote>
<h2 id="窗口看门狗WWDG">窗口看门狗WWDG</h2>
<h3 id="WWDG框图">WWDG框图</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250112161153418-1737529755593169.png" alt="image-20250112161153418"></p>
<blockquote>
<p>**时钟源：**PCK1 = 36M，进入预分频器前还进行了4096分频，图中没画出</p>
<p>**看门狗的预分频器WDGTB：**与独立看门狗PR和定时器的PSC都是一样的道理</p>
<hr>
<p>**看门狗控制寄存器(WWDG_CR)：<strong>包</strong>WDGA(看门狗使能位)**和计数器，与计数器合二为一了。</p>
<p>**6/7位递减计数器CNT：**CNT的有效位为T0~T5，T6位用于判断是否溢出。<strong>启动时必须将此位写入1，值为1代表计数器没有溢出，值为0代表计数器溢出，产生看门狗复位</strong>。位于控制寄存器CR中，计数器和控制寄存器合二为一。</p>
<p>窗口看门狗没有重装寄存器，直接向CNT写数据。</p>
<p><strong>当T6~T0位为1 0 0 0 0 0 0 (<code>0x40</code>)，第1位为标志位T6为1，6位计数器的值为000000。再减一次后T6位变为0，计数器溢出，T6通过图中线路产生复位信号</strong>。</p>
<ul>
<li>
<p><strong>如果把T0~T5看成计数器，就是6位计数器，那么就是自减到0时溢出</strong></p>
</li>
<li>
<p><strong>如果把T0~T6为看成计数器，就是7位计数器，那么就是自减小于0x40时溢出</strong></p>
</li>
</ul>
<p><code>喂狗操作：</code>写入WWDG_CR寄存器，也就是写入CNT</p>
</blockquote>
<blockquote>
<hr>
<p><strong>看门狗配置寄存器WWDG_CFR：</strong></p>
<p>用于设置喂狗的<code>窗口值的最早界限</code>，写入W6~W0，7位数据，固定不变</p>
<hr>
<p>最左边是比较器逻辑，什么时候产生复位操作的逻辑</p>
<hr>
<p><code>工作流程：</code></p>
<p>首先时钟从PCLK1(36M时钟进入)，然后经过预分频器分频，驱动计数器进行计数，每来一个时钟自减一次。最终比较进行复位</p>
</blockquote>
<h3 id="WWDG工作特性">WWDG工作特性</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250112163354916-17366708495051-1737529755594170.png" alt="image-20250112163354916"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250112182947095-1737529755594171.png" alt="image-20250112182947095"></p>
<blockquote>
<p>定期写入WWDG_CR寄存器喂狗，避免WWDG复位</p>
<p><strong>W[6:0]</strong>：喂狗的最早界限，对应<code>窗口时间</code></p>
<p><strong>T[6:0]：</strong> 喂狗的计数器值，对应<code>超时时间</code></p>
<p><strong>0x3F</strong>：喂狗的最晚界限，由0x40-1得到，对应<code>超时时间的最大值</code></p>
<p><code>窗口时间~超时时间:</code>之间喂狗才不会复位</p>
<hr>
<p>递减计数器T[6:0] = 0X40 产生早期唤醒中断EWI</p>
</blockquote>
<h3 id="WWDG超时时间">WWDG超时时间</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250112164040798-1737529755594172.png" alt="image-20250112164040798"></p>
<h2 id="IWDG和WWDG对比">IWDG和WWDG对比</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250112164553712-1737529755594173.png" alt="image-20250112164553712"></p>
<blockquote>
<p><strong>窗口看门狗的精度比独立看门狗高</strong></p>
</blockquote>
<h2 id="独立看门狗代码">独立看门狗代码</h2>
<h3 id="相关库函数">相关库函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*stm32f10x_iwdg.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_WriteAccessCmd</span><span class="params">(<span class="type">uint16_t</span> IWDG_WriteAccess)</span>;</span><br><span class="line"><span class="comment">//写使能控制，键寄存器写入ENABLE就是0x5555，Disable就是0x0000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_SetPrescaler</span><span class="params">(<span class="type">uint8_t</span> IWDG_Prescaler)</span>;</span><br><span class="line"><span class="comment">//设置预分频</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_SetReload</span><span class="params">(<span class="type">uint16_t</span> Reload)</span>;</span><br><span class="line"><span class="comment">//设置重装载值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_ReloadCounter</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//喂狗操作：重新装载寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_Enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//启用独立看门狗，键寄存器写入0xCCCC</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">IWDG_GetFlagStatus</span><span class="params">(<span class="type">uint16_t</span> IWDG_FLAG)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*RCC库函数，stm32f10x_rcc.c*/</span></span><br><span class="line">FlagStatus <span class="title function_">RCC_GetFlagStatus</span><span class="params">(<span class="type">uint8_t</span> RCC_FLAG)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* *   For @b other_STM32_devices, this parameter can be one of the following values:        </span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_PLLRDY: PLL clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_PINRST: Pin reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_PORRST: POR/PDR reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_SFTRST: Software reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_LPWRRST: Low Power reset</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用RCC中的获取标志位函数可以根据可选参数得到是什么造成的复位，这里用于判断复位是否由看门狗完成</p>
<p><code>同时我们的看门狗标志位必须手动清除，因为及时按下复位键也不会手动清0。如果不清零下次即使是复位键复位也会判断为看门狗复位</code></p>
</blockquote>
<h3 id="配置流程-2">配置流程</h3>
<ol>
<li>开启时钟LSI**(不需要我们写代码，开启看门狗时会自动强制开启LSI)**</li>
</ol>
<blockquote>
<p><strong>在手册的看门狗时钟部分可以看到，开启独立看门狗后LSI会被强制打开，等LSI稳定后，就可以自动为独立看门狗提供时钟</strong></p>
</blockquote>
<ol start="2">
<li>
<p>写入键寄存器0x5555关闭写保护，再写入预分频值和重装值**(直接调用库函数，不需要我们寄存器操作)**</p>
</li>
<li>
<p>写入键寄存器0xCCCC启动看门狗**(直接调用库函数IWDG_Enable)**</p>
</li>
<li>
<p><strong>主循环执行喂狗操作</strong></p>
</li>
</ol>
<h3 id="按键触发独立看门狗">按键触发独立看门狗</h3>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250112171912193-1737529755594174.png" alt="image-20250112171912193"></p>
<p><code>设置1000ms超时：</code><strong>图中可以看到前两个分频系数最大超时时间&lt;1000ms不满足,所以选下面的,优先选择预分频系数小的最大化利用计数器值</strong></p>
<p><strong>LSI时钟</strong>：40kHz -&gt; 0.025ms</p>
<p><strong>计算预分频系数PR</strong>：16</p>
<p><strong>计算重载寄存器RL</strong>： 1000/(0.025*16) = 2499+1</p>
<p>重载寄存器RL值：2499</p>
<p>0.025ms * 16 * (2499+1) = 1000ms</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();						<span class="comment">//OLED初始化</span></span><br><span class="line">	Key_Init();							<span class="comment">//按键初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;IWDG TEST&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*判断复位信号来源*/</span></span><br><span class="line">	<span class="keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) == SET)	<span class="comment">//如果是独立看门狗复位</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;IWDGRST&quot;</span>);			<span class="comment">//OLED闪烁IWDGRST字符串</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		RCC_ClearFlag();							<span class="comment">//清除标志位!!!</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>											<span class="comment">//否则，即为其他复位</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;RST&quot;</span>);				<span class="comment">//OLED闪烁RST字符串</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*IWDG初始化*/</span></span><br><span class="line">	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);	<span class="comment">//1.独立看门狗写使能</span></span><br><span class="line">	IWDG_SetPrescaler(IWDG_Prescaler_16);			<span class="comment">//2.设置预分频为上面计算的16,</span></span><br><span class="line">	IWDG_SetReload(<span class="number">2499</span>);							<span class="comment">//2.设置重装值为双面计算的2499，独立看门狗的超时时间为1000ms</span></span><br><span class="line">	IWDG_ReloadCounter();							<span class="comment">//3.重装计数器，喂狗，这样更严谨一点使下个周期为1000ms</span></span><br><span class="line">	IWDG_Enable();									<span class="comment">//4.独立看门狗使能</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Key_GetNum();								<span class="comment">//调用阻塞式的按键扫描函数，模拟主循环卡死</span></span><br><span class="line">		</span><br><span class="line">		IWDG_ReloadCounter();						<span class="comment">//重装计数器，喂狗，避免复位</span></span><br><span class="line">		</span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;FEED&quot;</span>);				<span class="comment">//OLED闪烁FEED字符串</span></span><br><span class="line">		Delay_ms(<span class="number">200</span>);								<span class="comment">//喂狗间隔为200+600=800ms,没到1000ms不会重装</span></span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;    &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">600</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Delay_ms(1010);//模拟超时喂狗，多留一点冗余时间</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>按键使用的是阻塞式消抖，其中包含while循环，一直按着不松就会卡死在while循环，这样就会造成超时主循环阻塞没喂狗，触发看门狗复位</p>
</blockquote>
<blockquote>
<p>现象：正常情况下屏幕间断显示FEED</p>
<p>正常按下Reset按键，屏幕显示&quot;RST&quot;复位。</p>
<p>按下按键不松手，屏幕显示&quot;IWDGRST&quot;</p>
</blockquote>
<h2 id="窗口看门狗代码">窗口看门狗代码</h2>
<h3 id="库函数-11">库函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_DeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_SetPrescaler</span><span class="params">(<span class="type">uint32_t</span> WWDG_Prescaler)</span>;<span class="comment">//写入预分频器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_SetWindowValue</span><span class="params">(<span class="type">uint8_t</span> WindowValue)</span>;<span class="comment">//设置窗口最早界限</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_EnableIT</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//使能EWI中断</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_SetCounter</span><span class="params">(<span class="type">uint8_t</span> Counter)</span>;<span class="comment">//喂狗操作</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_Enable</span><span class="params">(<span class="type">uint8_t</span> Counter)</span>;<span class="comment">//使能看门狗,手册上说明了计数器时刻自减，所以可能是任何值，所以需要使能的时候喂一下狗</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">WWDG_GetFlagStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="配置流程-3">配置流程</h3>
<ol>
<li>
<p><strong>RCC开启APB1总线上的WWDG时钟。</strong></p>
</li>
<li>
<p><strong>设置预分频值，窗口值</strong></p>
</li>
<li>
<p><strong>使能看门狗(带有喂狗值，需要使能的时候喂一下狗)</strong></p>
</li>
<li>
<p><strong>主循环在窗口时间~超时时间内喂狗</strong></p>
</li>
</ol>
<h3 id="按键触发窗口看门狗">按键触发窗口看门狗</h3>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250112174602385-1737529755594175.png" alt="image-20250112174602385"></p>
<p><code>设定超时时间50ms</code>：图中看到只能选择最后一个分频系数</p>
<p>PCLK1的T：1/36M</p>
<p>4096是进入预分频前对PCLK1的一个分频</p>
<p>**计算预分频系数：**2的3次方 = 8</p>
<p><strong>计算T[5:0]写入计数器的值：</strong> 50ms /[(1/36M)*4096 *8] = 54.931640625  = 55(取整) = 54+1</p>
<p><code>喂狗值：</code>54</p>
<p><strong>超时时间</strong> = 1/36M * 4096 * 8 * (54+1) = 约为50ms</p>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250112180841188-1737529755594176.png" alt="image-20250112180841188"></p>
<p><code>设定窗口时间为30ms:</code></p>
<p>PCLK1的T：1/36M</p>
<p>4096是进入预分频前对PCLK1的一个分频</p>
<p>计算窗口值W[5:0]：54 - 30ms /[(1/36M)*4096 *8] = 54 - 33(取整) = 21</p>
<p><code>窗口值：</code> 21</p>
<p><strong>窗口时间</strong> = 1/36M * 4096 * 8 * (54-33) = 约为30ms</p>
<hr>
<p><code>最终我们主循环的喂狗周期为：</code><strong>30ms ~ 50ms</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();						<span class="comment">//OLED初始化</span></span><br><span class="line">	Key_Init();							<span class="comment">//按键初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;WWDG TEST&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*判断复位信号来源*/</span></span><br><span class="line">	<span class="keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_WWDGRST) == SET)	<span class="comment">//如果是窗口看门狗复位</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;WWDGRST&quot;</span>);			<span class="comment">//OLED闪烁WWDGRST字符串</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		RCC_ClearFlag();							<span class="comment">//清除标志位！！！</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>											<span class="comment">//否则，即为其他复位</span></span><br><span class="line">	&#123;</span><br><span class="line">		OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;RST&quot;</span>);				<span class="comment">//OLED闪烁RST字符串</span></span><br><span class="line">		Delay_ms(<span class="number">500</span>);</span><br><span class="line">		OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*1.开启时钟*/</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);	<span class="comment">//开启WWDG的时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*WWDG初始化*/</span></span><br><span class="line">	WWDG_SetPrescaler(WWDG_Prescaler_8);			<span class="comment">//设置预分频为8</span></span><br><span class="line">	WWDG_SetWindowValue(<span class="number">21</span> | <span class="number">0x40</span>);					<span class="comment">//设置窗口值，窗口时间为30ms</span></span><br><span class="line">	WWDG_Enable(<span class="number">54</span> | <span class="number">0x40</span>);							<span class="comment">//使能并第一次喂狗，超时时间为50ms</span></span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Key_GetNum();								<span class="comment">//调用阻塞式的按键扫描函数，模拟主循环卡死</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">/*如果把喂狗放在这里的话程序会一直触发看门狗复位，因为距离第一次喂狗时间&lt;30ms，就会触发看门狗复位*/</span></span><br><span class="line">        </span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;FEED&quot;</span>);				<span class="comment">//OLED闪烁FEED字符串</span></span><br><span class="line">		Delay_ms(<span class="number">20</span>);								<span class="comment">//喂狗间隔为20+20=40ms</span></span><br><span class="line">		OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;    &quot;</span>);</span><br><span class="line">		Delay_ms(<span class="number">20</span>);</span><br><span class="line">		</span><br><span class="line">		WWDG_SetCounter(<span class="number">54</span> | <span class="number">0x40</span>);					<span class="comment">//重装计数器，喂狗</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>代码中的或上0x40操作：</code></p>
<p>每次喂狗或上0x40是对计数器的T6位设置为1，避免每次喂狗后立即产生一个复位</p>
<p>而设置窗口时的或上0x40是为了使W6位也为1，这样才能将该窗口值与喂狗值比较，否则窗口值一直小于喂狗值</p>
</blockquote>
<h1>FLASH 闪存</h1>
<h2 id="FLASH简介">FLASH简介</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250112184103510-1737529755594177.png" alt="image-20250112184103510"></p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113122739972-1737529755594178.png" alt="image-20250113122739972"></p>
<p><code>FLASH：</code>程序存储器、系统存储器、选项字节三部分。</p>
<p>通过<code>闪存存储器接口(外设)：</code><strong>可以对程序存储器和选项字节进行擦除和编程</strong></p>
<hr>
<p><code>读写FLASH的用途：</code></p>
<ol>
<li><strong>利用程序存储器Flash的剩余空间来保存掉电不丢失的用户数据</strong></li>
<li><strong>通过在程序中编程IAP，实现程序的自我更新</strong></li>
</ol>
<hr>
<p><code>在线编程</code>(In-Circuit Programming-ICP)：用于更新程序存储器的全部内容，它通过JTAG、SWD协议或系统加载程序(Bootloader)下载程序</p>
<p><code>在程序中编程</code>(In-Application Programming-lAP)： 可以使用微制器支持的任一种通信接口下载程序</p>
<hr>
<p><code>下图各个流程都是闪存编程参考手册中的内容，可以观看闪存编程手册编程!!!</code></p>
</blockquote>
<blockquote>
<p>当有些参数数据需要掉电不丢失的时候，我们可以将其写入内部FLASH中，这样不用外挂存储器芯片，节省了资源</p>
</blockquote>
<h2 id="闪存模块组织">闪存模块组织</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113123459899-1737529755594179.png" alt="image-20250113123459899"></p>
<blockquote>
<p><code>闪存三部分：</code></p>
<p><strong>主存储器</strong>对应：<code>1.程序存储器Flash</code>，起始地址0x0800 0000。也是我们平时说的闪存容量的部分，另外两部分也属于闪存，但不统计进入容量内。</p>
<p><strong>信息块</strong>：</p>
<ul>
<li>
<p><strong>启动程序代码</strong>对应：<code>2.系统存储器</code>，存放bootloader。起始地址0x1FFF F000</p>
</li>
<li>
<p><strong>用户选择字节</strong>对应：<code>3.选项字节</code>，起始地址0x1FFF F800</p>
</li>
</ul>
<p><strong>闪存存储器接口寄存器(外设)</strong>：从地址来看就是普通的外设寄存器，SRAM的内容</p>
<hr>
<p>与W25Q64分为块、扇区、页不同</p>
<p><strong>内部Flash只有页为基本单位，每页大小为</strong><code>1K</code></p>
<p>以000、400、800、C00结尾的都一定是页的起始地址。</p>
<hr>
<p><code>对于不同容量产品，闪存的分配方式有些区别，参考单独的闪存编程参考手册！！！</code></p>
</blockquote>
<h2 id="FLASH基本结构">FLASH基本结构</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113143613020-1737529755594180.png" alt="image-20250113143613020"></p>
<blockquote>
<ol>
<li>
<p><strong>闪存存储器接口也叫闪存编程和擦除控制器FPEC</strong>。可以对程序存储器擦除和编程、选项字节擦除和编程</p>
</li>
<li>
<p>选项字节可以配置程序存储器的读写保护</p>
</li>
</ol>
</blockquote>
<h2 id="FLASH解锁">FLASH解锁</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113143920049-1737529755594181.png" alt="image-20250113143920049"></p>
<blockquote>
<p><code>FPEC：</code>闪存存储器接口/闪存编程和擦除控制器，其中的键寄存器有三个键值</p>
<p><strong>通过向键寄存器写入指定值可以解锁FLASH的写操作，对于读操作不用执行解锁操作</strong></p>
<p><code>解锁方式：</code></p>
<ol>
<li>先向FLASH_KEYR写入KEY1</li>
<li>再向FLASH_KEYR写入KEY2</li>
</ol>
<p>保护机制：一旦没有先写入KEY1，再写入KEY2就会锁死，除非复位</p>
<p><code>加锁方式：</code></p>
<ol>
<li>设置FLASH_CR中给的LOCK位锁住FPEC和FLASH_CR</li>
</ol>
<p><code>操作闪存方式：</code>先解锁，操作完后，再加锁即可</p>
</blockquote>
<h2 id="使用指针访问存储器-指针写入操作">使用指针访问存储器(指针写入操作)</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113144515473-1737529755594182.png" alt="image-20250113144515473"></p>
<blockquote>
<p>想以什么形式的方式读出数据，就把uint16_t* 改为对应类型即可，比如想以8位读取，将uint16_t*改为uint8_t*即可</p>
</blockquote>
<blockquote>
<p><code>使用 __IO原因：</code></p>
<p>当单片机通过指针访问外部硬件设备的寄存器时，<strong>由于这些寄存器的值可能会由硬件自动更新</strong>（例如，一个定时器寄存器的值会随时间变化），因此应该将这些寄存器对应的变量声明为volatile。 这样，每次访问这些变量时，都会直接从硬件寄存器中读取值，而不是使用可能已过时的缓存值。</p>
</blockquote>
<h2 id="程序存储器FLASH的擦除和编程">程序存储器FLASH的擦除和编程</h2>
<p>以下内容对应stm32闪存编写手册的2.3.4节和2.3.3节</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113151653732-1737529755594183.png" alt="image-20250113151653732"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113151600875-1737529755594184.png" alt="image-20250113151600875"></p>
<h3 id="程序存储器FLASH的全擦除">程序存储器FLASH的全擦除</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113145605786-1737529755594185.png" alt="image-20250113145605786"></p>
<blockquote>
<p><strong>程序的全擦除在库函数中使用了一个函数，我们可以直接使用，以下就是函数的底层寄存器操作步骤</strong></p>
<p><code>步骤如下：</code></p>
<ol>
<li>读取FLASH_CR的<code>LOCK位</code>，如果锁住了需要先解锁(库函数都是直接解锁)</li>
<li>置FLASH_CR的<code>MER = 1</code> (MER表示执行的是全擦除)，置FLASH_CR的<code>STRT = 1</code> (STRT为触发条件，置1后芯片开始干活)</li>
<li>检测FLASH_SR的<code>BSY位是否为1</code>，为1就一直等待，直到BSY位置0后全擦除结束</li>
</ol>
<p>读出并验证被擦除页的数据我们可以不管</p>
</blockquote>
<h3 id="程序存储器FLASH的页擦除">程序存储器FLASH的页擦除</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113172548064-1737529755594186.png" alt="image-20250113172548064"></p>
<blockquote>
<p><strong>程序的页擦除在库函数中使用了一个函数，我们可以直接使用，以下就是函数的底层寄存器操作步骤</strong></p>
<p><code>步骤如下：</code></p>
<ol>
<li>
<p>读取FLASH_CR的<code>LOCK位</code>，如果锁住了需要先解锁(库函数都是直接解锁)</p>
</li>
<li>
<p>置FLASH_CR的<code>PER = 1</code> (PER表示执行的是页擦除)，</p>
<p>然后在FLASH_AR中选择要擦除的页，此地址提前写入</p>
<p>最后置FLASH_CR的<code>STRT = 1</code> (STRT为触发条件，置1后芯片开始干活)</p>
</li>
<li>
<p>检测FLASH_SR的<code>BSY位是否为1</code>，为1就一直等待，直到BSY位置0后全擦除结束</p>
</li>
</ol>
<p>读出并验证被擦除页的数据我们可以不管</p>
</blockquote>
<h3 id="程序存储器FLASH编程">程序存储器FLASH编程</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113145516235-1737529755594188.png" alt="image-20250113145516235"></p>
<blockquote>
<p><code>注：STM32的闪存会在写入前检查指定地址有没有擦除，如果没有擦除，STM32不执行写入操作，除非写入的全为0!!!</code></p>
<p><strong>程序的全擦除在库函数中使用了一个函数，我们可以直接使用，以下就是函数的底层寄存器操作步骤</strong></p>
<p><code>步骤如下：</code></p>
<ol>
<li>读取FLASH_CR的<code>LOCK位</code>，如果锁住了需要先解锁(库函数都是直接解锁)</li>
<li>置FLASH_CR的<code>PG = 1</code> (PG表示执行的是编程操作)</li>
<li>在指定地址写入半字(16位)，只能以半字写入16位(使用指针写入操作)</li>
<li>检测FLASH_SR的<code>BSY位是否为1</code>，为1就一直等待，直到BSY位置0后全擦除结束</li>
</ol>
<p><code>每次流程只能写入半字，如果想要写入很多字节，只需循环调用上面的步骤即可</code></p>
<hr>
<p><code>字、半字、字节：</code></p>
<p>Word(字)：32位数据</p>
<p>HalfWord(半字)：16位数据</p>
<p>Byte(字节)：8位数据</p>
</blockquote>
<h2 id="选项字节">选项字节</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113151106010-1737529755594187.png" alt="image-20250113151106010"></p>
<blockquote>
<p><code>选项字节：</code>存放独立于程序代码的配置参数</p>
</blockquote>
<p><strong>内容对应闪存编程手册2.5节</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113151906094-1737529755594189.png" alt="image-20250113151906094"></p>
<h3 id="选项字节擦除">选项字节擦除</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113151712143-1737529755594190.png" alt="image-20250113151712143"></p>
<blockquote>
<ol>
<li>
<p>先解锁闪存</p>
</li>
<li>
<p>检查FLASH SR的BSY位，以确认没有其他正在进行的闪存操作</p>
</li>
<li>
<p>解锁FLASH_CR的OPTWRE(Option Write Enable)位，即：对FLASH_OPTKEY写入类似对FLASH_KEYR解锁的两个KEY操作</p>
</li>
<li>
<p>设置FLASH CR的OPTER位为1，设置FLASH CR的STRT位为1</p>
</li>
<li>
<p>等待BSY位变为0，即擦除结束</p>
</li>
<li>
<p>读出被擦除的选择字节并做验证(不必要操作)</p>
</li>
</ol>
</blockquote>
<h3 id="选项字节的编程">选项字节的编程</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113151403201-1737529755595191.png" alt="image-20250113151403201"></p>
<blockquote>
<ol>
<li>
<p>先解锁闪存</p>
</li>
<li>
<p>检查FLASH SR的BSY位，以确认没有其他正在进行的闪存操作</p>
</li>
<li>
<p>解锁FLASH_CR的OPTWRE(Option Write Enable)位，即：对FLASH_OPTKEY写入类似对FLASH_KEYR解锁的两个KEY操作</p>
</li>
<li>
<p>设置FLASH CR的OPTPG位为1</p>
</li>
<li>
<p>写入要编程的半字到指定地址</p>
</li>
<li>
<p>等待BSY位变为0，即写入结束</p>
</li>
<li>
<p>读出被擦除的选择字节并做验证(不必要操作)</p>
</li>
</ol>
</blockquote>
<h2 id="器件电子签名">器件电子签名</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113152633326-1737529755595192.png" alt="image-20250113152633326"></p>
<blockquote>
<p><code>器件电子签名相关内容对应参考手册第28章的内容!!!</code></p>
<p><strong>电子签名其实就是芯片ID号</strong></p>
<p>**存放在系统存储器区域：**包含BootLoader和几个字节的电子签名</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113152728389-1737529755595193.png" alt="image-20250113152728389"></p>
</blockquote>
<h2 id="FLASH-库函数">FLASH 库函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*stm32f10x_flash.h*/</span></span><br><span class="line"><span class="comment">/*------------ Functions used for all STM32F10x devices -----*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_SetLatency</span><span class="params">(<span class="type">uint32_t</span> FLASH_Latency)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_HalfCycleAccessCmd</span><span class="params">(<span class="type">uint32_t</span> FLASH_HalfCycleAccess)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_PrefetchBufferCmd</span><span class="params">(<span class="type">uint32_t</span> FLASH_PrefetchBuffer)</span>;</span><br><span class="line">FlagStatus <span class="title function_">FLASH_GetPrefetchBufferStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*内核运行代码相关，我们不需要使用*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*加锁解锁：*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_Unlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_Lock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//芯片的加锁和解锁，KEY1,KEY2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*芯片擦除：*/</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ErasePage</span><span class="params">(<span class="type">uint32_t</span> Page_Address)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseAllPages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseOptionBytes</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//分别是页擦除、全擦除、选项字节擦除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*芯片写入(编程):*/</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ProgramWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint32_t</span> Data)</span>;<span class="comment">//指定地址写入字</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ProgramHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint16_t</span> Data)</span>;<span class="comment">////指定地址写入半字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*选项字节读写相关:*/</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ProgramOptionByteData</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint8_t</span> Data)</span>;<span class="comment">//选项字节写入Data</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EnableWriteProtection</span><span class="params">(<span class="type">uint32_t</span> FLASH_Pages)</span>;<span class="comment">//选项字节写保护使能</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ReadOutProtection</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//选项字节都保护</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_UserOptionByteConfig</span><span class="params">(<span class="type">uint16_t</span> OB_IWDG, <span class="type">uint16_t</span> OB_STOP, <span class="type">uint16_t</span> OB_STDBY)</span>;<span class="comment">//用户选项的三个配置位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*选项字节状态获取：*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">FLASH_GetUserOptionByte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">FLASH_GetWriteProtectionOptionByte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FlagStatus <span class="title function_">FLASH_GetReadOutProtectionStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_ITConfig</span><span class="params">(<span class="type">uint32_t</span> FLASH_IT, FunctionalState NewState)</span>;</span><br><span class="line">FlagStatus <span class="title function_">FLASH_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> FLASH_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> FLASH_FLAG)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_GetStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_WaitForLastOperation</span><span class="params">(<span class="type">uint32_t</span> Timeout)</span>;<span class="comment">//等待上一次操作，也就是等待BSY为0，在上面读写擦除的库函数内部已经调用了，我们不需要调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--我们这里用不到下面的函数</span><br><span class="line"><span class="comment">/*------------ New function used for all STM32F10x devices -----*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_UnlockBank1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_LockBank1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseAllBank1Pages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_GetBank1Status</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_WaitForLastBank1Operation</span><span class="params">(<span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> STM32F10X_XL</span></span><br><span class="line"><span class="comment">/*---- New Functions used only with STM32F10x_XL density devices -----*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_UnlockBank2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_LockBank2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseAllBank2Pages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_GetBank2Status</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_WaitForLastBank2Operation</span><span class="params">(<span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_BootConfig</span><span class="params">(<span class="type">uint16_t</span> FLASH_BOOT)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面三个库函数分为部分：<strong>通用函数、新加的通用函数、新加的只能被大容量XL系列使用的函数</strong></p>
<p>图中的Bank2是后面新推出加大容量XL系列新加的一块Flash</p>
</blockquote>
<h2 id="实验">实验</h2>
<h3 id="简单读写FLASH-FLASH底层代码实现">简单读写FLASH(FLASH底层代码实现)</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取一个字32bit</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">MyFlash_ReadWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">return</span>  *((__IO <span class="type">uint32_t</span>*)(Address));<span class="comment">////使用指针访问指定地址下的数据并返回</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取半字16bit</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">MyFlash_ReadHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">return</span>  *((__IO <span class="type">uint16_t</span>*)(Address));<span class="comment">//使用指针访问指定地址下的数据并返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将32位地址强转为指向uint16_t数据的指针，Address值也就是该指针不会变，仅仅将这个指针(地址)指向的数据变为了uint16_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字节8bit</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyFlash_ReadByte</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">return</span>  *((__IO <span class="type">uint8_t</span>*)(Address));<span class="comment">//使用指针访问指定地址下的数据并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_EraseAllPages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">		FLASH_EraseAllPages();<span class="comment">//全擦除</span></span><br><span class="line">		FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ErasePage</span><span class="params">(<span class="type">uint32_t</span> Page_Address)</span></span><br><span class="line">&#123;</span><br><span class="line">		FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">		FLASH_ErasePage(Page_Address);<span class="comment">//全擦除</span></span><br><span class="line">		FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选项字节擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFLash_EraseOptionBytes</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">		FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">		FLASH_EraseOptionBytes();<span class="comment">//全擦除</span></span><br><span class="line">	  FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入字32bit</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint32_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	FLASH_Unlock();							<span class="comment">//解锁</span></span><br><span class="line">	FLASH_ProgramWord(Address, Data);		<span class="comment">//编程字</span></span><br><span class="line">	FLASH_Lock();							<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入半字16bit</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint16_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	FLASH_Unlock();							<span class="comment">//解锁</span></span><br><span class="line">	FLASH_ProgramHalfWord(Address, Data);	<span class="comment">//编程半字</span></span><br><span class="line">	FLASH_Lock();							<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyFlash.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYFLASH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYFLASH_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">MyFlash_ReadWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">MyFlash_ReadHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyFlash_ReadByte</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_EraseAllPages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ErasePage</span><span class="params">(<span class="type">uint32_t</span> Page_Address)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFLash_EraseOptionBytes</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint32_t</span> Data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyFlash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> data1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> data2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> data3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		</span><br><span class="line">			</span><br><span class="line">		MyFlash_ErasePage(<span class="number">0x0800FC00</span>);<span class="comment">//写入前要先擦除，写入区域</span></span><br><span class="line">				</span><br><span class="line">				MyFlash_ProgramWord(<span class="number">0x0800FC00</span>,<span class="number">0x12345678</span>);<span class="comment">//写入Flash最后的区域一个字,数据为0x12345678</span></span><br><span class="line">	      MyFlash_ProgramHalfWord(<span class="number">0x0800FC10</span>,<span class="number">0xABCD</span>);<span class="comment">//写入半个字，数据为0xABCD</span></span><br><span class="line">	      </span><br><span class="line">	    data1 = MyFlash_ReadWord(<span class="number">0x0800FC00</span>);</span><br><span class="line">		data2 = MyFlash_ReadHalfWord(<span class="number">0x0800FC00</span>);</span><br><span class="line">	      </span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最终读取的结果如下keil变量的值，以及内存中的值如图</p>
<p><strong>我们也可以使用STM32 ST-LINK Utility软件直接观察</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113194907167-1737529755595195.png" alt="image-20250113194907167"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113194929798-1737529755595194.png" alt="image-20250113194929798"></p>
<h3 id="在SRAM中定义数组和标志位对FLASH数据存储">在SRAM中定义数组和标志位对FLASH数据存储</h3>
<blockquote>
<p><strong>在SRAM定义数组写入数据到FLASH，并且实现上电FLASH数据读取到SRAM操作</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*store.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STORE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STORE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> Store_Data[]; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Save</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*store.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyFLASH.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对于这种在很多地方出现，对应不同芯片有不同值得数据我们使用宏定义，提高程序的复用*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORE_START_ADDRESS		0x0800FC00		<span class="comment">//存储的起始地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORE_COUNT				512				<span class="comment">//存储数据的个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> Store_Data[STORE_COUNT];				<span class="comment">//定义SRAM数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块初始化</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*地址的第一个半字存储标志位以此判断是不是第一次使用,*/</span></span><br><span class="line">	<span class="keyword">if</span> (MyFLASH_ReadHalfWord(STORE_START_ADDRESS) != <span class="number">0xA5A5</span>)	<span class="comment">//读取第一个半字的标志位，if成立，则执行第一次使用的初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		MyFLASH_ErasePage(STORE_START_ADDRESS);					<span class="comment">//擦除指定页</span></span><br><span class="line">		MyFLASH_ProgramHalfWord(STORE_START_ADDRESS, <span class="number">0xA5A5</span>);	<span class="comment">//在第一个半字写入自己规定的标志位，用于判断是不是第一次使用</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">1</span>; i &lt; STORE_COUNT; i ++)				<span class="comment">//循环STORE_COUNT次，除了第一个标志位</span></span><br><span class="line">		&#123;</span><br><span class="line">			MyFLASH_ProgramHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>, <span class="number">0x0000</span>);		<span class="comment">//除了标志位的有效数据全部清0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*上电时，将闪存数据加载回SRAM数组，实现SRAM数组的掉电不丢失*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; STORE_COUNT; i ++)					<span class="comment">//循环STORE_COUNT次，包括第一个标志位</span></span><br><span class="line">	&#123;</span><br><span class="line">		Store_Data[i] = MyFLASH_ReadHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>);		<span class="comment">//将闪存的数据加载回SRAM数组</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块保存数据到闪存</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Save</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MyFLASH_ErasePage(STORE_START_ADDRESS);				<span class="comment">//擦除指定页</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; STORE_COUNT; i ++)			<span class="comment">//循环STORE_COUNT次，包括第一个标志位</span></span><br><span class="line">	&#123;</span><br><span class="line">		MyFLASH_ProgramHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>, Store_Data[i]);	<span class="comment">//将SRAM数组的数据备份保存到闪存</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块将所有有效数据清0</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Clear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">1</span>; i &lt; STORE_COUNT; i ++)			<span class="comment">//循环STORE_COUNT次，除了第一个标志位</span></span><br><span class="line">	&#123;</span><br><span class="line">		Store_Data[i] = <span class="number">0x0000</span>;							<span class="comment">//SRAM数组有效数据清0</span></span><br><span class="line">	&#125;</span><br><span class="line">	Store_Save();										<span class="comment">//保存数据到闪存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Store.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> KeyNum;					<span class="comment">//定义用于接收按键键码的变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*模块初始化*/</span></span><br><span class="line">	OLED_Init();				<span class="comment">//OLED初始化</span></span><br><span class="line">	Key_Init();					<span class="comment">//按键初始化</span></span><br><span class="line">	Store_Init();				<span class="comment">//参数存储模块初始化，在上电的时候将闪存的数据加载回Store_Data，实现掉电不丢失</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*显示静态字符串*/</span></span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Flag:&quot;</span>);</span><br><span class="line">	OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Data:&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		KeyNum = Key_GetNum();		<span class="comment">//获取按键键码</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (KeyNum == <span class="number">1</span>)			<span class="comment">//按键1按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			Store_Data[<span class="number">1</span>] ++;		<span class="comment">//变换测试数据</span></span><br><span class="line">			Store_Data[<span class="number">2</span>] += <span class="number">2</span>;</span><br><span class="line">			Store_Data[<span class="number">3</span>] += <span class="number">3</span>;</span><br><span class="line">			Store_Data[<span class="number">4</span>] += <span class="number">4</span>;</span><br><span class="line">			Store_Save();			<span class="comment">//将Store_Data的数据备份保存到闪存，实现掉电不丢失</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (KeyNum == <span class="number">2</span>)			<span class="comment">//按键2按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			Store_Clear();			<span class="comment">//将Store_Data的数据全部清0</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		OLED_ShowHexNum(<span class="number">1</span>, <span class="number">6</span>, Store_Data[<span class="number">0</span>], <span class="number">4</span>);	<span class="comment">//显示Store_Data的第一位标志位</span></span><br><span class="line">		OLED_ShowHexNum(<span class="number">3</span>, <span class="number">1</span>, Store_Data[<span class="number">1</span>], <span class="number">4</span>);	<span class="comment">//显示Store_Data的有效存储数据</span></span><br><span class="line">		OLED_ShowHexNum(<span class="number">3</span>, <span class="number">6</span>, Store_Data[<span class="number">2</span>], <span class="number">4</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, Store_Data[<span class="number">3</span>], <span class="number">4</span>);</span><br><span class="line">		OLED_ShowHexNum(<span class="number">4</span>, <span class="number">6</span>, Store_Data[<span class="number">4</span>], <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>实现按键1按下存入FLASH中，按键2按下清除数据</p>
</blockquote>
<h3 id="读取芯片ID-使用指针直接访问读取">读取芯片ID(使用指针直接访问读取)</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113152633326-1737529755595192.png" alt="image-20250113152633326"></p>
<p><code>对应手册28章内容：</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113204952775-1737529755595196.png" alt="image-20250113204952775"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113205028352-1737529755595197.png" alt="image-20250113205028352"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	OLED_Init();						<span class="comment">//OLED初始化</span></span><br><span class="line">	</span><br><span class="line">	OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;F_SIZE:&quot;</span>);	<span class="comment">//显示静态字符串</span></span><br><span class="line">	OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, *((__IO <span class="type">uint16_t</span> *)(<span class="number">0x1FFFF7E0</span>)), <span class="number">4</span>);		<span class="comment">//使用指针读取指定地址下的闪存容量寄存器</span></span><br><span class="line">	</span><br><span class="line">	OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;U_ID:&quot;</span>);		<span class="comment">//显示静态字符串</span></span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>, <span class="number">6</span>, *((__IO <span class="type">uint16_t</span> *)(<span class="number">0x1FFFF7E8</span>)), <span class="number">4</span>);		<span class="comment">//使用指针读取指定地址下的产品唯一身份标识寄存器</span></span><br><span class="line">	OLED_ShowHexNum(<span class="number">2</span>, <span class="number">11</span>, *((__IO <span class="type">uint16_t</span> *)(<span class="number">0x1FFFF7E8</span> + <span class="number">0x02</span>)), <span class="number">4</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">3</span>, <span class="number">1</span>, *((__IO <span class="type">uint32_t</span> *)(<span class="number">0x1FFFF7E8</span> + <span class="number">0x04</span>)), <span class="number">8</span>);</span><br><span class="line">	OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, *((__IO <span class="type">uint32_t</span> *)(<span class="number">0x1FFFF7E8</span> + <span class="number">0x08</span>)), <span class="number">8</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>**闪存容量寄存器：**使用半字读取</p>
<p>**产品唯一身份标识寄存器：**2个半字和2个字读取</p>
<p>全部显示到OLED上去</p>
</blockquote>
<h2 id="存在的BUG-当程序很大时覆盖用户存储参数区">存在的BUG-当程序很大时覆盖用户存储参数区</h2>
<p><code>问题描述：</code></p>
<p><strong>我们上面由于程序较小，程序存储在Flash的靠前区域，我们使用最后一页存储用户数据，但是如果程序很大的时候，可能就会到最后一页，造成程序和用户数据存储的位置冲突。</strong></p>
<p><code>解决方法：</code>给程序文件限定一个存储范围，不让它分配到后面我们的用户数据空间来。</p>
<ol>
<li><strong>打开工程管理</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113203529438-1737529755595198.png" alt="image-20250113203529438"></p>
<ol start="2">
<li><strong>目前使用的是起始地址为0x80000000，Size大小为0x10000(64KB)，刚好使用完了程序存储区</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113203606973-1737529755595199.png" alt="image-20250113203606973"></p>
<ol start="3">
<li><strong>如果我们想把程序区的最后自己使用，修改Size为0xFC00，这样到FC00之前就是程序存储的地方，后面地址我们可以自己存放用户参数</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113203950691-1737529755595200.png" alt="image-20250113203950691"></p>
<blockquote>
<p>注意修改size大小不能太小，太小了也会报错</p>
</blockquote>
<h2 id="Flash写入之前的擦除必要性">Flash写入之前的擦除必要性</h2>
<p><strong>1.Flash 默认状态是“全 1”</strong>：</p>
<ul>
<li>Flash 存储器在擦除之前的默认值是“1”，即每个字节的每一位都设为 1。当你想要写入数据时，必须将目标区域从“1”改为“0”。但是 Flash 存储器并不支持直接将 “0” 恢复为 “1”，只能将其设置为“0”。</li>
</ul>
<p><strong>2.擦除是将区域复位为“全 1”</strong>：</p>
<ul>
<li>擦除操作是将整个存储单元（如页面或扇区）恢复为“全 1”状态，为后续的写入做好准备。只有当区域恢复为全 1 后，才能写入新的数据。</li>
</ul>
<p><strong>3.Flash 的写入操作是“增量”</strong>：</p>
<ul>
<li>你可以在一个已擦除区域中写入数据，但不能直接覆盖其中的</li>
</ul>
<h2 id="STM32-ST-LINK-Utility">STM32 ST-LINK Utility</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../assets/image-20250113171621586-1737529755595201.png" alt="image-20250113171621586"></p>
<blockquote>
<p>我们可以使用STM32 ST-LINK Utility这个软件直接查看和修改我们芯片内部的各个地址的内容。</p>
<p>关于上方的内部FLASH和选项字节模块对应都可以查看和修改</p>
<p>使用代码配置读写保护时如果造成了芯片自锁，但程序里没有预留解除写保护的代码，造成没法下载程序了，我们可以使用这个这个软件直接去掉读写保护就可以解除芯片的自锁。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>STM32(标准库)</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.thekqd.top/posts/cb085122.html">https://www.thekqd.top/posts/cb085122.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Thedi🍭</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-01-13</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-01-22</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>嵌入式</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/ad4f1e09.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/21.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/b900f0d0.html" title="STM32(HAL库)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/98.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-01-22</div><div class="title">STM32(HAL库)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">keil配置与芯片包下载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E4%BB%B6%E5%BA%93%E6%96%87%E4%BB%B6"><span class="toc-text">固件库文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keil%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-text">keil新建工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">启动文件的选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stm32f10x-h"><span class="toc-text">stm32f10x.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4%E6%80%BB%E7%BB%93"><span class="toc-text">新建工程步骤总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">模块化编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">STM32启动文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">GPIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RCC%E5%BC%80%E5%90%AF%E6%97%B6%E9%92%9F"><span class="toc-text">RCC开启时钟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">GPIO标准库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">具体流程代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-LED%E6%B5%81%E6%B0%B4%E7%81%AF"><span class="toc-text">实验-LED流水灯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">输入模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">GPIO相关寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%84%9A%E9%87%8D%E6%98%A0%E5%B0%84-%E5%A4%8D%E7%94%A8%E5%8A%9F%E8%83%BD%E9%87%8D%E6%98%A0%E5%83%8F"><span class="toc-text">引脚重映射(复用功能重映像)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">EXTI(外部中断)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-text">初始化配置流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0"><span class="toc-text">中断函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E8%AE%A1%E6%95%B0"><span class="toc-text">实验- 旋转编码器计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E5%AF%B9%E5%B0%84%E5%BC%8F%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%A1%E6%AC%A1"><span class="toc-text">实验-对射式红外传感器计次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%AD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">使用中断注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">TIM(定时器)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">计数器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%9F%BA%E5%8D%95%E5%85%83"><span class="toc-text">时基单元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E6%BA%90"><span class="toc-text">时钟源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-2"><span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD-%E5%AE%9A%E6%97%B6%E6%88%96%E8%AE%A1%E6%95%B0%E5%8A%9F%E8%83%BD"><span class="toc-text">定时器中断(定时或计数功能)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TIM%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-text">TIM配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E6%AF%8F%E7%A7%92%E8%AE%A1%E6%95%B0-%E5%86%85%E9%83%A8%E6%97%B6%E9%92%9F"><span class="toc-text">实验-使用定时器每秒计数(内部时钟)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E5%AF%B9%E5%B0%84%E5%BC%8F%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8-%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F%E6%A8%A1%E5%BC%8F2"><span class="toc-text">实验-对射式红外传感器(外部时钟模式2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E5%BE%AA%E8%BF%B9%E6%A8%A1%E5%9D%97%E6%B5%8B%E9%87%8F%E5%95%86%E5%93%81%E6%95%B0%E9%87%8F-%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F%E6%A8%A1%E5%BC%8F2"><span class="toc-text">实验-循迹模块测量商品数量(外部时钟模式2)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E5%8A%9F%E8%83%BD-OC"><span class="toc-text">输出比较功能(OC)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OC%E7%AE%80%E4%BB%8B"><span class="toc-text">OC简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PWM%E8%BE%93%E5%87%BA%E7%AE%80%E4%BB%8B"><span class="toc-text">PWM输出简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%88%B5%E6%9C%BA%E7%AE%80%E4%BB%8B"><span class="toc-text">舵机简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E5%8F%8A%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B"><span class="toc-text">直流电机及驱动简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-3"><span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-text">输出比较配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWM%E5%91%BC%E5%90%B8%E7%81%AF"><span class="toc-text">实验-PWM呼吸灯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-text">配置流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWM%E9%A9%B1%E5%8A%A8%E8%88%B5%E6%9C%BA"><span class="toc-text">实验-PWM驱动舵机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWM%E9%A9%B1%E5%8A%A8DRV8833%E7%94%B5%E6%9C%BA"><span class="toc-text">实验-PWM驱动DRV8833电机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%8A%9F%E8%83%BD-IC"><span class="toc-text">输入捕获功能(IC)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IC%E7%AE%80%E4%BB%8B"><span class="toc-text">IC简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%91%E7%8E%87%E6%B5%8B%E9%87%8F"><span class="toc-text">频率测量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E9%80%9A%E9%81%93"><span class="toc-text">输入捕获通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-text">主从触发模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%92%8CPWMI%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-text">输入捕获和PWMI基本结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-4"><span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-text">输入捕获配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%A8%A1%E5%BC%8F%E6%B5%8B%E9%A2%91%E7%8E%87-%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E7%9B%B4%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">实验-输入捕获模式测频率(输入捕获直接模式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-PWMI%E6%A8%A1%E5%BC%8F%E6%B5%8B%E9%A2%91%E7%8E%87%E5%92%8C%E5%8D%A0%E7%A9%BA%E6%AF%94-%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E4%BA%A4%E5%8F%89-%E9%97%B4%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">实验-PWMI模式测频率和占空比(输入捕获交叉&#x2F;间接模式)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">编码器接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="toc-text">编码器接口简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E4%BA%A4%E7%BC%96%E7%A0%81%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-text">正交编码器介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-text">编码器接口基本结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-5"><span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-text">编码器接口配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E6%AD%A3%E4%BA%A4%E7%BC%96%E7%A0%81%E5%99%A8%E6%B5%8B%E9%80%9F"><span class="toc-text">实验-正交编码器测速</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">ADC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E7%AE%80%E4%BB%8B"><span class="toc-text">ADC简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">ADC内部结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E8%BE%93%E5%85%A5%E9%80%9A%E9%81%93"><span class="toc-text">ADC输入通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%BC%8F"><span class="toc-text">ADC转换模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E8%A7%A6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-text">ADC触发控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90"><span class="toc-text">ADC数据对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4"><span class="toc-text">ADC转换时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E6%A0%A1%E5%87%86"><span class="toc-text">ADC校准</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF"><span class="toc-text">硬件电路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-text">ADC基本结构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-6"><span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-text">ADC配置流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-ADC%E8%AF%BB%E5%8F%96%E7%94%B5%E4%BD%8D%E5%99%A8%E7%94%B5%E5%8E%8B-ADC%E5%8D%95%E9%80%9A%E9%81%93"><span class="toc-text">实验-ADC读取电位器电压(ADC单通道)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-ADC%E5%A4%9A%E9%80%9A%E9%81%93%E9%87%87%E9%9B%86"><span class="toc-text">实验- ADC多通道采集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E7%AE%80%E4%BB%8B"><span class="toc-text">DMA简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STM32%E5%AD%98%E5%82%A8%E5%99%A8%E6%98%A0%E5%83%8F"><span class="toc-text">STM32存储器映像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E6%A1%86%E5%9B%BE"><span class="toc-text">DMA框图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-text">DMA 基本结构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E8%AF%B7%E6%B1%82%E6%98%A0%E5%83%8F"><span class="toc-text">DMA请求映像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6%E4%B8%8E%E5%AF%B9%E9%BD%90"><span class="toc-text">数据宽度与对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E8%BF%90-DMA-%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%B0%E5%AD%98%E5%82%A8%E5%99%A8%E8%BD%AC%E8%BF%90"><span class="toc-text">数据转运+DMA(存储器到存储器转运)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADC%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F-DMA-%E5%A4%96%E8%AE%BE%E5%88%B0%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text">ADC扫描模式+DMA(外设到存储器)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-7"><span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-text">DMA配置流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-DMA%E6%95%B0%E6%8D%AE%E8%BD%AC%E8%BF%90-%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%B0%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text">实验-DMA数据转运(存储器到存储器)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-DMA-ADC%E5%A4%9A%E9%80%9A%E9%81%93%E9%87%87%E9%9B%86"><span class="toc-text">实验-DMA+ADC多通道采集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">通信接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B"><span class="toc-text">接口简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="toc-text">串口通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CH340%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8"><span class="toc-text">CH340串口驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-2"><span class="toc-text">硬件电路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86"><span class="toc-text">电平标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%8F%82%E6%95%B0%E5%8F%8A%E6%97%B6%E5%BA%8F"><span class="toc-text">串口参数及时序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USART%E7%AE%80%E4%BB%8B"><span class="toc-text">USART简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USART%E6%A1%86%E5%9B%BE"><span class="toc-text">USART框图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USART%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">USART基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B8%A7"><span class="toc-text">数据帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%B7%E5%A7%8B%E4%BD%8D%E4%BE%A6%E6%B5%8B"><span class="toc-text">起始位侦测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%87%87%E6%A0%B7"><span class="toc-text">数据采样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A2%E7%89%B9%E7%8E%87%E5%8F%91%E7%94%9F%E5%99%A8"><span class="toc-text">波特率发生器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F"><span class="toc-text">数据模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-8"><span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USART%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="toc-text">USART配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%B8%B2%E5%8F%A3%E5%8F%91%E9%80%81%E5%92%8C%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6"><span class="toc-text">实验-串口发送和串口接收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E5%8D%95%E5%AD%97%E8%8A%82-%E8%BD%AE%E8%AF%A2-%E4%B8%AD%E6%96%AD"><span class="toc-text">实验-串口接收单字节(轮询+中断)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-USART%E4%B8%B2%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-text">实验-USART串口数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-printf%E5%87%BD%E6%95%B0%E7%9A%84%E7%A7%BB%E6%A4%8D"><span class="toc-text">实验-printf函数的移植</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-text">数据包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BB%8B%E7%BB%8D"><span class="toc-text">数据包介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6"><span class="toc-text">数据包的发送和接收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%B8%B2%E5%8F%A3%E6%94%B6%E5%8F%91HEX%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-text">实验-串口收发HEX数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E4%B8%B2%E5%8F%A3%E6%94%B6%E5%8F%91%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-text">实验-串口收发文本数据包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C"><span class="toc-text">I2C</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E4%BB%8B%E7%BB%8D"><span class="toc-text">I2C介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E4%B8%8E%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">硬件电路与优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E6%97%B6%E5%BA%8F%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83"><span class="toc-text">I2C时序基本单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E4%BB%8E%E6%9C%BA%E5%9C%B0%E5%9D%80"><span class="toc-text">I2C从机地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E6%97%B6%E5%BA%8F"><span class="toc-text">I2C时序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MPU6050"><span class="toc-text">MPU6050</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050%E7%AE%80%E4%BB%8B"><span class="toc-text">MPU6050简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050%E5%8F%82%E6%95%B0"><span class="toc-text">MPU6050参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-3"><span class="toc-text">硬件电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050%E6%A1%86%E5%9B%BE"><span class="toc-text">MPU6050框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050%E4%BA%A7%E5%93%81%E6%89%8B%E5%86%8C"><span class="toc-text">MPU6050产品手册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%83%8F%E6%89%8B%E5%86%8C"><span class="toc-text">MPU6050寄存器映像手册</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9FI2C%E8%AF%BB%E5%86%99"><span class="toc-text">软件模拟I2C读写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6I2C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">软件I2C代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050-%E6%B5%8B%E8%AF%95%E8%AF%BB%E5%86%99"><span class="toc-text">MPU6050-测试读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8A%9F%E8%83%BD"><span class="toc-text">读功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E5%8A%9F%E8%83%BD"><span class="toc-text">写功能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MPU6050-%E8%AF%BB%E5%8F%96%E5%8A%A0%E9%80%9F%E5%BA%A6-%E8%A7%92%E9%80%9F%E5%BA%A6"><span class="toc-text">MPU6050-读取加速度&#x2F;角速度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E5%A4%96%E8%AE%BE-%E7%A1%AC%E4%BB%B6%E8%AF%BB%E5%86%99I2C"><span class="toc-text">I2C外设(硬件读写I2C)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I2C%E6%A1%86%E5%9B%BE"><span class="toc-text">I2C框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I2C%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">I2C基本结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B"><span class="toc-text">主机发送流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E6%8E%A5%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="toc-text">主机接收流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%9C%BA%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6"><span class="toc-text">从机发送接收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-9"><span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I2C%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE"><span class="toc-text">I2C外设配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C-%E7%A1%AC%E4%BB%B6I2C%E8%AF%BB%E5%8F%96MPU6050%E6%95%B0%E6%8D%AE"><span class="toc-text">实验-硬件I2C读取MPU6050数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%92%8C%E7%A1%AC%E4%BB%B6I2C%E5%AF%B9%E6%AF%94"><span class="toc-text">软件和硬件I2C对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI"><span class="toc-text">SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI%E4%BB%8B%E7%BB%8D"><span class="toc-text">SPI介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-4"><span class="toc-text">硬件电路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%A7%BB%E4%BD%8D%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">数据移位示意图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI%E6%97%B6%E5%BA%8F%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83"><span class="toc-text">SPI时序基本单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI%E6%97%B6%E5%BA%8F"><span class="toc-text">SPI时序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#W25Q64%E4%BB%8B%E7%BB%8D"><span class="toc-text">W25Q64介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-5"><span class="toc-text">硬件电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%86%E5%9B%BE"><span class="toc-text">框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flash%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">Flash操作注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%AF%E7%89%87%E6%89%8B%E5%86%8C"><span class="toc-text">芯片手册</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6SPI%E8%AF%BB%E5%86%99W25Q64"><span class="toc-text">软件SPI读写W25Q64</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6SPI%E5%BA%95%E5%B1%82%E4%BB%A3%E7%A0%81"><span class="toc-text">软件SPI底层代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#W25Q64%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-text">W25Q64测试代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#W25Q64%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">W25Q64完整代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6SPI%E5%A4%96%E8%AE%BE-%E7%A1%AC%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-text">硬件SPI外设(硬件读写)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SPI%E6%A1%86%E5%9B%BE"><span class="toc-text">SPI框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%A8%A1%E5%BC%8F%E5%85%A8%E5%8F%8C%E5%B7%A5%E8%BF%9E%E7%BB%AD%E4%BC%A0%E8%BE%93"><span class="toc-text">主模式全双工连续传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E4%BC%A0%E8%BE%93"><span class="toc-text">非连续传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TXE%E5%92%8CRXNE%E6%A0%87%E5%BF%97%E4%BD%8D%E6%B8%85%E9%99%A4%E9%97%AE%E9%A2%98"><span class="toc-text">TXE和RXNE标志位清除问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%92%8C%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">连续和非连续的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%A1%AC%E4%BB%B6%E6%B3%A2%E5%BD%A2%E5%AF%B9%E6%AF%94"><span class="toc-text">软件硬件波形对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPI%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">SPI库函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6SPI%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-text">硬件SPI初始化流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6SPI%E8%AF%BB%E5%86%99W25Q64"><span class="toc-text">硬件SPI读写W25Q64</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">RTC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%AF%86"><span class="toc-text">常识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unix%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">Unix时间戳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC-GMT"><span class="toc-text">RTC&#x2F;GMT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2"><span class="toc-text">时间戳转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BKP%E7%AE%80%E4%BB%8B"><span class="toc-text">BKP简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BKP%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">BKP库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99BKP"><span class="toc-text">读写BKP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RTC%E5%A4%96%E8%AE%BE"><span class="toc-text">RTC外设</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E7%AE%80%E4%BB%8B"><span class="toc-text">RTC简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E6%A1%86%E5%9B%BE"><span class="toc-text">RTC框图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">RTC基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF-6"><span class="toc-text">硬件电路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">RTC操作注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RCC%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">RCC库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">RTC库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E9%85%8D%E7%BD%AE"><span class="toc-text">RTC配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4"><span class="toc-text">RTC显示当前时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BKP%E5%AF%84%E5%AD%98%E5%99%A8%E8%A7%A3%E5%86%B3%E6%8E%89%E7%94%B5%E6%97%B6%E9%97%B4%E4%B8%8D%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-text">BKP寄存器解决掉电时间不丢失问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">PWR电源控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PWR%E7%AE%80%E4%BB%8B"><span class="toc-text">PWR简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E6%BA%90%E6%A1%86%E5%9B%BE"><span class="toc-text">电源框图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E7%94%B5%E5%A4%8D%E4%BD%8D%E5%92%8C%E6%8E%89%E7%94%B5%E5%A4%8D%E4%BD%8D-POR-PDR"><span class="toc-text">上电复位和掉电复位(POR&#x2F;PDR)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E7%94%B5%E5%8E%8B%E6%A3%80%E6%B5%8B%E5%99%A8PVD"><span class="toc-text">可编程电压检测器PVD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="toc-text">低功耗模式介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%89%E6%8B%A9%E7%9A%84%E5%9B%BE"><span class="toc-text">模式选择的图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%89%B9%E6%80%A7%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">三种模式特性及注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%94%B5%E6%96%B9%E6%B3%95"><span class="toc-text">节电方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SLEEPDEEP%E5%92%8CSLEEPONEXIT%E4%BD%8D%E9%85%8D%E7%BD%AE"><span class="toc-text">SLEEPDEEP和SLEEPONEXIT位配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%91"><span class="toc-text">修改主频</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9D%A1%E7%9C%A0%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B"><span class="toc-text">睡眠模式实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%94%B6%E5%8F%91"><span class="toc-text">串口收发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9C%E6%9C%BA%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B"><span class="toc-text">停机模式实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-10"><span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%B0%84%E5%BC%8F%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD-%E5%81%9C%E6%9C%BA%E6%A8%A1%E5%BC%8F"><span class="toc-text">对射式红外传感器外部中断(停机模式)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%85%E6%9C%BA%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B"><span class="toc-text">待机模式实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E9%97%B9%E9%92%9F-%E5%BE%85%E6%9C%BA%E6%A8%A1%E5%BC%8F"><span class="toc-text">RTC闹钟(待机模式)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">看门狗WDG</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97%E7%AE%80%E4%BB%8B"><span class="toc-text">看门狗简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97IWDG"><span class="toc-text">独立看门狗IWDG</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IWDG%E6%A1%86%E5%9B%BE"><span class="toc-text">IWDG框图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IWDG%E9%94%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">IWDG键寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IWDG%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-text">IWDG超时时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97WWDG"><span class="toc-text">窗口看门狗WWDG</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WWDG%E6%A1%86%E5%9B%BE"><span class="toc-text">WWDG框图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WWDG%E5%B7%A5%E4%BD%9C%E7%89%B9%E6%80%A7"><span class="toc-text">WWDG工作特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WWDG%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-text">WWDG超时时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IWDG%E5%92%8CWWDG%E5%AF%B9%E6%AF%94"><span class="toc-text">IWDG和WWDG对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97%E4%BB%A3%E7%A0%81"><span class="toc-text">独立看门狗代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">相关库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B-2"><span class="toc-text">配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E8%A7%A6%E5%8F%91%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-text">按键触发独立看门狗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97%E4%BB%A3%E7%A0%81"><span class="toc-text">窗口看门狗代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0-11"><span class="toc-text">库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B-3"><span class="toc-text">配置流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E8%A7%A6%E5%8F%91%E7%AA%97%E5%8F%A3%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-text">按键触发窗口看门狗</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">FLASH 闪存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FLASH%E7%AE%80%E4%BB%8B"><span class="toc-text">FLASH简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AA%E5%AD%98%E6%A8%A1%E5%9D%97%E7%BB%84%E7%BB%87"><span class="toc-text">闪存模块组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FLASH%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-text">FLASH基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FLASH%E8%A7%A3%E9%94%81"><span class="toc-text">FLASH解锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8%E5%99%A8-%E6%8C%87%E9%92%88%E5%86%99%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">使用指针访问存储器(指针写入操作)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8FLASH%E7%9A%84%E6%93%A6%E9%99%A4%E5%92%8C%E7%BC%96%E7%A8%8B"><span class="toc-text">程序存储器FLASH的擦除和编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8FLASH%E7%9A%84%E5%85%A8%E6%93%A6%E9%99%A4"><span class="toc-text">程序存储器FLASH的全擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8FLASH%E7%9A%84%E9%A1%B5%E6%93%A6%E9%99%A4"><span class="toc-text">程序存储器FLASH的页擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8FLASH%E7%BC%96%E7%A8%8B"><span class="toc-text">程序存储器FLASH编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%AD%97%E8%8A%82"><span class="toc-text">选项字节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%AD%97%E8%8A%82%E6%93%A6%E9%99%A4"><span class="toc-text">选项字节擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%AD%97%E8%8A%82%E7%9A%84%E7%BC%96%E7%A8%8B"><span class="toc-text">选项字节的编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%99%A8%E4%BB%B6%E7%94%B5%E5%AD%90%E7%AD%BE%E5%90%8D"><span class="toc-text">器件电子签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FLASH-%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">FLASH 库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C"><span class="toc-text">实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%BB%E5%86%99FLASH-FLASH%E5%BA%95%E5%B1%82%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">简单读写FLASH(FLASH底层代码实现)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8SRAM%E4%B8%AD%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84%E5%92%8C%E6%A0%87%E5%BF%97%E4%BD%8D%E5%AF%B9FLASH%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-text">在SRAM中定义数组和标志位对FLASH数据存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E8%8A%AF%E7%89%87ID-%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E8%AF%BB%E5%8F%96"><span class="toc-text">读取芯片ID(使用指针直接访问读取)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84BUG-%E5%BD%93%E7%A8%8B%E5%BA%8F%E5%BE%88%E5%A4%A7%E6%97%B6%E8%A6%86%E7%9B%96%E7%94%A8%E6%88%B7%E5%AD%98%E5%82%A8%E5%8F%82%E6%95%B0%E5%8C%BA"><span class="toc-text">存在的BUG-当程序很大时覆盖用户存储参数区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flash%E5%86%99%E5%85%A5%E4%B9%8B%E5%89%8D%E7%9A%84%E6%93%A6%E9%99%A4%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-text">Flash写入之前的擦除必要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STM32-ST-LINK-Utility"><span class="toc-text">STM32 ST-LINK Utility</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/img/avatar.webp" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.thehsp.cn/" title="thehsp"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.postimg.cc/hG3dPJgH/fda91706f29ff4047883c4b7b84449e.jpg" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2025</b></span><span><b>&nbsp;&nbsp;By Thedi🍭</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/Linux/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 Linux (9)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/嵌入式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍼 嵌入式学习笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/C/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 C++学习笔记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/数据结构与算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 数据结构与算法 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/MySQL/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 数据库笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/演示/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 Markdown (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://www.thekqd.top/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #69e8f2}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/3.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/aa76cb12.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/21.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/aa76cb12.html&quot;);" href="javascript:void(0);" alt="">线程池C++版</a><div class="blog-slider__text">线程池C++版</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/aa76cb12.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f2e69609.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/100.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f2e69609.html&quot;);" href="javascript:void(0);" alt="">MySQL通用语法及操作</a><div class="blog-slider__text">MySQL的相关知识包括基础篇、进阶篇和运维篇,学习自黑马</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f2e69609.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/174bd570.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/99.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/174bd570.html&quot;);" href="javascript:void(0);" alt="">socket</a><div class="blog-slider__text">socket网络编程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/174bd570.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/15fc6e8c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/26.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/15fc6e8c.html&quot;);" href="javascript:void(0);" alt="">多线程</a><div class="blog-slider__text">线程相关知识（pthread）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/15fc6e8c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>