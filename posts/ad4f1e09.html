<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++学习笔记 | Thedi的仓库</title><meta name="keywords" content="C++"><meta name="author" content="Thedi🍭"><meta name="copyright" content="Thedi🍭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="学习C++时的一点笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记">
<meta property="og:url" content="https://www.thekqd.top/posts/ad4f1e09.html">
<meta property="og:site_name" content="Thedi的仓库">
<meta property="og:description" content="学习C++时的一点笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.thekqd.top/assets/20.webp">
<meta property="article:published_time" content="2024-02-21T10:16:23.000Z">
<meta property="article:modified_time" content="2025-01-22T07:00:55.129Z">
<meta property="article:author" content="Thedi🍭">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.thekqd.top/assets/20.webp"><link rel="shortcut icon" href="https://i.postimg.cc/4xP8HS1p/Computer.png"><link rel="canonical" href="https://www.thekqd.top/posts/ad4f1e09"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-22 15:00:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Thedi的仓库" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Thedi的仓库</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">C++学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-02-21T10:16:23.000Z" title="发表于 2024-02-21 18:16:23">2024-02-21</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-22T07:00:55.129Z" title="更新于 2025-01-22 15:00:55">2025-01-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">3.1w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>111分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++学习笔记"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>C++学习笔记：</h1>
<h2 id="名称空间std">名称空间std</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113132517924.png" alt="image-20221113132517924"></p>
<p>&lt;math.h&gt;新式为<cmath></p>
<p>&lt;string.h&gt;新式为<cstring></p>
<p>如果使用iostream，而不是iostream.h，即当头文件中没有扩展名h时，iostream中定义的用于输出的cout变量实际是<strong>std::cout</strong>,而endl实际上是<strong>std::endl</strong>.因此，可以省略编译指令using，用下述方式进行编码:</p>
<p>std::cout&lt;&lt;&quot; xxxxxx&quot;;</p>
<p>std::cout&lt;&lt;std::endl;</p>
<p>但如果使用using编译指令:<strong>using namespace std;</strong></p>
<p><strong>便可以直接使用cin和cout…，而不必加上std::前缀</strong></p>
<h2 id="控制符endl">控制符endl</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113133422849.png" alt="image-20221113133422849"></p>
<p><strong>C++中的旧版换行采用的是&quot;\n</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113133633328.png" alt="image-20221113133633328"></p>
<h2 id="cin和cout">cin和cout</h2>
<p><strong>（1）.</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113135231199.png" alt="image-20221113135231199"></p>
<p><strong>（2）.</strong></p>
<p><strong>输出可以拼接:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113140118344.png" alt="image-20221113140118344">**</p>
<h2 id="每次读取一行字符串-string-输入">每次读取一行字符串(string)输入</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113193250853.png" alt="image-20221113193250853"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113194203451.png" alt="image-20221113194203451"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113194311275.png" alt="image-20221113194311275"></p>
<h2 id="总结">总结:</h2>
<p><strong>1.cin(&gt;&gt;)</strong></p>
<p>虽然可以使用 cin 和 &gt;&gt; 来输入字符串，当 cin 读取数据时，<strong>一旦它接触到第一个非空格字符即开始阅读，当它读取到下一个空白字符时，它将停止读取。</strong></p>
<p>可以输入 “Mark” 或 “Twain”，但不能输入 “Mark (停止读取)  Twain”，<br>
<strong>因为 cin 不能输入包含嵌入空格的字符串。</strong></p>
<p><strong>2.cin.get(char ch)/(array_name,size)</strong></p>
<p>无参数时，读入一个字符，包括换行符，常用来处理输入缓冲区中的换行符。</p>
<p>有参数时，从缓冲区读取数据，到达行尾或size-1个字符**(剩下的空间储存在结尾添加的空字符)**后结束读取(超过规定字符数不会出现错误,会直接截断)，不会对换行符进行处理，将其留在缓冲区</p>
<p><strong>3.cin.getline(array_name,size)</strong></p>
<p>从缓冲区读取数据,到达行尾或size-1**(剩下的空间储存在结尾添加的空字符)**个字符结束读取(超过规定的字符数会出现错误,中断)，会读取换行符将其替换为空字符，并且丢弃。</p>
<p>**4.getline(cin,array_name） **/  <strong>std::getline(std::cin,array_name)</strong></p>
<p>例如：getline(cin,str);</p>
<p>从缓冲区中读取数据，遇到换行符时将其替换为空字符，并且丢弃。</p>
<h2 id="补">补:</h2>
<p><strong>(1)cin.getline(char*s,streamsize n,char delim)</strong></p>
<p>所需的头文件为<iostream>(这里的参数char s是输入的字符串变量， n是输入字符串的字符个数（第n个补’\0’）， delim是输入终止条件，即遇到delim所代表的字符就终止输入,正常使用时 char delim可以省略，c++语言默认为’\0’)   例 :   cin.getline(name,20,‘C’)或cin.getline(name,20)</p>
<p><strong>(2)getline(istream&amp; is, string&amp; str, char delim)</strong></p>
<p>所需的头文件为<string>(s是标准输入流函数， str是用来存字符的变量名， delim是结束标志,作用与cin.getline()里的相同）例: getline(cin,str,‘A’)</p>
<p>==<strong>注:</strong> <strong>getline()是string流的函数，只能用于string类型(不能用于输入char*类型)的输入操作.</strong>==</p>
<p>==<strong>cin.getline()是std流的函数，只能用于char*类型的输入操作（不能用于string类型输入）</strong>。==       <strong>char*为数组</strong></p>
<p><strong>当你定义了一个char*类型变量，只能用cin/cin.getline()输入。！！！！！</strong></p>
<p>**(3).**在使用getline读入一整行时，<br>
若是前面是使用getchar()、cin这类读入了一个字母，<br>
但是不会读入后续换行\n符号或者空格的输入时，再接getline()就容易出现问题。</p>
<p>这是因为输入数字之后，敲回车，产生的换行符仍然滞留在输入流了，<br>
接着就被getline(cin,s)给读进去了，<br>
此时的s=“\n”,所以实际上s只是读入了一个换行符\n。</p>
<p>而若是前面使用getline()，再又用getline()进行读入，此时不会发生问题。<br>
<strong>getline()中读入结束的回车后，结束符不放入缓存区，会将读入的\n直接去除，</strong><br>
<strong>下一个输入前，缓冲区为空，并不会因为回车留下\n。</strong></p>
<p>而cin的结束后，以及getchar()此类的读入结束后,按下回车或者使用空格读入下一个，<br>
此时按下的回车或空格会还在缓存区,继续用getline()就会出现前面所提到的情况。<br>
那么如何解决前面用了cin、getchar()后的输入呢？<br>
<strong>可以直接在cin和getchar()后使用一个getchar()吃掉接下来的换行.</strong></p>
<h1>string类(头文件&quot;string&quot;)</h1>
<p><strong>1.</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202153066.png" alt="image-20221113202153066"></p>
<p><strong>2.</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202108337.png" alt="image-20221113202108337"></p>
<p><strong>3.数组和string类的不同点:</strong></p>
<p>**(1)**在数组中，不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象。</p>
<p>**(2)**可以使用+让两个string对象合并起来，还可以使用+=将字符串附加到string对象的末尾。</p>
<p>同时可以对字符串实现运算符（==，=），可以直接比较</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202543882.png" alt="image-20221113202543882"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202618980.png" alt=""></p>
<p><strong>4.用getline将输入读取到string对象</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202709793.png" alt="image-20221113202709793"></p>
<h2 id="补：获取字符串长度">补：获取字符串长度</h2>
<p><strong>1.length()函数</strong><br>
直接获取字符串长度，包括空格在内</p>
<p>表示方法:    **str.length()**即可表示str字符串的长度</p>
<p><strong>2.strlen()函数</strong><br>
需要添加头文件&lt;string.h&gt;,而且<strong>参数只能是char数组</strong>（不能是string类）<br>
而且结尾必须是\0(即字符数组不能满，因为满了结尾就不是\0，会接着向下检索到\0为止)<br>
啊哦char c[6]{“kunkun”}; 这样是错误的嗷 直接没法进行编译，编译器直接帮我们解决问题2。</p>
<p>表示方法：  <strong>strlen(数组名)</strong></p>
<p><strong>3.size()</strong></p>
<p>需要添加&lt;string.h&gt;头文件，用法类似于length()。<br>
size()表示的是string这个容器中的元素个数。（还可以获取vector类型的长度）<br>
如果使用过std::vector之类的容器的话，可以把string看做是一个vector(这里只是举例，并不能等价)， char就是这个容器的元素类型。那么size()表示的就是这个vector(容器)中char的个数。<br>
表示方法:</p>
<p>**str.size()**即可表示str字符串的长度（不包含’\0’）</p>
<h1>数组的替代品</h1>
<p><strong>具体见CSDN</strong></p>
<h2 id="模板类vector">模板类vector</h2>
<ul>
<li>
<p>vector是向量类型，可以容纳许多类型的数据，因此也被称为容器</p>
</li>
<li>
<p>(可以理解为<strong>动态数组</strong>，是封装好了的类）</p>
</li>
<li>
<p>进行<code>vector</code>操作前应添加头文件<code>#include &lt;vector&gt;</code></p>
</li>
<li>
<p>.2 vector初始化：<br>
方式1.</p>
<p>定义具有10个整型元素的向量（尖括号为元素类型名，它可以是任何合法的数据类型），不具有初值，其值不确定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>方式2.</p>
<p>定义具有10个整型元素的向量，且给出的每个元素初值为1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>方式3.</p>
<p>用向量b给向量a赋值，a的值完全等价于b的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b);</span><br></pre></td></tr></table></figure>
<p>方式4.</p>
<p>将向量b中从0-2（共三个）的元素赋值给a，a的类型为int型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b.<span class="built_in">begin</span>(),b.begin+<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>方式5.</p>
<p>//从数组中获得初值<br>
int b[7]={1,2,3,4,5,6,7};</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>）;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-vector对象的常用内置函数使用（举例说明）">1.3 vector对象的常用内置函数使用（举例说明）</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a,b;</span><br><span class="line"><span class="comment">//b为向量，将b的0-2个元素赋值给向量a</span></span><br><span class="line">a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//a含有4个值为2的元素</span></span><br><span class="line">a.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//返回a的最后一个元素</span></span><br><span class="line">a.<span class="built_in">back</span>();</span><br><span class="line"><span class="comment">//返回a的第一个元素</span></span><br><span class="line">a.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//返回a的第i元素,当且仅当a存在</span></span><br><span class="line">a[i];</span><br><span class="line"><span class="comment">//清空a中的元素</span></span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//判断a是否为空，空则返回true，非空则返回false</span></span><br><span class="line">a.<span class="built_in">empty</span>();</span><br><span class="line"><span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入数值5,</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入3个数，其值都为5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//b为数组，在a的第一个元素（从第0个元素算起）的位置插入b的第三个元素到第5个元素（不包括b+6）</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>);</span><br><span class="line"><span class="comment">//返回a中元素的个数</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">a.<span class="built_in">capacity</span>();</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值随机</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值为2</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//将a的容量扩充至100，</span></span><br><span class="line">a.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//b为向量，将a中的元素和b中的元素整体交换</span></span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">//b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt;</span></span><br><span class="line">a==b;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="size">size()</h2>
<p>C++中，在获取<strong>字符串长度</strong>时，size()函数与length()函数作用相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">length</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p><strong>size()函数以及length()函数</strong>都用于计算字符串（string）长度，不能用char*作为参数。除此之外，size()函数还可以获取vector类型的长度。</p>
<p>size()函数返回值为unsigned int 类型为正数</p>
<p>注意 让其作为返回值赋给变量时，变量类型要为<br>
unsigned int 或 size_t型</p>
<p>补:<strong>size_t</strong></p>
<p><strong>size_t</strong> 是一些C/C++标准在stddef.h中定义的，size_t 类型表示C中任何对象所能达到的最大长度，它是无符号整数。</p>
<p>32位上的定义:  等价于 unsigned int</p>
<p>64位上的定义:  等价于 unsigned long</p>
<h2 id="empty">empty()</h2>
<p>C++中empty()作为判断容器是否为空的函数</p>
<p>用法为 <strong>对象名.empty()</strong>    例: <strong>s.empty()</strong></p>
<p><strong>如果对象为空就返回1(ture)，</strong></p>
<p><strong>不为空返回0(false)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;&quot;</span>；</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; “字符串为空”;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串不为空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="swap-swap-交换">swap()         swap(交换)</h2>
<p><strong>具体见CSDN</strong></p>
<p>标准库的<strong>C ++中</strong>的<code>swap()</code>函数是一个在两个<strong>相同类型</strong>的给定变量之间直接交换值的函数。<strong>元素个数不相等也可以进行交换</strong></p>
<p>用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">swap</span>(a,b);</span><br></pre></td></tr></table></figure>
<h2 id="insert-insert-插入">insert()      insert(插入)</h2>
<p><strong>对象.insert()</strong></p>
<p><strong>几种用法:</strong>         <strong>下标（索引）都是默认从第0个位置开始（第0个位置，第1个位置）</strong></p>
<p><strong>1、在第index位置插入count个字符c----&gt;str.insert(index,count,c);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;012356789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;<span class="number">012356789</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="number">1</span>,<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串----&gt;&quot;</span>  &lt;&lt; str &lt;&lt; endl;  <span class="number">0123456789</span></span><br></pre></td></tr></table></figure>
<p><strong>2、在第index位置插入一个常量字符串----&gt;str.insert(index,str);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;0156789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;  <span class="number">0156789</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">2</span>,<span class="string">&quot;234&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;   <span class="number">0123456789</span></span><br></pre></td></tr></table></figure>
<p><strong>3、第index位置插入常量字符串str中的count个字符----&gt;str.insert(index,str,count);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;456789&quot;</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl; <span class="number">0123456789</span></span><br></pre></td></tr></table></figure>
<p>4、<strong>第index位置插入常量str----&gt;str.insert(index,str);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;45&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl; <span class="number">0123456789</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>5、第index位置插入常量str的从index_str开始的count个字符----&gt;str.insert(index,str,index_str,count);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;2345678&quot;</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;   <span class="number">0123456789</span></span><br></pre></td></tr></table></figure>
<p><strong>6、index位置插入常量str从index_str开始以后的字符串----&gt;str.insert(index,str,index_str,string::npos);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;012345&quot;</span>,<span class="number">4</span>,string::npos);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;  <span class="number">0123456789</span></span><br></pre></td></tr></table></figure>
<h1>NULL和nullptr</h1>
<p>c中用NULL表示空指针</p>
<p>但在c++中用nullptr表示空指针，把NULL当作0来使用</p>
<p><strong>具体的见CSDN</strong></p>
<h2 id="对类的定义：">对类的定义：</h2>
<p><strong>首先用class+标记名对类进行定义</strong>：<strong>1.private部分，2.public部分</strong></p>
<p><strong>(1)private</strong>中的数据为隐藏数据（通常是变量），只能通过public中的成员函数对其进行访问，外部没有访问权力。</p>
<p><strong>(2)public</strong>中通常是成员函数，可以在成员函数中访问该类的private中的数据，<strong>通常只在里面声明函数原型,在其他地方定义</strong>（此处用的链表，链表的下一个结点）</p>
<p>**注：**访问成员函数要作用域解析符 <strong>: :</strong>  ，格式为 : <strong>类标记名+ : : + 函数名</strong>   <strong>尤其是在定义时</strong> 例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Input</span><span class="params">()</span></span>&#123;<span class="comment">//定义一个全新的函数Input,不是成员函数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Classroom::Input</span><span class="params">()</span></span>&#123;<span class="comment">//对成员函数进行定义</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处用了友元类，具体见笔记</p>
<h2 id="类对象（变量）的创建">类对象（变量）的创建</h2>
<p><strong>标记名 + 对象名</strong> 例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classroom</span>&#123;</span></span><br><span class="line">    private：</span><br><span class="line">        </span><br><span class="line">    public：</span><br><span class="line">        <span class="type">void</span> <span class="title function_">Input</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br><span class="line">Classroom a<span class="comment">//创建一个Classroom类的对象a</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Classroom::Input();<span class="comment">//错误写法</span></span><br><span class="line">    a.Input()<span class="comment">//正确写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重点！！   注意：在调用成员函数之前，必须创建对象,不能直接像定义成员函数那样调用成员函数.   如上方</strong></p>
<p><strong>调用成员函数的方式是通过 点关系符 ”  .  “</strong></p>
<p>！！！！ <strong>类访问==成员函数==时用&quot;.&quot;访问,并且如果没有参数访问的时候必须带上后面的括号，否则认为访问的是变量；</strong></p>
<p>格式为：   <strong>对象名 . 函数名()</strong></p>
<p><strong>例如:       a.Input();</strong></p>
<p><strong>下为类对象（变量）在学生管理程序中使用：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221120220212245.png" alt="image-20221120220212245"></p>
<h2 id="new和delete">new和delete</h2>
<p><strong>该处以链表+类为例：</strong></p>
<p>![image-20221120200903909](E:\！！！！Markdown\C++.assets\image-20221120200903909.png![image-20221120202508583](E:\！！！！Markdown\C++.assets\image-20221120202508583.png<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221120202614633.png" alt="image-20221120202614633"></p>
<h3 id="1-New">1.New</h3>
<p>（1）用malloc分配内存时需要头文件cstdlib,但是new 不需要引用新的头文件。</p>
<p>（2）new为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配的内存</p>
<p>通用格式如下：<strong>typename * pointer_name = new typeName</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);<span class="comment">//申请了一个初值为10的整型数据,括号中为初始化的值</span></span><br><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//申请了能存放10个整型数据元素的数组，其首地址为arr</span></span><br></pre></td></tr></table></figure>
<p>注意:</p>
<p>*<em>int <em>p=new int 此时解引用p的值将会是一个随机值，未初始化。</em></em></p>
<p>*<em>int <em>p=new int() 此时括号里为空，解引用p的值将自动初始化为0</em></em></p>
<p>此处文件中<strong>current</strong> 是一个指针 ，<strong>Student</strong>是类标记，<strong>new + 类型名 返回的值是一个地址</strong></p>
<p>（3）new 从被称为<strong>堆</strong>或<strong>自由储存区</strong>的内存区域分配内存，除了主动释放外不会被回收。而局部变量通常储存在<strong>栈</strong>的内存区域中</p>
<h3 id="2-Delete">2.Delete</h3>
<p><strong>delete 用来释放new分配的内存</strong></p>
<p>通常    delete + 指针名    即可（注意:delete不一定使用用于new的指针，而是用于new的地址）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p；</span><br><span class="line"><span class="keyword">delete</span>[] arr;<span class="comment">//注意要删除数组时，需要加[]，以表示arr为数组。</span></span><br></pre></td></tr></table></figure>
<p><strong>使用new 和 delete 应该遵守以下规则：</strong></p>
<p>1.不要使用delete来释放不是new分配的内存。</p>
<p>2.不要使用delete来释放同一个内存块两次。</p>
<p>3.如果使用new [ ]为数组分配内存，则应该使用delete [ ]来释放</p>
<p>4.如果使用new为一个实体分配内存，则应该使用delete（没有方括号）来释放。</p>
<p>5.对空指针使用delete是安全的。</p>
<h2 id="C-中文件的输入输出">C++中文件的输入输出</h2>
<h3 id="写入到文本文件中">写入到文本文件中</h3>
<p>==要求==：</p>
<p><strong>1.包含头文件iostream，</strong></p>
<p><strong>包含头文件fstream</strong></p>
<p><strong>iostream: 头文件中定义了一个处理输出的ostream类</strong></p>
<p><strong>fstream：头文件定义了一个用于处理输出的ofstream类</strong></p>
<p><strong>2.<strong>声明一个或多个</strong>ofstream</strong>（<strong>output fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为outFile</strong></p>
<p>**3.**必须指明名称空间std，为引用ofstream，必须使用编译指令using或者前缀的std：：</p>
<p>**4.**将ofstream对象与文件关联起来。为此，方法之一是使用open()方法</p>
<p>**5.**使用完文件后，应使用close()将其关闭</p>
<p>**6.**可结合ofstream对象 和运算符&lt;&lt;来输出各种类型的数据。</p>
<p>**总结：**文件的输出主要步骤如下:</p>
<p>1.包含头文件fstream</p>
<p>2.创建一个ofstream（output fstream）对象（<strong>通常取名为outFile</strong>）</p>
<p>3.将该ofstream 对象同一个文件关联起来。</p>
<p>**4.向cout那样使用ofstream对象（通常outFile）**重点：<strong>cout在屏幕上输出，而outFile是在文件中输出（写入）</strong></p>
<p><strong>例子见下方</strong></p>
<h3 id="从文本文件中读取数据">从文本文件中读取数据</h3>
<p>==要求==：</p>
<p><strong>1.包含头文件iostream，包含头文件fstream</strong></p>
<p><strong>iostream: 头文件中定义了一个处理输出的istream类</strong></p>
<p><strong>fstream：头文件定义了一个用于处理输入的ifstream类</strong></p>
<p><strong>2.<strong>声明一个或多个</strong>ifstream</strong>（<strong>input fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为inFile</strong></p>
<p>**3.**必须指明名称空间std，为引用ifstream，必须使用编译指令using或者前缀的std：：</p>
<p>**4.**将ifstream对象与文件关联起来。为此，方法之一是使用open()方法</p>
<p>**5.**使用完文件后，应使用close()将其关闭</p>
<p>**6.**可结合ifstream对象 和运算符&lt;&lt;来输出各种类型的数据。</p>
<h4 id="检查文件">检查文件</h4>
<p>格式为: 对象名.isopen()  例:    <strong>inFile.is_open()</strong></p>
<p>如果文件成功被打开，返回<strong>true</strong>；如果文件没有被打开，<strong>因此表达式   !inFile.is_open()  将为true</strong></p>
<p>通常使用下方代码判断是否打开成功</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">   	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>exit(0)程序正常结束</strong></p>
<p><strong>exit(1)程序异常结束</strong></p>
<p><strong>exit()使用需要用到头文件==cstdlib==</strong></p>
<h4 id="文件读取结尾">文件读取结尾</h4>
<p><strong>eof在遇到EOF（文件结束标志）时返回ture ，否则返回false</strong></p>
<p>通常和while循环一起用作文件读取结束，<strong>!inFile.eof</strong>在文件结束前为真，结束为假（退出循环）</p>
<p>具体格式为：   <strong>while(  !inFile.eof（）)</strong></p>
<h4 id="文件的打开和关闭">文件的打开和关闭</h4>
<p>**1.对象名.open(“文件名”) **（一个参数）例：<strong>outFile.open(“student.txt”)</strong> 如果文件不存在，将会自动创建一个相同名字的文件,如果文件存在，将会打开该文件，首先截断该文件，将其长度截短到0，丢弃原有的内容，然后将新的输入加入到该文件中</p>
<p><strong>2.对象名.open(“文件名”，打开方式)</strong> （两个参数）例如 : **outFile.open(“student.txt”,std::ios::in)**只读模式  见下方</p>
<p>格式：对象名.close()  例: <strong>outFile.close()</strong></p>
<p>注意方法close()，不需要使用文件名作为参数，因为outFile已经同特定的文件关联起来，如果忘记关闭文件，程序正常终止的时候将自动关闭它。</p>
<p><strong>下面时学生管理程序中的例子:</strong></p>
<p><strong>读取数据到文件中（output输出数据到文件）：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221120212115308.png" alt="image-20221120212115308"></p>
<p><strong>从该文件中读取数据（input从文件中输入数据到外）：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221120212136110.png" alt="image-20221120212136110"></p>
<p><strong>从文件中读取数据时，也需要用到new分配新的内存，与Input（）函数在输入数据时相同</strong></p>
<p><strong>inFile 对应的c中的fscanf（从文件中读取数据）</strong></p>
<p><strong>outFile对应的时c中的fprintf（写入数据到文件）</strong></p>
<h1>构造函数和析构函数</h1>
<h2 id="构造函数">构造函数</h2>
<ul>
<li>按参数种类分：无参构造函数、有参构造函数、有默认参构造函数</li>
<li>按类型分为：普通构造函数、拷贝构造函数(赋值构造函数)</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Viewinfinitely/article/details/115017678?ops_request_misc=%7B%22request%5Fid%22%3A%22170626893616800185850269%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170626893616800185850269&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115017678-null-null.142%5Ev99%5Epc_search_result_base4&amp;utm_term=C%2B%2B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">C++构造函数的各种用法全面解析（C++初学面向对象编程）_c++ 构造函数-CSDN博客</a></p>
<h1>运算符重载</h1>
<h2 id="运算符重载的概念和原理">运算符重载的概念和原理</h2>
<p>如果不做特殊处理，C++ 的 +、-、*、/ 等运算符只能用于对基本类型的常量或变量进行运算，不能用于对象之间的运算。</p>
<p>有时希望对象之间也能用这些运算符进行运算，以达到使程序更简洁、易懂的目的。例如，复数是可以进行四则运算的，两个复数对象相加如果能直接用+运算符完成，不是很直观和简洁吗？</p>
<p>利用 C++ 提供的“运算符重载”机制，赋予运算符新的功能，就能解决用+将两个复数对象相加这样的问题。</p>
<p>运算符重载，就是对已有的运算符赋予多重含义，使同一运算符作用于不同类型的数据时产生不同的行为。运算符重载的目的是使得 C++ 中的运算符也能够用来操作对象。</p>
<p>运算符重载的实质是编写以运算符作为名称的函数。不妨把这样的函数称为运算符函数。运算符函数的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">返回值类型  <span class="keyword">operator</span>  运算符(形参表)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符可以是+、-、*、/等，必须是有效的C++运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值可以是一个引用，也可以是一个对象，但一定注意！！！，不要返回一个指向局部变量或临时对象的引用，因为函数执行完毕后，局部变量和临时对象将消失，引用将指向一个不存在的数据</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一个简单的重载+运算符*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="type">int</span> testData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> testData;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;testData = data;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Test <span class="keyword">operator</span>+(<span class="type">const</span> Test&amp; t)</span><br><span class="line">     &#123;</span><br><span class="line">         Test test;</span><br><span class="line">         test.testData = testData+t.testData;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> test;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Test t1,t2;</span><br><span class="line">    Test t3,t4;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">setData</span>(<span class="number">5</span>);</span><br><span class="line">    t2.<span class="built_in">setData</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    t3 = t1+t2;</span><br><span class="line"></span><br><span class="line">    t4 = t1.<span class="keyword">operator</span>+(t3);</span><br><span class="line">    <span class="comment">//t4 = t1+t2+t3 这是允许的，得出的结果相同</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t1:&quot;</span> &lt;&lt; t1.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t2:&quot;</span> &lt;&lt; t2.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t3:&quot;</span> &lt;&lt; t3.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t4:&quot;</span> &lt;&lt; t4.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：重载后的+号允许大于两个对象相加，如t4 = t1+ t2 + t3</span></span><br></pre></td></tr></table></figure>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>该函数有两种调用方式</strong>：</p>
<ul>
<li>通过对象调用方法来调用，如上边的t4</li>
<li>直接通过重载的符号调用，如上方t1+t2</li>
</ul>
</div>
<h2 id="运算符重载限制">运算符重载限制:</h2>
<p>运算符重载规则，即允许重载的运算符，不允许重载的运算符见：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_72157449/article/details/128664136?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=c++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E9%99%90%E5%88%B6&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128664136.142%5Ev96%5Epc_search_result_base1&amp;spm=1018.2226.3001.4187">【⑤C++ | 运算符重载】意义 | 限制 | 方法 | 规则 | 特殊运算符重载 | 应用场景-CSDN博客</a></p>
<p>注：在 <strong>C++ 中，类型的名字（包括类的名字）本身也是一种运算符</strong>，即类型强制转换运算符。 类型强制转换运算符是单目运算符，也可以被重载，但只能重载为成员函数，不能重载为全局函数。</p>
<h1>类的继承</h1>
<h2 id="继承的定义">继承的定义</h2>
<p>定义：</p>
<p>继承(inheritance)机制是面向对象程序设计中使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能。这样产生的新类，称派生类（或子类），被继承的类称基类（或父类）。</p>
<p>继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。之前接触的复用都是函数复用，继承是类设计层次的复用。</p>
<h2 id="继承：is-a-关系">继承：is-a 关系</h2>
<p>因为派生类可以在基类上添加新特性，所以这种关系成为is-a-kind-of(是一种)关系更加准确，通常术语是is-a关系。例如：香蕉是一种水果</p>
<p>同时在指针指向的对象上面也有讲究：</p>
<ul>
<li>可以将基类指针指向派生类对象(多态性体现)</li>
<li>不能将派生类指针指向基类对象(不允许这样做)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span>:<span class="keyword">public</span> Fruit</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fruit *pFruit1 = <span class="keyword">new</span> <span class="built_in">Fruit</span>();<span class="comment">//正确</span></span><br><span class="line">    Fruit *pBanana = <span class="keyword">new</span> <span class="built_in">Banana</span>();<span class="comment">//正确，满足香蕉一种水果，水果包含香蕉的关系</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用基类指针引用派生类对象的能力允许多态性。在这种情况下，你可以通过基类指针调用基类的函数或访问基类的成员，而在运行时，将调用正确的派生类方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    Banana* pFruit2 = <span class="keyword">new</span> <span class="built_in">Fruit</span>();<span class="comment">//错误，水果不是一种香蕉，香蕉不包含水果，不允许这样做</span></span><br><span class="line">    Banana* pBanana1 =<span class="keyword">new</span> <span class="built_in">Banana</span>();<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承的格式">继承的格式</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 新类的名字: 继承方式 继承类的名字</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一个简单的例子*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">people</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">people</span>(string name,<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:<span class="keyword">public</span> people</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> schoolnum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">student</span>(string name,<span class="type">int</span> age,<span class="type">int</span> schoolNum):<span class="built_in">people</span>(name,age)<span class="comment">//使用成员初始化列表语法,会先调用基类的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;schoolnum = schoolNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*上面的构造函数等价于</span></span><br><span class="line"><span class="comment">    student(string name,int age,int schoolnum)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        this-&gt;name = name;</span></span><br><span class="line"><span class="comment">        this-&gt;age = age;</span></span><br><span class="line"><span class="comment">        this-&gt;schoolnum = schoolnum;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    这两种方法都可以</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; endl &lt;&lt; age &lt;&lt; endl &lt;&lt; schoolnum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">student <span class="title">s</span><span class="params">(<span class="string">&quot;keqiudi&quot;</span>,<span class="number">18</span>,<span class="number">2022124018</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>在继承的时候可以使用类名加上作用域解析符(:)来调用基类的方法，通常在私有继承中使用，第二种便是使用this指针调用继承过来的基类的方法</strong></p>
</div>
<p>更多详细内容学习：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_62718027/article/details/125922249?ops_request_misc=%7B%22request%5Fid%22%3A%22170126212316800222846414%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170126212316800222846414&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-125922249-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=C%2B%2B%E7%B1%BB%E7%BB%A7%E6%89%BF&amp;spm=1018.2226.3001.4187">c++：继承（超详解）</a></p>
<h2 id="继承的总结：">继承的总结：</h2>
<ol>
<li>基类private成员无论以什么方式继承到派生类中都是不可见的。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它。</li>
<li>基类private成员在派生类中不能被访问，如果基类成员不想在派生类外直接被访问，但需要在派生类中访问，就定义为protected。可以看出保护成员限定符是因继承才出现的。</li>
<li>基类的私有成员在子类都是不可见；基类的其他成员在子类的访问方式就是访问限定符和继承方式中权限更小的那个（权限排序：public&gt;protected&gt;private）。</li>
<li>使用关键字class时<strong>默认的继承方式是private</strong>，使用struct时默认的继承方式是public，但最好显式地写出继承方式。</li>
</ol>
<h2 id="多态公有继承">多态公有继承</h2>
<p>简单来说就是一个方法的行文随上下文而异，有两种重要机制可用于实现多态的公有继承</p>
<ol>
<li>在派生类中重新定义基类的方法</li>
<li>使用虚方法</li>
</ol>
<h3 id="虚方法">虚方法</h3>
<ul>
<li>关键词：virtual</li>
<li>在基类中将<strong>派生类会重新定义的方法</strong>声明为虚方法。使用了virtual，程序将根据<strong>引用或指针指向的对象</strong>的类型来选择方法，而未使用时程序将仅仅根据<strong>引用或指针的类型</strong>来选择方法，与<strong>多态性</strong>紧密相关。</li>
<li>virtual关键词只用于类声明的方法原型中，而不用于类方法实现中</li>
<li>派生类中覆盖的方法后要加上override标注</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//brass.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BRASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BRASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string fullName; <span class="comment">//客户姓名</span></span><br><span class="line">	<span class="type">long</span> acctNum; <span class="comment">//账号</span></span><br><span class="line">	<span class="type">double</span> balance; <span class="comment">//当前结余</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Brass</span>(<span class="type">const</span> string &amp;s = <span class="string">&quot;Nullbody&quot;</span>, <span class="type">long</span> an = <span class="number">-1</span>, <span class="type">double</span> bal = <span class="number">0.0</span>); <span class="comment">//创建账户</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Deposit</span><span class="params">(<span class="type">double</span> amt)</span></span>; <span class="comment">//存款</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span>; <span class="comment">//取款</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">Balance</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//显示账户信息</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//显示</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Brass</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrassPlus</span> : <span class="keyword">public</span> Brass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> maxLoan; <span class="comment">//透支上限</span></span><br><span class="line">	<span class="type">double</span> rate; <span class="comment">//透支贷款利率</span></span><br><span class="line">	<span class="type">double</span> owesBank; <span class="comment">//当前的透支总额</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BrassPlus</span>(<span class="type">const</span> string &amp;s = <span class="string">&quot;Nullbody&quot;</span>, <span class="type">long</span> an = <span class="number">-1</span>, <span class="type">double</span> bal = <span class="number">0.0</span>, <span class="type">double</span> m1 = <span class="number">500</span>, <span class="type">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">	<span class="built_in">BrassPlus</span>(<span class="type">const</span> Brass &amp;ba, <span class="type">double</span> m1 = <span class="number">500</span>, <span class="type">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//覆盖基类实现，函数重载</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span> <span class="keyword">override</span></span>; <span class="comment">//覆盖基类实现，函数重载</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResetMax</span><span class="params">(<span class="type">double</span> m)</span> </span>&#123; maxLoan = m; &#125; <span class="comment">//透支上限</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResetRate</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123; rate = r; &#125; <span class="comment">//透支贷款利率</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResetOwes</span><span class="params">()</span> </span>&#123; owesBank = <span class="number">0</span>; &#125; <span class="comment">//当前透支总额</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设计的Brass基类指针既可以指向Brass对象，也可以指向BrassPlus对象，因此可以使用一个数组来表示多种类型的对象，这就是多态性。下面在一个数组中可以很清楚的看清virtual的作用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> CLIENTS = <span class="number">2</span>;</span><br><span class="line">Brass *clients[CLIENTS];<span class="comment">//Brass类型的指针</span></span><br><span class="line">clients[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">Brass</span>(<span class="string">&quot;Test0&quot;</span>, <span class="number">1234</span>, <span class="number">1234.56</span>);<span class="comment">//指向Brass类型对象</span></span><br><span class="line">clients[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">BrassPlus</span>(<span class="string">&quot;Test1&quot;</span>, <span class="number">5678</span>, <span class="number">5678.91</span>);<span class="comment">//指向BrassPlus类型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; CLIENTS;++i)</span><br><span class="line">&#123;</span><br><span class="line">    clients[i]-&gt;<span class="built_in">ViewAcct</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>多态性说明</strong>：</p>
<ul>
<li>假如ViewAcct()是使用关键字virtual声明</li>
</ul>
<p>如果数组成员(指针)指向的是Brass对象，则调用的是Brass::ViewAcct()。<br>
如果数组成员(指针)指向的是BrassPlus对象，则调用的是BrassPlus::ViewAcct()。</p>
<ul>
<li>假如ViewAcct()不是虚方法</li>
</ul>
<p>则在任何情况下都将调用Brass::ViewAcct()。</p>
<h3 id="虚析构函数">虚析构函数</h3>
<p>基类要声明一个虚析构函数，为了确保释放派生类对象时，按正确的顺序调用析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string fullName; <span class="comment">//客户姓名</span></span><br><span class="line">	<span class="type">long</span> acctNum; <span class="comment">//账号</span></span><br><span class="line">	<span class="type">double</span> balance; <span class="comment">//当前结余</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Brass</span>() &#123;&#125; <span class="comment">//这是虚析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>为何使用虚析构函数</strong>：</p>
<ul>
<li>如果析构函数不是虚方法，则将只调用对应于指针类型的析构函数。对于Brass * 指针将只调用Brass基类的析构函数，即使Brass * 指针指向的是BrassPlus对象。</li>
<li>如果析构函数是虚方法，将调用相应的指向对象类型的析构函数。即如果指针指向的是Brass对象，将调用Brass对象的析构函数，如果指针指向的是BrassPlus对象，将调用BrassPlus的析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以确保正确的析构函数序列被调用。</li>
<li>如果BrassPlus包含一个执行某些操作的析构函数，则Brass必须有一个虚析构函数，即使Brass的析构函数不执行任何操作。</li>
</ul>
</div>
<h2 id="静态联编和动态联编">静态联编和动态联编</h2>
<p><strong>静态联编</strong>：静态联编是指联编工作在<strong>编译阶段完成的</strong>，联编过程是在程序运行之前完成。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，静态联编对函数的选择是<strong>基于指向对象的指针或者引用的类型</strong>。其优点是<strong>效率高，但灵活性差</strong>，也因此作为C++默认联编选择。</p>
<p><strong>动态联编</strong>：动态联编是指联编在<strong>程序运行时动态地进行</strong>，根据当时的情况来确定调用哪个同名函数，实际上是在运行时是<strong>虚函数的实现</strong>。动态联编对成员函数的选择是基于<strong>对象的类型</strong>，针对不同的对象类型将做出不同的编译结果。C++中一般情况下的联编是静态联编，但是当涉及到<strong>多态性和虚函数时应该使用动态联编</strong>。动态联编的优点是<strong>灵活性强，但效率低</strong>。</p>
<p>动态联编规定：只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式为：指向基类的指针变量名-&gt;虚函数名（实参表）或基类对象的引用名.虚函数名（实参表）</p>
<ul>
<li>编译器对<strong>非虚方法</strong>使用<strong>静态联编</strong></li>
<li>编译器对<strong>虚方法</strong>使用<strong>动态联编</strong></li>
</ul>
<hr>
<p><strong>实现动态联编需要同时满足以下三个条件：</strong></p>
<p>①  必须把动态联编的行为定义为类的虚函数。</p>
<p>②  类之间应满足子类型关系，通常表现为一个类从另一个类公有派生而来。</p>
<p>③  必须先使用基类指针指向子类型的对象，然后直接或者间接使用基类指针调用虚函数</p>
<p><strong>总结</strong>：</p>
<p>大多数情况下，动态联编很好，因为他让程序能够选择特定类型设计的方法。<strong>虚函数是实现多态的基础，是实现动态联编的必要条件之一</strong>。动态联编要靠虚函数来实现，虚函数要靠动态联编的支持。两者相辅相成，缺一不可。</p>
<h2 id="初始化列表">初始化列表</h2>
<h3 id="概念">概念</h3>
<p>当在C++中定义类的构造函数时，可以使用初始化列表来初始化类的成员变量。初始化列表是在构造函数的参数列表后面使用冒号(:)分隔开来的一组初始化语句,多个参数初始化使用逗号隔开，用于初始化类的成员变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*初始化列表写法*/</span></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> value,<span class="type">double</span> values):<span class="built_in">data</span>(value),<span class="built_in">datas</span>(values)<span class="comment">//这里的冒号及冒号右边的部分就是构造函数的初始化列表,逗号隔开</span></span><br><span class="line">	&#123;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*函数体内写法*/</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value,<span class="type">double</span> values)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;</span><br><span class="line">        <span class="type">double</span> = datas;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">    <span class="type">double</span> datas;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意</strong>：</p>
<ul>
<li>对于<strong>继承的对象</strong>，构造函数在成员初始化列表中使用基类名来调用特定的基类构造函数。</li>
<li>对于<strong>成员对象</strong>，构造函数则使用成员名。</li>
</ul>
</div>
<h3 id="什么时候必须使用">什么时候必须使用</h3>
<ol>
<li><strong>在成员变量为引用类型时</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> &amp;data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value):<span class="built_in">data</span>(value)<span class="comment">//正确</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;<span class="comment">//会报错引用类型不允许这样做,只能使用初始化列表(上面的方式初始化)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>在成员变量为const时</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value):<span class="built_in">data</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="built_in">A</span>(<span class="type">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;<span class="comment">//会报错const类型不允许这样做,只能使用初始化列表(上面的方式初始化)</span></span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="建议使用的地方">建议使用的地方</h3>
<ul>
<li>初始化基类部分</li>
</ul>
<p>在派生类构造函数中使用初始化列表法初始基类的变量，可以避免在函数体中进行额外的赋值操作提高效率，同时提高可读性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*对于成员对象使用成员名初始化列表*/</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> value)</span>:data(value)//这里的冒号及冒号右边的部分就是构造函数的初始化列表,逗号隔开</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> datas;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*对于继承的对象，使用基类名初始化列表，调用基类构造函数初始化基类部分*/</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> value,<span class="type">double</span> values):<span class="built_in">A</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        datas = values; <span class="comment">//正常的在函数体内初始化派生类部分,更清晰表明继承关系，这个地方也可以在上面使用初始化列表方式为datas赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong>：</p>
<p>建议尽可能使用初始化列表法来初始化构造函数中的成员变量，但并非所有情况都必须使用初始化列表。</p>
<p>一般来说，以下情况建议使用初始化列表法：</p>
<ol>
<li><strong>初始化成员变量</strong>：如果构造函数需要初始化类的成员变量,但此时类的结构和逻辑不是很复杂时，使用初始化列表是最清晰和高效的方式。</li>
<li><strong>初始化基类部分</strong>：在派生类的构造函数中调用基类的构造函数时，应该使用初始化列表来确保基类部分被正确地初始化。</li>
<li><strong>初始化const和引用类型成员变量</strong>：const和引用类型的成员变量只能在初始化列表中进行初始化，无法在构造函数体内进行赋值。</li>
<li><strong>初始化具有复杂初始化逻辑的成员变量</strong>：如果某个成员变量的初始化逻辑比较复杂，使用初始化列表可以将初始化逻辑集中在一起，提高代码的可读性。</li>
</ol>
<p>但也有一些情况可以在构造函数体内进行初始化，例如：</p>
<ol>
<li><strong>运行时条件决定的初始化</strong>：如果某些成员变量的初始化取决于运行时条件，可能需要在构造函数体内进行初始化。</li>
<li><strong>需要在构造函数体内执行额外逻辑</strong>：如果构造函数需要执行一些额外的逻辑操作，可以在构造函数体内进行初始化。</li>
</ol>
<h3 id="优点和缺点">优点和缺点</h3>
<p><strong>优点</strong>:</p>
<ol>
<li>(涉及含有类成员时)<strong>效率高</strong>: 使用初始化列表可以直接对成员变量进行初始化，而不需要先调用默认构造函数再进行赋值操作，从而提高了代码的执行效率。基本类型时效率与在函数体中差不多</li>
<li><strong>确保成员变量的初始化</strong>: 使用初始化列表可以确保所有成员变量在对象构造时立即得到正确的初始化，避免了可能出现的未初始化的情况。</li>
<li><strong>处理const和引用类型成员变量</strong>: 对于const成员变量和引用类型成员变量，只能在初始化列表中进行初始化，因为它们不能在构造函数体内被赋值。</li>
<li><strong>清晰明了</strong>: 初始化列表将所有初始化操作集中在一起，使代码更加清晰易读，便于理解和维护</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>可读性差</strong>: 对于复杂的类结构和初始化逻辑，初始化列表可能会使代码变得复杂和难以理解，降低了可读性。</li>
<li><strong>限制较多</strong>: 有些情况下，无法在初始化列表中初始化所有的成员变量，例如需要在构造函数体内进行逻辑判断后再进行初始化的情况。</li>
<li><strong>容易遗忘</strong>: 在添加新成员变量时，容易忘记在初始化列表中添加相应的初始化操作，导致未初始化的错误。</li>
</ol>
<h2 id="使用using-重新定义访问权限">使用using 重新定义访问权限</h2>
<p>使用<strong>保护派生或私有派生</strong>时，基类的公有成员将成为保护成员或私有成员。假设要让基类的方法在派生类外面可用，可以在派生类的public成员中使用using声明指出派生类可以使用特定的基类成员，就像using指定的成员或函数是派生类的公有方法一样，即使采用的是私有派生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一个简单的例子*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">people</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">people</span>(string name,<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>: <span class="keyword">private</span> people<span class="comment">//私有派生</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> schoolnum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> people::showName;<span class="comment">//使用using定义重新定义访问权限</span></span><br><span class="line">    <span class="keyword">using</span> people::name;<span class="comment">//使用using定义重新定义访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">student</span>(string name,<span class="type">int</span> age,<span class="type">int</span> schoolNum):<span class="built_in">people</span>(name,age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;schoolnum = schoolNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">student <span class="title">s</span><span class="params">(<span class="string">&quot;keqiudi&quot;</span>,<span class="number">18</span>,<span class="number">2022124018</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">showName</span>();<span class="comment">//正确，使用了using可以在派生类外调用</span></span><br><span class="line">    cout &lt;&lt; s.name &lt;&lt; endl;<span class="comment">//正确，使用了using可以在派生类外调用</span></span><br><span class="line">    cout &lt;&lt; s.age &lt;&lt; endl;<span class="comment">//报错，未使用using，继承后为派生类private成员不可以直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="多重继承">多重继承</h2>
<h3 id="定义">定义</h3>
<p>派生类都只有一个基类，称为单继承。除此之外，C++也支持多继承，即一个派生类可以有两个或多个基类。<br>
多继承的语法也很简单，将多个基类用逗号隔开。</p>
<p>如已声明了类A、类B和类C，那么可以这样来声明派生类D：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A, <span class="keyword">private</span> B, <span class="keyword">protected</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//类D新增加的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数-2">构造函数</h3>
<p>与单继承形式基本相同，只是在派生类的构造函数中调用多个基类的构造函数。<br>
以上面的 A、B、C、D 类为例，D 类构造函数的写法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">D</span>(形参列表): <span class="built_in">A</span>(实参列表), <span class="built_in">B</span>(实参列表), <span class="built_in">C</span>(实参列表)<span class="comment">//使用初始化列表写法调用基类构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二义性">二义性</h3>
<p>当两个或多个基类有同名成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员。这个时候需要在<strong>名字前面加上类名和域解析符::</strong>，以显示地指明到底使用哪个类的成员，消除二义性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseA</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">BaseA</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BaseA</span>(<span class="type">int</span> value):_value(value)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseA::_value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseB</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">BaseB</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BaseB</span>(<span class="type">int</span> value):_value(value)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseB::_value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> BaseA, <span class="keyword">public</span> BaseB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Derived</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> valueA, <span class="type">int</span> valueB):<span class="built_in">BaseA</span>(valueA), <span class="built_in">BaseB</span>(valueB)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseA::_value: &quot;</span> &lt;&lt; BaseA::_value &lt;&lt; endl;<span class="comment">//使用::指明基类BaseA的value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseB::_value: &quot;</span> &lt;&lt; BaseB::_value &lt;&lt; endl;<span class="comment">//使用::指明基类BaseB的value</span></span><br><span class="line">        BaseA::<span class="built_in">showValue</span>();<span class="comment">//使用::指明调用基类BaseA的方法</span></span><br><span class="line">        BaseB::<span class="built_in">showValue</span>();<span class="comment">//使用::指明调用基类BaseB的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    d.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>模板</h1>
<h2 id="类模板">类模板</h2>
<p>在C++中，<strong>模板类</strong>是一种用于创建通用数据结构或算法的强大工具。模板类允许您编写一次代码，然后在不同数据类型上重复使用它，例如有两个或多个类，其功能是相同的，仅仅是数据类型不同时使用，<strong>以提高代码的可重用性和灵活性</strong>。</p>
<p>模板类允许您定义一种通用的类模板，其中某些成员或函数可以根据不同进行参数化。它们使用template关键字定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,....&gt;</span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;</span><br><span class="line">类的定义;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>typename</code>表明其后面的符号是一种数据类型，可以用<code>class</code>代替</li>
<li><code>T</code>是通用的数据类型，名称可以替换，通常为大写字母</li>
<li>函数模板建议用 <code>typename</code> 描述通用数据类型，类模板建议用 <code>class</code></li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">nameType</span>,<span class="keyword">class</span> <span class="title class_">ageType</span>&gt;<span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    nameType name;</span><br><span class="line">    ageType age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(nameType name,ageType age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">student</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    student.<span class="built_in">showPerson</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数模板">函数模板</h2>
<p>函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能，提高了程序的可重用性。</p>
<p>C++ 语言支持模板。有了模板，例如可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。</p>
<p><strong>写法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span>,<span class="keyword">typename</span> 类型参数<span class="number">2</span>, ...&gt;</span><br><span class="line">返回值类型  模板名(形参表)</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*typename可以使用class替换*/</span></span><br></pre></td></tr></table></figure>
<p><strong>一个简单的示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp; x, T &amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>, m = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(n, m);  <span class="comment">//编译器自动生成 void Swap (int &amp;, int &amp;)函数</span></span><br><span class="line">    <span class="type">double</span> f = <span class="number">1.2</span>, g = <span class="number">2.3</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(f, g);  <span class="comment">//编译器自动生成 void Swap (double &amp;, double &amp;)函数</span></span><br><span class="line">    string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(s1, s2);  <span class="comment">//编译器自动生成 void Swap (string &amp;, string &amp;)函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="类模板与函数模板区别">类模板与函数模板区别</h2>
<ol>
<li><strong>应用对象</strong>：
<ul>
<li><strong>函数模板</strong>主要用于生成通用函数，可以用于不同类型的参数。它通过在函数定义中使用模板来实现，允许编写一次通用的函数代码，用于多种数据类型。</li>
<li><strong>类模板</strong>主要用于生成通用类，可以包含不同类型的成员变量或成员函数。它通过在类定义中使用模板来实现，允许创建一种通用的类形式，适用于多种数据类型。</li>
</ul>
</li>
<li><strong>自动类型推导的使用方式</strong>：
<ul>
<li><strong>函数模板</strong>在调用时支持自动类型推导，允许省略模板参数，由编译器根据实参类型自动推导出模板参数的类型。</li>
<li><strong>类模板</strong>在实例化时需要显式指定模板参数，没有像函数模板那样的自动类型推导。每次实例化都需要<strong>明确指定模板参数</strong>。</li>
</ul>
</li>
<li><strong>默认参数</strong>：
<ul>
<li><strong>函数模板</strong>和<strong>类模板</strong>都支持默认参数。在模板参数列表中可以为某些模板参数设置默认值，使得在使用时可以不必每次都指定这些参数。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板与函数模板的区别</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; <span class="comment">//指定默认参数</span></span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameType m_Name;</span><br><span class="line">	AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Person p(&quot;孙悟空&quot;, 1000);错误的，类模板无法用自动类型推导</span></span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;keqiudi&quot;</span>, <span class="number">19</span>);<span class="comment">//正确，只能用显式指定类型推导</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string&gt;<span class="built_in">p</span>(<span class="string">&quot;keqiudi&quot;</span>, <span class="number">19</span>); <span class="comment">//类模板在参数列表中有默认参数</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="类模板成员函数实现">类模板成员函数实现</h2>
<p>在类<strong>内部定义成员函数</strong>可以更简洁，因为不需<strong>要再次指定模板参数</strong>。类内部的成员函数定义可以直接使用类模板的模板参数，而在<strong>外部定义时需要重新指定一次</strong>。</p>
<p>总体来说，选择在类内部还是类外部定义成员函数取决于项目的需求和组织代码的风格。一般而言，对于简单、短小的成员函数，可以选择在类内部定义；而对于复杂或长的成员函数，以及避免头文件的多次包含导致的重定义错误，通常建议在类外部定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板成员类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="comment">/*内部定义&#123;</span></span><br><span class="line"><span class="comment">		this-&gt;m_Name = name;</span></span><br><span class="line"><span class="comment">		this-&gt;m_Age = age;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/*内部定义&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造函数的类外实现，每个函数都要重新指定模板参数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="comment">//要点1：每个函数前加上template&lt;&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)<span class="comment">//要点2:类名指出模板参数再进行解析(::)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*成员函数的类外实现，每个函数都要重新指定模板参数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="成员模板">成员模板</h2>
<p>模板可用作结构、类或模板类的成员。要完全实现STL(标准模板库)，必须使用这个特性</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">beta</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;<span class="comment">//模板成员</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">hold</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">         	V val;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">         	<span class="built_in">hold</span>(V v=<span class="number">0</span>):<span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>&#123;cout &lt;&lt; val &lt;&lt; endl;&#125;</span><br><span class="line">        </span><br><span class="line">        	<span class="function">V <span class="title">Value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    hold&lt;T&gt; q; <span class="comment">//模板类中的模板对象,传入的模板参数为T，即外部模板类想通过的模板参数</span></span><br><span class="line">    hold&lt;<span class="type">int</span>&gt; n;<span class="comment">//模板对象</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">beta</span>(T t,<span class="type">int</span> i):<span class="built_in">q</span>(t),<span class="built_in">n</span>(i)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;<span class="comment">//模板函数做成员</span></span><br><span class="line">    <span class="function">U <span class="title">blab</span><span class="params">(U u,T t)</span></span>&#123;<span class="keyword">return</span> (n.<span class="built_in">Value</span>()+q.<span class="built_in">Value</span>()*u/t);&#125; </span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span>&#123; q.<span class="built_in">show</span>(); n.<span class="built_in">show</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">beta&lt;<span class="type">double</span>&gt; <span class="title">guy</span><span class="params">(<span class="number">3.5</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T被设置为double\n&quot;</span>;</span><br><span class="line">    guy.<span class="built_in">Show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;V被设置为T,即double，第二个V被设置为int\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; guy.<span class="built_in">blab</span>(<span class="number">10</span>,<span class="number">2.3</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;U被设置为int\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; guy.<span class="built_in">blab</span>(<span class="number">10.0</span>,<span class="number">2.3</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;U被设置为double\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板对象做函数参数">类模板对象做函数参数</h2>
<p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型：直接显示对象的数据类型，此时模板对象必须含有模板类的参数</li>
<li>参数模板化：将对象中的参数变为模板进行传递</li>
<li>整个类模板化：将这个对象类型模板化进行传递</li>
</ol>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板对象做函数参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name,T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">199</span>);</span><br><span class="line">	<span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 2、参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">60</span>);</span><br><span class="line">	<span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将模板做模板类参数">将模板做模板类参数</h2>
<p>模板可以包含类型参数(如typename T)和非类型参数(如 int n)。模板还可以本身就是模板的参数，这种参数是模板类新增的特性，用于实现STL。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Thing</span>&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *模板参数是template &lt;typename T&gt; class Thing，其中template &lt;typename T&gt; class 是类型，Thing是参数。</span></span><br><span class="line"><span class="comment"> 假设有Crab&lt;King&gt; legs;</span></span><br><span class="line"><span class="comment"> 那么King必须是一个模板类，其声明与模板参数Thing的声明匹配；</span></span><br><span class="line"><span class="comment"> 即：</span></span><br><span class="line"><span class="comment"> template&lt;class T&gt;</span></span><br><span class="line"><span class="comment"> class King&#123;...&#125;</span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Crab</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Thing&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    Thing&lt;<span class="type">double</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设有如下声明</span></span><br><span class="line">Crab&lt;Stack&gt;stack;</span><br><span class="line"><span class="comment">//成员函数Thing&lt;int&gt;就被替换为Stack&lt;int&gt;,Thing&lt;double&gt;替换为Stack&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *总之模板参数Thing将被替换为声明Crab对象时被用作模板参数的模板类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="类模板与继承">类模板与继承</h2>
<p>当类模板碰到继承时，需要注意以下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中<code>T</code>的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中<code>T</code>的类型，子类也需为类模板</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板与继承</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son: public Base //错误，必须要知道父类中的T类型，才能继承给子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想灵活指定父类中T的类型，子类也需要变成类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;T1的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;T2的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	T1 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2&lt;<span class="type">int</span>,<span class="type">char</span>&gt; s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="模板类和友元">模板类和友元</h2>
<p>模板类声明也可以有友元。模板的友元分为3类：</p>
<ol>
<li>
<p>非模板友元</p>
</li>
<li>
<p>约束(bound)模板友元，即友元的类型取决于类被实例化时的类型；</p>
</li>
<li>
<p>非约束(unbound)模板友元，即友元的所有具体化都是类的每一个具体化的友元</p>
</li>
</ol>
<ul>
<li>
<p>非模板友元</p>
<p>在模板类中将一个常规函数声明为友元</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasFriend</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">int</span>&gt;&amp; hf)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">double</span>&gt;&amp; hf)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *上述声明使counts()函数成为模板所有实例化的友元,例如是HasFriend&lt;int&gt;和HasFriend&lt;string&gt;的友元</span></span><br><span class="line"><span class="comment"> *report()函数也是，只不过接受一个模板类参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">int</span>&gt;&amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">double</span>&gt;&amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>约束模板友元</li>
</ul>
<p>​		修改前一个示例，使友元函数本身成为模板，即使类的每一个具体化都获得与友元匹配的具体化，一共包含3步。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一步，在类定义前面声明每个模板函数*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(T&amp; t)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*第二步，在类中将模板声明为友元，这些语句根据类模板参数的类型声明具体化*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">class</span> TT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> HasFriendT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">counts</span>&lt;TT&gt;();</span><br><span class="line">    	<span class="keyword">friend</span> <span class="type">void</span> report&lt;&gt;(HasFriendT&lt;TT&gt; &amp; tt);</span><br><span class="line">        <span class="comment">//或使用friend void report&lt;HasFriendT&lt;TT&gt;&gt;(HasFriendT&lt;TT&gt; &amp; tt);</span></span><br><span class="line">    	<span class="comment">//声明中的&lt;&gt;指出这是模板具体化，&lt;&gt;可以为空，因为可以从函数参数推断出模板类型参数</span></span><br><span class="line">    	<span class="comment">//但counts()没有参数，因此必须使用模板参数语法(&lt;TT&gt;)来指明其具体化,TT为HasFriendT类的类模板参数类型</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三步，为友元函数提供定义*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(T &amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>非约束模板友元</li>
</ul>
<p>每个函数<strong>具体化</strong>都是每个类<strong>具体化</strong>的友元，<strong>友元模板类型参数与模板类类型参数不同</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ManyFriend</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T item</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">ManyFriend</span>(<span class="type">const</span> T&amp; i):<span class="built_in">item</span>(i)&#123;&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C,<span class="keyword">typename</span> D&gt;</span><br><span class="line">      <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show2</span><span class="params">(C&amp; c,D&amp; d)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C,<span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show2</span><span class="params">(C&amp; c,D&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; c.item &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; d.item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板成员函数创建时机">类模板成员函数创建时机</h2>
<p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>对于类模板的成员函数在使用时进行实例化。当你使用特定类型实例化类模板对象时，编译器会生成该类型的成员函数实现。</li>
<li>对于普通类，所有的成员函数都在编译时就被实例化了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*故可以做到以下的操作*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数的创建时机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//类模板中的成员函数在调用的时候才创建，所以不会报错</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		obj.<span class="built_in">showPerson1</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		obj.<span class="built_in">showPerson2</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Myclass&lt;Person1&gt;m;</span><br><span class="line">	m.<span class="built_in">func1</span>();</span><br><span class="line">	<span class="comment">//m.func2(); 此时模板参数传递为Person1故无法调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="类模板分文件编写-重要">类模板分文件编写(重要)</h2>
<p>如果工程中需要利用多个类模板，那么将这些类模板都写在同一个文件中将会导致代码可读性变差，所以有必要对类模板进行分文件编写，但是类模板的分文件编写面临着一些问题，以下是类模板分文件编写面临的问题及解决方法。</p>
<p><strong>问题</strong>：模板的特性导致了编译器对模板的实例化是在链接阶段进行的，而编译器需要在链接时找到模板的定义，当模板类的定义放在.h文件模板类实现放在.cpp文件，会出现链接失败情况，找不到定义。</p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>直接包含<code>.cpp</code>源文件（不常用因为.cpp风格不好一般用.hpp文件）</li>
<li>将声明和实现写到同一个文件中，并更改后缀名为<code>.hpp</code></li>
</ul>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>.hpp</code> 文件通常用来包含 C++ 的头文件，其中包含类声明、函数原型、模板定义等。这种文件扩展名的选择<strong>是一种约定</strong>，用于表示这个头文件中包含一些声明与实现在一起，比如模板类</p>
<p>一般来说，<code>.hpp</code> 文件和 <code>.h</code> 文件在功能上是相似的，都用于包含头文件，但 <code>.hpp</code> 文件更常见于 C++ 项目中，尤其是涉及到类和模板的情况。</p>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编写的templatePerson.hpp文件，模板类的定义和实现放在一个文件中*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.cpp文件内容*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;templatePerson.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="模板别名-C-11">模板别名(C++11)</h2>
<p>如果能为类型指定别名，将很方便，在模板设计中尤其如此，可以使用typedef为模板具体化指定别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">double</span>,12&gt;arrd;</span><br><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">int</span>,12&gt;arri;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>C++11新增了一项功能——使用(using)为模板提供一系列别名，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> arrtype = std::array&lt;T,<span class="number">12</span>&gt;;</span><br><span class="line"><span class="comment">//使用using将arrtype定义为一个模板别名，arrtype&lt;T&gt;表示类型std::array&lt;T,12&gt;。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arrtype&lt;<span class="type">double</span>&gt; gallons;<span class="comment">//等价于 std::array&lt;double,12&gt;</span></span><br><span class="line">arrtype&lt;<span class="type">int</span>&gt; days;<span class="comment">//与上面相同</span></span><br><span class="line">arrtype&lt;std::string&gt; months</span><br></pre></td></tr></table></figure>
<p>C++11 允许将语法using = 用于非模板。用于非模板时语法与常规typedef等价：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span>* pc1;</span><br><span class="line"><span class="keyword">using</span> pc2 = <span class="type">const</span> <span class="type">char</span>*;<span class="comment">//与上方等价</span></span><br></pre></td></tr></table></figure>
<p><strong>好处</strong>：</p>
<ul>
<li>使用模板别名可以提高代码的可读性，特别是在涉及复杂模板或需要引入特定模板类型时。</li>
<li>模板别名还可以使代码更易于维护，因为你只需要在一个地方修改模板类型或表达式，而无需修改多处使用的地方。</li>
</ul>
<h1>友元</h1>
<p>在C++中，友元类和友元函数是用来在类之间建立友好关系的机制，允许一个类的成员访问另一个类的私有成员。这样可以增加程序的灵活性和封装性。</p>
<p>虽然友元提供了灵活性，但过度使用友元可能会破坏封装性，因此应该谨慎使用。友元应该只在确实需要访问私有成员的情况下使用，以保持代码的清晰性和可维护性。</p>
<h2 id="友元函数">友元函数</h2>
<ul>
<li><strong>作用</strong>： <strong>允许一个非成员函数访问类的私有成员。</strong></li>
<li><strong>用法</strong>： 可以在类的声明中使用<code>friend</code>关键字声明友元函数，然后在类外定义这个函数。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span>:myData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">showMyData</span><span class="params">(<span class="type">const</span> Myclass&amp; myclass)</span></span>;<span class="comment">//友元函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元函数类外定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMyData</span><span class="params">(<span class="type">const</span> Myclass&amp; myclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myData = &quot;</span> &lt;&lt; myclass.myData &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//友元函数可以访问私有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showMyData</span>(myclass);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="友元类">友元类</h2>
<ul>
<li><strong>作用</strong>： <strong>允许一个类的所有成员函数访问另一个类的私有成员</strong>。</li>
<li><strong>用法</strong>：在类的声明中使用<code>friend</code>关键字声明<strong>友元类</strong>。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> friendData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FriendClass</span><span class="params">(<span class="type">int</span> data)</span>:friendData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">FriendClass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Myclass</span>;<span class="comment">//指定Myclass为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span>:myData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;FriendClass data is: &quot;</span> &lt;&lt; friendclass.friendData &lt;&lt; endl;<span class="comment">//友元类的成员函数直接访问另一个类的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">FriendClass <span class="title">friendclass</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">   <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   myclass.<span class="built_in">showFriendData</span>(friendclass);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="友元成员函数">友元成员函数</h2>
<ul>
<li><strong>作用</strong>： <strong>允许一个类的某一个成员函数访问另一个类的私有成员</strong>。</li>
<li><strong>用法</strong>：在类的声明中使用<code>friend</code>关键字声明<strong>友元</strong>。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明FriendClass，以便在Myclass中声明友元关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span> : myData(data) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明Myclass的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> friendData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FriendClass</span><span class="params">(<span class="type">int</span> data)</span> : friendData(data) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">FriendClass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数的声明，在FriendClass中声明，使Myclass的showFriendData作为FriendClass类的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Myclass::showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Myclass的成员函数因为是FriendClass的友元，所以定义必须在类外，用于访问FriendClass的私有成员，</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myclass::showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FriendClass data is: &quot;</span> &lt;&lt; friendclass.friendData &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Myclass data is: &quot;</span> &lt;&lt; myData &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FriendClass <span class="title">friendclass</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    myclass.<span class="built_in">showFriendData</span>(friendclass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="友元的优缺点">友元的优缺点</h2>
<p><strong>优点：</strong></p>
<ol>
<li><strong>灵活性：</strong> 友元机制允许在类之间建立友好关系，使得某个函数或类可以访问其他类的私有成员，提高了灵活性。</li>
<li><strong>特定需求的访问权限：</strong> 有时候，为了实现特定的功能，需要某些函数或类能够直接访问其他类的私有成员，友元机制提供了一种选择。</li>
<li><strong>效率：</strong> 有时候使用友元可以避免通过公有接口的方式(比如get方法等等)进行多次函数调用，提高代码执行效率。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>破坏封装性：</strong> 友元可以直接访问类的私有成员，这可能破坏类的封装性，增加了代码的耦合性，增加了维护的难度。</li>
<li><strong>复杂性增加：</strong> 过度使用友元可能导致代码更加复杂，使得程序难以理解和维护。</li>
<li><strong>设计问题：</strong> 有时候需要重新考虑设计，以避免对友元的过度依赖。可能存在更好的设计模式或方法，不需要使用友元。</li>
</ol>
<h1>嵌套类</h1>
<h2 id="概念-2">概念</h2>
<p>在C++中，嵌套类是一个类被定义在另一个类的内部的情况。被嵌套的类称为内部类或嵌套类，而包含这个内部类的类称为外部类。嵌套类可以具有私有、受保护或公有的访问权限，这取决于它在外部类中的声明方式。包含类的成员函数可以创建和使用被嵌套类的对象；而仅当声明位于公有部分时，才能在包含类的外面使用嵌套类，而且必须使用作用域解析运算符(旧版本的C++不允许嵌套类或无法完全实现这种概念)</p>
<p><strong>一个示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内部类 Point 表示二维平面上的点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Point</span>(<span class="type">int</span> xCoord, <span class="type">int</span> yCoord) : <span class="built_in">x</span>(xCoord), <span class="built_in">y</span>(yCoord) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部类的成员函数</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Point: (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Point center; <span class="comment">// Shape 类包含 Point 类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Shape 类的构造函数</span></span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">int</span> centerX, <span class="type">int</span> centerY) : <span class="built_in">center</span>(centerX, centerY) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shape 类的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayShape</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shape with center at &quot;</span>;</span><br><span class="line">        center.<span class="built_in">display</span>(); <span class="comment">// 调用内部类的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Shape 类对象</span></span><br><span class="line">    <span class="function">Shape <span class="title">myShape</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Shape 类的成员函数</span></span><br><span class="line">    myShape.<span class="built_in">displayShape</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="作用">作用</h2>
<p>嵌套类的主要作用之一是组织和封装代码，使代码更为模块化、清晰和可读。以下是嵌套类的一些主要作用：</p>
<ol>
<li><strong>封装实现细节：</strong> 嵌套类允许将一个类的一部分实现细节封装在另一个类中，从而隐藏一些具体的实现细节，提高封装性。外部类可以更专注于公共接口，而具体的实现则留给内部类。</li>
<li><strong>组织相关的类：</strong> 当两个类有密切关联时，将它们组织在一起可以形成更清晰的结构。嵌套类可以在逻辑上将这些关联的类放在同一个地方，方便代码的组织和维护。</li>
<li><strong>限制访问权限：</strong> 内部类可以访问外部类的私有成员，但外部类不能直接访问内部类的私有成员。这种特性可以用于在设计中划分不同层次的访问权限，使得代码更安全。</li>
<li><strong>实现接口与实现分离：</strong> 将接口和实现分离，可以通过内部类隐藏一些实现细节。外部类可以专注于公共接口，而具体的实现细节则留给内部类。</li>
<li><strong>增加代码的模块化：</strong> 将相关的类组织在一起可以使代码更模块化。每个嵌套类可以有自己的职责，这样代码更易于理解和维护。</li>
</ol>
<h2 id="访问控制">访问控制</h2>
<ol>
<li>
<p><strong>公有嵌套类</strong>： 如果内部类声明为<code>public</code>，则外部类的任何成员函数、友元或其他类都可以访问内部类。这使得内部类对外可见，允许外部代码直接访问它。</p>
</li>
<li>
<p><strong>私有嵌套类</strong>：如果内部类声明为<code>private</code>，则只有外部类的成员函数和友元可以访问内部类。外部类的客户端无法直接访问或创建内部类的对象。</p>
</li>
<li>
<p><strong>保护嵌套类</strong>： 如果内部类声明为<code>protected</code>，则外部类的成员函数、友元以及继承了外部类的派生类都可以访问内部类</p>
</li>
</ol>
<h1>异常</h1>
<h2 id="异常概念">异常概念</h2>
<p>C语言异常处理机制是：</p>
<ol>
<li>终止程序。缺陷：用户难以接受。如发生内存错误，除0错误时就会终止</li>
<li>返回错误码。缺陷：需要程序员自己去查对应的错误</li>
</ol>
<p>在C++中，异常是一种在程序执行过程中发生的错误或者意外状况。异常提供了一种机制，允许程序员在代码中识别和处理错误，以及在出现错误时进行适当的响应。异常处理是C++中一个重要的编程概念，它使得程序更健壮，更容易维护。</p>
<p>C++中异常处理有三个关键字：<strong>throw、catch、try</strong></p>
<ul>
<li>throw：当问题出现，程序抛出一个异常。抛异常使用throw关键字完成。</li>
<li>catch：用于捕捉异常。**catch(…)**可以捕获任意类型的异常，主要时用来捕获没有显示捕获类型的异常。相当于条件判断中的else。</li>
<li>try：try中包含会出现异常的代码或者函数。后面通常会跟一个或者多个catch块。</li>
</ul>
<p><strong>注意：可以抛出任意类型的对象。抛出的异常必须捕获。try要和catch匹配使用，catch里的内容抛出异常时才执行，没有异常，不执行。</strong></p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入被除数和除数:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;除0错误&quot;</span>;<span class="comment">//抛出异常,这里抛出的是字符串类型异常，也可以是对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">test</span>() &lt;&lt; endl;<span class="comment">//会出现异常的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//捕获字符串类型的异常，a即 &quot;除0错误&quot;。</span></span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* a)&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="comment">//捕获任意类型的异常，通常未知异常</span></span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unknow exception&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常的抛出和匹配规则">异常的抛出和匹配规则</h2>
<h3 id="异常的抛出">异常的抛出</h3>
<ol>
<li>
<p>异常时通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码。</p>
</li>
<li>
<p>被选中的处理代码的调用链是，找到于该类型匹配且离抛出异常位置最近的那一个catch。</p>
</li>
<li>
<p>抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象。</p>
</li>
<li>
<p>catch(…)可以捕获任意类型的对象，主要是用来捕获没有显示捕获类型的异常，因为如果没有匹配的catch会终止程序。相当于条件判断中的else。问题是不知道异常错误是什么。</p>
</li>
<li>
<p>实际中抛出和捕获的类型不一定类型完全匹配，可以抛出派生类对象，使用基类来捕获，这个在实际生活中很实用。主要原因是：派生类可以赋值给基类。</p>
</li>
</ol>
<h3 id="匹配规则">匹配规则</h3>
<ul>
<li>首先检查throw本身是否在try块内部，如果是，再在当前函数栈中查找匹配的catch语句。如果有匹配的直接跳到catch的地方执行。</li>
<li>如果没有匹配的catch块，则退出当前函数栈，在调用函数的栈中查找匹配的catch。</li>
<li>如果到达main函数的栈，都没有匹配的catch，就会终止程序。</li>
<li>上述沿着调用链查找匹配的catch块的过程叫栈展开。所以实际要最后要加一个catch(…)来捕获任意类型的异常，防止程序终止。</li>
<li>找到匹配的catch会直接跳到catch语句执行，执行完后，会继续沿着catch语句后面执行。</li>
</ul>
<h2 id="异常的重新抛出">异常的重新抛出</h2>
<p>有可能单个的catch不能完全处理一个异常，**在进行一些矫正处理后，需要交给更外层的调用链函数来处理。**catch可以做完矫正操作，再将异常重新抛出，交给更上层的函数进行处理。</p>
<h2 id="异常安全问题">异常安全问题</h2>
<p>由于抛异常只要找到匹配的catch就直接跳到catch块执行，没有找到对应catch的函数就不会继续执行。这样导致函数的执行流回很乱。可能会导致一些问题。</p>
<ul>
<li>
<p>构造函数完成对象的构造和初始化，最好不要再构造函数中抛出异常，否则可能导致对象不完整或者没有完全初始化</p>
</li>
<li>
<p>析构函数主要完成资源的清理，最好不要在析构函数中抛异常，否则可能导致内存泄漏。</p>
</li>
<li>
<p>C++异常经常会导致资源泄漏问题。比如：在new和delete中抛出异常，导致new出来的资源没有释放，导致内存泄漏。在lock和unlock中抛出异常，导致锁没有释放，导致死锁。</p>
</li>
</ul>
<p>有两种解决办法：</p>
<ul>
<li>将异常捕获，释放资源后，将锁重新抛出。</li>
<li>使用RAII的思想解决。定义一个类封装，管理资源。当要使用时实例化一个类对象，将资源传入，当退出函数，调用对象析构函数，释放资源。</li>
</ul>
<h2 id="异常规范说明">异常规范说明</h2>
<ul>
<li><strong>noexcept</strong>：表示函数不抛出异常。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>noexcept(expression)</strong>： 表示如果 <code>expression</code> 求值结果为 <code>true</code>，则函数不抛出异常。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(someExpression())</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>早期的异常规范：</strong> 在早期的C++标准中，可以使用 <code>throw()</code> 表示函数不抛出异常，或者使用 <code>throw(type1, type2, ...)</code> 来指定函数可能抛出的异常类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// 函数不抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">anotherFunction</span><span class="params">()</span> <span class="title">throw</span><span class="params">(std::exception, MyException)</span></span>; <span class="comment">// 函数可能抛出 std::exception 或 MyException</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>现代C++中的 noexcept</strong>： 推荐使用 <code>noexcept</code> 关键字来表示函数是否抛出异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 函数不抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">anotherFunction</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(someExpression())</span></span>; <span class="comment">// 函数在 someExpression() 为 true 时不抛出异常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>异常规范的问题：</strong> 早期的异常规范在实践中并没有提供太多的好处，而且容易导致问题。因此，自C++11开始，异常规范已经被弃用，而 <code>noexcept</code> 关键字更灵活且更安全。</p>
<h2 id="自定义异常体系">自定义异常体系</h2>
<p>在实际中，并不是我们想抛什么异常就抛什么异常，这样会导致捕捉的时候不好捕捉。而是，会建立一个继承体系，<strong>建立一个异常类，派生类继承这个类，来定义出不同的异常。</strong></p>
<ul>
<li>到时候抛出异常**，只需要用基类进行捕捉即可**</li>
<li>基类可以相当于是一个框架，派生类是具体的异常。然后去具体实现异常的内容，然后<strong>抛异常只需要抛派生类，捕捉异常只需要捕捉基类即可。</strong> ‘</li>
</ul>
<p>下列使用一个简单实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="comment">//异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Exception</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">0</span>):_errmsg(str), _id(id)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>;<span class="comment">//派生类中输出的指定异常信息</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _errmsg;<span class="comment">//错误信息</span></span><br><span class="line">    <span class="type">int</span> _id;<span class="comment">//错误码</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="comment">//数据库异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SqlException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">1</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//网络异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">2</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//缓存异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CacheException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">3</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当网络连接失败，抛出这个异常即可</span></span><br><span class="line">    <span class="comment">//throw HttpException(&quot;Http fail&quot;, 2);</span></span><br><span class="line">    <span class="comment">//当缓存错误,抛出这个异常</span></span><br><span class="line">    <span class="comment">//throw CacheException(&quot;Cache error&quot;, 3);</span></span><br><span class="line">    <span class="comment">//当数据库错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">SqlException</span>(<span class="string">&quot;Sql error&quot;</span>, <span class="number">4</span>);<span class="comment">//抛出派生类异常对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//捕获基类异常，</span></span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> Exception&amp; a)&#123;</span><br><span class="line">        a.<span class="built_in">what</span>();<span class="comment">//输出错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unknow exception&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-标准库的异常体系">C++标准库的异常体系</h2>
<p>在C++库中也建立了一个异常体系。也给我们提供了一些异常类。我们可以在程序中使用这些标准异常，它们也是以父子类层次结构组织起来的。</p>
<ul>
<li>基类：std::exception</li>
<li>派生类：std::runtime_error等</li>
</ul>
<h2 id="异常优缺点">异常优缺点</h2>
<p><strong>优点</strong>：</p>
<ul>
<li>异常对象定义好了，相比较于错误码，可以清晰准确的展示出错误的各种信息，甚至包含堆栈调用信息，可以帮我们很好的定位程序的bug。</li>
<li>在函数调用链中，深层函数返回错误，我们得层层返回，需要不断的判断是什么错误，再返回给最外层。异常直接会找到对应的catch执行，不需要判断是什么错误。</li>
<li>部分函数更好处理，比如没有返回值的函数或者返回值为自身的T&amp; operator，不好返回错误码。并且pos越界了，内存错误等不需要终止程序。</li>
<li>更好的进行测试代码</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>异常导致执行流乱跳，运行混乱。导致我们调试和分析程序时，比较困难。</li>
<li>C++没有垃圾回收机制，可能会导致异常安全问题。开辟的资源和打开的流，由于执行流乱跳，导致没有释放和关闭等。导致内存泄漏。打开的锁为关闭，导致死锁。</li>
<li>C++标准库的异常体系定义不好，导致我们需要各自定义各自的体系，非常混乱。</li>
<li>随意抛异常，外层不好捕获，所以尽量按找异常规范使用。</li>
</ul>
<h2 id="RTTI">RTTI</h2>
<p>在C++中，RTTI是<strong>运行阶段类型识别</strong>的简称（Runtime Type Identification）。它允许在程序运行时获取对象的类型信息。是新添加到C++中的特性之一，很多老式实现不支持。主要用途包括：</p>
<ol>
<li><strong>识别对象类型：</strong> RTTI允许在程序运行时确定对象的类型。这对于处理多态性和动态多态性（dynamic polymorphism）非常有用。例如，在一个基类的指针或引用指向派生类对象时，你可以使用RTTI来确定实际派生类的类型。</li>
<li><strong>安全的类型转换：</strong> 在某些情况下，你可能需要将基类指针或引用安全地转换为派生类指针或引用。RTTI的<code>dynamic_cast</code>运算符可用于执行这种安全的转换，它会在转换之前检查类型信息，如果转换不安全，<strong>它会返回空指针或引发异常</strong>，而不是导致未定义行为。</li>
<li><strong>类型检查：</strong> RTTI允许你在运行时检查对象的类型信息，从而采取相应的措施。这对于实现一些通用的算法或框架，需要根据对象的类型来执行不同的操作，非常有用。</li>
<li><strong>异常处理：</strong> 在一些情况下，RTTI可用于处理异常。当在基类指针或引用上使用<code>dynamic_cast</code>时，如果转换失败，会返回空指针或引发<code>std::bad_cast</code>异常，可以在异常处理中捕获。</li>
</ol>
<p>C++中有三个支持RTTI的元素</p>
<ul>
<li>dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针，否则，该运算符返回空指针-0</li>
<li>typeid运算符返回一个指出对象的类型的值</li>
<li>type_info结构储存了有关特定类型的信息</li>
</ul>
<h3 id="dynamic-cast">dynamic_cast</h3>
<p><strong>dynamic_cast 操作符</strong>：<code>dynamic_cast</code> 用于在运行时执行安全的类型转换，主要用于处理继承关系。它可以将指向基类的指针或引用转换为派生类的指针或引用，同时执行类型检查。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">   Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (derivedPtr != <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Successfully casted to Derived.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Failed to cast to Derived.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> basePtr;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Derived&amp; derivedRef = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(*basePtr);</span><br><span class="line">    <span class="comment">// 成功转换</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_cast&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在一些情况下，RTTI可用于处理异常。当在基类指针或引用上使用dynamic_cast时，如果转换失败，会返回空指针或引发std::bad_cast异常，可以在异常处理中捕获。*/</span></span><br></pre></td></tr></table></figure>
<h3 id="typeid和type-info">typeid和type_info</h3>
<p><strong>typeid运算符</strong>：</p>
<ul>
<li><strong>用途：</strong> <code>typeid</code>运算符用于在运行时获取对象的类型信息。它返回一个<code>const std::type_info&amp;</code> 对象，该对象包含有关实际类型的信息，其中type_info是在头文件typeinfo(以前是typeInfo.h)中定义的一个类。。</li>
<li><strong>语法：</strong> <code>typeid(expression)</code>，其中<code>expression</code>是一个表达式，通常是<strong>一个对象或一个类型</strong>。</li>
</ul>
<p><strong>type_info类</strong>：</p>
<ul>
<li><strong>用途：</strong> <code>type_info</code>是一个类，表示类型信息。它包含有关类型的信息，例如类型的名称。</li>
<li><strong>成员函数：</strong>
<ul>
<li><strong><code>name()</code>：</strong> 返回一个指向包含类型名称的C字符串的指针。请注意，这个名称的格式是实现定义的，可能在不同编译器和平台上有所不同。</li>
<li><strong>其他成员函数：</strong> 可能会有其他一些实现特定的成员函数，但标准并没有规定。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="type">const</span> std::type_info&amp; typeInfo = <span class="built_in">typeid</span>(*basePtr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object type: &quot;</span> &lt;&lt; typeInfo.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>typeid运算符使得能够确定两个对象是否为同种类型。type_info类重载了==和!运算符，可以使用这些运算符来对类型比较。</strong></p>
<p><strong>例如</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> Base;</span><br><span class="line">    Derived* derivedPtr = <span class="keyword">new</span> Derived;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Base) == <span class="built_in">typeid</span>(*basePtr)) &lt;&lt; std::endl;<span class="comment">//(*basePtr表示指向的对象)相同,返回值1</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Base) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//返回值0</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Derived) == <span class="built_in">typeid</span>(*basePtr)) &lt;&lt; std::endl;<span class="comment">//返回值0</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Derived) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//返回值1</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(*basePtr) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//,对象不同返回值0</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">delete</span> derivedPtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>智能指针模板类</h1>
<p>当谈到C++中的智能指针时，通常会涉及到 <code>std::shared_ptr</code> 和 <code>std::unique_ptr</code> 这两个模板类。还有一个<code>std::auto_ptr</code>已经被摒弃，但在C++11以前使用了多年，如果编译器不支持其他两种，则auto_ptr是唯一选择。<strong>这些智能指针类旨在管理动态分配的内存，并在对象不再需要时自动释放该内存，从而避免内存泄漏和悬挂指针的问题。</strong></p>
<p>要创建智能指针对象，必须包含头文件<strong>memory</strong>，该文件模板定义。然后使用通常的模板语法来实例化所需类型的指针。</p>
<h2 id="auto-ptr模板类">auto_ptr模板类</h2>
<p><code>std::auto_ptr</code> 是 C++98 标准中引入的智能指针，用于管理动态分配的内存。然而，它在 C++11 标准中已被弃用，并且在 C++17 标准中已经被移除。主要原因是 <code>std::auto_ptr</code> 存在一些问题，特别是在资源所有权转移方面存在潜在的危险。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">autoPtr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    *autoPtr1 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// autoPtr2 现在拥有 autoPtr1 的内存所有权</span></span><br><span class="line">    std::auto_ptr&lt;<span class="type">int</span>&gt; autoPtr2 = autoPtr1;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; *autoPtr1 &lt;&lt; std::endl;<span class="comment">//输出1</span></span><br><span class="line">    <span class="comment">// 这里autoPtr1不再拥有资源，会导致运行时错误</span></span><br><span class="line">    <span class="comment">// 使用 autoPtr1 时可能会出现未定义的行为</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="function">std::auto_ptr&lt;<span class="type">double</span>&gt; <span class="title">autoPtr3</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>;</span><br><span class="line">    *autoPtr3 = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; *autoPtr3 &lt;&lt; std::endl;<span class="comment">//输出3.14</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::auto_ptr&lt;string&gt; <span class="title">autoPtr4</span><span class="params">(<span class="keyword">new</span> string)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>std::auto_ptr</strong>具有独占所有权的特性，但其所有权转移的方式可能导致一些问题，因为它采用了移动语义而非拷贝语义。这意味着当一个 <strong>std::auto_ptr</strong>所有权转移给另一个时，原始的 <strong>std::auto_ptr</strong> 将不再拥有对资源的所有权。</p>
</div>
<h2 id="shared-ptr模板类">shared_ptr模板类</h2>
<p><code>std::shared_ptr</code> 是一种共享所有权的智能指针，多个 <code>shared_ptr</code> 实例可以共享对同一块内存的所有权。它使用引用计数来追踪有多少个 <code>shared_ptr</code> 共享相同的资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 创建一个shared_ptr并分配内存</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  等价于std::shared_ptr&lt;int&gt; sharedPtr(new int(42));</span></span><br><span class="line"><span class="comment">         *  但是std::make_shared&lt;int&gt;(42)更加安全，因为它有性能优势和异常安全性</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 共享所有权</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; anotherSharedPtr = sharedPtr;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;sharedPtr: &quot;</span> &lt;&lt; *sharedPtr &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;anotherSharedPtr: &quot;</span> &lt;&lt; *anotherSharedPtr &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 使用sharedPtr和anotherSharedPtr</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当最后一个shared_ptr离开作用域时，内存会被自动释放</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="unique-ptr模板类">unique_ptr模板类</h2>
<p><code>std::unique_ptr</code> 是一种独占所有权的智能指针，一个 <code>unique_ptr</code> 实例独立拥有对其指向的资源的所有权，不能共享。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建一个unique_ptr并分配内存</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::cout &lt;&lt; *uniquePtr &lt;&lt; std::endl;<span class="comment">//输出42</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  等价于std::unique_ptr&lt;int&gt; sharedPtr(new int(42));</span></span><br><span class="line"><span class="comment">         *  但是std::make_unique&lt;int&gt;(42)更加安全，因为它有性能优势和异常安全性</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// unique_ptr不能直接赋值给另一个unique_ptr（会发生所有权转移）</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; anotherUniquePtr = uniquePtr;  // 错误，编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过std::move进行所有权转移</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; anotherUniquePtr = std::<span class="built_in">move</span>(uniquePtr);</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt; *anotherUniquePtr &lt;&lt; std::endl;<span class="comment">//输出42</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用anotherUniquePtr</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当anotherUniquePtr离开作用域时，内存会被自动释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="unique-ptr为何优于auto-ptr">unique_ptr为何优于auto_ptr</h2>
<ol>
<li>
<p><strong>更安全的所有权转移：</strong> <code>std::unique_ptr</code> 使用移动语义进行所有权转移，而 <code>std::auto_ptr</code> 使用复制语义。由于 <code>std::auto_ptr</code> 的复制语义可能导致不明确的行为，因此在 C++11 引入 <code>std::unique_ptr</code> 时，<code>std::auto_ptr</code> 被标记为已弃用。使用 <code>std::unique_ptr</code> 更容易理解和更安全。</p>
</li>
<li>
<p><strong>支持数组和自定义删除器：</strong> <code>std::unique_ptr</code> 可以用于管理数组（<code>std::unique_ptr&lt;T[]&gt;</code>），而 <code>std::auto_ptr</code> 不支持这种用法。此外，<code>std::unique_ptr</code> 还支持通过自定义删除器来管理非默认方式分配的资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arrayPtr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">arrayPtr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arrayPtr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">arrayPtr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>更灵活的模板参数：</strong> <code>std::unique_ptr</code> 具有更灵活的模板参数，可以轻松地与自定义删除器和分配器一起使用。这提供了更多的灵活性，以适应各种资源管理需求。</p>
</li>
<li>
<p><strong>更严格的所有权管理：</strong> <code>std::unique_ptr</code> 严格实现了独占所有权的概念，一个 <code>std::unique_ptr</code> 实例独立拥有对其指向的资源的所有权。这使得代码更加明确，减少了潜在的错误。</p>
</li>
</ol>
<p><strong>警告</strong>：</p>
<p><strong>只有使用new分配内存时</strong>，才能使用auto_ptr和shared_ptr，<strong>使用new[] 分配内存时</strong>，不能使用它们，只能使用unique_ptr。<strong>不使用new或new[]分配内存时</strong>，也不能使用unique_ptr。</p>
<h1>标准模板库STL</h1>
<h2 id="模板类vector-2">模板类vector</h2>
<p><strong>vector又名动态数组</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52324409/article/details/121000029?ops_request_misc=%7B%22request%5Fid%22%3A%22170903352516800180642186%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170903352516800180642186&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121000029-null-null.142%5Ev99%5Epc_search_result_base1&amp;utm_term=vector%E5%AE%B9%E5%99%A8&amp;spm=1018.2226.3001.4187">C++ vector容器详解_c++容器vector-CSDN博客</a></p>
<h2 id="基于范围的for循环">基于范围的for循环</h2>
<p>基于范围的for循环是为用于STL而设计的。在这种for循环中，括号中的代码<strong>声明一个类型(通常用auto)与容器储存的内容相同的变量</strong>，然后指出了容器的名称。接下来，循环体使用指定的变量依次访问容器的每个元素。若<strong>使用引用参数，则可修改容器内容</strong>。</p>
<p>一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> price[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; price2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*未使用引用参数，不能修改容器内容*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: price) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*使用引用可以修改容器内容*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x: price2) &#123;</span><br><span class="line">        x=<span class="number">10</span>;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h2 id="泛型编程">泛型编程</h2>
<p>STL是一种泛型编程。面向对象编程关注的是编程的数据方面，而泛型编程关注的则是算法。他们之间的共同点是抽象和创建可重用代码，但他们的理念绝然不同。</p>
<p>泛型编程旨在编写独立于数据类型的代码。在C++中，完成通用程序的工具是模板。模板使得能够按泛型定义函数或类，而STL通过通用算法更近了一步。为了解模板和设计是如何协同工作的，我们需要先了解一下迭代器。</p>
<h3 id="迭代器">迭代器</h3>
<p>在C++中，模板使得<strong>算法独立于储存的数据类型</strong>，而迭代器使<strong>算法独立于使用的容器类型</strong>，迭代器（Iterator）是一种用于遍历容器（如数组、向量、链表等）中元素的对象。迭代器提供了一种统一的方式来访问容器中的元素，而不必关心容器的具体类型或实现细节。C++标准库提供了多种类型的迭代器，<strong>主要分为五种</strong>：</p>
<ol>
<li><strong>Input Iterator（输入迭代器）</strong>：
<ul>
<li>只允许从容器中读取元素，但不能修改元素。</li>
<li>支持逐个递增，只能用于单向遍历。</li>
</ul>
</li>
<li><strong>Output Iterator（输出迭代器）</strong>：
<ul>
<li>只允许往容器中写入元素，但不能读取元素。</li>
<li>支持逐个递增，也只能用于单向遍历。</li>
</ul>
</li>
<li><strong>Forward Iterator（前向迭代器）</strong>：
<ul>
<li>具有Input Iterator和Output Iterator的功能，支持读写操作。</li>
<li>支持逐个递增，可用于单向遍历。</li>
</ul>
</li>
<li><strong>Bidirectional Iterator（双向迭代器）</strong>：
<ul>
<li>具有Forward Iterator的功能，同时支持逐个递减。</li>
<li>支持双向遍历，即可以前进也可以后退。</li>
</ul>
</li>
<li><strong>Random Access Iterator（随机访问迭代器）</strong>：
<ul>
<li>具有Bidirectional Iterator的功能，同时支持随机访问元素。</li>
<li>支持通过指针算术运算（如 +、-）直接跳跃访问容器中的元素。</li>
</ul>
</li>
</ol>
<p>在C++标准库中，不同的容器提供不同类型的迭代器，例如，<code>std::vector</code>和<code>std::list</code>提供了双向迭代器，而<code>std::array</code>和<code>std::deque</code>提供了随机访问迭代器。在使用迭代器时，要注意选择适当的类型以满足操作的需求。。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义一个迭代器...*/</span></span><br><span class="line">vector&lt;type&gt;::iterator it;</span><br><span class="line">list&lt;type&gt;::iterator it2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*一个简单的示例*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; price= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">list&lt;<span class="type">double</span>&gt;::iterator it2;<span class="comment">//定义的一个遍历list容器的迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = price2.<span class="built_in">begin</span>();<span class="comment">//定义的一个遍历vector容器的迭代器</span></span><br><span class="line"><span class="keyword">for</span>(; it != price2.<span class="built_in">end</span>(); it++)<span class="comment">//迭代器支持前缀++和后缀++，遍历容器</span></span><br><span class="line">&#123;</span><br><span class="line">   std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实际上作为一种编程风格，最好避免直接使用迭代器，而应尽可能使用STL函数(for_each())来处理细节。也可以使用C++11新增的基于范围的for循环。</p>
<h3 id="容器">容器</h3>
<p>STL具有容器概念和容器类型。概念是具有名称(容器、序列容器、关联容器)的通用类别，容器类型是可用于创建具体容器对象的模板。</p>
<p>主要的容器分类包括：</p>
<ol>
<li><strong>序列容器（Sequence Containers）</strong>：
<ul>
<li>顺序存储元素，元素的顺序与它们被插入的顺序相同。</li>
<li>包括：
<ul>
<li><strong>std::vector：</strong> 动态数组，支持快速随机访问。</li>
<li><strong>std::list：</strong> 双向链表，支持在任意位置快速插入和删除元素。</li>
<li><strong>std::deque：</strong> 双端队列，支持在两端快速插入和删除元素。</li>
<li><strong>std::array：</strong> 固定大小的数组，支持快速随机访问。</li>
</ul>
</li>
</ul>
</li>
<li><strong>关联容器（Associative Containers）</strong>：
<ul>
<li>基于键值对（Key-Value）的存储方式，通过键值来快速查找元素。</li>
<li>包括：
<ul>
<li><strong>std::set：</strong> 有序集合，不允许重复元素。</li>
<li><strong>std::map：</strong> 有序映射，存储键值对，不允许重复的键。</li>
<li><strong>std::multiset：</strong> 有序集合，允许重复元素。</li>
<li><strong>std::multimap：</strong> 有序映射，允许重复的键。</li>
</ul>
</li>
</ul>
</li>
<li><strong>无序容器（Unordered Containers）</strong>：
<ul>
<li>使用哈希表实现，元素的存储顺序不固定。</li>
<li>包括：
<ul>
<li><strong>std::unordered_set：</strong> 无序集合，不允许重复元素。</li>
<li><strong>std::unordered_map：</strong> 无序映射，存储键值对，不允许重复的键。</li>
<li><strong>std::unordered_multiset：</strong> 无序集合，允许重复元素。</li>
<li><strong>std::unordered_multimap：</strong> 无序映射，允许重复的键。</li>
</ul>
</li>
</ul>
</li>
<li><strong>容器适配器（Container Adapters）</strong>：
<ul>
<li>提供特定接口的封装，简化了底层容器的使用。</li>
<li>包括：
<ul>
<li><strong>std::stack：</strong> 栈，后进先出（LIFO）。</li>
<li><strong>std::queue：</strong> 队列，先进先出（FIFO）。</li>
<li><strong>std::priority_queue：</strong> 优先队列，按照优先级排序。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>用法见</strong>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45524532/article/details/115386824?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=C++%E5%AE%B9%E5%99%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-115386824.142%5Ev99%5Epc_search_result_base9&amp;spm=1018.2226.3001.4187">C++常用容器-CSDN博客</a></p>
<h2 id="函数对象">函数对象</h2>
<p>在C++中，函数对象（Function Objects），也称为函数符或仿函数（Functor），函数符是可以以函数方式与()结合使用的任意对象。这包括函数名的指针和重载了()运算符对象的类(即定义了函数operator()()的类)。是一种可调用对象，可以像函数一样被调用。函数对象通常是类对象，但不像普通函数，它们可以携带状态信息，并可以通过成员函数实现自定义行为。函数对象可用于算法、STL容器等各种场景中。</p>
<p><strong>函数对象类</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数符类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddFunctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>使用方式</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddFunctor addFunctor;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">addFunctor</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 结果为7</span></span><br></pre></td></tr></table></figure>
<h3 id="应用">应用</h3>
<ol>
<li><strong>函数对象作为算法的参数</strong>：</li>
</ol>
<p>函数对象可以作为算法的参数，提供一种灵活的方式来定制算法的行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SquareFunctor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    SquareFunctor squareFunctor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象对容器中的每个元素进行平方操作</span></span><br><span class="line">    std::<span class="built_in">transform</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), numbers.<span class="built_in">begin</span>(), squareFunctor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在numbers为 &#123;1, 4, 9, 16, 25&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>函数对象与STL</strong>：</li>
</ol>
<p>函数对象在STL（标准模板库）中广泛应用，例如在排序、查找等算法中可以通过函数对象来指定比较的规则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DescendingOrder</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    DescendingOrder descendingOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象进行降序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), descendingOrder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在numbers为 &#123;8, 5, 3, 2, 1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="算法">算法</h2>
<p><strong>STL的算法</strong>：</p>
<ul>
<li><strong>作用范围</strong>：STL的算法是独立于容器的通用算法。它们被设计为能够在不同类型的容器上进行操作，而不依赖于具体容器的实现。这种独立性使得同一个算法可以用于不同的数据结构，例如，可以使用<code>std::sort</code>在不同类型的容器上进行排序。</li>
<li><strong>参数类型</strong>：STL的算法通常接受迭代器（iterator）作为参数，因此可以用于各种容器，如数组、向量、链表等。它们不直接与容器关联，而是通过迭代器与容器交互。</li>
<li><strong>功能丰富</strong>：STL的算法涵盖了广泛的应用场景，包括排序、查找、数学运算、变换等。这些算法是为了提供通用且高效的数据处理工具。</li>
</ul>
<p>以下是一些常用的STL算法及其简要介绍：</p>
<ol>
<li><strong>排序算法</strong>：
<ul>
<li><code>std::sort</code>：对容器进行排序，默认是升序排序。可以传递自定义的比较函数或Lambda表达式来实现不同的排序规则。</li>
<li><code>std::stable_sort</code>：稳定排序，保持相等元素的相对顺序。</li>
<li><code>std::partial_sort</code>：部分排序，将容器中的一部分元素排序，其余元素不变。</li>
</ul>
</li>
<li><strong>查找算法</strong>：
<ul>
<li><code>std::find</code>：在容器中查找指定值的第一个出现位置。</li>
<li><code>std::binary_search</code>：在已排序的容器中进行二分查找。</li>
<li><code>std::count</code>：统计容器中指定值的出现次数。</li>
</ul>
</li>
<li><strong>变换算法</strong>：
<ul>
<li><code>std::transform</code>：将一个范围的元素转换为另一个范围，可以结合函数对象或Lambda表达式进行元素的变换操作。</li>
<li><code>std::copy</code>：将一个范围的元素复制到另一个范围。</li>
<li><code>std::replace</code>：替换容器中指定值的所有出现。</li>
</ul>
</li>
<li><strong>删除和修改算法</strong>：
<ul>
<li><code>std::remove</code>：在容器中移除指定值的所有元素，不改变容器大小，返回一个新的结束迭代器。</li>
<li><code>std::remove_if</code>：根据谓词条件移除满足条件的元素。</li>
<li><code>std::unique</code>：移除容器中相邻的重复元素，仅保留一个。</li>
</ul>
</li>
<li><strong>数值算法</strong>：
<ul>
<li><code>std::accumulate</code>：对范围内的元素进行累积操作，可以用于计算总和、平均值等。</li>
<li><code>std::inner_product</code>：计算两个范围的内积。</li>
<li><code>std::iota</code>：用给定的值填充一个范围。</li>
</ul>
</li>
<li><strong>其他算法</strong>：
<ul>
<li><code>std::min</code>、<code>std::max</code>：找到范围内的最小值和最大值。</li>
<li><code>std::reverse</code>：将容器中的元素进行反转。</li>
<li><code>std::rotate</code>：将容器中的元素进行旋转。</li>
</ul>
</li>
</ol>
<p>C++标准库中还有很多其他有用的算法。使用STL算法，可以编写更简洁、可读性更好的代码，并且由于这些算法经过优化，通常具有较好的性能</p>
<h2 id="STL总结">STL总结</h2>
<p>STL（Standard Template Library）是C++标准库的一部分，提供了一套通用的模板类和函数，用于处理常见的数据结构和算法。STL的设计目标是提供高效、灵活、可复用的代码，以便开发者能够更加专注于解决问题而不必重复实现基础数据结构和算法。<strong>STL主要包括以下三个组件</strong>：</p>
<ol>
<li>容器：序列容器、关联容器等等</li>
<li>算法：提供了一系列通用的算法，如排序、查找、变换、合并等。这些算法可以用于不同类型的容器，通过迭代器进行操作，实现了数据结构和算法的分离，增强了代码的可复用性和通用性。算法通过函数对象或函数指针支持用户自定义的操作和比较规则。</li>
<li>迭代器：迭代器是STL中用于遍历容器元素的通用接口，为算法和容器提供了统一的访问机制。不同类型的容器支持不同类型的迭代器，包括输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器，提供了不同程度的功能和效率。</li>
</ol>
<h2 id="其他库">其他库</h2>
<h3 id="vector、valarray、array">vector、valarray、array</h3>
<p>C++标准库提供了多个数组模板（<code>std::vector</code>、<code>std::valarray</code>、<code>std::array</code>），每个模板都有其特定的用途和优势。这样设计的目的是为了满足不同的编程需求，提供更丰富、更灵活的选择。以下是这三个数组模板的主要区别和适用场景：</p>
<ol>
<li><strong><code>std::vector</code></strong>：</li>
</ol>
<ul>
<li><strong>动态大小</strong>：<code>std::vector</code>是一个动态数组，其大小可以在运行时动态调整。这使得它非常适用于需要动态增减大小的场景，例如在运行时读取不确定数量的数据。</li>
<li><strong>内存管理</strong>：<code>std::vector</code>会自动处理内存的分配和释放，使得在动态数组的使用上更加方便。</li>
</ul>
<ol start="2">
<li><strong><code>std::valarray</code></strong>：</li>
</ol>
<ul>
<li><strong>数值运算</strong>：<code>std::valarray</code>设计用于面向数值计算，提供了一些成员函数和操作符用于逐元素进行数学运算。它的目标是提高数值计算的效率。</li>
<li><strong>元素级别的操作</strong>：<code>std::valarray</code>更适用于执行逐元素的数学运算，如数组的逐元素加法、乘法等。</li>
</ul>
<ol start="3">
<li><strong><code>std::array</code></strong>：</li>
</ol>
<ul>
<li><strong>固定大小</strong>：<code>std::array</code>是一个静态数组，其大小在编译时就确定了，不能动态改变。这使得它适用于固定大小的场景，例如需要在编译时确定数组大小的情况。</li>
<li><strong>栈上分配</strong>：<code>std::array</code>通常在栈上分配内存，因此相较于动态数组，它的内存访问更加高效。</li>
</ul>
<h3 id="模板initializer-list">模板initializer_list</h3>
<p>在C++中，<code>initializer_list</code> 是一个标准库中的类模板，用于方便地<strong>初始化容器或其他类的对象</strong>。它允许在对象的构造函数中传递一个初始化列表，类似于数组的初始化方式。<code>initializer_list</code> 的定义位于头文件 <code>&lt;initializer_list&gt;</code> 中。</p>
<ul>
<li><strong>用于容器的构造函数</strong>：使得容器类如 <code>std::vector</code>、<code>std::initializer_list</code> 等能够通过初始化列表进行构造。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vector类构造函数中参数使用了initializer_list</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>容器和类的构造函数重载</strong>：类可以同时提供接受 <code>initializer_list</code> 和其他参数的构造函数，以便支持不同的初始化方式。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">double</span> b) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(std::initializer_list&lt;<span class="type">int</span>&gt; values) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;<span class="comment">//使传递一个初始化列表</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>输入、输出和文件</h1>
<h2 id="流和缓冲区">流和缓冲区</h2>
<p>在C++中，流（stream）和缓冲区（buffer）是与输入和输出相关的概念，用于处理数据的流动和存储。流提供了一个抽象层，使得输入和输出可以以统一的方式进行处理，而缓冲区则用于临时存储数据，以提高性能和效率。</p>
<h3 id="流（Stream）">流（Stream）</h3>
<p>流是一个抽象的概念，表示数据在程序和外部设备（如文件、屏幕、键盘等）之间的传输。在C++中，标准库提供了一些流类（如iostream、fstream、stringstream等），用于实现输入和输出的操作。流可以分为输入流和输出流，分别用于读取和写入数据。</p>
<p>常见的流类包括：</p>
<ol>
<li>
<p><strong><code>iostream</code>：</strong> 提供了<code>cin</code>（标准输入流）和<code>cout</code>（标准输出流），用于从键盘读取输入和向屏幕输出数据。</p>
</li>
<li>
<p><strong><code>fstream</code>：</strong> 用于文件输入和输出，包括<code>ifstream</code>（文件输入流）和<code>ofstream</code>（文件输出流）。</p>
</li>
<li>
<p><strong><code>stringstream</code>：</strong> 用于在内存中操作字符串，可以将字符串作为输入或输出流处理。</p>
</li>
</ol>
<h3 id="缓冲区（Buffer）">缓冲区（Buffer）</h3>
<p>缓冲区是用于暂时存储数据的区域，它可以提高输入输出的效率。标准库中的流都具有与之关联的缓冲区，用于暂时存储数据，然后一次性地进行读取或写入，而不是每次都直接与外部设备进行通信。</p>
<p>流的缓冲区可以分为两种：</p>
<ol>
<li><strong>输入缓冲区：</strong> 存储从外部设备（如键盘或文件）读取的数据，以便程序可以逐一处理。</li>
<li><strong>输出缓冲区：</strong> 存储要写入外部设备的数据，以提高写入效率。</li>
</ol>
<p>在一些情况下，你可能需要手动刷新缓冲区，以确保数据被及时处理。使用<code>flush()</code>函数可以强制将输出缓冲区的内容写入外部设备。</p>
<h2 id="iostream文件">iostream文件</h2>
<p><code>iostream</code>是C++标准库中的头文件之一，它包含了对输入和输出流的支持。具体而言，<code>iostream</code>是由两个基本的头文件合并而成，分别是：</p>
<ul>
<li><strong><code>istream</code>（Input Stream）：</strong> 用于输入流，提供了从输入设备（如键盘）读取数据的功能。主要的类包括<code>istream</code>和<code>ifstream</code>。</li>
<li><strong><code>ostream</code>（Output Stream）：</strong> 用于输出流，提供了向输出设备（如屏幕或文件）写入数据的功能。主要的类包括<code>ostream</code>和<code>ofstream</code>。</li>
</ul>
<p>通过合并这两个头文件，得到了<code>iostream</code>，其中包括了<code>cin</code>、<code>cout</code>、<code>cerr</code>、<code>clog</code>等标准流对象，以及相关的功能和操作符重载，使得输入输出操作变得简便和灵活。</p>
<p>C++的iostream库管理了很多细节。例如在程序中包换iostream文件将自动创建8个流对象(4个用于窄字符流，4个用于宽字符流)</p>
<p>常见的8个流对象及其用途包括：</p>
<ul>
<li><strong><code>cin</code>：</strong> 标准输入流，用于从用户输入中读取数据，wcin对象于此类似但处理的是wchar_t(宽字符类型)类型。</li>
<li><strong><code>cout</code>：</strong> 标准输出流，用于将数据输出到控制台。wcout对象于此类似但处理的是wchar_t(宽字符类型)类型。</li>
<li><strong><code>cerr</code>：</strong> 标准错误流，没有被缓冲，用于输出错误信息到控制台。wcerr对象于此类似但处理的是wchar_t(宽字符类型)类型。</li>
<li><strong><code>clog</code>：</strong> 标准日志流，用于输出程序运行时的一般信息。wclog对象于此类似但处理的是wchar_t(宽字符类型)类型。</li>
</ul>
<h3 id="cerr和clog">cerr和clog</h3>
<p>在C++中，<code>cerr</code>和<code>clog</code>都是标准错误流，用于输出错误信息到控制台。它们是<code>ostream</code>类的实例，提供了与<code>cout</code>相似的输出功能，但通常用于不同的目的。</p>
<ol>
<li>
<p><strong><code>cerr</code>（标准错误流）：</strong></p>
<ul>
<li><code>cerr</code>是一个标准错误流对象，用于输出程序的错误信息。</li>
<li>与<code>cout</code>不同，<code>cerr</code>的<strong>输出默认不被缓冲</strong>，意味着错误消息会立即显示在控制台上，而<strong>不受缓冲机制的影响</strong>。</li>
<li>通常用于输出紧急的错误信息，以便及时发现问题。</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;This is an error message.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong><code>clog</code>（标准日志流）：</strong></p>
<ul>
<li><code>clog</code>也是一个标准错误流对象，用于输出程序运行时的一般信息，类似于日志。</li>
<li>与<code>cerr</code>不同，<code>clog</code>的输出默认是被缓冲的，可以通过<code>std::flush</code>强制刷新输出，或者等到缓冲区满时才刷新。</li>
<li><strong>通常用于输出程序的运行时信息，方便调试和了解程序执行的进展</strong>。</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::clog &lt;&lt; <span class="string">&quot;This is a log message.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>总体而言，<code>cerr</code>和<code>clog</code>都是用于输出程序的诊断信息的标准错误流，它们与<code>cout</code>一起构成了C++中的标准流。选择使用哪一个取决于你的需求，如果你需要及时看到错误信息，可以使用<code>cerr</code>，如果你希望输出日志信息，并允许一定程度的缓冲，可以使用<code>clog</code>。</p>
<h2 id="使用cout进行输出">使用cout进行输出</h2>
<h3 id="重载的-运算符">重载的&lt;&lt;运算符</h3>
<p>在C++中，&lt;&lt;运算符的默认含义是按位左移运算符，但ostream类重新定义了&lt;&lt;运算符，将其重载为输出。在这种情况下&lt;&lt;能识别C++中的所有的基本类型(int、double、string…)</p>
<p>对于上述每种类型，ostream类提供了operator&lt;&lt;()函数的定义。</p>
<p>&lt;&lt;运算符的所有化身返回类型都是ostream&amp;，格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(type);</span><br></pre></td></tr></table></figure>
<p>意味着该运算符将返回一个指向ostream对象的引用，该引用指向用于调用该运算符的对象。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">// &lt;&lt;运算符返回的是cout对象</span></span><br></pre></td></tr></table></figure>
<p>这种特性使得cout能串联输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;oh&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="其他osteam方法">其他osteam方法</h3>
<p>ostream还提供了put()方法和write()方法</p>
<p>put：用于显示字符</p>
<p>write：用于显示字符串</p>
<ul>
<li>put原型：将一个字符插入到输出流中。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">put</span><span class="params">(<span class="type">char</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;W&#x27;</span>);</span><br><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;I&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;t&#x27;</span>);<span class="comment">//可进行拼接输出</span></span><br><span class="line">cout.<span class="built_in">put</span>(<span class="number">65</span>) <span class="comment">//输出A</span></span><br><span class="line">cout.<span class="built_in">put</span>(<span class="number">66.3</span>) <span class="comment">//自动将double值66.3转换为char值66，输出B</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>write模板原型： 将指定数量的字符从指定位置的字符串插入到输出流中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">basic_ostream&lt;<span class="type">char</span>, Traits&gt;&amp; <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, streamsize n)</span></span>;</span><br><span class="line"></span><br><span class="line">-第一个参数为指定字符串</span><br><span class="line">-第二个参数为指定长度</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello, C++!&quot;</span>;</span><br><span class="line">    cout.<span class="built_in">write</span>(message, <span class="number">6</span>); <span class="comment">// 将 &quot;Hello&quot; 写入输出流</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="刷新输出缓冲区">刷新输出缓冲区</h3>
<ul>
<li>
<p>在C++中，刷新输出缓冲区是指将缓冲区中的数据强制写入输出设备。默认情况下，输出流（如<code>cout</code>、<code>cerr</code>等）会将数据存储在内部缓冲区中，而不是每次写入一个字符就立即刷新到输出设备。刷新输出缓冲区的操作可以通过 <code>flush</code> 方法或 <code>flush</code> 操纵符来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一种*/</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is some text.&quot;</span> &lt;&lt; flush; <span class="comment">// 刷新输出缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第二种*/</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is some text.&quot;</span> &lt;&lt; endl;   <span class="comment">// endl 操纵符会输出一个换行符并刷新输出缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三种*/</span></span><br><span class="line"><span class="built_in">flush</span>(cout);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="用cout进行格式化">用cout进行格式化</h3>
<ol>
<li><strong>控制输出的进制</strong>：在下一次将格式状态修改为其他进制时才会输出其他进制，否则一直按照设置进制之后进行输出</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 十六进制输出</span></span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; <span class="string">&quot;Hexadecimal: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*或者使用hex(cout)、oct(cout)*/</span></span><br><span class="line">    <span class="comment">// 八进制输出</span></span><br><span class="line">    cout &lt;&lt; oct &lt;&lt; <span class="string">&quot;Octal: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hex,oct都是控制符</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>调整字段宽度和对齐方式</strong>：width()方法只影响接下来显示的一个项目，然后字段宽度将恢复为默认值</li>
</ol>
<p>使用width()进行设置字段宽度，left左对齐，right右对齐</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> num2 = <span class="number">45.6789</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制输出宽度和对齐方式</span></span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; left &lt;&lt; num1;</span><br><span class="line">    </span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; right &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>填充字符</strong>：</li>
</ol>
<p>在默认情况下，cout用空格填充字段中未被使用的部分，可以使用fill()成员函数来改变填充字符。<strong>在下次修改之前将一直使用之前修改的字符填充</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> num2 = <span class="number">45.6789</span>;</span><br><span class="line">    cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">// 控制输出宽度和对齐方式</span></span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);<span class="comment">//宽度为10，前7位用*填充</span></span><br><span class="line">    cout &lt;&lt; right &lt;&lt; num1;</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; right &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>设置浮点数的显示精度</strong>：</li>
</ol>
<p>浮点数精度的含义取决于输出模式。在<strong>默认情况</strong>下，指的是显示的总位数，在<strong>定点模式和科学模式</strong>下，精度指的是小数点后面的位数。c++默认精度位6位(末尾的0不显示)。precision()成员函数使得能选择其他值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cout精度设置为2</span></span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><strong>打印末尾的0和小数点</strong>：</li>
</ol>
<p>对于有些输出(比如价格栏中的数字)，保留末尾的0将更为美观。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.setf(ios_base::showpoint);</span><br></pre></td></tr></table></figure>
<p><strong>上面的dec、hex、oct、left、right等都是标准控制符能够调用setf()，并且自动提供正确的参数，工作方式都相似。</strong></p>
<h3 id="头文件iomanip">头文件iomanip</h3>
<p>使用iostream工具来设置一些格式值有时不太方便。为简化工作，C++在头文件iomanip中提供了一些控制符，作用类似，表示更方便。常用的有三个：setprecision()、setfill()和setw()，表示设置精度、填充字符、字段宽度。</p>
<p>setprecision()：接受一个指定精度的整数参数</p>
<p>setfill()：接受一个指定字段宽度的整数参数</p>
<p>setw()：接受一个指定填充字符的char参数</p>
<p>因为他们都是控制符，故可以使用cout将语句连接起来。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> root = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">10</span>;n&lt;=<span class="number">100</span>; n+=<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;.&#x27;</span>) &lt;&lt; n &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; root &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用cin进行输入">使用cin进行输入</h2>
<h3 id="cin如何检查输入">cin如何检查输入</h3>
<p>不同版本的抽取运算符查看输入流的方法是相同的。<strong>他们跳过空白（空格、换行符、制表符），直到遇到非空白字符</strong>。即使对于单字符模式（char、unsigned char）也是如此。在其他模式下，&gt;&gt;运算符将读取一个指定类型的数据。<strong>将从非空白字符开始，到与目标类型不匹配的第一个字符的全部内容</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"><span class="comment">//假设输入12348z</span></span><br><span class="line">cout &lt;&lt; num;<span class="comment">//输出12348，剩下的留在输入缓冲区</span></span><br></pre></td></tr></table></figure>
<h3 id="流状态">流状态</h3>
<p>在C++中，<code>cin</code> 对象的流状态会受到输入的影响。<code>cin</code> 是C++标准库中的标准输入流对象，用于从标准输入设备（通常是键盘）获取用户输入。流状态的不同值反映了输入的有效性和状态。以下是一些关于 <code>cin</code> 流状态的详细介绍：</p>
<ol>
<li><strong>流状态位</strong>：</li>
</ol>
<p><code>cin</code> 有一系列的流状态位，主要的有：</p>
<ul>
<li><strong><code>failbit</code>：</strong> 当输入的数据类型不匹配或输入格式错误时，<code>failbit</code> 会被设置。例如，用户输入了非整数字符而 <code>cin</code> 期望输入整数。</li>
<li><strong><code>badbit</code>：</strong> 当输入流发生严重错误时，如IO错误或设备故障，<code>badbit</code> 会被设置。</li>
<li><strong><code>eofbit</code>：</strong> 当遇到文件末尾时，<code>eofbit</code> 会被设置。</li>
<li><strong><code>goodbit</code>：</strong> 表示没有错误发生。</li>
</ul>
<ol start="2">
<li><strong>流状态查询</strong>：</li>
</ol>
<p>可以通过 <code>cin</code> 对象的成员函数 <code>fail()</code>、<code>bad()</code>、<code>eof()</code> 和 <code>good()</code> 来查询流的状态。</p>
<ul>
<li><strong><code>fail()</code>：</strong> 返回 <code>true</code> 表示 <code>failbit</code> 或 <code>badbit</code> 被设置。</li>
<li><strong><code>bad()</code>：</strong> 返回 <code>true</code> 表示 <code>badbit</code> 被设置。</li>
<li><strong><code>eof()</code>：</strong> 返回 <code>true</code> 表示 <code>eofbit</code> 被设置。</li>
<li><strong><code>good()</code>：</strong> 返回 <code>true</code> 表示没有任何错误位被设置，即 <code>goodbit</code> 被设置。</li>
</ul>
<ol start="3">
<li><strong>流状态的影响</strong>：</li>
</ol>
<p>在使用 <code>cin</code> 进行输入时，输入的有效性和格式与流状态密切相关。如果输入不符合预期，流状态位将被设置，进而影响程序的行为。例如：</p>
<h3 id="使用cin错误处理">使用cin错误处理</h3>
<p>在使用 <code>cin</code> 进行输入时，最好进行错误处理，以确保用户输入的数据是有效的。例如，如果用户输入了非整数的字符，<code>cin</code> 将进入错误状态。可以通过检查 <code>cin.fail()</code> 来检测错误，并通过 <code>cin.clear()</code> 来清除错误状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter an integer: &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!(cin &gt;&gt; num)) &#123;</span><br><span class="line">        <span class="comment">/*输入有效返回true，无效返回false*/</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid input. Please enter an integer: &quot;</span>;</span><br><span class="line">        cin.<span class="built_in">clear</span>(); <span class="comment">// 清除错误状态</span></span><br><span class="line">      cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 忽略缓冲区中的无效字符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- cin.clear() 的作用是清除 cin 对象的错误状态，以便能够继续尝试接收输入。如果不清除错误状态，cin 会一直保持在错误状态，导致后续的输入操作无法正常进行。</span><br><span class="line"></span><br><span class="line">- cin.ignore(numeric_limits&lt;streamsize&gt;<span class="punctuation">:</span><span class="punctuation">:</span>max()<span class="punctuation">,</span> &#x27;\n&#x27;) 的作用是清除输入缓冲区中的无效字符，直到遇到换行符为止。这通常用于处理用户输入错误时，清除缓冲区中的残留字符，以便下一次输入操作不受之前错误的影响。</span><br><span class="line"></span><br><span class="line">- cin.fail() 是 cin 流的一个成员函数，用于检查最近一次的输入操作是否成功。它返回一个布尔值，如果最近的输入操作失败，则返回 <span class="literal"><span class="keyword">true</span></span>，否则返回 <span class="literal"><span class="keyword">false</span></span>。</span><br></pre></td></tr></table></figure>
<h3 id="其他istream类方法">其他istream类方法</h3>
<ol>
<li><strong>单字符输入</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(<span class="type">char</span>&amp; )</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在使用char参数或没有参数的情况下，get()方法读取下一个字符，即使该字符是空格、制表符或换行符。get(char&amp; ch)版本将输入字符赋给其参数，而get(void)版本将输入字符转换为整型并将其返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">cin.<span class="built_in">get</span>(c1);</span><br><span class="line"></span><br><span class="line">c1 = cin.<span class="built_in">get</span>();<span class="comment">//返回值为整型</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">cin.<span class="built_in">get</span>(c1).<span class="built_in">get</span>(c2) &gt;&gt; c3;</span><br><span class="line"><span class="comment">//可以进行拼接get，代表先赋值给c1返回调用对象cin，再赋值给c2，返回cin，最后把下一个非空白字符赋值给c3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ct=<span class="number">0</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cin.<span class="built_in">get</span>(ch);<span class="comment">//如果这里替换位&gt;&gt;下面将不会退出循环</span></span><br><span class="line"><span class="keyword">while</span>(ch!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; ch;</span><br><span class="line">    ct++;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设输入 I C++ clearly.&lt;Enter&gt;</span></span><br><span class="line"><span class="comment">//最终输出会跳过空格，输出IC++clearly.</span></span><br></pre></td></tr></table></figure>
<p>2.<strong>字符串输入</strong>：get()、getline()和ignore()</p>
<ul>
<li><strong>cin.get()</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">get</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>,<span class="type">char</span>)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">get</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">- <span class="type">char</span>*:放置输入字符串的内存单元的地址</span><br><span class="line">- <span class="type">int</span>:比读取的最大字符大<span class="number">1</span>，额外的一个字符用于存储结果为空字符</span><br><span class="line">- <span class="type">char</span>:指定用作分界符的字符，只有两个参数时将使用换行符用作分界符</span><br><span class="line">    </span><br><span class="line">cin.<span class="built_in">get</span>(array,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>无参数时，读入一个字符，包括换行符，常用来处理输入缓冲区中的换行符。</p>
<p>有参数时，从缓冲区读取数据，到达行尾或size-1个字符**(剩下的空间储存在结尾添加的空字符)<strong>后结束读取(超过规定字符数不会出现错误,会直接截断)，不会对换行符进行处理，将</strong>其留在输入流**。</p>
<ul>
<li><strong>cin.getline()</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>,<span class="type">char</span>)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">- <span class="type">char</span>*:放置输入字符串的内存单元的地址</span><br><span class="line">- <span class="type">int</span>:比读取的最大字符大<span class="number">1</span>，额外的一个字符用于存储结果为空字符</span><br><span class="line">- <span class="type">char</span>:指定用作分界符的字符，只有两个参数时将使用换行符用作分界符</span><br><span class="line">    </span><br><span class="line">cin.<span class="built_in">getline</span>(array,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>从缓冲区读取数据,到达行尾或size-1**(剩下的空间储存在结尾添加的空字符)**个字符结束读取(超过规定的字符数会出现错误,中断)，会读取并丢弃输入流中的换行符。</p>
<ul>
<li><strong>ignore()</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">ignore</span><span class="params">(<span class="type">int</span> =<span class="number">1</span>,<span class="type">int</span>= EOF)</span></span>;</span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">255</span>,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">255</span>,<span class="string">&#x27;\n&#x27;</span>).<span class="built_in">ignore</span>(<span class="number">255</span>,<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//可拼接</span></span><br></pre></td></tr></table></figure>
<p>原型为两个参数提供的默认值为1和EOF，EOF导致读取指定数目的字符或读取到文件结尾</p>
<p><code>cin.ignore</code> 是 C++ 中用于忽略输入流中一定数量字符或特定字符的函数。这个函数通常用于清除输入缓冲区中的不需要的字符，以便在后续的输入操作中不受其影响。</p>
<h2 id="文件输入输出">文件输入输出</h2>
<h3 id="文件输入输出-2">文件输入输出</h3>
<p><strong>iostream: 头文件中定义了一个处理输出的ostream类</strong></p>
<p><strong>fstream：头文件定义了一个用于处理输出的ofstream类</strong></p>
<p><strong>文件的输出主要步骤如下</strong>:</p>
<ol>
<li>
<p>包含头文件fstream，iostream</p>
</li>
<li>
<p>创建一个ofstream（output fstream）对象（<strong>通常取名为outFile</strong>）</p>
</li>
<li>
<p>将该ofstream 对象同一个文件关联起来(使用open方法)。</p>
</li>
<li>
<p>向cout那样使用ofstream对象（通常outFile）</p>
<p><strong>重点</strong>：cout在屏幕上输出，而outFile是在文件中输出（写入）</p>
</li>
<li>
<p>outFile.close()关闭文件流</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span><span class="comment">//步骤1</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">	ofstream outFile;<span class="comment">//步骤2</span></span><br><span class="line">	outFile.<span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>,std::ios::out);<span class="comment">//步骤3以写入的方式打开文件</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!outFile.<span class="built_in">is_open</span>()) </span><br><span class="line">	&#123;<span class="comment">//判断文件是否打开成功，打开成功返回true</span></span><br><span class="line">     	cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">     	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>()</span><br><span class="line">	&#123;</span><br><span class="line">    	outFile &lt;&lt; data &lt;&lt; endl;<span class="comment">//步骤4，输入文件中</span></span><br><span class="line">	&#125;</span><br><span class="line">      </span><br><span class="line">    outFile.<span class="built_in">close</span>();<span class="comment">//步骤5，关闭文件流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>文件的输入包括以下步骤</strong>：</p>
<ol>
<li>
<p>包含头文件iostream，包含头文件fstream</p>
</li>
<li>
<p>声明一个或多个<strong>ifstream</strong>（<strong>input fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为inFile</strong></p>
</li>
<li>
<p>将ifstream对象与文件关联起来。为此，方法之一是使用open()方法</p>
</li>
<li>
<p>可结合ifstream对象 和运算符&gt;&gt;来输入各种类型的数据。</p>
</li>
<li>
<p>使用inFile.close()关闭文件流</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">255</span>];</span><br><span class="line">    ifstream inFile;<span class="comment">//步骤2</span></span><br><span class="line">    inFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,std::ios::in);<span class="comment">//步骤3</span></span><br><span class="line">    <span class="keyword">if</span> (!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!inFile.<span class="built_in">eof</span>())<span class="comment">//判断是否读取到文件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        inFile &gt;&gt; data;<span class="comment">//步骤4</span></span><br><span class="line">        inFile.<span class="built_in">getline</span>(str,<span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">close</span>();<span class="comment">//步骤5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="检查文件-2">检查文件</h3>
<p>格式为: 对象名.isopen()  例：   <strong>inFile.is_open()</strong></p>
<p>如果文件成功被打开，返回<strong>true</strong>；如果文件没有被打开，<strong>因此表达式   !inFile.is_open()  将为true</strong></p>
<p><strong>通常使用下方代码判断是否打开成功</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">   	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//exit(0)程序正常结束</span></span><br><span class="line"><span class="comment">//exit(1)程序异常结束</span></span><br><span class="line"><span class="comment">//exit()使用需要用到头文件cstdlib</span></span><br></pre></td></tr></table></figure>
<h3 id="判断文件结尾">判断文件结尾</h3>
<p>格式为：对象名.eof()  例:   <strong>inFile.eof()</strong></p>
<p><strong>eof在遇到EOF（文件结束标志）时返回ture ，否则返回false</strong></p>
<p>通常和while循环一起用作文件读取结束，<strong>!inFile.eof</strong>在文件结束前为真，结束为假（退出循环）</p>
<p>具体格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!inFile.<span class="built_in">eof</span>())<span class="comment">//判断是否读取到文件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        inFile &gt;&gt; data;<span class="comment">//步骤4</span></span><br><span class="line">        inFile.<span class="built_in">getline</span>(str,<span class="number">255</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件打开关闭">文件打开关闭</h3>
<ul>
<li><strong>文件打开</strong>：</li>
</ul>
<p>**1.对象名.open(“文件名”) **（一个参数）例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果文件不存在，将会自动创建一个相同名字的文件,如果文件存在，将会打开该文件，首先截断该文件，将其长度截短到0，丢弃原有的内容，然后将新的输入加入到该文件中</p>
<p><strong>2.对象名.open(“文件名”，打开方式)</strong> （两个参数）例如 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,std::ios::in)</span><br></pre></td></tr></table></figure>
<p>只读模式以只读模式打开</p>
<ul>
<li><strong>文件关闭</strong>：</li>
</ul>
<p>格式：对象名.close()  例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>
<p>注意方法close()，不需要使用文件名作为参数，因为outFile已经同特定的文件关联起来，如果忘记关闭文件，程序正常终止的时候将自动关闭它。</p>
<h3 id="打开多个文件">打开多个文件</h3>
<p>打开多个文件时可以同时打开多个文件流：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">std::ifstream userInFile,managerInFile;</span><br><span class="line">    userInFile.<span class="built_in">open</span>(<span class="string">&quot;user_data.txt&quot;</span>, std::ios::in);</span><br><span class="line">    managerInFile.<span class="built_in">open</span>(<span class="string">&quot;manager_data.txt&quot;</span>, std::ios::in);</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">if</span>(!userInFile.<span class="built_in">is_open</span>()||!managerInFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(!userInFile.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">while</span>(!managerInFile.<span class="built_in">eof</span>())</span><br><span class="line"> 	&#123;</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line">    userInFile.<span class="built_in">close</span>();</span><br><span class="line">    managerInFile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="文件打开模式">文件打开模式</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/digitalkee/article/details/105799054?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=c++%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%A8%A1%E5%BC%8F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105799054.142%5Ev99%5Epc_search_result_base1&amp;spm=1018.2226.3001.4187">C++ open 打开文件（含打开模式一览表）_c++ open函数-CSDN博客</a></p>
<h1>c++新标准</h1>
<p><strong>更多内容见C++ primer plus 18章</strong></p>
<h2 id="统一的初始化">统一的初始化</h2>
<p>C++11扩大了大括号扩起的列表，即初始化列表的使用范围，使其可用于所有内置类型和用户定义的类对象。使用初始化列表时，可添加等号，也可不添加。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">double</span> y&#123;<span class="number">2.75</span>&#125;;</span><br><span class="line"><span class="type">short</span> quar[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">76</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>另外初始化列表可用于new表达式中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ar = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>] &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;<span class="comment">//c++11</span></span><br></pre></td></tr></table></figure>
<h2 id="右值引用">右值引用</h2>
<h3 id="左值和右值：">左值和右值：</h3>
<ul>
<li>
<p><strong>左值（lvalue）：</strong> <strong>左值是可以标识内存位置的表达式</strong>。通常，左值是具有名称的变量、对象或表达式的结果，它们可以出现在等号的左边，可以被取地址。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;  <span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span>* ptr = &amp;x;  <span class="comment">// &amp;x 是左值，因为它是地址</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>右值（rvalue）：</strong> <strong>右值是不能标识内存位置的表达式</strong>。右值通常是临时的、<strong>无法取地址的值</strong>，出现在等号的右边。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">10</span> + <span class="number">5</span>;  <span class="comment">// 10 + 5 是右值</span></span><br><span class="line"><span class="type">int</span> z = x + y;   <span class="comment">// x + y 是右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z = x;<span class="comment">//x不是右值，可以取地址</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="左值引用和右值引用：">左值引用和右值引用：</h3>
<ul>
<li>
<p><strong>左值引用（lvalue reference）：</strong> 左值引用是用于引用左值的引用类型。它使用 <code>&amp;</code> 符号声明。<strong>左值引用主要用于在函数中传递参数或作为函数的返回类型，以及在赋值操作中</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = x;  <span class="comment">// ref 是对 x 的左值引用</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>右值引用（rvalue reference）：</strong> <strong>右值引用是用于引用右值的引用类型</strong>。它使用 <code>&amp;&amp;</code> 符号声明。<strong>右值引用通常与移动语义一起使用，允许有效地将资源从一个对象移动到另一个对象，而不进行深层复制</strong>。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">10</span> + <span class="number">5</span>;  <span class="comment">// rref 是对右值的引用</span></span><br><span class="line"><span class="comment">//无法对rref取地址</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>右值引用通常与移动语义结合，例如在移动构造函数和移动赋值运算符中使用，提高了对动态分配资源的效率。左值引用用于传递可修改的参数，而右值引用用于支持移动操作。</strong></p>
<h2 id="Lambda函数">Lambda函数</h2>
<p>在C++中，lambda 表达式是一种方便的方式，允许你在函数内部定义匿名函数。它的语法形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// lambda body</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>capture</code> 是捕获列表，用于指定在 lambda 表达式中可以访问的外部变量。</li>
<li><code>parameters</code> 是 lambda 函数的参数列表。</li>
<li><code>return_type</code> 是返回类型。</li>
<li><code>lambda body</code> 包含实际的函数体。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operateWithLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 表达式，接受两个参数，返回它们的和</span></span><br><span class="line">    <span class="keyword">auto</span> add1 = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式计算并输出结果</span></span><br><span class="line">    <span class="type">int</span> result1 = <span class="built_in">add1</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum1 is: &quot;</span> &lt;&lt; result1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 表达式也可以访问外部变量</span></span><br><span class="line">    <span class="keyword">auto</span> add2 = [x,y]() -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> result2 = <span class="built_in">add2</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum2 is: &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> addWithExternal = [x](<span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式计算并输出结果</span></span><br><span class="line">    <span class="type">int</span> resultWithExternal = <span class="built_in">addWithExternal</span>(y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum with external variable is: &quot;</span> &lt;&lt; resultWithExternal &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">operateWithLambda</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>C++学习笔记</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.thekqd.top/posts/ad4f1e09.html">https://www.thekqd.top/posts/ad4f1e09.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Thedi🍭</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-02-21</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-01-22</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>C++</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/cb085122.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/3.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">STM32(标准库)</div></div></a></div><div class="next-post pull-right"><a href="/posts/d29d5856.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/100.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++的关键字用法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/d29d5856.html" title="C++的关键字用法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/100.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-02-21</div><div class="title">C++的关键字用法</div></div></a></div><div><a href="/posts/f28c0c7b.html" title="学生管理程序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/28.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-07-18</div><div class="title">学生管理程序</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">C++学习笔记：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4std"><span class="toc-text">名称空间std</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%AC%A6endl"><span class="toc-text">控制符endl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cin%E5%92%8Ccout"><span class="toc-text">cin和cout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E6%AC%A1%E8%AF%BB%E5%8F%96%E4%B8%80%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2-string-%E8%BE%93%E5%85%A5"><span class="toc-text">每次读取一行字符串(string)输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5"><span class="toc-text">补:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">string类(头文件&quot;string&quot;)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-text">补：获取字符串长度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">数组的替代品</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BBvector"><span class="toc-text">模板类vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-vector%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%89"><span class="toc-text">1.3 vector对象的常用内置函数使用（举例说明）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#size"><span class="toc-text">size()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#empty"><span class="toc-text">empty()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swap-swap-%E4%BA%A4%E6%8D%A2"><span class="toc-text">swap()         swap(交换)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insert-insert-%E6%8F%92%E5%85%A5"><span class="toc-text">insert()      insert(插入)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">NULL和nullptr</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">对类的定义：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%8F%98%E9%87%8F%EF%BC%89%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">类对象（变量）的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%92%8Cdelete"><span class="toc-text">new和delete</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-New"><span class="toc-text">1.New</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Delete"><span class="toc-text">2.Delete</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">C++中文件的输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E5%88%B0%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-text">写入到文本文件中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">从文本文件中读取数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6"><span class="toc-text">检查文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%BB%93%E5%B0%BE"><span class="toc-text">文件读取结尾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD"><span class="toc-text">文件的打开和关闭</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">构造函数和析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">运算符重载的概念和原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E9%99%90%E5%88%B6"><span class="toc-text">运算符重载限制:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">继承的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%9Ais-a-%E5%85%B3%E7%B3%BB"><span class="toc-text">继承：is-a 关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">继承的格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">继承的总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-text">多态公有继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-text">虚方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">虚析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-text">静态联编和动态联编</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">初始化列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8"><span class="toc-text">什么时候必须使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-text">建议使用的地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-text">优点和缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8using-%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-text">使用using 重新定义访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">多重继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-2"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-text">二义性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">类模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8C%BA%E5%88%AB"><span class="toc-text">类模板与函数模板区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-text">类模板成员函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="toc-text">成员模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">类模板对象做函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%A8%A1%E6%9D%BF%E5%81%9A%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0"><span class="toc-text">将模板做模板类参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text">类模板与继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%92%8C%E5%8F%8B%E5%85%83"><span class="toc-text">模板类和友元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-text">类模板成员函数创建时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99-%E9%87%8D%E8%A6%81"><span class="toc-text">类模板分文件编写(重要)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%88%AB%E5%90%8D-C-11"><span class="toc-text">模板别名(C++11)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-text">友元类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">友元成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">友元的优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">嵌套类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-text">访问控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%A6%82%E5%BF%B5"><span class="toc-text">异常概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA%E5%92%8C%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-text">异常的抛出和匹配规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA"><span class="toc-text">异常的抛出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-text">匹配规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA"><span class="toc-text">异常的重新抛出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">异常安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%A7%84%E8%8C%83%E8%AF%B4%E6%98%8E"><span class="toc-text">异常规范说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-text">自定义异常体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-text">C++标准库的异常体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">异常优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RTTI"><span class="toc-text">RTTI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic-cast"><span class="toc-text">dynamic_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeid%E5%92%8Ctype-info"><span class="toc-text">typeid和type_info</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">智能指针模板类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#auto-ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-text">auto_ptr模板类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-text">shared_ptr模板类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-text">unique_ptr模板类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-ptr%E4%B8%BA%E4%BD%95%E4%BC%98%E4%BA%8Eauto-ptr"><span class="toc-text">unique_ptr为何优于auto_ptr</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">标准模板库STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BBvector-2"><span class="toc-text">模板类vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-text">基于范围的for循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-text">容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E6%80%BB%E7%BB%93"><span class="toc-text">STL总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BA%93"><span class="toc-text">其他库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E3%80%81valarray%E3%80%81array"><span class="toc-text">vector、valarray、array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BFinitializer-list"><span class="toc-text">模板initializer_list</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">输入、输出和文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">流和缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%EF%BC%88Stream%EF%BC%89"><span class="toc-text">流（Stream）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88Buffer%EF%BC%89"><span class="toc-text">缓冲区（Buffer）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iostream%E6%96%87%E4%BB%B6"><span class="toc-text">iostream文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cerr%E5%92%8Cclog"><span class="toc-text">cerr和clog</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8cout%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%87%BA"><span class="toc-text">使用cout进行输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">重载的&lt;&lt;运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96osteam%E6%96%B9%E6%B3%95"><span class="toc-text">其他osteam方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">刷新输出缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8cout%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">用cout进行格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6iomanip"><span class="toc-text">头文件iomanip</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8cin%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%85%A5"><span class="toc-text">使用cin进行输入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cin%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E8%BE%93%E5%85%A5"><span class="toc-text">cin如何检查输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%8A%B6%E6%80%81"><span class="toc-text">流状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8cin%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">使用cin错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96istream%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">其他istream类方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">文件输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-2"><span class="toc-text">文件输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6-2"><span class="toc-text">检查文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%BB%93%E5%B0%BE"><span class="toc-text">判断文件结尾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD"><span class="toc-text">文件打开关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-text">打开多个文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%A8%A1%E5%BC%8F"><span class="toc-text">文件打开模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">c++新标准</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">统一的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-text">右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%EF%BC%9A"><span class="toc-text">左值和右值：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-text">左值引用和右值引用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E5%87%BD%E6%95%B0"><span class="toc-text">Lambda函数</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/img/avatar.webp" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.thehsp.cn/" title="thehsp"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.postimg.cc/hG3dPJgH/fda91706f29ff4047883c4b7b84449e.jpg" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2025</b></span><span><b>&nbsp;&nbsp;By Thedi🍭</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/Linux/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 Linux (9)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/嵌入式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍼 嵌入式学习笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/C/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 C++学习笔记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/数据结构与算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 数据结构与算法 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/MySQL/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 数据库笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/演示/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 Markdown (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://www.thekqd.top/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #69e8f2}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/aa76cb12.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/99.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/aa76cb12.html&quot;);" href="javascript:void(0);" alt="">线程池C++版</a><div class="blog-slider__text">线程池C++版</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/aa76cb12.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f2e69609.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/3.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f2e69609.html&quot;);" href="javascript:void(0);" alt="">MySQL通用语法及操作</a><div class="blog-slider__text">MySQL的相关知识包括基础篇、进阶篇和运维篇,学习自黑马</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f2e69609.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/174bd570.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/33.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/174bd570.html&quot;);" href="javascript:void(0);" alt="">socket</a><div class="blog-slider__text">socket网络编程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/174bd570.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/15fc6e8c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/37.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/15fc6e8c.html&quot;);" href="javascript:void(0);" alt="">多线程</a><div class="blog-slider__text">线程相关知识（pthread）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/15fc6e8c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>