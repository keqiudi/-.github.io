<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++学习笔记 | walnut的仓库</title><meta name="keywords" content="C++"><meta name="author" content="walnut🍭"><meta name="copyright" content="walnut🍭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="学习C++时的一点笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记">
<meta property="og:url" content="https://www.thekqd.top/posts/ad4f1e09.html">
<meta property="og:site_name" content="walnut的仓库">
<meta property="og:description" content="学习C++时的一点笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.thekqd.top/assets/100.webp">
<meta property="article:published_time" content="2024-02-21T10:16:23.000Z">
<meta property="article:modified_time" content="2024-02-21T10:20:20.845Z">
<meta property="article:author" content="walnut🍭">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.thekqd.top/assets/100.webp"><link rel="shortcut icon" href="https://i.postimg.cc/4xP8HS1p/Computer.png"><link rel="canonical" href="https://www.thekqd.top/posts/ad4f1e09"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-21 18:20:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="walnut的仓库" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.postimg.cc/fbN6bFqP/20220206101541-14a48.jpg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">walnut的仓库</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">C++学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-02-21T10:16:23.000Z" title="发表于 2024-02-21 18:16:23">2024-02-21</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-21T10:20:20.845Z" title="更新于 2024-02-21 18:20:20">2024-02-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">2w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>73分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++学习笔记"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C-学习笔记："><a href="#C-学习笔记：" class="headerlink" title="C++学习笔记："></a>C++学习笔记：</h1><h2 id="名称空间std"><a href="#名称空间std" class="headerlink" title="名称空间std"></a>名称空间std</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221113132517924.png" alt="image-20221113132517924"></p>
<p><math.h>新式为<cmath></p>
<p><string.h>新式为<cstring></p>
<p>如果使用iostream，而不是iostream.h，即当头文件中没有扩展名h时，iostream中定义的用于输出的cout变量实际是<strong>std::cout</strong>,而endl实际上是<strong>std::endl</strong>.因此，可以省略编译指令using，用下述方式进行编码:</p>
<p>std::cout&lt;&lt;” xxxxxx”;</p>
<p>std::cout&lt;&lt;std::endl;</p>
<p>但如果使用using编译指令:<strong>using namespace std;</strong></p>
<p><strong>便可以直接使用cin和cout…，而不必加上std::前缀</strong></p>
<h2 id="控制符endl"><a href="#控制符endl" class="headerlink" title="控制符endl"></a>控制符endl</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221113133422849.png" alt="image-20221113133422849"></p>
<p><strong>C++中的旧版换行采用的是”\n</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221113133633328.png" alt="image-20221113133633328"></p>
<h2 id="cin和cout"><a href="#cin和cout" class="headerlink" title="cin和cout"></a>cin和cout</h2><p><strong>（1）.</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221113135231199.png" alt="image-20221113135231199"></p>
<p><strong>（2）.</strong></p>
<p><strong>输出可以拼接:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221113140118344.png" alt="image-20221113140118344">**</p>
<h2 id="每次读取一行字符串-string-输入"><a href="#每次读取一行字符串-string-输入" class="headerlink" title="每次读取一行字符串(string)输入"></a>每次读取一行字符串(string)输入</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221113193250853.png" alt="image-20221113193250853"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221113194203451.png" alt="image-20221113194203451"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221113194311275.png" alt="image-20221113194311275"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p><strong>1.cin(&gt;&gt;)</strong></p>
<p>虽然可以使用 cin 和 &gt;&gt; 来输入字符串，当 cin 读取数据时，<strong>一旦它接触到第一个非空格字符即开始阅读，当它读取到下一个空白字符时，它将停止读取。</strong></p>
<p>可以输入 “Mark” 或 “Twain”，但不能输入 “Mark (停止读取)  Twain”，<br><strong>因为 cin 不能输入包含嵌入空格的字符串。</strong></p>
<p><strong>2.cin.get(char ch)/(array_name,size)</strong></p>
<p>无参数时，读入一个字符，包括换行符，常用来处理输入缓冲区中的换行符。</p>
<p>有参数时，从缓冲区读取数据，到达行尾或size-1个字符<strong>(剩下的空间储存在结尾添加的空字符)</strong>后结束读取(超过规定字符数不会出现错误,会直接截断)，不会对换行符进行处理，将其留在缓冲区</p>
<p><strong>3.cin.getline(array_name,size)</strong>      </p>
<p>从缓冲区读取数据,到达行尾或size-1<strong>(剩下的空间储存在结尾添加的空字符)</strong>个字符结束读取(超过规定的字符数会出现错误,中断)，会读取换行符将其替换为空字符，并且丢弃。</p>
<p><strong>4.getline(cin,array_name） </strong>/  <strong>std::getline(std::cin,array_name)</strong></p>
<p>例如：getline(cin,str); </p>
<p>从缓冲区中读取数据，遇到换行符时将其替换为空字符，并且丢弃。</p>
<h2 id="补"><a href="#补" class="headerlink" title="补:"></a>补:</h2><p><strong>(1)cin.getline(char*s,streamsize n,char delim)</strong></p>
<p>所需的头文件为<iostream>(这里的参数char s是输入的字符串变量， n是输入字符串的字符个数（第n个补’\0’）， delim是输入终止条件，即遇到delim所代表的字符就终止输入,正常使用时 char delim可以省略，c++语言默认为’\0’)   例 :   cin.getline(name,20,’C’)或cin.getline(name,20)</p>
<p><strong>(2)getline(istream&amp; is, string&amp; str, char delim)</strong></p>
<p>所需的头文件为<string>(s是标准输入流函数， str是用来存字符的变量名， delim是结束标志,作用与cin.getline()里的相同）例: getline(cin,str,’A’)</p>
<p>==<strong>注:</strong> <strong>getline()是string流的函数，只能用于string类型(不能用于输入char*类型)的输入操作.</strong>==</p>
<p>==<strong>cin.getline()是std流的函数，只能用于char*类型的输入操作（不能用于string类型输入）</strong>。==       <strong>char*为数组</strong></p>
<p>  <strong>当你定义了一个string类型变量，只能用cin/getline()来输入。！！！！！！</strong></p>
<p>   <strong>当你定义了一个char*类型变量，只能用cin/cin.getline()输入。！！！！！</strong></p>
<p><strong>(3).</strong>在使用getline读入一整行时，<br>若是前面是使用getchar()、cin这类读入了一个字母，<br>但是不会读入后续换行\n符号或者空格的输入时，再接getline()就容易出现问题。</p>
<p>这是因为输入数字之后，敲回车，产生的换行符仍然滞留在输入流了，<br>接着就被getline(cin,s)给读进去了，<br>此时的s=“\n”,所以实际上s只是读入了一个换行符\n。</p>
<p>而若是前面使用getline()，再又用getline()进行读入，此时不会发生问题。<br><strong>getline()中读入结束的回车后，结束符不放入缓存区，会将读入的\n直接去除，</strong><br><strong>下一个输入前，缓冲区为空，并不会因为回车留下\n。</strong></p>
<p>而cin的结束后，以及getchar()此类的读入结束后,按下回车或者使用空格读入下一个，<br>此时按下的回车或空格会还在缓存区,继续用getline()就会出现前面所提到的情况。<br>那么如何解决前面用了cin、getchar()后的输入呢？<br><strong>可以直接在cin和getchar()后使用一个getchar()吃掉接下来的换行.</strong></p>
<h1 id="string类-头文件”string”"><a href="#string类-头文件”string”" class="headerlink" title="string类(头文件”string”)"></a>string类(头文件”string”)</h1><p><strong>1.</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221113202153066.png" alt="image-20221113202153066"></p>
<p><strong>2.</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221113202108337.png" alt="image-20221113202108337"></p>
<p><strong>3.数组和string类的不同点:</strong></p>
<p><strong>(1)</strong>在数组中，不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象。</p>
<p><strong>(2)</strong>可以使用+让两个string对象合并起来，还可以使用+=将字符串附加到string对象的末尾。</p>
<p>同时可以对字符串实现运算符（==，=），可以直接比较</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221113202543882.png" alt="image-20221113202543882"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221113202618980.png" alt=""></p>
<p><strong>4.用getline将输入读取到string对象</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221113202709793.png" alt="image-20221113202709793"></p>
<h2 id="补：获取字符串长度"><a href="#补：获取字符串长度" class="headerlink" title="补：获取字符串长度"></a>补：获取字符串长度</h2><p><strong>1.length()函数</strong><br>直接获取字符串长度，包括空格在内</p>
<p>表示方法:    <strong>str.length()</strong>即可表示str字符串的长度</p>
<p><strong>2.strlen()函数</strong><br>需要添加头文件<string.h>,而且<strong>参数只能是char数组</strong>（不能是string类）<br>而且结尾必须是\0(即字符数组不能满，因为满了结尾就不是\0，会接着向下检索到\0为止)<br>啊哦char c[6]{“kunkun”}; 这样是错误的嗷 直接没法进行编译，编译器直接帮我们解决问题2。</p>
<p>表示方法：  <strong>strlen(数组名)</strong></p>
<p><strong>3.size()</strong></p>
<p>需要添加<string.h>头文件，用法类似于length()。<br>size()表示的是string这个容器中的元素个数。（还可以获取vector类型的长度）<br>如果使用过std::vector之类的容器的话，可以把string看做是一个vector(这里只是举例，并不能等价)， char就是这个容器的元素类型。那么size()表示的就是这个vector(容器)中char的个数。<br>表示方法:</p>
<p><strong>str.size()</strong>即可表示str字符串的长度（不包含’\0’）</p>
<h1 id="数组的替代品"><a href="#数组的替代品" class="headerlink" title="数组的替代品"></a>数组的替代品</h1><p><strong>具体见CSDN</strong></p>
<h2 id="模板类vector"><a href="#模板类vector" class="headerlink" title="模板类vector"></a>模板类vector</h2><ul>
<li><p>vector是向量类型，可以容纳许多类型的数据，因此也被称为容器</p>
</li>
<li><p>(可以理解为<strong>动态数组</strong>，是封装好了的类）</p>
</li>
<li><p>进行<code>vector</code>操作前应添加头文件<code>#include &lt;vector&gt;</code></p>
</li>
<li><p>.2 vector初始化：<br>方式1.</p>
<p>定义具有10个整型元素的向量（尖括号为元素类型名，它可以是任何合法的数据类型），不具有初值，其值不确定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>方式2.</p>
<p>定义具有10个整型元素的向量，且给出的每个元素初值为1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>方式3.</p>
<p>用向量b给向量a赋值，a的值完全等价于b的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b);</span><br></pre></td></tr></table></figure>
<p>方式4.</p>
<p>将向量b中从0-2（共三个）的元素赋值给a，a的类型为int型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b.<span class="built_in">begin</span>(),b.begin+<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>方式5.</p>
<p>//从数组中获得初值<br>int b[7]={1,2,3,4,5,6,7};</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>）;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-3-vector对象的常用内置函数使用（举例说明）"><a href="#1-3-vector对象的常用内置函数使用（举例说明）" class="headerlink" title="1.3 vector对象的常用内置函数使用（举例说明）"></a>1.3 vector对象的常用内置函数使用（举例说明）</h4>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a,b;</span><br><span class="line"><span class="comment">//b为向量，将b的0-2个元素赋值给向量a</span></span><br><span class="line">a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//a含有4个值为2的元素</span></span><br><span class="line">a.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//返回a的最后一个元素</span></span><br><span class="line">a.<span class="built_in">back</span>();</span><br><span class="line"><span class="comment">//返回a的第一个元素</span></span><br><span class="line">a.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//返回a的第i元素,当且仅当a存在</span></span><br><span class="line">a[i];</span><br><span class="line"><span class="comment">//清空a中的元素</span></span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//判断a是否为空，空则返回true，非空则返回false</span></span><br><span class="line">a.<span class="built_in">empty</span>();</span><br><span class="line"><span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入数值5,</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入3个数，其值都为5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//b为数组，在a的第一个元素（从第0个元素算起）的位置插入b的第三个元素到第5个元素（不包括b+6）</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>);</span><br><span class="line"><span class="comment">//返回a中元素的个数</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">a.<span class="built_in">capacity</span>();</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值随机</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值为2</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//将a的容量扩充至100，</span></span><br><span class="line">a.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//b为向量，将a中的元素和b中的元素整体交换</span></span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">//b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt;</span></span><br><span class="line">a==b;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><p>C++中，在获取<strong>字符串长度</strong>时，size()函数与length()函数作用相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">length</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p><strong>size()函数以及length()函数</strong>都用于计算字符串（string）长度，不能用char*作为参数。除此之外，size()函数还可以获取vector类型的长度。</p>
<p>size()函数返回值为unsigned int 类型为正数</p>
<p>注意 让其作为返回值赋给变量时，变量类型要为<br>unsigned int 或 size_t型</p>
<p>补:<strong>size_t</strong></p>
<p><strong>size_t</strong> 是一些C/C++标准在stddef.h中定义的，size_t 类型表示C中任何对象所能达到的最大长度，它是无符号整数。</p>
<p>32位上的定义:  等价于 unsigned int</p>
<p>64位上的定义:  等价于 unsigned long</p>
<h2 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h2><p>C++中empty()作为判断容器是否为空的函数</p>
<p>用法为 <strong>对象名.empty()</strong>    例: <strong>s.empty()</strong></p>
<p><strong>如果对象为空就返回1(ture)，</strong></p>
<p><strong>不为空返回0(false)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;&quot;</span>；</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; “字符串为空”;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串不为空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="swap-swap-交换"><a href="#swap-swap-交换" class="headerlink" title="swap()         swap(交换)"></a>swap()         swap(交换)</h2><p><strong>具体见CSDN</strong></p>
<p>标准库的<strong>C ++中</strong>的<code>swap()</code>函数是一个在两个<strong>相同类型</strong>的给定变量之间直接交换值的函数。<strong>元素个数不相等也可以进行交换</strong></p>
<p>用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">swap</span>(a,b);</span><br></pre></td></tr></table></figure>
<h2 id="insert-insert-插入"><a href="#insert-insert-插入" class="headerlink" title="insert()      insert(插入)"></a>insert()      insert(插入)</h2><p><strong>对象.insert()</strong></p>
<p><strong>几种用法:</strong>         <strong>下标（索引）都是默认从第0个位置开始（第0个位置，第1个位置）</strong></p>
<p><strong>1、在第index位置插入count个字符c——&gt;str.insert(index,count,c);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;012356789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;<span class="number">012356789</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="number">1</span>,<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串----&gt;&quot;</span>  &lt;&lt; str &lt;&lt; endl;  <span class="number">0123456789</span></span><br></pre></td></tr></table></figure>
<p><strong>2、在第index位置插入一个常量字符串——&gt;str.insert(index,str);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;0156789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;  <span class="number">0156789</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">2</span>,<span class="string">&quot;234&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;   <span class="number">0123456789</span></span><br></pre></td></tr></table></figure>
<p><strong>3、第index位置插入常量字符串str中的count个字符——&gt;str.insert(index,str,count);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;456789&quot;</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl; <span class="number">0123456789</span></span><br></pre></td></tr></table></figure>
<p>4、<strong>第index位置插入常量str——&gt;str.insert(index,str);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;45&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl; <span class="number">0123456789</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>5、第index位置插入常量str的从index_str开始的count个字符——&gt;str.insert(index,str,index_str,count);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;2345678&quot;</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;   <span class="number">0123456789</span></span><br></pre></td></tr></table></figure>
<p><strong>6、index位置插入常量str从index_str开始以后的字符串——&gt;str.insert(index,str,index_str,string::npos);</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;012345&quot;</span>,<span class="number">4</span>,string::npos);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;  <span class="number">0123456789</span></span><br></pre></td></tr></table></figure>
<h1 id="NULL和nullptr"><a href="#NULL和nullptr" class="headerlink" title="NULL和nullptr"></a>NULL和nullptr</h1><p>c中用NULL表示空指针</p>
<p>但在c++中用nullptr表示空指针，把NULL当作0来使用</p>
<p><strong>具体的见CSDN</strong></p>
<h2 id="对类的定义："><a href="#对类的定义：" class="headerlink" title="对类的定义："></a>对类的定义：</h2><p><strong>首先用class+标记名对类进行定义</strong>：<strong>1.private部分，2.public部分</strong></p>
<p><strong>(1)private</strong>中的数据为隐藏数据（通常是变量），只能通过public中的成员函数对其进行访问，外部没有访问权力。</p>
<p><strong>(2)public</strong>中通常是成员函数，可以在成员函数中访问该类的private中的数据，<strong>通常只在里面声明函数原型,在其他地方定义</strong>（此处用的链表，链表的下一个结点）</p>
<p><strong>注：</strong>访问成员函数要作用域解析符 <strong>: :</strong>  ，格式为 : <strong>类标记名+ : : + 函数名</strong>   <strong>尤其是在定义时</strong> 例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Input</span><span class="params">()</span></span>&#123;<span class="comment">//定义一个全新的函数Input,不是成员函数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Classroom::Input</span><span class="params">()</span></span>&#123;<span class="comment">//对成员函数进行定义</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处用了友元类，具体见笔记</p>
<h2 id="类对象（变量）的创建"><a href="#类对象（变量）的创建" class="headerlink" title="类对象（变量）的创建"></a>类对象（变量）的创建</h2><p><strong>标记名 + 对象名</strong> 例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classroom</span>&#123;</span></span><br><span class="line">    private：</span><br><span class="line">        </span><br><span class="line">    public：</span><br><span class="line">        <span class="type">void</span> <span class="title function_">Input</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br><span class="line">Classroom a<span class="comment">//创建一个Classroom类的对象a</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Classroom::Input();<span class="comment">//错误写法</span></span><br><span class="line">    a.Input()<span class="comment">//正确写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重点！！   注意：在调用成员函数之前，必须创建对象,不能直接像定义成员函数那样调用成员函数.   如上方</strong></p>
<p><strong>调用成员函数的方式是通过 点关系符 ”  .  “</strong></p>
<p>！！！！ <strong>类访问==成员函数==时用”.”访问,并且如果没有参数访问的时候必须带上后面的括号，否则认为访问的是变量；</strong></p>
<p>格式为：   <strong>对象名 . 函数名()</strong></p>
<p>  <strong>例如:       a.Input();</strong></p>
<p><strong>下为类对象（变量）在学生管理程序中使用：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221120220212245.png" alt="image-20221120220212245"></p>
<h2 id="new分配内存空间，delete释放内存"><a href="#new分配内存空间，delete释放内存" class="headerlink" title="new分配内存空间，delete释放内存"></a>new分配内存空间，delete释放内存</h2><p><strong>该处以链表+类为例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221120200903909.png![image-20221120202508583](E:\！！！！Markdown\C++.assets\image-20221120202508583.png![image-20221120202614633](E:\！！！！Markdown\C++.assets\image-20221120202614633.png" alt="image-20221120200903909"></p>
<h3 id="1-New"><a href="#1-New" class="headerlink" title="1.New"></a>1.New</h3><p>（1）用malloc分配内存时需要头文件cstdlib,但是new 不需要引用新的头文件。</p>
<p> （2）new为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配的内存</p>
<p>通用格式如下：<strong>typename * pointer_name = new typeName</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);<span class="comment">//申请了一个初值为10的整型数据,括号中为初始化的值</span></span><br><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//申请了能存放10个整型数据元素的数组，其首地址为arr</span></span><br></pre></td></tr></table></figure>
<p>注意: </p>
<p><strong>int *p=new int 此时解引用p的值将会是一个随机值，未初始化。</strong></p>
<p><strong>int *p=new int() 此时括号里为空，解引用p的值将自动初始化为0</strong></p>
<p>此处文件中<strong>current</strong> 是一个指针 ，<strong>Student</strong>是类标记，<strong>new + 类型名 返回的值是一个地址</strong></p>
<p>（3）new 从被称为<strong>堆</strong>或<strong>自由储存区</strong>的内存区域分配内存，除了主动释放外不会被回收。而局部变量通常储存在<strong>栈</strong>的内存区域中</p>
<h3 id="2-Delete"><a href="#2-Delete" class="headerlink" title="2.Delete"></a>2.Delete</h3><p><strong>delete 用来释放new分配的内存</strong></p>
<p>通常    delete + 指针名    即可（注意:delete不一定使用用于new的指针，而是用于new的地址）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p；</span><br><span class="line"><span class="keyword">delete</span>[] arr;<span class="comment">//注意要删除数组时，需要加[]，以表示arr为数组。</span></span><br></pre></td></tr></table></figure>
<p><strong>使用new 和 delete 应该遵守以下规则：</strong></p>
<p>1.不要使用delete来释放不是new分配的内存。</p>
<p>2.不要使用delete来释放同一个内存块两次。</p>
<p>3.如果使用new [ ]为数组分配内存，则应该使用delete [ ]来释放</p>
<p>4.如果使用new为一个实体分配内存，则应该使用delete（没有方括号）来释放。</p>
<p>5.对空指针使用delete是安全的。</p>
<h2 id="C-中文件的输入输出"><a href="#C-中文件的输入输出" class="headerlink" title="C++中文件的输入输出"></a>C++中文件的输入输出</h2><h3 id="写入到文本文件中"><a href="#写入到文本文件中" class="headerlink" title="写入到文本文件中"></a>写入到文本文件中</h3><p>==要求==：</p>
<p><strong>1.包含头文件iostream，</strong></p>
<p><strong>包含头文件fstream</strong></p>
<p><strong>iostream: 头文件中定义了一个处理输出的ostream类</strong></p>
<p><strong>fstream：头文件定义了一个用于处理输出的ofstream类</strong></p>
<p><strong>2.</strong>声明一个或多个<strong>ofstream</strong>（<strong>output fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为outFile</strong></p>
<p><strong>3.</strong>必须指明名称空间std，为引用ofstream，必须使用编译指令using或者前缀的std：：</p>
<p><strong>4.</strong>将ofstream对象与文件关联起来。为此，方法之一是使用open()方法</p>
<p><strong>5.</strong>使用完文件后，应使用close()将其关闭</p>
<p><strong>6.</strong>可结合ofstream对象 和运算符&lt;&lt;来输出各种类型的数据。</p>
<p><strong>总结：</strong>文件的输出主要步骤如下:</p>
<p>1.包含头文件fstream</p>
<p>2.创建一个ofstream（output fstream）对象（<strong>通常取名为outFile</strong>）</p>
<p>3.将该ofstream 对象同一个文件关联起来。</p>
<p><strong>4.向cout那样使用ofstream对象（通常outFile）</strong>重点：<strong>cout在屏幕上输出，而outFile是在文件中输出（写入）</strong></p>
<p><strong>例子见下方</strong></p>
<h3 id="从文本文件中读取数据"><a href="#从文本文件中读取数据" class="headerlink" title="从文本文件中读取数据"></a>从文本文件中读取数据</h3><p>==要求==：</p>
<p><strong>1.包含头文件iostream，包含头文件fstream</strong></p>
<p><strong>iostream: 头文件中定义了一个处理输出的istream类</strong></p>
<p><strong>fstream：头文件定义了一个用于处理输入的ifstream类</strong></p>
<p><strong>2.</strong>声明一个或多个<strong>ifstream</strong>（<strong>input fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为inFile</strong></p>
<p><strong>3.</strong>必须指明名称空间std，为引用ifstream，必须使用编译指令using或者前缀的std：：</p>
<p><strong>4.</strong>将ifstream对象与文件关联起来。为此，方法之一是使用open()方法</p>
<p><strong>5.</strong>使用完文件后，应使用close()将其关闭</p>
<p><strong>6.</strong>可结合ifstream对象 和运算符&lt;&lt;来输出各种类型的数据。</p>
<h4 id="检查文件是否被成功打开的首先方法是使用is-open-无参数"><a href="#检查文件是否被成功打开的首先方法是使用is-open-无参数" class="headerlink" title="检查文件是否被成功打开的首先方法是使用is_open(无参数)"></a>检查文件是否被成功打开的首先方法是使用is_open(无参数)</h4><p>格式为: 对象名.isopen()  例:    <strong>inFile.is_open()</strong></p>
<p>如果文件成功被打开，返回<strong>true</strong>；如果文件没有被打开，<strong>因此表达式   !inFile.is_open()  将为true</strong></p>
<p>通常使用下方代码判断是否打开成功</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">   	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>exit(0)程序正常结束</strong></p>
<p><strong>exit(1)程序异常结束</strong></p>
<p><strong>exit()使用需要用到头文件==cstdlib==</strong>  </p>
<h4 id="文件读取结尾的判断使用-eof（无参数）-gt-end-of-file-EOF"><a href="#文件读取结尾的判断使用-eof（无参数）-gt-end-of-file-EOF" class="headerlink" title="文件读取结尾的判断使用 eof（无参数）-&gt;end of file =EOF"></a>文件读取结尾的判断使用 eof（无参数）-&gt;end of file =EOF</h4><p>格式为：对象名.eof()  例:   <strong>inFile.eof()</strong></p>
<p><strong>eof在遇到EOF（文件结束标志）时返回ture ，否则返回false</strong></p>
<p>通常和while循环一起用作文件读取结束，<strong>!inFile.eof</strong>在文件结束前为真，结束为假（退出循环）</p>
<p>具体格式为：   <strong>while(  !inFile.eof（）)</strong> </p>
<h4 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h4><p><strong>1.对象名.open(“文件名”) </strong>（一个参数）例：<strong>outFile.open(“student.txt”)</strong> 如果文件不存在，将会自动创建一个相同名字的文件,如果文件存在，将会打开该文件，首先截断该文件，将其长度截短到0，丢弃原有的内容，然后将新的输入加入到该文件中</p>
<p><strong>2.对象名.open(“文件名”，打开方式)</strong> （两个参数）例如 : <strong>outFile.open(“student.txt”,std::ios::in)</strong>只读模式  见下方</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221120211120660.png" alt="image-20221120211120660"> </p>
<p><strong>下面附上文件打开模式标记</strong>：<strong>（没用using编译指令的时候，前面全部加std：：）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221120211222224.png" alt="image-20221120211222224"></p>
<p><strong>使用完文件后应该对其进行关闭：</strong></p>
<p>格式：对象名.close()  例: <strong>outFile.close()</strong></p>
<p>注意方法close()，不需要使用文件名作为参数，因为outFile已经同特定的文件关联起来，如果忘记关闭文件，程序正常终止的时候将自动关闭它。</p>
<p><strong>下面时学生管理程序中的例子:</strong></p>
<p><strong>读取数据到文件中（output输出数据到文件）：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221120212115308.png" alt="image-20221120212115308"></p>
<p><strong>从该文件中读取数据（input从文件中输入数据到外）：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\！！！！Markdown\C++.assets\image-20221120212136110.png" alt="image-20221120212136110"></p>
<p><strong>从文件中读取数据时，也需要用到new分配新的内存，与Input（）函数在输入数据时相同</strong></p>
<p><strong>inFile 对应的c中的fscanf（从文件中读取数据）</strong></p>
<p><strong>outFile对应的时c中的fprintf（写入数据到文件）</strong></p>
<h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>按参数种类分：无参构造函数、有参构造函数、有默认参构造函数</li>
<li>按类型分为：普通构造函数、拷贝构造函数(赋值构造函数)</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Viewinfinitely/article/details/115017678?ops_request_misc=%7B%22request%5Fid%22%3A%22170626893616800185850269%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170626893616800185850269&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115017678-null-null.142^v99^pc_search_result_base4&amp;utm_term=C%2B%2B构造函数&amp;spm=1018.2226.3001.4187">C++构造函数的各种用法全面解析（C++初学面向对象编程）_c++ 构造函数-CSDN博客</a></p>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h2 id="运算符重载的概念和原理"><a href="#运算符重载的概念和原理" class="headerlink" title="运算符重载的概念和原理"></a>运算符重载的概念和原理</h2><p>如果不做特殊处理，C++ 的 +、-、*、/ 等运算符只能用于对基本类型的常量或变量进行运算，不能用于对象之间的运算。</p>
<p>有时希望对象之间也能用这些运算符进行运算，以达到使程序更简洁、易懂的目的。例如，复数是可以进行四则运算的，两个复数对象相加如果能直接用+运算符完成，不是很直观和简洁吗？</p>
<p>利用 C++ 提供的“运算符重载”机制，赋予运算符新的功能，就能解决用+将两个复数对象相加这样的问题。</p>
<p>运算符重载，就是对已有的运算符赋予多重含义，使同一运算符作用于不同类型的数据时产生不同的行为。运算符重载的目的是使得 C++ 中的运算符也能够用来操作对象。</p>
<p>运算符重载的实质是编写以运算符作为名称的函数。不妨把这样的函数称为运算符函数。运算符函数的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">返回值类型  <span class="keyword">operator</span>  运算符(形参表)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符可以是+、-、*、/等，必须是有效的C++运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值可以是一个引用，也可以是一个对象，但一定注意！！！，不要返回一个指向局部变量或临时对象的引用，因为函数执行完毕后，局部变量和临时对象将消失，引用将指向一个不存在的数据</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一个简单的重载+运算符*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="type">int</span> testData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> testData;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;testData = data;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Test <span class="keyword">operator</span>+(<span class="type">const</span> Test&amp; t)</span><br><span class="line">     &#123;</span><br><span class="line">         Test test;</span><br><span class="line">         test.testData = testData+t.testData;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> test;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Test t1,t2;</span><br><span class="line">    Test t3,t4;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">setData</span>(<span class="number">5</span>);</span><br><span class="line">    t2.<span class="built_in">setData</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    t3 = t1+t2;</span><br><span class="line"></span><br><span class="line">    t4 = t1.<span class="keyword">operator</span>+(t3);</span><br><span class="line">    <span class="comment">//t4 = t1+t2+t3 这是允许的，得出的结果相同</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t1:&quot;</span> &lt;&lt; t1.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t2:&quot;</span> &lt;&lt; t2.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t3:&quot;</span> &lt;&lt; t3.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t4:&quot;</span> &lt;&lt; t4.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：重载后的+号允许大于两个对象相加，如t4 = t1+ t2 + t3</span></span><br></pre></td></tr></table></figure>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>该函数有两种调用方式</strong>：</p>
<ul>
<li>通过对象调用方法来调用，如上边的t4</li>
<li>直接通过重载的符号调用，如上方t1+t2</li>
</ul>
</div>
<h2 id="运算符重载限制"><a href="#运算符重载限制" class="headerlink" title="运算符重载限制:"></a>运算符重载限制:</h2><p>运算符重载规则，即允许重载的运算符，不允许重载的运算符见：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_72157449/article/details/128664136?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=c++运算符重载限制&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128664136.142^v96^pc_search_result_base1&amp;spm=1018.2226.3001.4187">【⑤C++ | 运算符重载】意义 | 限制 | 方法 | 规则 | 特殊运算符重载 | 应用场景-CSDN博客</a></p>
<p>注：在 <strong>C++ 中，类型的名字（包括类的名字）本身也是一种运算符</strong>，即类型强制转换运算符。 类型强制转换运算符是单目运算符，也可以被重载，但只能重载为成员函数，不能重载为全局函数。</p>
<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="继承的定义"><a href="#继承的定义" class="headerlink" title="继承的定义"></a>继承的定义</h2><p>定义：</p>
<p>继承(inheritance)机制是面向对象程序设计中使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能。这样产生的新类，称派生类（或子类），被继承的类称基类（或父类）。</p>
<p>继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。之前接触的复用都是函数复用，继承是类设计层次的复用。</p>
<h2 id="继承：is-a-关系"><a href="#继承：is-a-关系" class="headerlink" title="继承：is-a 关系"></a>继承：is-a 关系</h2><p>因为派生类可以在基类上添加新特性，所以这种关系成为is-a-kind-of(是一种)关系更加准确，通常术语是is-a关系。例如：香蕉是一种水果</p>
<p>同时在指针指向的对象上面也有讲究：</p>
<ul>
<li>可以将基类指针指向派生类对象(多态性体现)</li>
<li>不能将派生类指针指向基类对象(不允许这样做)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span>:<span class="keyword">public</span> Fruit</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fruit *pFruit1 = <span class="keyword">new</span> <span class="built_in">Fruit</span>();<span class="comment">//正确</span></span><br><span class="line">    Fruit *pBanana = <span class="keyword">new</span> <span class="built_in">Banana</span>();<span class="comment">//正确，满足香蕉一种水果，水果包含香蕉的关系</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用基类指针引用派生类对象的能力允许多态性。在这种情况下，你可以通过基类指针调用基类的函数或访问基类的成员，而在运行时，将调用正确的派生类方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    Banana* pFruit2 = <span class="keyword">new</span> <span class="built_in">Fruit</span>();<span class="comment">//错误，水果不是一种香蕉，香蕉不包含水果，不允许这样做</span></span><br><span class="line">    Banana* pBanana1 =<span class="keyword">new</span> <span class="built_in">Banana</span>();<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 新类的名字: 继承方式 继承类的名字</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一个简单的例子*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">people</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">people</span>(string name,<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:<span class="keyword">public</span> people</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> schoolnum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">student</span>(string name,<span class="type">int</span> age,<span class="type">int</span> schoolNum):<span class="built_in">people</span>(name,age)<span class="comment">//使用成员初始化列表语法,会先调用基类的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;schoolnum = schoolNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*上面的构造函数等价于</span></span><br><span class="line"><span class="comment">    student(string name,int age,int schoolnum)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        this-&gt;name = name;</span></span><br><span class="line"><span class="comment">        this-&gt;age = age;</span></span><br><span class="line"><span class="comment">        this-&gt;schoolnum = schoolnum;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    这两种方法都可以</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; endl &lt;&lt; age &lt;&lt; endl &lt;&lt; schoolnum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">student <span class="title">s</span><span class="params">(<span class="string">&quot;keqiudi&quot;</span>,<span class="number">18</span>,<span class="number">2022124018</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>在继承的时候可以使用类名加上作用域解析符(:)来调用基类的方法，通常在私有继承中使用，第二种便是使用this指针调用继承过来的基类的方法</strong></p>
</div>
<p>更多详细内容学习：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_62718027/article/details/125922249?ops_request_misc=%7B%22request%5Fid%22%3A%22170126212316800222846414%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170126212316800222846414&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-125922249-null-null.142^v96^pc_search_result_base1&amp;utm_term=C%2B%2B类继承&amp;spm=1018.2226.3001.4187">c++：继承（超详解）</a></p>
<h2 id="继承的总结："><a href="#继承的总结：" class="headerlink" title="继承的总结："></a>继承的总结：</h2><ol>
<li>基类private成员无论以什么方式继承到派生类中都是不可见的。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它。</li>
<li>基类private成员在派生类中不能被访问，如果基类成员不想在派生类外直接被访问，但需要在派生类中访问，就定义为protected。可以看出保护成员限定符是因继承才出现的。</li>
<li>基类的私有成员在子类都是不可见；基类的其他成员在子类的访问方式就是访问限定符和继承方式中权限更小的那个（权限排序：public&gt;protected&gt;private）。</li>
<li>使用关键字class时<strong>默认的继承方式是private</strong>，使用struct时默认的继承方式是public，但最好显式地写出继承方式。</li>
</ol>
<h2 id="多态公有继承"><a href="#多态公有继承" class="headerlink" title="多态公有继承"></a>多态公有继承</h2><p>简单来说就是一个方法的行文随上下文而异，有两种重要机制可用于实现多态的公有继承</p>
<ol>
<li>在派生类中重新定义基类的方法</li>
<li>使用虚方法</li>
</ol>
<h3 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h3><ul>
<li>关键词：virtual</li>
<li>在基类中将<strong>派生类会重新定义的方法</strong>声明为虚方法。使用了virtual，程序将根据<strong>引用或指针指向的对象</strong>的类型来选择方法，而未使用时程序将仅仅根据<strong>引用或指针的类型</strong>来选择方法，与<strong>多态性</strong>紧密相关。</li>
<li>virtual关键词只用于类声明的方法原型中，而不用于类方法实现中</li>
<li>派生类中覆盖的方法后要加上override标注</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//brass.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BRASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BRASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string fullName; <span class="comment">//客户姓名</span></span><br><span class="line">	<span class="type">long</span> acctNum; <span class="comment">//账号</span></span><br><span class="line">	<span class="type">double</span> balance; <span class="comment">//当前结余</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Brass</span>(<span class="type">const</span> string &amp;s = <span class="string">&quot;Nullbody&quot;</span>, <span class="type">long</span> an = <span class="number">-1</span>, <span class="type">double</span> bal = <span class="number">0.0</span>); <span class="comment">//创建账户</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Deposit</span><span class="params">(<span class="type">double</span> amt)</span></span>; <span class="comment">//存款</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span>; <span class="comment">//取款</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">Balance</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//显示账户信息</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//显示</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Brass</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrassPlus</span> : <span class="keyword">public</span> Brass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> maxLoan; <span class="comment">//透支上限</span></span><br><span class="line">	<span class="type">double</span> rate; <span class="comment">//透支贷款利率</span></span><br><span class="line">	<span class="type">double</span> owesBank; <span class="comment">//当前的透支总额</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BrassPlus</span>(<span class="type">const</span> string &amp;s = <span class="string">&quot;Nullbody&quot;</span>, <span class="type">long</span> an = <span class="number">-1</span>, <span class="type">double</span> bal = <span class="number">0.0</span>, <span class="type">double</span> m1 = <span class="number">500</span>, <span class="type">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">	<span class="built_in">BrassPlus</span>(<span class="type">const</span> Brass &amp;ba, <span class="type">double</span> m1 = <span class="number">500</span>, <span class="type">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//覆盖基类实现，函数重载</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span> <span class="keyword">override</span></span>; <span class="comment">//覆盖基类实现，函数重载</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResetMax</span><span class="params">(<span class="type">double</span> m)</span> </span>&#123; maxLoan = m; &#125; <span class="comment">//透支上限</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResetRate</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123; rate = r; &#125; <span class="comment">//透支贷款利率</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ResetOwes</span><span class="params">()</span> </span>&#123; owesBank = <span class="number">0</span>; &#125; <span class="comment">//当前透支总额</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设计的Brass基类指针既可以指向Brass对象，也可以指向BrassPlus对象，因此可以使用一个数组来表示多种类型的对象，这就是多态性。下面在一个数组中可以很清楚的看清virtual的作用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> CLIENTS = <span class="number">2</span>;</span><br><span class="line">Brass *clients[CLIENTS];<span class="comment">//Brass类型的指针</span></span><br><span class="line">clients[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">Brass</span>(<span class="string">&quot;Test0&quot;</span>, <span class="number">1234</span>, <span class="number">1234.56</span>);<span class="comment">//指向Brass类型对象</span></span><br><span class="line">clients[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">BrassPlus</span>(<span class="string">&quot;Test1&quot;</span>, <span class="number">5678</span>, <span class="number">5678.91</span>);<span class="comment">//指向BrassPlus类型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; CLIENTS;++i)</span><br><span class="line">&#123;</span><br><span class="line">    clients[i]-&gt;<span class="built_in">ViewAcct</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>多态性说明</strong>：</p>
<ul>
<li>假如ViewAcct()是使用关键字virtual声明</li>
</ul>
<p>如果数组成员(指针)指向的是Brass对象，则调用的是Brass::ViewAcct()。<br>如果数组成员(指针)指向的是BrassPlus对象，则调用的是BrassPlus::ViewAcct()。</p>
<ul>
<li>假如ViewAcct()不是虚方法</li>
</ul>
<p>则在任何情况下都将调用Brass::ViewAcct()。</p>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>基类要声明一个虚析构函数，为了确保释放派生类对象时，按正确的顺序调用析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string fullName; <span class="comment">//客户姓名</span></span><br><span class="line">	<span class="type">long</span> acctNum; <span class="comment">//账号</span></span><br><span class="line">	<span class="type">double</span> balance; <span class="comment">//当前结余</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Brass</span>() &#123;&#125; <span class="comment">//这是虚析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>为何使用虚析构函数</strong>：</p>
<ul>
<li>如果析构函数不是虚方法，则将只调用对应于指针类型的析构函数。对于Brass <em> 指针将只调用Brass基类的析构函数，即使Brass </em> 指针指向的是BrassPlus对象。</li>
<li>如果析构函数是虚方法，将调用相应的指向对象类型的析构函数。即如果指针指向的是Brass对象，将调用Brass对象的析构函数，如果指针指向的是BrassPlus对象，将调用BrassPlus的析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以确保正确的析构函数序列被调用。</li>
<li>如果BrassPlus包含一个执行某些操作的析构函数，则Brass必须有一个虚析构函数，即使Brass的析构函数不执行任何操作。</li>
</ul>
</div>
<h2 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h2><p><strong>静态联编</strong>：静态联编是指联编工作在<strong>编译阶段完成的</strong>，联编过程是在程序运行之前完成。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，静态联编对函数的选择是<strong>基于指向对象的指针或者引用的类型</strong>。其优点是<strong>效率高，但灵活性差</strong>，也因此作为C++默认联编选择。</p>
<p><strong>动态联编</strong>：动态联编是指联编在<strong>程序运行时动态地进行</strong>，根据当时的情况来确定调用哪个同名函数，实际上是在运行时是<strong>虚函数的实现</strong>。动态联编对成员函数的选择是基于<strong>对象的类型</strong>，针对不同的对象类型将做出不同的编译结果。C++中一般情况下的联编是静态联编，但是当涉及到<strong>多态性和虚函数时应该使用动态联编</strong>。动态联编的优点是<strong>灵活性强，但效率低</strong>。</p>
<p>动态联编规定：只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式为：指向基类的指针变量名-&gt;虚函数名（实参表）或基类对象的引用名.虚函数名（实参表）</p>
<ul>
<li>编译器对<strong>非虚方法</strong>使用<strong>静态联编</strong></li>
<li>编译器对<strong>虚方法</strong>使用<strong>动态联编</strong></li>
</ul>
<hr>
<p><strong>实现动态联编需要同时满足以下三个条件：</strong></p>
<p>①  必须把动态联编的行为定义为类的虚函数。</p>
<p>②  类之间应满足子类型关系，通常表现为一个类从另一个类公有派生而来。</p>
<p>③  必须先使用基类指针指向子类型的对象，然后直接或者间接使用基类指针调用虚函数</p>
<p><strong>总结</strong>：</p>
<p>大多数情况下，动态联编很好，因为他让程序能够选择特定类型设计的方法。<strong>虚函数是实现多态的基础，是实现动态联编的必要条件之一</strong>。动态联编要靠虚函数来实现，虚函数要靠动态联编的支持。两者相辅相成，缺一不可。</p>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当在C++中定义类的构造函数时，可以使用初始化列表来初始化类的成员变量。初始化列表是在构造函数的参数列表后面使用冒号(:)分隔开来的一组初始化语句,多个参数初始化使用逗号隔开，用于初始化类的成员变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*初始化列表写法*/</span></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> value,<span class="type">double</span> values):<span class="built_in">data</span>(value),<span class="built_in">datas</span>(values)<span class="comment">//这里的冒号及冒号右边的部分就是构造函数的初始化列表,逗号隔开</span></span><br><span class="line">	&#123;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*函数体内写法*/</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value,<span class="type">double</span> values)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;</span><br><span class="line">        <span class="type">double</span> = datas;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">    <span class="type">double</span> datas;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意</strong>：</p>
<ul>
<li>对于<strong>继承的对象</strong>，构造函数在成员初始化列表中使用基类名来调用特定的基类构造函数。</li>
<li>对于<strong>成员对象</strong>，构造函数则使用成员名。</li>
</ul>
</div>
<h3 id="什么时候必须使用"><a href="#什么时候必须使用" class="headerlink" title="什么时候必须使用"></a>什么时候必须使用</h3><ol>
<li><strong>在成员变量为引用类型时</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> &amp;data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value):<span class="built_in">data</span>(value)<span class="comment">//正确</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;<span class="comment">//会报错引用类型不允许这样做,只能使用初始化列表(上面的方式初始化)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>在成员变量为const时</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value):<span class="built_in">data</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="built_in">A</span>(<span class="type">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;<span class="comment">//会报错const类型不允许这样做,只能使用初始化列表(上面的方式初始化)</span></span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="建议使用的地方"><a href="#建议使用的地方" class="headerlink" title="建议使用的地方"></a>建议使用的地方</h3><ul>
<li>初始化基类部分</li>
</ul>
<p>在派生类构造函数中使用初始化列表法初始基类的变量，可以避免在函数体中进行额外的赋值操作提高效率，同时提高可读性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*对于成员对象使用成员名初始化列表*/</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> value)</span>:data(value)//这里的冒号及冒号右边的部分就是构造函数的初始化列表,逗号隔开</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> datas;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*对于继承的对象，使用基类名初始化列表，调用基类构造函数初始化基类部分*/</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> value,<span class="type">double</span> values):<span class="built_in">A</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        datas = values; <span class="comment">//正常的在函数体内初始化派生类部分,更清晰表明继承关系，这个地方也可以在上面使用初始化列表方式为datas赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong>：</p>
<p>建议尽可能使用初始化列表法来初始化构造函数中的成员变量，但并非所有情况都必须使用初始化列表。</p>
<p>一般来说，以下情况建议使用初始化列表法：</p>
<ol>
<li><strong>初始化成员变量</strong>：如果构造函数需要初始化类的成员变量,但此时类的结构和逻辑不是很复杂时，使用初始化列表是最清晰和高效的方式。</li>
<li><strong>初始化基类部分</strong>：在派生类的构造函数中调用基类的构造函数时，应该使用初始化列表来确保基类部分被正确地初始化。</li>
<li><strong>初始化const和引用类型成员变量</strong>：const和引用类型的成员变量只能在初始化列表中进行初始化，无法在构造函数体内进行赋值。</li>
<li><strong>初始化具有复杂初始化逻辑的成员变量</strong>：如果某个成员变量的初始化逻辑比较复杂，使用初始化列表可以将初始化逻辑集中在一起，提高代码的可读性。</li>
</ol>
<p>但也有一些情况可以在构造函数体内进行初始化，例如：</p>
<ol>
<li><strong>运行时条件决定的初始化</strong>：如果某些成员变量的初始化取决于运行时条件，可能需要在构造函数体内进行初始化。</li>
<li><strong>需要在构造函数体内执行额外逻辑</strong>：如果构造函数需要执行一些额外的逻辑操作，可以在构造函数体内进行初始化。</li>
</ol>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p><strong>优点</strong>:</p>
<ol>
<li>(涉及含有类成员时)<strong>效率高</strong>: 使用初始化列表可以直接对成员变量进行初始化，而不需要先调用默认构造函数再进行赋值操作，从而提高了代码的执行效率。基本类型时效率与在函数体中差不多</li>
<li><strong>确保成员变量的初始化</strong>: 使用初始化列表可以确保所有成员变量在对象构造时立即得到正确的初始化，避免了可能出现的未初始化的情况。</li>
<li><strong>处理const和引用类型成员变量</strong>: 对于const成员变量和引用类型成员变量，只能在初始化列表中进行初始化，因为它们不能在构造函数体内被赋值。</li>
<li><strong>清晰明了</strong>: 初始化列表将所有初始化操作集中在一起，使代码更加清晰易读，便于理解和维护</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>可读性差</strong>: 对于复杂的类结构和初始化逻辑，初始化列表可能会使代码变得复杂和难以理解，降低了可读性。</li>
<li><strong>限制较多</strong>: 有些情况下，无法在初始化列表中初始化所有的成员变量，例如需要在构造函数体内进行逻辑判断后再进行初始化的情况。</li>
<li><strong>容易遗忘</strong>: 在添加新成员变量时，容易忘记在初始化列表中添加相应的初始化操作，导致未初始化的错误。</li>
</ol>
<h2 id="使用using-重新定义访问权限"><a href="#使用using-重新定义访问权限" class="headerlink" title="使用using 重新定义访问权限"></a>使用using 重新定义访问权限</h2><p>使用<strong>保护派生或私有派生</strong>时，基类的公有成员将成为保护成员或私有成员。假设要让基类的方法在派生类外面可用，可以在派生类的public成员中使用using声明指出派生类可以使用特定的基类成员，就像using指定的成员或函数是派生类的公有方法一样，即使采用的是私有派生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一个简单的例子*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">people</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">people</span>(string name,<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>: <span class="keyword">private</span> people<span class="comment">//私有派生</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> schoolnum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> people::showName;<span class="comment">//使用using定义重新定义访问权限</span></span><br><span class="line">    <span class="keyword">using</span> people::name;<span class="comment">//使用using定义重新定义访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">student</span>(string name,<span class="type">int</span> age,<span class="type">int</span> schoolNum):<span class="built_in">people</span>(name,age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;schoolnum = schoolNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">student <span class="title">s</span><span class="params">(<span class="string">&quot;keqiudi&quot;</span>,<span class="number">18</span>,<span class="number">2022124018</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">showName</span>();<span class="comment">//正确，使用了using可以在派生类外调用</span></span><br><span class="line">    cout &lt;&lt; s.name &lt;&lt; endl;<span class="comment">//正确，使用了using可以在派生类外调用</span></span><br><span class="line">    cout &lt;&lt; s.age &lt;&lt; endl;<span class="comment">//报错，未使用using，继承后为派生类private成员不可以直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>派生类都只有一个基类，称为单继承。除此之外，C++也支持多继承，即一个派生类可以有两个或多个基类。<br>多继承的语法也很简单，将多个基类用逗号隔开。</p>
<p>如已声明了类A、类B和类C，那么可以这样来声明派生类D：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A, <span class="keyword">private</span> B, <span class="keyword">protected</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//类D新增加的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>与单继承形式基本相同，只是在派生类的构造函数中调用多个基类的构造函数。<br>以上面的 A、B、C、D 类为例，D 类构造函数的写法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">D</span>(形参列表): <span class="built_in">A</span>(实参列表), <span class="built_in">B</span>(实参列表), <span class="built_in">C</span>(实参列表)<span class="comment">//使用初始化列表写法调用基类构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><p>当两个或多个基类有同名成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员。这个时候需要在<strong>名字前面加上类名和域解析符::</strong>，以显示地指明到底使用哪个类的成员，消除二义性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseA</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">BaseA</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BaseA</span>(<span class="type">int</span> value):_value(value)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseA::_value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseB</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">BaseB</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BaseB</span>(<span class="type">int</span> value):_value(value)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseB::_value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> BaseA, <span class="keyword">public</span> BaseB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Derived</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> valueA, <span class="type">int</span> valueB):<span class="built_in">BaseA</span>(valueA), <span class="built_in">BaseB</span>(valueB)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseA::_value: &quot;</span> &lt;&lt; BaseA::_value &lt;&lt; endl;<span class="comment">//使用::指明基类BaseA的value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseB::_value: &quot;</span> &lt;&lt; BaseB::_value &lt;&lt; endl;<span class="comment">//使用::指明基类BaseB的value</span></span><br><span class="line">        BaseA::<span class="built_in">showValue</span>();<span class="comment">//使用::指明调用基类BaseA的方法</span></span><br><span class="line">        BaseB::<span class="built_in">showValue</span>();<span class="comment">//使用::指明调用基类BaseB的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    d.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>在C++中，<strong>模板类</strong>是一种用于创建通用数据结构或算法的强大工具。模板类允许您编写一次代码，然后在不同数据类型上重复使用它，例如有两个或多个类，其功能是相同的，仅仅是数据类型不同时使用，<strong>以提高代码的可重用性和灵活性</strong>。</p>
<p>模板类允许您定义一种通用的类模板，其中某些成员或函数可以根据不同进行参数化。它们使用template关键字定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,....&gt;</span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;</span><br><span class="line">类的定义;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>typename</code>表明其后面的符号是一种数据类型，可以用<code>class</code>代替</li>
<li><code>T</code>是通用的数据类型，名称可以替换，通常为大写字母</li>
<li>函数模板建议用 <code>typename</code> 描述通用数据类型，类模板建议用 <code>class</code></li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">nameType</span>,<span class="keyword">class</span> <span class="title class_">ageType</span>&gt;<span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    nameType name;</span><br><span class="line">    ageType age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(nameType name,ageType age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">student</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    student.<span class="built_in">showPerson</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能，提高了程序的可重用性。</p>
<p>C++ 语言支持模板。有了模板，例如可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。</p>
<p><strong>写法</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span>,<span class="keyword">typename</span> 类型参数<span class="number">2</span>, ...&gt;</span><br><span class="line">返回值类型  模板名(形参表)</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*typename可以使用class替换*/</span></span><br></pre></td></tr></table></figure>
<p><strong>一个简单的示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp; x, T &amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>, m = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(n, m);  <span class="comment">//编译器自动生成 void Swap (int &amp;, int &amp;)函数</span></span><br><span class="line">    <span class="type">double</span> f = <span class="number">1.2</span>, g = <span class="number">2.3</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(f, g);  <span class="comment">//编译器自动生成 void Swap (double &amp;, double &amp;)函数</span></span><br><span class="line">    string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(s1, s2);  <span class="comment">//编译器自动生成 void Swap (string &amp;, string &amp;)函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="类模板与函数模板区别"><a href="#类模板与函数模板区别" class="headerlink" title="类模板与函数模板区别"></a>类模板与函数模板区别</h2><ol>
<li><strong>应用对象</strong>：<ul>
<li><strong>函数模板</strong>主要用于生成通用函数，可以用于不同类型的参数。它通过在函数定义中使用模板来实现，允许编写一次通用的函数代码，用于多种数据类型。</li>
<li><strong>类模板</strong>主要用于生成通用类，可以包含不同类型的成员变量或成员函数。它通过在类定义中使用模板来实现，允许创建一种通用的类形式，适用于多种数据类型。</li>
</ul>
</li>
<li><strong>自动类型推导的使用方式</strong>：<ul>
<li><strong>函数模板</strong>在调用时支持自动类型推导，允许省略模板参数，由编译器根据实参类型自动推导出模板参数的类型。</li>
<li><strong>类模板</strong>在实例化时需要显式指定模板参数，没有像函数模板那样的自动类型推导。每次实例化都需要<strong>明确指定模板参数</strong>。</li>
</ul>
</li>
<li><strong>默认参数</strong>：<ul>
<li><strong>函数模板</strong>和<strong>类模板</strong>都支持默认参数。在模板参数列表中可以为某些模板参数设置默认值，使得在使用时可以不必每次都指定这些参数。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板与函数模板的区别</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; <span class="comment">//指定默认参数</span></span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameType m_Name;</span><br><span class="line">	AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Person p(&quot;孙悟空&quot;, 1000);错误的，类模板无法用自动类型推导</span></span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;keqiudi&quot;</span>, <span class="number">19</span>);<span class="comment">//正确，只能用显式指定类型推导</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string&gt;<span class="built_in">p</span>(<span class="string">&quot;keqiudi&quot;</span>, <span class="number">19</span>); <span class="comment">//类模板在参数列表中有默认参数</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="类模板成员函数实现"><a href="#类模板成员函数实现" class="headerlink" title="类模板成员函数实现"></a>类模板成员函数实现</h2><p>在类<strong>内部定义成员函数</strong>可以更简洁，因为不需<strong>要再次指定模板参数</strong>。类内部的成员函数定义可以直接使用类模板的模板参数，而在<strong>外部定义时需要重新指定一次</strong>。</p>
<p>总体来说，选择在类内部还是类外部定义成员函数取决于项目的需求和组织代码的风格。一般而言，对于简单、短小的成员函数，可以选择在类内部定义；而对于复杂或长的成员函数，以及避免头文件的多次包含导致的重定义错误，通常建议在类外部定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板成员类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="comment">/*内部定义&#123;</span></span><br><span class="line"><span class="comment">		this-&gt;m_Name = name;</span></span><br><span class="line"><span class="comment">		this-&gt;m_Age = age;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/*内部定义&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造函数的类外实现，每个函数都要重新指定模板参数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="comment">//要点1：每个函数前加上template&lt;&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)<span class="comment">//要点2:类名指出模板参数再进行解析(::)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*成员函数的类外实现，每个函数都要重新指定模板参数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h2><p>模板可用作结构、类或模板类的成员。要完全实现STL(标准模板库)，必须使用这个特性</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">beta</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;<span class="comment">//模板成员</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">hold</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">         	V val;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">         	<span class="built_in">hold</span>(V v=<span class="number">0</span>):<span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>&#123;cout &lt;&lt; val &lt;&lt; endl;&#125;</span><br><span class="line">        </span><br><span class="line">        	<span class="function">V <span class="title">Value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    hold&lt;T&gt; q; <span class="comment">//模板类中的模板对象,传入的模板参数为T，即外部模板类想通过的模板参数</span></span><br><span class="line">    hold&lt;<span class="type">int</span>&gt; n;<span class="comment">//模板对象</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">beta</span>(T t,<span class="type">int</span> i):<span class="built_in">q</span>(t),<span class="built_in">n</span>(i)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;<span class="comment">//模板函数做成员</span></span><br><span class="line">    <span class="function">U <span class="title">blab</span><span class="params">(U u,T t)</span></span>&#123;<span class="keyword">return</span> (n.<span class="built_in">Value</span>()+q.<span class="built_in">Value</span>()*u/t);&#125; </span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span>&#123; q.<span class="built_in">show</span>(); n.<span class="built_in">show</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">beta&lt;<span class="type">double</span>&gt; <span class="title">guy</span><span class="params">(<span class="number">3.5</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T被设置为double\n&quot;</span>;</span><br><span class="line">    guy.<span class="built_in">Show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;V被设置为T,即double，第二个V被设置为int\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; guy.<span class="built_in">blab</span>(<span class="number">10</span>,<span class="number">2.3</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;U被设置为int\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; guy.<span class="built_in">blab</span>(<span class="number">10.0</span>,<span class="number">2.3</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;U被设置为double\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h2><p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型：直接显示对象的数据类型，此时模板对象必须含有模板类的参数</li>
<li>参数模板化：将对象中的参数变为模板进行传递</li>
<li>整个类模板化：将这个对象类型模板化进行传递</li>
</ol>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板对象做函数参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name,T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">199</span>);</span><br><span class="line">	<span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 2、参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">60</span>);</span><br><span class="line">	<span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将模板做模板类参数"><a href="#将模板做模板类参数" class="headerlink" title="将模板做模板类参数"></a>将模板做模板类参数</h2><p>模板可以包含类型参数(如typename T)和非类型参数(如 int n)。模板还可以本身就是模板的参数，这种参数是模板类新增的特性，用于实现STL。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Thing</span>&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *模板参数是template &lt;typename T&gt; class Thing，其中template &lt;typename T&gt; class 是类型，Thing是参数。</span></span><br><span class="line"><span class="comment"> 假设有Crab&lt;King&gt; legs;</span></span><br><span class="line"><span class="comment"> 那么King必须是一个模板类，其声明与模板参数Thing的声明匹配；</span></span><br><span class="line"><span class="comment"> 即：</span></span><br><span class="line"><span class="comment"> template&lt;class T&gt;</span></span><br><span class="line"><span class="comment"> class King&#123;...&#125;</span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Crab</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Thing&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    Thing&lt;<span class="type">double</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设有如下声明</span></span><br><span class="line">Crab&lt;Stack&gt;stack;</span><br><span class="line"><span class="comment">//成员函数Thing&lt;int&gt;就被替换为Stack&lt;int&gt;,Thing&lt;double&gt;替换为Stack&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *总之模板参数Thing将被替换为声明Crab对象时被用作模板参数的模板类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h2><p>当类模板碰到继承时，需要注意以下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中<code>T</code>的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中<code>T</code>的类型，子类也需为类模板</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板与继承</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son: public Base //错误，必须要知道父类中的T类型，才能继承给子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想灵活指定父类中T的类型，子类也需要变成类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;T1的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;T2的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	T1 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2&lt;<span class="type">int</span>,<span class="type">char</span>&gt; s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="模板类和友元"><a href="#模板类和友元" class="headerlink" title="模板类和友元"></a>模板类和友元</h2><p>模板类声明也可以有友元。模板的友元分为3类：</p>
<ol>
<li><p>非模板友元</p>
</li>
<li><p>约束(bound)模板友元，即友元的类型取决于类被实例化时的类型；</p>
</li>
<li><p>非约束(unbound)模板友元，即友元的所有具体化都是类的每一个具体化的友元</p>
</li>
</ol>
<ul>
<li><p>非模板友元</p>
<p>在模板类中将一个常规函数声明为友元</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasFriend</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">int</span>&gt;&amp; hf)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">double</span>&gt;&amp; hf)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *上述声明使counts()函数成为模板所有实例化的友元,例如是HasFriend&lt;int&gt;和HasFriend&lt;string&gt;的友元</span></span><br><span class="line"><span class="comment"> *report()函数也是，只不过接受一个模板类参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">int</span>&gt;&amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">double</span>&gt;&amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>约束模板友元</li>
</ul>
<p>​        修改前一个示例，使友元函数本身成为模板，即使类的每一个具体化都获得与友元匹配的具体化，一共包含3步。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一步，在类定义前面声明每个模板函数*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(T&amp; t)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*第二步，在类中将模板声明为友元，这些语句根据类模板参数的类型声明具体化*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">class</span> TT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> HasFriendT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">counts</span>&lt;TT&gt;();</span><br><span class="line">    	<span class="keyword">friend</span> <span class="type">void</span> report&lt;&gt;(HasFriendT&lt;TT&gt; &amp; tt);</span><br><span class="line">        <span class="comment">//或使用friend void report&lt;HasFriendT&lt;TT&gt;&gt;(HasFriendT&lt;TT&gt; &amp; tt);</span></span><br><span class="line">    	<span class="comment">//声明中的&lt;&gt;指出这是模板具体化，&lt;&gt;可以为空，因为可以从函数参数推断出模板类型参数</span></span><br><span class="line">    	<span class="comment">//但counts()没有参数，因此必须使用模板参数语法(&lt;TT&gt;)来指明其具体化,TT为HasFriendT类的类模板参数类型</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三步，为友元函数提供定义*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(T &amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>非约束模板友元</li>
</ul>
<p>每个函数<strong>具体化</strong>都是每个类<strong>具体化</strong>的友元，<strong>友元模板类型参数与模板类类型参数不同</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ManyFriend</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T item</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">ManyFriend</span>(<span class="type">const</span> T&amp; i):<span class="built_in">item</span>(i)&#123;&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C,<span class="keyword">typename</span> D&gt;</span><br><span class="line">      <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show2</span><span class="params">(C&amp; c,D&amp; d)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C,<span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show2</span><span class="params">(C&amp; c,D&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; c.item &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; d.item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板成员函数创建时机"><a href="#类模板成员函数创建时机" class="headerlink" title="类模板成员函数创建时机"></a>类模板成员函数创建时机</h2><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>对于类模板的成员函数在使用时进行实例化。当你使用特定类型实例化类模板对象时，编译器会生成该类型的成员函数实现。</li>
<li>对于普通类，所有的成员函数都在编译时就被实例化了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*故可以做到以下的操作*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数的创建时机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//类模板中的成员函数在调用的时候才创建，所以不会报错</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		obj.<span class="built_in">showPerson1</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		obj.<span class="built_in">showPerson2</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Myclass&lt;Person1&gt;m;</span><br><span class="line">	m.<span class="built_in">func1</span>();</span><br><span class="line">	<span class="comment">//m.func2(); 此时模板参数传递为Person1故无法调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="类模板分文件编写-重要"><a href="#类模板分文件编写-重要" class="headerlink" title="类模板分文件编写(重要)"></a>类模板分文件编写(重要)</h2><p>如果工程中需要利用多个类模板，那么将这些类模板都写在同一个文件中将会导致代码可读性变差，所以有必要对类模板进行分文件编写，但是类模板的分文件编写面临着一些问题，以下是类模板分文件编写面临的问题及解决方法。</p>
<p><strong>问题</strong>：模板的特性导致了编译器对模板的实例化是在链接阶段进行的，而编译器需要在链接时找到模板的定义，当模板类的定义放在.h文件模板类实现放在.cpp文件，会出现链接失败情况，找不到定义。</p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>直接包含<code>.cpp</code>源文件（不常用因为.cpp风格不好一般用.hpp文件）</li>
<li>将声明和实现写到同一个文件中，并更改后缀名为<code>.hpp</code></li>
</ul>
<div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>.hpp</code> 文件通常用来包含 C++ 的头文件，其中包含类声明、函数原型、模板定义等。这种文件扩展名的选择<strong>是一种约定</strong>，用于表示这个头文件中包含一些声明与实现在一起，比如模板类</p>
<p>一般来说，<code>.hpp</code> 文件和 <code>.h</code> 文件在功能上是相似的，都用于包含头文件，但 <code>.hpp</code> 文件更常见于 C++ 项目中，尤其是涉及到类和模板的情况。</p>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编写的templatePerson.hpp文件，模板类的定义和实现放在一个文件中*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.cpp文件内容*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;templatePerson.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="模板别名-C-11"><a href="#模板别名-C-11" class="headerlink" title="模板别名(C++11)"></a>模板别名(C++11)</h2><p>如果能为类型指定别名，将很方便，在模板设计中尤其如此，可以使用typedef为模板具体化指定别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">double</span>,12&gt;arrd;</span><br><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">int</span>,12&gt;arri;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>C++11新增了一项功能——使用(using)为模板提供一系列别名，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> arrtype = std::array&lt;T,<span class="number">12</span>&gt;;</span><br><span class="line"><span class="comment">//使用using将arrtype定义为一个模板别名，arrtype&lt;T&gt;表示类型std::array&lt;T,12&gt;。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arrtype&lt;<span class="type">double</span>&gt; gallons;<span class="comment">//等价于 std::array&lt;double,12&gt;</span></span><br><span class="line">arrtype&lt;<span class="type">int</span>&gt; days;<span class="comment">//与上面相同</span></span><br><span class="line">arrtype&lt;std::string&gt; months</span><br></pre></td></tr></table></figure>
<p>C++11 允许将语法using = 用于非模板。用于非模板时语法与常规typedef等价：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span>* pc1;</span><br><span class="line"><span class="keyword">using</span> pc2 = <span class="type">const</span> <span class="type">char</span>*;<span class="comment">//与上方等价</span></span><br></pre></td></tr></table></figure>
<p><strong>好处</strong>：</p>
<ul>
<li>使用模板别名可以提高代码的可读性，特别是在涉及复杂模板或需要引入特定模板类型时。</li>
<li>模板别名还可以使代码更易于维护，因为你只需要在一个地方修改模板类型或表达式，而无需修改多处使用的地方。</li>
</ul>
<h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><p>在C++中，友元类和友元函数是用来在类之间建立友好关系的机制，允许一个类的成员访问另一个类的私有成员。这样可以增加程序的灵活性和封装性。</p>
<p>虽然友元提供了灵活性，但过度使用友元可能会破坏封装性，因此应该谨慎使用。友元应该只在确实需要访问私有成员的情况下使用，以保持代码的清晰性和可维护性。</p>
<h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><ul>
<li><strong>作用</strong>： <strong>允许一个非成员函数访问类的私有成员。</strong></li>
<li><strong>用法</strong>： 可以在类的声明中使用<code>friend</code>关键字声明友元函数，然后在类外定义这个函数。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span>:myData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">showMyData</span><span class="params">(<span class="type">const</span> Myclass&amp; myclass)</span></span>;<span class="comment">//友元函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元函数类外定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMyData</span><span class="params">(<span class="type">const</span> Myclass&amp; myclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myData = &quot;</span> &lt;&lt; myclass.myData &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//友元函数可以访问私有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showMyData</span>(myclass);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><ul>
<li><strong>作用</strong>： <strong>允许一个类的所有成员函数访问另一个类的私有成员</strong>。</li>
<li><strong>用法</strong>：在类的声明中使用<code>friend</code>关键字声明<strong>友元类</strong>。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> friendData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FriendClass</span><span class="params">(<span class="type">int</span> data)</span>:friendData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">FriendClass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Myclass</span>;<span class="comment">//指定Myclass为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span>:myData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;FriendClass data is: &quot;</span> &lt;&lt; friendclass.friendData &lt;&lt; endl;<span class="comment">//友元类的成员函数直接访问另一个类的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">FriendClass <span class="title">friendclass</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">   <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   myclass.<span class="built_in">showFriendData</span>(friendclass);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h2><ul>
<li><strong>作用</strong>： <strong>允许一个类的某一个成员函数访问另一个类的私有成员</strong>。</li>
<li><strong>用法</strong>：在类的声明中使用<code>friend</code>关键字声明<strong>友元</strong>。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明FriendClass，以便在Myclass中声明友元关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span> : myData(data) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明Myclass的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> friendData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FriendClass</span><span class="params">(<span class="type">int</span> data)</span> : friendData(data) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">FriendClass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数的声明，在FriendClass中声明，使Myclass的showFriendData作为FriendClass类的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Myclass::showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Myclass的成员函数因为是FriendClass的友元，所以定义必须在类外，用于访问FriendClass的私有成员，</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myclass::showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FriendClass data is: &quot;</span> &lt;&lt; friendclass.friendData &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Myclass data is: &quot;</span> &lt;&lt; myData &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FriendClass <span class="title">friendclass</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    myclass.<span class="built_in">showFriendData</span>(friendclass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="友元的优缺点"><a href="#友元的优缺点" class="headerlink" title="友元的优缺点"></a>友元的优缺点</h2><p><strong>优点：</strong></p>
<ol>
<li><strong>灵活性：</strong> 友元机制允许在类之间建立友好关系，使得某个函数或类可以访问其他类的私有成员，提高了灵活性。</li>
<li><strong>特定需求的访问权限：</strong> 有时候，为了实现特定的功能，需要某些函数或类能够直接访问其他类的私有成员，友元机制提供了一种选择。</li>
<li><strong>效率：</strong> 有时候使用友元可以避免通过公有接口的方式(比如get方法等等)进行多次函数调用，提高代码执行效率。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>破坏封装性：</strong> 友元可以直接访问类的私有成员，这可能破坏类的封装性，增加了代码的耦合性，增加了维护的难度。</li>
<li><strong>复杂性增加：</strong> 过度使用友元可能导致代码更加复杂，使得程序难以理解和维护。</li>
<li><strong>设计问题：</strong> 有时候需要重新考虑设计，以避免对友元的过度依赖。可能存在更好的设计模式或方法，不需要使用友元。</li>
</ol>
<h1 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>在C++中，嵌套类是一个类被定义在另一个类的内部的情况。被嵌套的类称为内部类或嵌套类，而包含这个内部类的类称为外部类。嵌套类可以具有私有、受保护或公有的访问权限，这取决于它在外部类中的声明方式。包含类的成员函数可以创建和使用被嵌套类的对象；而仅当声明位于公有部分时，才能在包含类的外面使用嵌套类，而且必须使用作用域解析运算符(旧版本的C++不允许嵌套类或无法完全实现这种概念)</p>
<p><strong>一个示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内部类 Point 表示二维平面上的点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Point</span>(<span class="type">int</span> xCoord, <span class="type">int</span> yCoord) : <span class="built_in">x</span>(xCoord), <span class="built_in">y</span>(yCoord) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部类的成员函数</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Point: (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Point center; <span class="comment">// Shape 类包含 Point 类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Shape 类的构造函数</span></span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">int</span> centerX, <span class="type">int</span> centerY) : <span class="built_in">center</span>(centerX, centerY) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shape 类的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayShape</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shape with center at &quot;</span>;</span><br><span class="line">        center.<span class="built_in">display</span>(); <span class="comment">// 调用内部类的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Shape 类对象</span></span><br><span class="line">    <span class="function">Shape <span class="title">myShape</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Shape 类的成员函数</span></span><br><span class="line">    myShape.<span class="built_in">displayShape</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>嵌套类的主要作用之一是组织和封装代码，使代码更为模块化、清晰和可读。以下是嵌套类的一些主要作用：</p>
<ol>
<li><strong>封装实现细节：</strong> 嵌套类允许将一个类的一部分实现细节封装在另一个类中，从而隐藏一些具体的实现细节，提高封装性。外部类可以更专注于公共接口，而具体的实现则留给内部类。</li>
<li><strong>组织相关的类：</strong> 当两个类有密切关联时，将它们组织在一起可以形成更清晰的结构。嵌套类可以在逻辑上将这些关联的类放在同一个地方，方便代码的组织和维护。</li>
<li><strong>限制访问权限：</strong> 内部类可以访问外部类的私有成员，但外部类不能直接访问内部类的私有成员。这种特性可以用于在设计中划分不同层次的访问权限，使得代码更安全。</li>
<li><strong>实现接口与实现分离：</strong> 将接口和实现分离，可以通过内部类隐藏一些实现细节。外部类可以专注于公共接口，而具体的实现细节则留给内部类。</li>
<li><strong>增加代码的模块化：</strong> 将相关的类组织在一起可以使代码更模块化。每个嵌套类可以有自己的职责，这样代码更易于理解和维护。</li>
</ol>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><ol>
<li><p><strong>公有嵌套类</strong>： 如果内部类声明为<code>public</code>，则外部类的任何成员函数、友元或其他类都可以访问内部类。这使得内部类对外可见，允许外部代码直接访问它。</p>
</li>
<li><p><strong>私有嵌套类</strong>：如果内部类声明为<code>private</code>，则只有外部类的成员函数和友元可以访问内部类。外部类的客户端无法直接访问或创建内部类的对象。</p>
</li>
<li><strong>保护嵌套类</strong>： 如果内部类声明为<code>protected</code>，则外部类的成员函数、友元以及继承了外部类的派生类都可以访问内部类</li>
</ol>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h2><p>C语言异常处理机制是：</p>
<ol>
<li>终止程序。缺陷：用户难以接受。如发生内存错误，除0错误时就会终止</li>
<li>返回错误码。缺陷：需要程序员自己去查对应的错误</li>
</ol>
<p>在C++中，异常是一种在程序执行过程中发生的错误或者意外状况。异常提供了一种机制，允许程序员在代码中识别和处理错误，以及在出现错误时进行适当的响应。异常处理是C++中一个重要的编程概念，它使得程序更健壮，更容易维护。</p>
<p>C++中异常处理有三个关键字：<strong>throw、catch、try</strong></p>
<ul>
<li>throw：当问题出现，程序抛出一个异常。抛异常使用throw关键字完成。</li>
<li>catch：用于捕捉异常。<strong>catch(…)</strong>可以捕获任意类型的异常，主要时用来捕获没有显示捕获类型的异常。相当于条件判断中的else。</li>
<li>try：try中包含会出现异常的代码或者函数。后面通常会跟一个或者多个catch块。</li>
</ul>
<p><strong>注意：可以抛出任意类型的对象。抛出的异常必须捕获。try要和catch匹配使用，catch里的内容抛出异常时才执行，没有异常，不执行。</strong></p>
<p><strong>示例</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入被除数和除数:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;除0错误&quot;</span>;<span class="comment">//抛出异常,这里抛出的是字符串类型异常，也可以是对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">test</span>() &lt;&lt; endl;<span class="comment">//会出现异常的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//捕获字符串类型的异常，a即 &quot;除0错误&quot;。</span></span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* a)&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="comment">//捕获任意类型的异常，通常未知异常</span></span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unknow exception&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常的抛出和匹配规则"><a href="#异常的抛出和匹配规则" class="headerlink" title="异常的抛出和匹配规则"></a>异常的抛出和匹配规则</h2><h3 id="异常的抛出"><a href="#异常的抛出" class="headerlink" title="异常的抛出"></a>异常的抛出</h3><ol>
<li><p>异常时通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码。</p>
</li>
<li><p>被选中的处理代码的调用链是，找到于该类型匹配且离抛出异常位置最近的那一个catch。</p>
</li>
<li><p>抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象。</p>
</li>
<li><p>catch(…)可以捕获任意类型的对象，主要是用来捕获没有显示捕获类型的异常，因为如果没有匹配的catch会终止程序。相当于条件判断中的else。问题是不知道异常错误是什么。</p>
</li>
<li><p>实际中抛出和捕获的类型不一定类型完全匹配，可以抛出派生类对象，使用基类来捕获，这个在实际生活中很实用。主要原因是：派生类可以赋值给基类。</p>
</li>
</ol>
<h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><ul>
<li>首先检查throw本身是否在try块内部，如果是，再在当前函数栈中查找匹配的catch语句。如果有匹配的直接跳到catch的地方执行。</li>
<li>如果没有匹配的catch块，则退出当前函数栈，在调用函数的栈中查找匹配的catch。</li>
<li>如果到达main函数的栈，都没有匹配的catch，就会终止程序。</li>
<li>上述沿着调用链查找匹配的catch块的过程叫栈展开。所以实际要最后要加一个catch(…)来捕获任意类型的异常，防止程序终止。</li>
<li>找到匹配的catch会直接跳到catch语句执行，执行完后，会继续沿着catch语句后面执行。</li>
</ul>
<h2 id="异常的重新抛出"><a href="#异常的重新抛出" class="headerlink" title="异常的重新抛出"></a>异常的重新抛出</h2><p> 有可能单个的catch不能完全处理一个异常，<strong>在进行一些矫正处理后，需要交给更外层的调用链函数来处理。</strong>catch可以做完矫正操作，再将异常重新抛出，交给更上层的函数进行处理。</p>
<h2 id="异常安全问题"><a href="#异常安全问题" class="headerlink" title="异常安全问题"></a>异常安全问题</h2><p> 由于抛异常只要找到匹配的catch就直接跳到catch块执行，没有找到对应catch的函数就不会继续执行。这样导致函数的执行流回很乱。可能会导致一些问题。</p>
<ul>
<li><p>构造函数完成对象的构造和初始化，最好不要再构造函数中抛出异常，否则可能导致对象不完整或者没有完全初始化</p>
</li>
<li><p>析构函数主要完成资源的清理，最好不要在析构函数中抛异常，否则可能导致内存泄漏。</p>
</li>
<li><p>C++异常经常会导致资源泄漏问题。比如：在new和delete中抛出异常，导致new出来的资源没有释放，导致内存泄漏。在lock和unlock中抛出异常，导致锁没有释放，导致死锁。</p>
</li>
</ul>
<p>有两种解决办法：</p>
<ul>
<li>将异常捕获，释放资源后，将锁重新抛出。</li>
<li>使用RAII的思想解决。定义一个类封装，管理资源。当要使用时实例化一个类对象，将资源传入，当退出函数，调用对象析构函数，释放资源。</li>
</ul>
<h2 id="异常规范说明"><a href="#异常规范说明" class="headerlink" title="异常规范说明"></a>异常规范说明</h2><ul>
<li><strong>noexcept</strong>：表示函数不抛出异常。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>noexcept(expression)</strong>： 表示如果 <code>expression</code> 求值结果为 <code>true</code>，则函数不抛出异常。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(someExpression())</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>早期的异常规范：</strong> 在早期的C++标准中，可以使用 <code>throw()</code> 表示函数不抛出异常，或者使用 <code>throw(type1, type2, ...)</code> 来指定函数可能抛出的异常类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// 函数不抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">anotherFunction</span><span class="params">()</span> <span class="title">throw</span><span class="params">(std::exception, MyException)</span></span>; <span class="comment">// 函数可能抛出 std::exception 或 MyException</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>现代C++中的 noexcept</strong>： 推荐使用 <code>noexcept</code> 关键字来表示函数是否抛出异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 函数不抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">anotherFunction</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(someExpression())</span></span>; <span class="comment">// 函数在 someExpression() 为 true 时不抛出异常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>异常规范的问题：</strong> 早期的异常规范在实践中并没有提供太多的好处，而且容易导致问题。因此，自C++11开始，异常规范已经被弃用，而 <code>noexcept</code> 关键字更灵活且更安全。</p>
<h2 id="自定义异常体系"><a href="#自定义异常体系" class="headerlink" title="自定义异常体系"></a>自定义异常体系</h2><p> 在实际中，并不是我们想抛什么异常就抛什么异常，这样会导致捕捉的时候不好捕捉。而是，会建立一个继承体系，<strong>建立一个异常类，派生类继承这个类，来定义出不同的异常。</strong></p>
<ul>
<li>到时候抛出异常<strong>，只需要用基类进行捕捉即可</strong></li>
<li>基类可以相当于是一个框架，派生类是具体的异常。然后去具体实现异常的内容，然后<strong>抛异常只需要抛派生类，捕捉异常只需要捕捉基类即可。</strong> ‘</li>
</ul>
<p>下列使用一个简单实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="comment">//异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Exception</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">0</span>):_errmsg(str), _id(id)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>;<span class="comment">//派生类中输出的指定异常信息</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _errmsg;<span class="comment">//错误信息</span></span><br><span class="line">    <span class="type">int</span> _id;<span class="comment">//错误码</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="comment">//数据库异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SqlException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">1</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//网络异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">2</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//缓存异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CacheException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">3</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当网络连接失败，抛出这个异常即可</span></span><br><span class="line">    <span class="comment">//throw HttpException(&quot;Http fail&quot;, 2);</span></span><br><span class="line">    <span class="comment">//当缓存错误,抛出这个异常</span></span><br><span class="line">    <span class="comment">//throw CacheException(&quot;Cache error&quot;, 3);</span></span><br><span class="line">    <span class="comment">//当数据库错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">SqlException</span>(<span class="string">&quot;Sql error&quot;</span>, <span class="number">4</span>);<span class="comment">//抛出派生类异常对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//捕获基类异常，</span></span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> Exception&amp; a)&#123;</span><br><span class="line">        a.<span class="built_in">what</span>();<span class="comment">//输出错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unknow exception&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-标准库的异常体系"><a href="#C-标准库的异常体系" class="headerlink" title="C++标准库的异常体系"></a>C++标准库的异常体系</h2><p> 在C++库中也建立了一个异常体系。也给我们提供了一些异常类。我们可以在程序中使用这些标准异常，它们也是以父子类层次结构组织起来的。</p>
<ul>
<li>基类：std::exception</li>
<li>派生类：std::runtime_error等</li>
</ul>
<h2 id="异常优缺点"><a href="#异常优缺点" class="headerlink" title="异常优缺点"></a>异常优缺点</h2><p><strong>优点</strong>：</p>
<ul>
<li>异常对象定义好了，相比较于错误码，可以清晰准确的展示出错误的各种信息，甚至包含堆栈调用信息，可以帮我们很好的定位程序的bug。</li>
<li>在函数调用链中，深层函数返回错误，我们得层层返回，需要不断的判断是什么错误，再返回给最外层。异常直接会找到对应的catch执行，不需要判断是什么错误。</li>
<li>部分函数更好处理，比如没有返回值的函数或者返回值为自身的T&amp; operator，不好返回错误码。并且pos越界了，内存错误等不需要终止程序。</li>
<li>更好的进行测试代码</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>异常导致执行流乱跳，运行混乱。导致我们调试和分析程序时，比较困难。</li>
<li>C++没有垃圾回收机制，可能会导致异常安全问题。开辟的资源和打开的流，由于执行流乱跳，导致没有释放和关闭等。导致内存泄漏。打开的锁为关闭，导致死锁。</li>
<li>C++标准库的异常体系定义不好，导致我们需要各自定义各自的体系，非常混乱。</li>
<li>随意抛异常，外层不好捕获，所以尽量按找异常规范使用。</li>
</ul>
<h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p>在C++中，RTTI是<strong>运行阶段类型识别</strong>的简称（Runtime Type Identification）。它允许在程序运行时获取对象的类型信息。是新添加到C++中的特性之一，很多老式实现不支持。主要用途包括：</p>
<ol>
<li><strong>识别对象类型：</strong> RTTI允许在程序运行时确定对象的类型。这对于处理多态性和动态多态性（dynamic polymorphism）非常有用。例如，在一个基类的指针或引用指向派生类对象时，你可以使用RTTI来确定实际派生类的类型。</li>
<li><strong>安全的类型转换：</strong> 在某些情况下，你可能需要将基类指针或引用安全地转换为派生类指针或引用。RTTI的<code>dynamic_cast</code>运算符可用于执行这种安全的转换，它会在转换之前检查类型信息，如果转换不安全，<strong>它会返回空指针或引发异常</strong>，而不是导致未定义行为。</li>
<li><strong>类型检查：</strong> RTTI允许你在运行时检查对象的类型信息，从而采取相应的措施。这对于实现一些通用的算法或框架，需要根据对象的类型来执行不同的操作，非常有用。</li>
<li><strong>异常处理：</strong> 在一些情况下，RTTI可用于处理异常。当在基类指针或引用上使用<code>dynamic_cast</code>时，如果转换失败，会返回空指针或引发<code>std::bad_cast</code>异常，可以在异常处理中捕获。</li>
</ol>
<p>C++中有三个支持RTTI的元素</p>
<ul>
<li>dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针，否则，该运算符返回空指针-0</li>
<li>typeid运算符返回一个指出对象的类型的值</li>
<li>type_info结构储存了有关特定类型的信息</li>
</ul>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p><strong>dynamic_cast 操作符</strong>：<code>dynamic_cast</code> 用于在运行时执行安全的类型转换，主要用于处理继承关系。它可以将指向基类的指针或引用转换为派生类的指针或引用，同时执行类型检查。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">   Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (derivedPtr != <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Successfully casted to Derived.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Failed to cast to Derived.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> basePtr;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Derived&amp; derivedRef = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(*basePtr);</span><br><span class="line">    <span class="comment">// 成功转换</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_cast&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在一些情况下，RTTI可用于处理异常。当在基类指针或引用上使用dynamic_cast时，如果转换失败，会返回空指针或引发std::bad_cast异常，可以在异常处理中捕获。*/</span></span><br></pre></td></tr></table></figure>
<h3 id="typeid和type-info"><a href="#typeid和type-info" class="headerlink" title="typeid和type_info"></a>typeid和type_info</h3><p><strong>typeid运算符</strong>：</p>
<ul>
<li><strong>用途：</strong> <code>typeid</code>运算符用于在运行时获取对象的类型信息。它返回一个<code>const std::type_info&amp;</code> 对象，该对象包含有关实际类型的信息，其中type_info是在头文件typeinfo(以前是typeInfo.h)中定义的一个类。。</li>
<li><strong>语法：</strong> <code>typeid(expression)</code>，其中<code>expression</code>是一个表达式，通常是<strong>一个对象或一个类型</strong>。</li>
</ul>
<p><strong>type_info类</strong>：</p>
<ul>
<li><strong>用途：</strong> <code>type_info</code>是一个类，表示类型信息。它包含有关类型的信息，例如类型的名称。</li>
<li><strong>成员函数：</strong><ul>
<li><strong><code>name()</code>：</strong> 返回一个指向包含类型名称的C字符串的指针。请注意，这个名称的格式是实现定义的，可能在不同编译器和平台上有所不同。</li>
<li><strong>其他成员函数：</strong> 可能会有其他一些实现特定的成员函数，但标准并没有规定。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="type">const</span> std::type_info&amp; typeInfo = <span class="built_in">typeid</span>(*basePtr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object type: &quot;</span> &lt;&lt; typeInfo.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>typeid运算符使得能够确定两个对象是否为同种类型。type_info类重载了==和!运算符，可以使用这些运算符来对类型比较。</strong></p>
<p><strong>例如</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> Base;</span><br><span class="line">    Derived* derivedPtr = <span class="keyword">new</span> Derived;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Base) == <span class="built_in">typeid</span>(*basePtr)) &lt;&lt; std::endl;<span class="comment">//(*basePtr表示指向的对象)相同,返回值1</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Base) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//返回值0</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Derived) == <span class="built_in">typeid</span>(*basePtr)) &lt;&lt; std::endl;<span class="comment">//返回值0</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Derived) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//返回值1</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(*basePtr) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//,对象不同返回值0</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">delete</span> derivedPtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>C++学习笔记</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.thekqd.top/posts/ad4f1e09.html">https://www.thekqd.top/posts/ad4f1e09.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>walnut🍭</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-02-21</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-02-21</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>C++</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/d29d5856.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/16.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++的关键字用法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/d29d5856.html" title="C++的关键字用法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/16.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-02-21</div><div class="title">C++的关键字用法</div></div></a></div><div><a href="/posts/f28c0c7b.html" title="学生管理程序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/5.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-07-18</div><div class="title">学生管理程序</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A"><span class="toc-text">C++学习笔记：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4std"><span class="toc-text">名称空间std</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%AC%A6endl"><span class="toc-text">控制符endl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cin%E5%92%8Ccout"><span class="toc-text">cin和cout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E6%AC%A1%E8%AF%BB%E5%8F%96%E4%B8%80%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2-string-%E8%BE%93%E5%85%A5"><span class="toc-text">每次读取一行字符串(string)输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5"><span class="toc-text">补:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#string%E7%B1%BB-%E5%A4%B4%E6%96%87%E4%BB%B6%E2%80%9Dstring%E2%80%9D"><span class="toc-text">string类(头文件”string”)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-text">补：获取字符串长度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81"><span class="toc-text">数组的替代品</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BBvector"><span class="toc-text">模板类vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-vector%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%89"><span class="toc-text">1.3 vector对象的常用内置函数使用（举例说明）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#size"><span class="toc-text">size()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#empty"><span class="toc-text">empty()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swap-swap-%E4%BA%A4%E6%8D%A2"><span class="toc-text">swap()         swap(交换)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insert-insert-%E6%8F%92%E5%85%A5"><span class="toc-text">insert()      insert(插入)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NULL%E5%92%8Cnullptr"><span class="toc-text">NULL和nullptr</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">对类的定义：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%8F%98%E9%87%8F%EF%BC%89%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">类对象（变量）的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8Cdelete%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"><span class="toc-text">new分配内存空间，delete释放内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-New"><span class="toc-text">1.New</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Delete"><span class="toc-text">2.Delete</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">C++中文件的输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E5%88%B0%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-text">写入到文本文件中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">从文本文件中读取数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E8%A2%AB%E6%88%90%E5%8A%9F%E6%89%93%E5%BC%80%E7%9A%84%E9%A6%96%E5%85%88%E6%96%B9%E6%B3%95%E6%98%AF%E4%BD%BF%E7%94%A8is-open-%E6%97%A0%E5%8F%82%E6%95%B0"><span class="toc-text">检查文件是否被成功打开的首先方法是使用is_open(无参数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%BB%93%E5%B0%BE%E7%9A%84%E5%88%A4%E6%96%AD%E4%BD%BF%E7%94%A8-eof%EF%BC%88%E6%97%A0%E5%8F%82%E6%95%B0%EF%BC%89-gt-end-of-file-EOF"><span class="toc-text">文件读取结尾的判断使用 eof（无参数）-&gt;end of file &#x3D;EOF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD"><span class="toc-text">文件的打开和关闭</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数和析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">运算符重载的概念和原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E9%99%90%E5%88%B6"><span class="toc-text">运算符重载限制:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">继承的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%9Ais-a-%E5%85%B3%E7%B3%BB"><span class="toc-text">继承：is-a 关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">继承的格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">继承的总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-text">多态公有继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95"><span class="toc-text">虚方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">虚析构函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-text">静态联编和动态联编</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">初始化列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8"><span class="toc-text">什么时候必须使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-text">建议使用的地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-text">优点和缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8using-%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-text">使用using 重新定义访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">多重继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-text">二义性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">类模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8C%BA%E5%88%AB"><span class="toc-text">类模板与函数模板区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-text">类模板成员函数实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="toc-text">成员模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">类模板对象做函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E6%A8%A1%E6%9D%BF%E5%81%9A%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%8F%82%E6%95%B0"><span class="toc-text">将模板做模板类参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text">类模板与继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%92%8C%E5%8F%8B%E5%85%83"><span class="toc-text">模板类和友元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-text">类模板成员函数创建时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99-%E9%87%8D%E8%A6%81"><span class="toc-text">类模板分文件编写(重要)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%88%AB%E5%90%8D-C-11"><span class="toc-text">模板别名(C++11)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-text">友元类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">友元成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">友元的优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-text">嵌套类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-text">访问控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%A6%82%E5%BF%B5"><span class="toc-text">异常概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA%E5%92%8C%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-text">异常的抛出和匹配规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA"><span class="toc-text">异常的抛出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-text">匹配规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA"><span class="toc-text">异常的重新抛出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">异常安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%A7%84%E8%8C%83%E8%AF%B4%E6%98%8E"><span class="toc-text">异常规范说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-text">自定义异常体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-text">C++标准库的异常体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">异常优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RTTI"><span class="toc-text">RTTI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic-cast"><span class="toc-text">dynamic_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeid%E5%92%8Ctype-info"><span class="toc-text">typeid和type_info</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/img/avatar.webp" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.thehsp.cn/" title="thehsp"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.postimg.cc/hG3dPJgH/fda91706f29ff4047883c4b7b84449e.jpg" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By walnut🍭</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/Linux/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 Linux (9)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/嵌入式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍼 嵌入式学习笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/C/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 C++学习笔记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/数据结构与算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 数据结构与算法 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/MySQL/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 数据库笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.thekqd.top/categories/演示/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 Markdown (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://www.thekqd.top/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #69e8f2}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/18.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/aa76cb12.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/15.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/aa76cb12.html&quot;);" href="javascript:void(0);" alt="">线程池C++版</a><div class="blog-slider__text">线程池C++版</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/aa76cb12.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f2e69609.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/36.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f2e69609.html&quot;);" href="javascript:void(0);" alt="">MySQL通用语法及操作</a><div class="blog-slider__text">MySQL的相关知识包括基础篇、进阶篇和运维篇,学习自黑马</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f2e69609.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/174bd570.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/11.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/174bd570.html&quot;);" href="javascript:void(0);" alt="">socket</a><div class="blog-slider__text">socket网络编程</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/174bd570.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/15fc6e8c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/26.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-07-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/15fc6e8c.html&quot;);" href="javascript:void(0);" alt="">多线程</a><div class="blog-slider__text">线程相关知识（pthread）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/15fc6e8c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>