<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thedi的仓库</title>
  
  
  <link href="https://www.thekqd.top/atom.xml" rel="self"/>
  
  <link href="https://www.thekqd.top/"/>
  <updated>2025-01-22T07:09:49.538Z</updated>
  <id>https://www.thekqd.top/</id>
  
  <author>
    <name>Thedi🍭</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STM32(标准库)</title>
    <link href="https://www.thekqd.top/posts/cb085122.html"/>
    <id>https://www.thekqd.top/posts/cb085122.html</id>
    <published>2025-01-13T13:48:37.000Z</published>
    <updated>2025-01-22T07:09:49.538Z</updated>
    
    <content type="html"><![CDATA[<h1>keil配置与芯片包下载</h1><h2 id="固件库文件">固件库文件</h2><p>以F103固件库为例：</p><p>STM32F10x_StdPeriph_Lib_V3.5.0固件库是为STM32F1系列微控制器设计的开发辅助库，主要用于简化对STM32F1外设的控制和配置。该库封装了对各类外设（如GPIO、ADC、USART、SPI、I2C等）的控制接口，使开发者无需直接操作复杂的寄存器就能使用这些硬件外设。通过它，开发者可以轻松地进行外设的初始化、配置和数据处理。</p><p><strong>主要结构</strong>：</p><ul><li><strong>_htmresc</strong>：图片没什么用</li><li><strong>Libraries</strong>：库函数的文件，我们之后建工程时会用<ul><li><strong>CMSIS</strong>：包含Cortex-Mx内核的相关定义和启动代码。<ul><li>CoreSupport：包含了与Cortex-M系列内核相关的文件，主要是一些适用于ARM Cortex-M内核的通用代码和数据结构，用于管理核心处理器功能。</li><li>DeviceSupport：含与特定厂商的微控制器设备相关的文件，特别是该设备特定的外设寄存器定义和访问方法。它提供了Cortex-M内核之外的硬件支持，适用于具体的MCU型号。</li></ul></li><li><strong>STM32F10x_StdPeriph_Driver</strong>：<strong>标准外设驱动库</strong>，包含STM32F1系列的外设驱动源文件和头文件。</li></ul></li><li><strong>Projects</strong>：是官方提供的工程示例和模板，使用库函数时可以参考</li><li><strong>Utilities</strong>：是STM32官方评估板的相关例程，这个评估版就是官方用STM32做的一个小电路板用来测评STM32的，文件夹内存放的就是小电路板的测评程序</li><li><strong>Release_Notes.html</strong>：这个是库函数的发布文档</li><li><strong>stm32f10x_stdperiph_lib_um.chm</strong>：使用手册，教大家如何使用库函数</li></ul><h2 id="keil新建工程">keil新建工程</h2><ol><li>新建一个 new μVision Project，设置名称后，会出现选择芯片，如果只有ARM，则需要将官方的芯片包(在官方下载.pack文件)导入。</li></ol><blockquote><p>最后会弹出来Manage Run-time Environment的界面，manage run-time environment是一个新建工程的小助手也有固件库，可以帮我快速建立工程，直接勾选即可，是keil5的新功能**。今天我们创建工程的方式是自己去搬运官网给的库，加深一下理解和增加动手能力，所以没有使用manage run-time environment来添加库，直接点击OK即可**</p></blockquote><p>此时就只有一个Target里面什么都没有，我们需要给它添加一点工程的必要文件。</p><p>此时我们可以看到刚刚创建的项目文件夹自动生成一堆文件夹，为了便于管理<strong>我们先在工程文件夹中创建一个Startup文件夹用于存放启动文件</strong></p><ol start="2"><li>此时打开固件库文件夹-&gt;“STM32F10x_StdPeriph_Lib_V3.5.0”-“Libraries”-“CMSIS”-“CM3”-“DeviceSupport”-“ST”-“STM32F10x”-“startup”，然后选中全部一起复制到刚刚我们创建的Startup文件夹中。</li></ol><blockquote><p>这些就是STM32的启动文件，STM32程序就是从这些启动文件开始执行的</p></blockquote><ol start="3"><li>“Libraries”-“CMSIS”-“CM3”-“DeviceSupport”-“ST”-“STM32F10x，我们把这三个文件也复制下来粘贴到Startup文件夹下</li></ol><blockquote><p>我们可以看到stm32f10x.h和两个system开头的文件</p><p>stm32f10x.h：是STM32的<strong>外设寄存器描述文件，用来描述STM32有哪些寄存器和它对应的地址。</strong></p><p>system文件：这个两个system文件(system_stm32f10x.c/h)用于配置时钟，STM32F103主频72MHz就是在system文件里配置的。</p></blockquote><hr><p><strong>接下来，因为STM32是内核和内核外围设备(外设)组成的，而且内核的寄存器描述和外围设备的描述文件不是在一起的，所以我们还需要添加内核寄存器的描述文件</strong></p><ol start="4"><li>进入“STM32F10x_StdPeriph_Lib_V3.5.0”-“Libraries”-“CMSIS”-“CM3”-“CoreSupport”。然后也把这两个相关内核相关的文件复制到Startup文件后所有的准备完成</li></ol><blockquote><p>里面有两个cm3(core_cm3.c和core_cm3.h)，这两个Cortex-M3文件就是<strong>内核的寄存器描述文件</strong>，还有一些内核配置函数</p></blockquote><ol start="5"><li>返回keil中将刚刚的文件添加到工程中，在Target 1中add group然后将新建的文件夹改名为Startup，将刚刚所有的Startup文件夹中的文件添加进去。</li></ol><blockquote><ol><li><p>首先是启动文件的添加，有一堆startup文件，我们选择其中的一个startup_stm32f10x_md.s添加到工程中。</p><p><strong>有关启动文件的选择，请看下面的笔记</strong></p></li><li><p>然后剩下的所有.c和.h文件都要添加进去</p></li></ol><p>我们可以按住Ctrl键，然后依次选择他们，点击Add，Close即可</p><p>这里的文件都是STM32里最基本的文件，是不需要我们修改的，添加到工程即可，此时可以看到这些文件都带有钥匙图标，代表只读文件</p></blockquote><ol start="6"><li>点击魔术棒，打开工程选项，在C/C++中找到include Paths，添加Startup文件夹的路径至其中。</li></ol><blockquote><p>最后我们还要在工程选项里添加上该文件夹的头文件路径，否则找不到.h文件</p></blockquote><ol start="7"><li>回到该项目的文件夹下，新建一个User文件夹，main函数就放在其中。再回到keil中，在Target添加一个组，改名为User，对其右键创建main.c到其中，此时在main.c中创建我们的main函数，进行开发即可。</li></ol><p><code>由于此时工程还没有添加STM32的库函数，所以是基于寄存器开发工程，如果想要使用寄存器开发那么到这里就可以结束了</code></p><hr><p><code>接下来继续添加库函数</code></p><ol start="8"><li>打开项目文件夹，新建Library文件夹用于存放库函数，接着打开固件库的文件夹，“STM32F10x_StdPeriph_Lib_V3.5.0”-“Libraries”-“STM32F10x_StdPeriph_Driver”-“src”，全选复制粘贴到Library中去，然后再回到Inc中去，再次将头文件全部复制粘贴到Library中去。</li></ol><blockquote><ol><li><p>其中misc.c是内核的库函数</p></li><li><p>其他的就是外设库函数</p></li></ol></blockquote><ol start="9"><li>回到keil中，在Target下添加一个组命名为Library，再将Library文件夹中的所有文件添加到工程中去，但是此时的库函数还不能直接使用，我们还需要在添加文件。继续打开固件库文“STM32F10x_StdPeriph_Lib_V3.5.0”-“Project”-“STM32F10x_StdPeriph_Template”中，把一个conf.h文件和两个it中断文件复制粘贴到User文件下，<strong>回到keil中将这三个文件添加到User的组中</strong></li></ol><blockquote><p>我们可以看到一个stm32f10x_conf.h的文件，这个config文件是用来配置库函数头文件包含关系，以及用来参数检查的函数定义，这是所有库函数都需要的</p><p>两个stm32f10x_it.c/h文件是用来存放中断函数的</p></blockquote><ol start="10"><li>最后我们还需要一个宏定义USE_STDPERIPH_DRIVER，我们打开<strong>b</strong>，切换到C/C++中，在Define中添加&quot;USE_STDPERIPH_DRIVER&quot;，最后别忘了在下方的include Paths再将User和Library目录的路径添加进去。</li></ol><blockquote><p>我们可以在stm32f10x.h文件中的最下方看到有一段</p><p>#ifdef USE_STDPERIPH_DRIVER<br>#include “stm32f10x_conf.h”<br>#endif</p><p>这个的意思是如果定义了USE_STDPERIPH_DRIVER(使用标准外设驱动)这个宏定义，才会包含stm32f10x_conf.h，即才会生效。</p><p><code>由于stm32f10x_conf.h文件包含了所有库函数的头文件，所以我们只需要include stm32f10x.h文件就可以任意调用库函数了</code></p></blockquote><p>最终我们的基本模板为：</p><blockquote><ul><li>DebugConfig</li><li>Listings</li><li>Objects</li><li>Library</li><li>Startup</li><li>User</li></ul><p>前三个为创建项目后自动生成的文件夹，后三个为我们手动创建的。</p></blockquote><p><code>一定记得将所有带有头文件的目录添加到C/C++的include Paths中以便于编译器能够找到头文件</code></p><h2 id="启动文件的选择">启动文件的选择</h2><p>我们在新建工程向Startup文件夹添加启动文件的时候，有一堆startup文件。当时我们选择其中的一个startup_stm32f10x_md.s添加到工程中。</p><p>现在来解释一下这个文件怎么选取：</p><p><strong>启动文件有很多类型，至于选择哪一个，我们要根据芯片的型号来选择</strong></p><p>看这张表：</p><blockquote><p>缩写                                翻译             FLASH容量        型号</p><p>LD(High Density)       小容量产品        16-32K             STM32F101/102/103</p><p>MD(Middle Density)      中容量产品      64-128K             STM32F101/102/103</p><p>HD(High Density)       大容量产品     256-512K             STM32F101/102/103</p><p>XL(Extra Large)       加大容量产品    大于512K             STM32F101/102/103</p><p>CL                                互联网产品       -                           STMF105/107</p><p>LD_VL(value line)       小容量产品超值系列        16-32K             STM32F100</p><p>MD_V                      中容量产品超值系列      64-128K             STM32F100</p><p>HD_VL                     大容量产品超值系列     256-512K             STM32F100</p></blockquote><ol><li><strong>先根据型号选择是哪个系列的启动文件</strong></li><li><strong>根据Flash容量选择对应的启动文件添加到Startup即可</strong></li></ol><h2 id="stm32f10x-h">stm32f10x.h</h2><p>我们可以在stm32f10x.h文件中的最下方看到有一段</p><p>#ifdef USE_STDPERIPH_DRIVER<br>#include “stm32f10x_conf.h”<br>#endif</p><p>这个的意思是如果定义了USE_STDPERIPH_DRIVER(使用标准外设驱动)这个宏定义，才会包含stm32f10x_conf.h，即才会生效。</p><p><code>由于stm32f10x_conf.h文件包含了所有库函数的头文件，所以我们只需要在编程的时候include stm32f10x.h文件就可以任意调用库函数了</code></p><h2 id="新建工程步骤总结">新建工程步骤总结</h2><ol><li><strong>建立工程文件夹，Keil中新建工程、选择型号</strong></li><li><strong>工程文件夹中建立Startup、Library、User等文件夹，复制固件库里面的文件到工程文件夹</strong></li><li><strong>工程里对应建立Start、Library、User等同名称的分组，并将文件夹内的文件添加到工程分组里</strong></li><li><strong>工程选项(魔法棒)，C/C++ Include Paths内添加所有包含头文件的文件夹</strong></li><li><strong>工程选项(魔法棒)，C/C++，Define中定义宏定义USE_STDPERIPH_DRIVER</strong></li><li><strong>工程选项(魔法棒)，Debug，下拉列表选择对应调试器，Settings，Flash，Download里勾选Reset and Run</strong></li></ol><h1>模块化编程</h1><p>如果我们把所有的初始化代码都写到main函数中就会显得很杂乱，为此我们单独创建一个Hardware文件夹用于存放各外设驱动(LED.c，LED.h，Key.c，Key.h等)</p><ol><li>在项目文件夹下创一个Hartware文件夹</li><li>回到keil中添加一个名为Hardware的组，然后添加或创建对应外设驱动的文件。</li><li>将Hardware添加到魔法棒中的C/C++的include Paths中</li></ol><p>最终我们的基本模板为：</p><blockquote><ul><li>DebugConfig</li><li>Listings</li><li>Objects</li><li>Library</li><li>Startup</li><li><strong>Hardware</strong></li><li>User</li></ul><p>前三个为创建项目后自动生成的文件夹，后四个个为我们手动创建的。</p></blockquote><p>例如在Hardware里的，LED驱动函数就是这样写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_ON</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_OFF</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_ON</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_OFF</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Turn</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_6 | GPIO_Pin_7);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_ON</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOC,GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Turn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadOutputDataBit(GPIOC,GPIO_Pin_2)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(GPIOC,GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOC,GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>所有的外设都可以这样独立写成驱动函数，初始化函数等。这样使的项目更好管理</p></blockquote><h1>STM32启动文件</h1><p>startup_stm32xx.s就是启动文件，这是一个用汇编写的文件，定义了中断向量表和中断服务函数等。启动有个复位中断是程序的入口，当stm32按下复位或者上电的时候，程序就会进入复位中断函数执行，复位中断函数做的就是调用SystemInit函数和调用main函数。</p><p>我们可以在启动文件文件的注释中知道流程为：</p><ol><li>初始化堆栈指针SP</li><li>初始化程序计数器PC为Reset_Handler</li><li>初始化堆、栈的大小</li><li>设置中断向量表的入口地址</li></ol><p>转向Reset_Handler执行：</p><ol start="5"><li>调用SystemInit()函数完成系统初始化(系统时钟、闪存接口配置等)</li><li>设置C库的分支入口为 __main(调用我们的main函数)</li></ol><hr><h1>GPIO</h1><ul><li><p>GPIO(General Purpose Input Output) 通用输入输出端口，可配置共8种输入输出模式。</p></li><li><p>引脚电平位0~3.3V，部分引脚可以容忍5V</p></li><li><p>输出模式下可控制端口输出高低电平，用于驱动LED，控制蜂鸣器，模拟通信协议输出时序</p></li><li><p>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</p></li></ul><p><a href="https://blog.csdn.net/qq_44016222/article/details/123206403?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stm32GPIO&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-123206403.nonecase&amp;spm=1018.2226.3001.4187">STM32-GPIO介绍_stm32 gpio-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_52162042/article/details/121278274?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%BC%B1%E4%B8%8A%E6%8B%89%E5%92%8C%E5%BC%BA%E4%B8%8A%E6%8B%89&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-121278274.142%5Ev100%5Epc_search_result_base6&amp;spm=1018.2226.3001.4187">上、下拉电阻（定义、强弱上拉、常见作用、吸电流、拉电流、灌电流）_弱上拉和强上拉的区别-CSDN博客</a></p><p><strong>操作stm32的GPIO分为三个步骤</strong>：</p><ol><li><strong>使用RCC开启GPIO时钟</strong></li><li><strong>使用GPIO_Init(库函数)函数初始化GPIO</strong></li><li><strong>使用输出或输入函数控制GPIO口</strong></li></ol><h2 id="RCC开启时钟">RCC开启时钟</h2><p>在stm32f10x_rcc.h中，有很多RCC相关函数但是我们最常用的是这三个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*RCC AHB总线外设时钟控制*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*RCC APB2总线外设时钟控制*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*RCC APB1总线外设时钟控制*/</span></span><br></pre></td></tr></table></figure><blockquote><p>我们可以跳到这些函数的定义查看注释我们可以知道，这些时钟控制函数就是<code>使能或失能外设时钟的</code></p><p>参数1：选择外设</p><p>参数2：使能或失能</p><p>如果不知道该外设是否在这个总线上，我们可以在注释上面的列表看，如果出现了代表在这个总线上</p></blockquote><h2 id="GPIO标准库函数">GPIO标准库函数</h2><p>在stm32f10x_gpio.h中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_DeInit</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">/*指定GPIO外设被复位*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_AFIODeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*指定AFIO复位*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">/*初始化外设，为指定的GPIO初始化，使用的是我们自己创建的结构体*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_StructInit</span><span class="params">(GPIO_InitTypeDef* GPIO_InitStruct)</span>;</span><br><span class="line"><span class="comment">/*指定结构体赋值*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadInputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadInputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">GPIO_ReadOutputDataBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GPIO_ReadOutputData</span><span class="params">(GPIO_TypeDef* GPIOx)</span>;</span><br><span class="line"><span class="comment">/*GPIO读取函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;<span class="comment">//指定端口拉高</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;<span class="comment">//指定端口拉低</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_WriteBit</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin, BitAction BitVal)</span>;<span class="comment">//端口写入指定值：Bit_SET或Bit_RESET</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Write</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> PortVal)</span>;</span><br><span class="line"><span class="comment">/*读写GPIO函数*/</span></span><br></pre></td></tr></table></figure><ul><li>对应GPIO的结构体定义如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> GPIO_Pin;             <span class="comment">/*!&lt; Specifies the GPIO pins to be configured.</span></span><br><span class="line"><span class="comment">                                      This parameter can be any value of @ref GPIO_pins_define */</span></span><br><span class="line"></span><br><span class="line">  GPIOSpeed_TypeDef GPIO_Speed;  <span class="comment">/*!&lt; Specifies the speed for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */</span></span><br><span class="line"></span><br><span class="line">  GPIOMode_TypeDef GPIO_Mode;    <span class="comment">/*!&lt; Specifies the operating mode for the selected pins.</span></span><br><span class="line"><span class="comment">                                      This parameter can be a value of @ref GPIOMode_TypeDef */</span></span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure><blockquote><p><strong>标准库的GPIO_InitTypeDef结构体参数只有三个：mode、pin、speed</strong></p><p><strong>这些跳转到对应定义可以知道值</strong></p><p>HAL库有5个参数，对比起来标准库更简单了</p></blockquote><h2 id="具体流程代码">具体流程代码</h2><p>假设我们需要点亮PC2的LED，查看手册后发现挂载再APB2总线上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1.开启对应外设时钟*/</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2. 初始化GPIOC*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    <span class="comment">//定义GPIO_InitStructure结构体，三个参数赋值</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    <span class="comment">//调用GPIO_Init初始化对应GPIO口，函数中读取结构体自动配置写入到对应寄存器</span></span><br><span class="line">GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验-LED流水灯">实验-LED流水灯</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_WriteBit(GPIOC,GPIO_Pin_2,Bit_RESET);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_WriteBit(GPIOC,GPIO_Pin_2,Bit_SET);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_WriteBit(GPIOC,GPIO_Pin_3,Bit_RESET);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_WriteBit(GPIOC,GPIO_Pin_3,Bit_SET);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*使用Write函数同时操控多个端口*/</span></span><br><span class="line"> <span class="comment">//GPIO_Write(GPIOC,~0x0004);</span></span><br><span class="line"><span class="comment">//Delay_ms(500);</span></span><br><span class="line"><span class="comment">//GPIO_Write(GPIOC,0x0004);</span></span><br><span class="line"><span class="comment">//Delay_ms(500);</span></span><br><span class="line"><span class="comment">//GPIO_Write(GPIOC,~0x0008);</span></span><br><span class="line"><span class="comment">//Delay_ms(500);</span></span><br><span class="line"><span class="comment">//GPIO_Write(GPIOC,0x0008);</span></span><br><span class="line"><span class="comment">//Delay_ms(500);</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当有多个引脚时，我们可以使用<strong>按位或的方式同时选中多个Pin</strong>：</p><p>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | …;      选中了Pin2和Pin3</p><p>我们来看对应定义：</p><p>#define GPIO_Pin_0                 ((uint16_t)0x0001)<br>#define GPIO_Pin_1                 ((uint16_t)0x0002)</p><p>#define GPIO_Pin_3                 ((uint16_t)0x0008)</p><p>…</p><p>#define GPIO_Pin_15                ((uint16_t)0x8000)</p><p>#define GPIO_Pin_All               ((uint16_t)0xFFFF)</p><p><code>一共16位，每一个引脚对应一个位，只需要使用按位或的操作既可以选中指定端口</code></p></blockquote><p><strong>知道这个后我们可以使用GPIO_Write函数同时操控多个端口：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*由于C语言不支持写2进制，故使用16进制来写*/</span></span><br><span class="line">GPIO_Write(GPIOC,~<span class="number">0x0004</span>);<span class="comment">//~(0000 0000 0000 0100),pin2亮</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOC,<span class="number">0x0004</span>);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOC,~<span class="number">0x0008</span>);<span class="comment">//~(0000 0000 0000 1000),pin3亮</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOC,<span class="number">0x0008</span>);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用Systick实现的延时函数，直接使用即可</strong>，使用时创建一个System文件夹，并把他们放到System文件夹下，在keil创建System组即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Delay.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint32_t</span> us)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">uint32_t</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_s</span><span class="params">(<span class="type">uint32_t</span> s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Delay.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  微秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xus 延时时长，范围：0~233015</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint32_t</span> xus)</span></span><br><span class="line">&#123;</span><br><span class="line">SysTick-&gt;LOAD = <span class="number">72</span> * xus;<span class="comment">//设置定时器重装值</span></span><br><span class="line">SysTick-&gt;VAL = <span class="number">0x00</span>;<span class="comment">//清空当前计数值</span></span><br><span class="line">SysTick-&gt;CTRL = <span class="number">0x00000005</span>;<span class="comment">//设置时钟源为HCLK，启动定时器</span></span><br><span class="line"><span class="keyword">while</span>(!(SysTick-&gt;CTRL &amp; <span class="number">0x00010000</span>));<span class="comment">//等待计数到0</span></span><br><span class="line">SysTick-&gt;CTRL = <span class="number">0x00000004</span>;<span class="comment">//关闭定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  毫秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xms 延时时长，范围：0~4294967295</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">uint32_t</span> xms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(xms--)</span><br><span class="line">&#123;</span><br><span class="line">Delay_us(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  秒级延时</span></span><br><span class="line"><span class="comment">  * @param  xs 延时时长，范围：0~4294967295</span></span><br><span class="line"><span class="comment">  * @retval 无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_s</span><span class="params">(<span class="type">uint32_t</span> xs)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(xs--)</span><br><span class="line">&#123;</span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="输入模式">输入模式</h2><h2 id="GPIO相关寄存器">GPIO相关寄存器</h2><p>查看芯片对应参考手册，结合对应代码可以得知如何使用GPIO相关寄存器</p><h2 id="引脚重映射-复用功能重映像">引脚重映射(复用功能重映像)</h2><p>在<code>参考手册</code>中，有一节复用功能I/O和调试配置(AFIO)，这一章节专门就是讲的引脚复用重映像功能，手册描述如下：</p><p>为了优化64脚或100脚封装的外设数目，可以把一些复用功能重新映射到其他引脚上。设置复用重映射和调试I/O配置寄存器(AFIO_MAPR)实现引脚的重新映射。这时，复用功能不再映射到它们的原始分配</p><blockquote><p>如果多个外设需要使用同一组引脚，默认引脚的配置可能会导致冲突。引脚重映像允许开发者重新分配功能到其他引脚，避免资源冲突。<br><strong>实际意义：</strong><br>在复杂系统中，可以高效利用芯片的引脚资源，而不用为了冲突放弃某些外设功能。</p><p>例如：</p><ul><li>需要同时使用<code>USART1</code>和<code>SPI1</code>，但两者默认引脚有重叠。</li><li>通过重映像将<code>USART1</code>从<code>PA9/PA10</code>移到<code>PB6/PB7</code>，释放<code>PA9/PA10</code>供其他功能使用。</li><li>这样我们就可以同时使用<code>USART1</code>和<code>SPI1</code>了</li></ul></blockquote><p><strong>对应库函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinRemapConfig</span><span class="params">(<span class="type">uint32_t</span> GPIO_Remap, FunctionalState NewState)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数1：对应外设重映射方式，一般是部分重映像或者完全重映像，具体查看对应手册</span></span><br><span class="line"><span class="comment"> * 参数2：是否是能</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>使用方式</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1.开启AFIO时钟*/</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line">    <span class="comment">/*2.选择对应外设的映射，映射方式即可*/</span></span><br><span class="line">GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2,ENABLE);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);</span></span><br><span class="line">    <span class="comment">/*接触JTAG复用，以便于TIM2能够重映射/</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意使用端口映射前，可能有些端口已经被占用了，比如调试端口JTAG，如果重映射使用的是调试端口，那么使用前需要先解除JTAG端口复用</p></blockquote><h1>EXTI(外部中断)</h1><h2 id="介绍">介绍</h2><p><strong>EXTI可以监测指定的GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序。</strong></p><p><strong>支持的触发方式</strong>：上升沿/下降沿/双边沿/软件触发</p><p><strong>支持的GPIO口</strong>：所有GPIO口，但相同的Pin不能同时触发中断(如：PA1与PB1与PC1之间)</p><p><strong>通道数</strong>：16个GPIO_Pin，外加PVD输出、RTC闹钟等</p><p><strong>触发响应的方式</strong>：<strong>中断响应/事件响应</strong></p><ul><li><strong>中断响应</strong>：正常的引脚电平变化触发中断</li><li><strong>事件响应</strong>：不会触发中断，而是触发别的外设操作，属于外设之间的联合工作</li></ul><h2 id="库函数">库函数</h2><p><code>相关的EXTI库函数去stm32f10x_exti.h中查看，这里直接使</code></p><h2 id="初始化配置流程">初始化配置流程</h2><p>只需要从GPIO到NVIC这一路出现的外设模块配置好即可，一共5步</p><p><img src="../assets/98-17375297555834.png" alt="image-20241117144622580"></p><ol><li><strong>配置RCC，打开相关的外设时钟</strong>。这里涉及到的是GPIO、AFIO、EXTI、NVIC的时钟，但由于EXTI和NVIC时钟(内核外设不需要开启时钟)一直都是打开的，不需要我们开启，所以只需要开启GPIO和AFIO时钟即可。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//开启GPIOA时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//开启对应AFIO时钟</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>配置GPIO，配置我们的端口为输入模式</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>在我们的手册中有对应外设每个引脚推荐配置模式，我们可以找到EXTI推荐配置为:浮空，上拉，下拉</strong></p></blockquote><ol start="3"><li><strong>配置AFIO 通过 AFIO 外设将 PC13 引脚映射到 EXTI 外设上，以便用于外部中断</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 参数1：使用哪个GPIO作为外部中断源,GPIO_PortSourceGPIOx where x can be (A..G).</span></span><br><span class="line"><span class="comment"> * 参数2：指定需要配置的外部中断线, GPIO_PinSourcex where x can be (0..15).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里配置AFIO只需要这个函数即可*/</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOC,GPIO_PinSource13);</span><br></pre></td></tr></table></figure><blockquote><p>没有单独写AFIO的库函数，与GPIO库函数放在一起的，可以去gpio的库函数中找这个函数查看对应参数。虽然写的是GPIO，但是我们查看该函数定义可以发现里面操作的是AFIO的寄存器</p></blockquote><ol start="4"><li><strong>配置EXTI，选择边沿触发方式，比如上升沿、双边沿等，还有触发响应方式，可以选择中断响应和事件响应。</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">EXTI_InitStructure.EXTI_Line= EXTI_Line13;<span class="comment">//对应选择的外部中断线</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd= ENABLE; <span class="comment">// 使能或不使能</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode= EXTI_Mode_Interrupt ; <span class="comment">//两种模式，一种是中断响应，一种是事件响应</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger= EXTI_Trigger_Falling; <span class="comment">// 触发方式</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br></pre></td></tr></table></figure><blockquote><p>相关的EXTI库函数去stm32f10x_exti.h中查看，这里直接使用</p></blockquote><ol start="5"><li><strong>配置NVIC，给我们的中断选择一个合适的优先级</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//优先级配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NVIC_PriorityGroupConfig()分组方式整个芯片只能只能用一种，按理来说这个分组的代码整个工程只需要执行一次即可。如果把这个函数放到模块里面进行分组，一定要确保每个模块分组都选的是同一个。也可以把这个代码放在主函数的开始，这样就不用每个模块分组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">// 使能</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span> ; <span class="comment">//指定抢占优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span> ;  <span class="comment">//指定子优先级</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br></pre></td></tr></table></figure><blockquote><p>因为NVIC是内核外设，库函数被分配到了misc.h/c(杂项)文件中去了，在这里查找对应参数，对应函数用法。</p><p>NVIC_InitTypeDef 中查看注释我们可以知道IRQ需要到stm32f10x.h去找，我们要选择对应芯片的<strong>选择编译</strong>，这里我们是stm32f10x_MD</p><p>在里面的选择编译中，我们找到了EXTI15_10_IRQn = 40 (stm32的EXTI10到15都是合并到了这个通道里)</p><p>所以我们定义为EXTI15_10_IRQn即可</p><hr><p><code>注意:配置NVIC时，NVIC_IRQChannel只能接受一个中断通道号，不能接收多个中断通道的组合，如果有多个中断通道配置需要配置多次</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn | EXTI0_IRQn;</span><br></pre></td></tr></table></figure><p><code>这样配置不会报错，但是两个中断都不会生效!!!</code></p><p><code>需要单独调用两次NVIC_Init初始化</code></p><hr><p>对应的设置抢占优先级和子优先级设置我们可以跳转到对应定义处，继续跳转到注释中提到的中断优先级对应的优先级表查看即可</p></blockquote><p><strong>只有两个按键配置流程连起来就是</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.配置RCC启用对应外设时钟*/</span></span><br><span class="line">     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line"> <span class="comment">/*2.配置GPIO*/</span></span><br><span class="line">     GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13|GPIO_Pin_12;</span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOC,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*3.配置AFIO*/</span>    GPIO_EXTILineConfig(GPIO_PortSourceGPIOC,GPIO_PinSource12); GPIO_EXTILineConfig(GPIO_PortSourceGPIOC,GPIO_PinSource13);</span><br><span class="line">     <span class="comment">/*4.配置EXTI*/</span></span><br><span class="line">  EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">  EXTI_InitStructure.EXTI_Line= EXTI_Line12 | EXTI_Line13;<span class="comment">//对应选择的按键外部中断线</span></span><br><span class="line">      EXTI_InitStructure.EXTI_LineCmd= ENABLE; <span class="comment">// 使能或不使能</span></span><br><span class="line">  EXTI_InitStructure.EXTI_Mode= EXTI_Mode_Interrupt ; <span class="comment">//两种模式，一种是中断，一种是事件</span></span><br><span class="line">      EXTI_InitStructure.EXTI_Trigger= EXTI_Trigger_Falling; <span class="comment">// 触发方式为下降沿触发</span></span><br><span class="line">  EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*5.配置NVIC*/</span></span><br><span class="line">  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">      NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;</span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">// 使能</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span> ; <span class="comment">//指定抢占优先级</span></span><br><span class="line">  NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span> ;  <span class="comment">//指定子优先级</span></span><br><span class="line">  NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中断函数">中断函数</h2><p><strong>完成了外部中断初始化配置后，接下来就是编写中断函数</strong></p><p>在启动文件的中断向量表中找到对应的中断函数的名字，这里是<code>EXTI15_10_IRQHandler</code></p><p>将其从启动文件中复制到对应位置进行编写，名字一定不能错，错了就无法进入了</p><p><strong>编写步骤如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*1.判断对应中断标志位是否为1(SET),如果是*/</span></span><br><span class="line"><span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line12) == SET)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*2.清除对应中断标志位，否则会一直触发中断*/</span></span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line12);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*3.用户干的事情*/</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line13) == SET)</span><br><span class="line">&#123;</span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line13);</span><br><span class="line">         <span class="comment">/*用户干的事情*/</span></span><br><span class="line">  ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>中断函数的返回值和参数都是void</p></li><li><p>此函数不用声明，中断触发自动调用</p></li><li><p>使用的相关函数在对应的exti标准库中去找(EXTI_GetITStatus等)，有两个获取标志位的函数，带有IT的是只能在中断中使用的，不带IT的是在中断外使用的</p></li></ol></blockquote><h2 id="实验-旋转编码器计数">实验- 旋转编码器计数</h2><p>旋转编码器相关知识见HAL库</p><p>此处旋转编码器<strong>A相对应：PB0</strong>，<strong>B相对应：PB1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Encoder.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ENCODER_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ENCODER_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int16_t</span> EncoderCount;<span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 1.打开对应外设时钟 */</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE );</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE );<span class="comment">//选择AFIO这个外设，开启时钟，通常用于启用或禁用 AFIO 外设的时钟，以便进行相应的配置操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.配置对应GPIO输入模式 */</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<span class="comment">//上拉输入，默认为高电平的输入方式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0|GPIO_Pin_1;<span class="comment">//旋转编码器分两相，PB0 为A相，PB1为B相</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init (GPIOB ,&amp;GPIO_InitStructure);<span class="comment">//初始化GPIOB外设</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.AFIO配置，映射到对应EXTI线上去 */</span></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource0);</span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource1);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 4.EXTI配置 */</span></span><br><span class="line">EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">EXTI_InitStructure.EXTI_Line=EXTI_Line0|EXTI_Line1;<span class="comment">//将第0条线路和第1条线路都初始化为中断模式，下降沿触发连线</span></span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd=ENABLE;<span class="comment">//开启中断</span></span><br><span class="line">EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt;<span class="comment">//中断模式</span></span><br><span class="line">EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling;<span class="comment">//下降沿触发，离开就+1</span></span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5.NVIC配置,这个地方需要两个中断初始化 */</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//选两位抢占两位响应，整个程序只需要配置一次</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=EXTI0_IRQn;<span class="comment">//外部中断0</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;/</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">1</span>;<span class="comment">//响应优先级</span></span><br><span class="line">NVIC_Init (&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel=EXTI1_IRQn;<span class="comment">//外部中断1</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="number">2</span>;<span class="comment">//响应优先级2大于1</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"><span class="comment">//PB0和PB1为同一抢占优先级，但PB1的响应优先级比PB0大，所以PB0可以被PB1打断</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int8_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//获取中断服务函数中改变的数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int8_t</span> num;</span><br><span class="line">num=EncoderCount;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//这个函数只有0这个引脚可以触发</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(EXTI_GetFlagStatus (EXTI_Line0)==SET)<span class="comment">//外部中断0的线被触发，进入中断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>)<span class="comment">//A下降沿，B低电平，反转</span></span><br><span class="line">&#123;</span><br><span class="line">EncoderCount --;<span class="comment">//计数--</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line0);<span class="comment">//清除中断标志位，跳出中断</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//这个函数只有1这个引脚可以触发</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(EXTI_GetFlagStatus (EXTI_Line1)==SET)<span class="comment">//外部中断1的线被触发，进入中断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)==<span class="number">0</span>)<span class="comment">//B下降沿，A低电平正转，</span></span><br><span class="line">&#123;</span><br><span class="line">EncoderCount ++;<span class="comment">//计数++</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line1);<span class="comment">//清除中断标志位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>正转编码器，counter增加，反转编码器，counter增加</strong></p></blockquote><h2 id="实验-对射式红外传感器计次">实验-对射式红外传感器计次</h2><h2 id="使用中断注意事项">使用中断注意事项</h2><ol><li><strong>中断函数中不要执行耗时过长的代码，不要使用延时函数</strong></li><li><strong>不要再中断函数中和主函数调用相同的函数或操作同一个硬件，操作用一个全局变量时要将该变量声明为volatile,避免编译器优化</strong></li><li><strong>中断建议操作变量或者标志位(状态位)</strong></li></ol><h1>TIM(定时器)</h1><h2 id="介绍-2">介绍</h2><ul><li><p>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断。</p></li><li><p>16位计数器、预分频器、自动重装载寄存器的时基单元，在72HZ计数时钟下可以实现最大59.65s((65535*65535)/72MHz)的定时时间</p></li><li><p>具备基本的定时中断功能，还包含内外时钟源选择、时钟捕获、输出比较、编码器接口，主从触发模式等多种功能</p></li><li><p>分为三种：<strong>高级定时器、通用定时器、基本定时器</strong>，难度依次递减</p></li></ul><p><img src="../assets/33-17375297555833.png" alt="image-20241118144626208"></p><h2 id="计数器模式">计数器模式</h2><p><strong>三种：向上计数模式、向下计数模式，中央对齐模式</strong></p><p><strong>基本定时器</strong>：只支持向上计数模式</p><p><strong>通用定时器和高级定时器</strong>：支持向上计数、向下计数、中央对齐计数</p><h2 id="时基单元">时基单元</h2><p>定时器框图中最重要的是时基单元，由三部分构成：<strong>预分频器PSC、自动重装载器ARR、计数器CNT</strong></p><ol><li><p><strong>Prescaler(psc)-预分频值</strong>：内部有一个预分频器PSC，内部时钟先输入到这里完成分频。简单来说就是分频值</p><p>时钟信号被分频后的频率 F= TCLK/(PSC+1)</p></li><li><p><strong>auto-reload preload(arr)-自动重装载值</strong>：内部有一个自动重装载寄存器，简单来说就是设置计数值上限，最大为65535</p></li><li><p><strong>CNT-计数器</strong>：内部有一个计数器自增，会与自动重装在寄存器比较，当计数值等于自动重装载值arr时，将会触发<strong>更新中断或更新事件</strong>，同时清零计数器</p></li></ol><p><code>定时器溢出时间 Tout =  (arr+1)/F   =   (arr+1)*(PSC+1) /TCLK</code></p><h2 id="时钟源">时钟源</h2><p><strong>在手册上我们可以看到，stm32通用定时器的时钟源有4种</strong>：</p><p>1、<strong>内部时钟(CK_INT)</strong></p><p>2、<strong>外部时钟模式1</strong>：外部输入引脚(TIx)</p><p>3、<strong>外部时钟模式2</strong>：外部触发输入(ETR)</p><p>4、<strong>内部触发输入(ITRx)</strong>：使用一个定时器作为另一个定时器的预分频器。如可以配置一个定时器Timer1而作为另一个定时器Timer2的预分频器。用于定时器级联</p><hr><p>基本定时器：只能选择内部时钟，也就是系统主频72MHz(F103)</p><p>通用(高级)定时器：时钟源不仅可以选择<strong>内部时钟输入</strong>，也可以选择<strong>外部时钟输入ETR</strong>(外部引脚输入)</p><p>在下面的<strong>参考手册通用定时器框图</strong>中可以看到通过TIMx_ETR引脚上可以外接一个外部方波时钟，在配置内部极性选择，边沿检测和预分频器，再配置一下输入滤波电路(对外部引脚输入进行滤波)，最后分为两路去<strong>ETRF(外部时钟模式2)<strong>和</strong>TRGI（外部时钟模式1）</strong></p><p><img src="../assets/image-20241118151537820.png" alt="image-20241118151537820"></p><p><img src="../assets/0-17375297555832.png" alt="image-20241118153011362"></p><blockquote><p>总结：看上面手册中的框图</p><p><strong>内部时钟输入</strong>：APB1/APB2，一般为系统主频</p><p><strong>外部时钟输入</strong>：分为外部时钟模式1和外部时钟模式2</p><ol><li><p>ETR引脚(外部引脚输入)：经过一堆(极性选择、边沿检测、滤波等)后</p><ul><li>独立进入触发控制器(ETR独享)，是外部时钟模式2</li><li>通过触发器进入从模式控制器，是外部时钟模式1</li></ul></li><li><p>其他定时器(ITR)：是内部触发输入，来源于其他TIM，可以实现定时器级联，是外部时钟模式1</p></li><li><p>TIMx_CH1引脚的边沿(TI1F_ED)：外部时钟模式1</p></li><li><p>TIMx_CH1引脚(TI1FP1)：外部时钟模式1</p></li><li><p>TIMx_CH2引脚(TI2FP2)：外部时钟模式1</p></li></ol><p>TI1FP1：Timer Input 1 Filter Polarity 1</p></blockquote><blockquote><p><code>一般情况下外部时钟通过ETR引脚就可以，其他这么多输入是为了某些特定场景使用，比如：ITR是为了定时器级联设置的</code></p></blockquote><h2 id="库函数-2">库函数</h2><p><code>相关的库函数直接在stm32f10x_tim.h寻找使用,这里给出常用的</code></p><p><strong>时钟源选择</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_InternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="comment">//1.内部时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity,<span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br><span class="line"><span class="comment">//2.外部输入模式1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity, <span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br><span class="line"><span class="comment">//3.外部输入模式2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_TIxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_TIxExternalCLKSource,<span class="type">uint16_t</span> TIM_ICPolarity, <span class="type">uint16_t</span> ICFilter)</span>;</span><br><span class="line"><span class="comment">//4.外部输入模式1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITRxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_InputTriggerSource)</span>;</span><br><span class="line"><span class="comment">//5.内部触发输入，级联</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity,<span class="type">uint16_t</span> ExtTRGFilter)</span>;</span><br></pre></td></tr></table></figure><p><strong>时基单元配置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_TimeBaseInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span>;</span><br></pre></td></tr></table></figure><p><strong>中断输出控制配置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><p><strong>NVIC配置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NVIC_Init</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><strong>运行控制配置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_Cmd</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><hr><p><strong>单独更改预分频值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_PrescalerConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Prescaler, <span class="type">uint16_t</span> TIM_PSCReloadMode)</span>;</span><br></pre></td></tr></table></figure><p><strong>计数器模式配置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CounterModeConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_CounterMode)</span>;</span><br></pre></td></tr></table></figure><p><strong>计数器预装载配置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ARRPreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><p><strong>手动写入计数器值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCounter</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Counter)</span>;</span><br></pre></td></tr></table></figure><p><strong>手动写入ARR值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetAutoreload</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Autoreload)</span>;</span><br></pre></td></tr></table></figure><p><strong>获取计数器或预分频值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCounter</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetPrescaler</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br></pre></td></tr></table></figure><p><strong>中断相关函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">TIM_GetFlagStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_FLAG)</span>;<span class="comment">//中断外使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearFlag</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_FLAG)</span>;</span><br><span class="line">ITStatus <span class="title function_">TIM_GetITStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span>;<span class="comment">//中断内使用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearITPendingBit</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span>;</span><br></pre></td></tr></table></figure><h2 id="定时器中断-定时或计数功能">定时器中断(定时或计数功能)</h2><p><a href="https://postimg.cc/kR4B9vCC"><img src="../assets/image-20241118154510279.png" alt="image-20241118154510279.png"></a></p><h3 id="TIM配置流程">TIM配置流程</h3><p>首先新建Timer.c和Timer.h文件到Hardware中</p><p>我们将上方的定时中断基本结构图打通就完成了配置</p><p>具体流程：</p><ol><li><strong>RCC开启时钟</strong>：查看手册我们可以发现TIM2在APB1总线上，故开启APB1总线时钟</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>选择时基单元的时钟源</strong>：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//上电后单片机默认使用内部时钟，这一行其实可以省略</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>配置时基单元</strong>：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode =TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>; </span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br></pre></td></tr></table></figure><blockquote><p>这里并没有对CNT计数器的初始化，如果我们想更改，调用TIM_SetCounter函数进行更改即可</p><p>TIM_ClockDivision参数：与滤波器相关的分频，这里随便选</p><p>TIM_RepetitionCounter参数：<strong>重复计数器的值，高级定时器才有的，不用给0</strong></p></blockquote><ol start="4"><li><strong>配置中断，即配置输出中断控制，允许更新中断输出到NVIC</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>这里的第二个参数我们选择的是更新中断，其他选择请跳转到对应函数的注释中查看</strong></p></blockquote><ol start="5"><li><strong>配置NVIC，在NVIC中打开定时器中断的通道，并分配一个优先级</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//优先级分组</span></span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//NVIC配置</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn  ;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>运行控制，我们需要使能定时器的运行，否则不会工作</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br></pre></td></tr></table></figure><p><strong>连起来就是</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*1.RCC使能时钟*/</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*2.时基单元时钟源选择：此处选择内部时钟*/</span></span><br><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//上电后单片机默认使用内部时钟，这一行其实可以省略</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*3.时基单元配置*/</span></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<span class="comment">//与滤波器相关的分频，这里随便选</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//计数器模式</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>; <span class="comment">//周期，也就是ARR的值</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;<span class="comment">//预分频器的值</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//重复计数器的值，高级定时器才有</span></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4.输出中断控制配置，允许更新中断输出到NVIC*/</span></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5.NVIC配置*/</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn  ;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*6.定时器运行控制，使能一下*/</span></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>中断函数</strong>：同样在启动文件中寻找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update)== SET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*中间为用户代码*/</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>上方函数调用查看更新中断的标志位</strong></p></blockquote><h3 id="实验-使用定时器每秒计数-内部时钟">实验-使用定时器每秒计数(内部时钟)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Timer.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Timer.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> Num;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM2);<span class="comment">//上电后单片机默认使用内部时钟，这一行其实可以省略</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<span class="comment">//与滤波器相关的分频，这里随便选</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//计数器模式</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span><span class="number">-1</span>; <span class="comment">//周期，也就是ARR的值</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span><span class="number">-1</span>;<span class="comment">//预分频器的值</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//重复计数器的值，高级定时器才有</span></span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">    </span><br><span class="line">        TIM_ClearFlag(TIM2,TIM_FLAG_Update);<span class="comment">//避免上电立即进入中断    </span></span><br><span class="line">    </span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update)== SET)</span><br><span class="line">&#123;</span><br><span class="line">Num++;</span><br><span class="line"></span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Timer_Init();</span><br><span class="line">OLED_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowSignedNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);</span><br><span class="line">        OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">5</span>,TIM_GetCounter(TIM2),<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里有个问题，上电后我们可以发现计数器的值直接为1，这代表在上电时就已经进入了一次中断处理程序了。</p><p>这是由于TIM_TimeBaseInit()函数中最后一排有个TIMx-&gt;EGR = TIM_PSCReloadMode_Immediate;</p><p>查看注释可以知道其手动生成了一个更新事件(为了让预分频器缓冲寄存器起作用，更新才会起作用)，导致上电立即进入中断。</p><p>解决方案：</p><p>在TIM_TimeBaseInit()后，开启中断前使用手动清除标志位。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"><span class="comment">/*添加到这里即可*/</span></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);</span><br><span class="line"></span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<span class="comment">//配置为更新中断</span></span><br></pre></td></tr></table></figure><h3 id="实验-对射式红外传感器-外部时钟模式2">实验-对射式红外传感器(外部时钟模式2)</h3><p><strong>参考手册查看到芯片的TIM2_CH1_ETR复用输入引脚为PA0，可以通过PA0引脚将传感器0模块的DO引脚输出波形引入到定时器TIM2中</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Timer.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> Num;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有外部引脚输出，故先配置外部引脚</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    <span class="comment">/*这里的GPIO输入模式在参考手册可以查到，使用TIM2外部输入，推荐为浮空输入*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*这里选择的外部时钟模式2，对应参数选择跳转到对应函数查看注释*/</span></span><br><span class="line">TIM_ETRClockMode2Config(TIM2,TIM_ExtTRGPSC_OFF,TIM_ExtTRGPolarity_NonInverted,<span class="number">0x0F</span>);</span><br><span class="line">    <span class="comment">//选择的是上升沿触发，最后一个参数是外部触发滤波器，取值对应可以在参考手册中从模式控制寄存器(TIMx_SMCR)中看到，取值为0x00~0x0f,如果我们不滤波(0x00)的话就会有很多抖动脉冲，计数很多次。这里一般选择0x0F(15)即可</span></span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10</span><span class="number">-1</span>; </span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span><span class="number">-1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_ClearFlag(TIM2,TIM_FLAG_Update);</span><br><span class="line">TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);</span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(TIM_GetITStatus(TIM2,TIM_IT_Update)== SET)</span><br><span class="line">&#123;</span><br><span class="line">Num++;</span><br><span class="line"></span><br><span class="line">TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Timer_Init();</span><br><span class="line">Key_Init();</span><br><span class="line">LED_Init();</span><br><span class="line">OLED_Init();</span><br><span class="line"><span class="comment">//OLED_ShowChar(10,10,&#x27;a&#x27;);</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowSignedNum(<span class="number">1</span>,<span class="number">5</span>,Num,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>,<span class="number">5</span>,TIM_GetCounter(TIM2),<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当我们把手放遮挡在拿开，计数器+1，计数9次后，Num+1</p></blockquote><h3 id="实验-循迹模块测量商品数量-外部时钟模式2">实验-循迹模块测量商品数量(外部时钟模式2)</h3><p><a href="https://www.bilibili.com/video/BV1N94y1u7Uz?spm_id_from=333.788.videopod.sections&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32】动画讲解定时器外部时钟 &amp; 实战传送带测速装置_哔哩哔哩_bilibili</a></p><p><strong>参考手册查看到芯片的TIM2_CH1_ETR复用输入引脚为PA0，可以通过PA0引脚将传感器0模块的DO引脚输出波形引入到定时器TIM2中。</strong></p><p>代码与上方完全相同</p><p>同样也可以使用外部时钟模式1的ETR从模式、TI1F_ED、TI1FP1、TI1FP2都可以实现</p><blockquote><p>最终我们将任意物品从循迹模块下方穿过，一个物品计数+1</p></blockquote><h2 id="输出比较功能-OC">输出比较功能(OC)</h2><h3 id="OC简介">OC简介</h3><p>OC(Output Compare)--------输出比较</p><p>输出比较可以通过比较<strong>CNT计数器</strong>与<strong>CCR</strong>(Capture/Compare Register)值的关系进行置1、置0或者翻转的操作，用于输出一定频率和占空比的PWM波形</p><blockquote><p><strong>CCR全称：Capture/Compare Register  –   捕获/比较寄存器</strong></p><p><strong>使用输入捕获时：就是捕获寄存器</strong></p><p><strong>使用输出比较时：就是比较寄存器</strong></p></blockquote><ul><li>每个高级定时器和通用定时器都拥有4个输出比较通道</li><li>高级定时器的前三个通道额外拥有死区生成和互补输出的功能</li></ul><h3 id="PWM输出简介">PWM输出简介</h3><p><strong>脉冲宽度调制-PWM</strong>，是英文“Pulse Width Modulation”的缩写，简称<strong>脉宽调制</strong>，其实是在利用微控制器的<strong>定时器模块</strong>来生成一种特定频率和占空比的<strong>脉冲信号(一段高低电平)</strong>，调整脉冲的宽度从而影响功率等。PWM信号是一种周期性的脉冲信号，通过调整脉冲的宽度（高电平时间）可以模拟模拟信号，控制电机速度、LED亮度、蜂鸣器响度等。必须具有惯性的系统才能使用PWM。</p><p><strong>PWM参数</strong>：</p><ol><li><p><strong>频率</strong> = 1 / Ts</p></li><li><p><strong>占空比</strong> =  Ton / Ts (图中的高电平占整个周期的时间)</p></li><li><p><strong>分辨率</strong> = 占空比变化步距(占空比以多少百分比跳变，1%到%2到%3，分辨率就是1%)</p></li></ol><p><img src="../assets/1-17375297555835.png" alt="image-20241119175400365"></p><blockquote><p>PWM频率越快，等效模拟的信号也就越平稳，对应的性能开销也就越大</p><p><strong>一般来说PWM的频率都在几K到几十K，这个频率就足够快了</strong></p></blockquote><hr><p><strong>原理图：CCR=30时</strong></p><p><img src="../assets/2-17375297555836.png" alt="image-20241120214655665"></p><blockquote><p>参数计算：</p><p>PWM频率：Freq = CK_PSC/(PSC+1)*(ARR+1)</p><p>PWM占空比：Duty = CCR/(ARR+1)</p><p>PWM分辨率：Reso = 1 / (ARR+1)   <strong>占空比越细腻越好</strong></p></blockquote><h3 id="舵机简介">舵机简介</h3><p>舵机是一种根据输入<strong>PWM信号占空比来控制输出角度的装置</strong></p><p>常见的舵机型号有：SG90，SG92</p><p>输入PWM信号要求：<strong>周期为20ms</strong>，<strong>高电平时长为0.5ms~2.5ms(0~180°)，可以查看对应舵机手册得到驱动角度对应PWM的周期</strong></p><p>三根线：一根VCC，一根GND，一根信号线</p><p><img src="../assets/3-17375297555837.png" alt="image-20241120215627230"></p><blockquote><p>给一个PWM，舵机就会固定在某一个角度，机械臂等机械机构就可以使用</p><p><strong>这里的PWM输出当成通信协议很常见，PWM波形通过信号线输出</strong></p></blockquote><h3 id="直流电机及驱动简介">直流电机及驱动简介</h3><p>直流电机是一种将电能转换为机械能的装置，有两个电极，当电极正接时，电机正转，当电极反接时，电机反转。(对应一个引脚高电平一个引脚低电平)</p><p><strong>直流电机属于大功率器件，GPIO口无法直接驱动，需要配合<code>电机驱动芯片</code>来操作</strong></p><p>TB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并控制其转速和方向，还有<strong>DRV8833驱动芯片</strong>等</p><p><img src="../assets/4-17375297555838.png" alt="image-20241120221616621"></p><blockquote><p>在对应模块使用手册可以查看使用方法以及原理图，各引脚含义</p></blockquote><h3 id="库函数-3">库函数</h3><p>主要初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="comment">/*对应的是四个输出比较通道的输出比较单元结构体的初始化*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OCStructInit</span><span class="params">(TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;</span><br><span class="line"><span class="comment">/*用于为一个结构体赋初值*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;</span><br><span class="line"><span class="comment">/*极性配置</span></span><br><span class="line"><span class="comment"> * 对每个通道极性的单独配置 </span></span><br><span class="line"><span class="comment"> * 带N是高级定时器中互补通道的配置，OC4没有互补通道</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCxCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_CCx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCxNCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_CCxN)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单独修改输出使能参数*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectOCxM</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_OCMode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单独修改输出比较模式的函数*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare1</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare2</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare2)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare3</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare3)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare4</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare4)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单独修改CCR寄存器的函数</span></span><br><span class="line"><span class="comment"> * 可用于调整占空比</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CtrlPWMOutputs</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>该函数仅高级定时器使用，在使用高级定时器输出PWM时，需要调用这个函数，使能主输出，否则PWM将不能正常输出</p></blockquote><hr><p><strong>一些小功能配置：使用不多</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC3Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC4Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;</span><br><span class="line"><span class="comment">/*配置强制输出模式：在运行中想要暂停输出波形并且强制输出高或低电平使用</span></span><br><span class="line"><span class="comment"> * 一般不怎么使用，修改占空比为0或100也能实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCPreloadControl</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="comment">/*用于配置CCR寄存器的预装功能，也就是影子寄存器</span></span><br><span class="line"><span class="comment"> * 也就是：写入的值不会立即生效，而是在更新时间才会生效</span></span><br><span class="line"><span class="comment"> * 一般不使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于配置快速使能</span></span><br><span class="line"><span class="comment"> * 功能手册中，单脉冲模式有介绍</span></span><br><span class="line"><span class="comment"> * 一般不使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC1Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC2Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC3Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC4Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*外部事件时清楚REF信号</span></span><br><span class="line"><span class="comment"> * 不怎么使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="输出比较配置流程">输出比较配置流程</h3><ol><li><p><strong>RCC开启时钟</strong></p></li><li><p><strong>配置GPIO：把PWM对应的GPIO口初始化为复用推挽输出模式(TIM复用)</strong></p></li><li><p><strong>选择时基单元时钟源</strong></p></li><li><p><strong>配置时基单元</strong></p></li><li><p><strong>配置输出比较单元：输出比较模式、极性选择、输出状态使能、CCR的值等</strong></p></li><li><p><strong>运行控制：启动对应TIM</strong></p></li></ol><h3 id="实验-PWM呼吸灯">实验-PWM呼吸灯</h3><h4 id="配置流程">配置流程</h4><ol><li><p><strong>RCC开启时钟，开启对应GPIO和TIM时钟</strong></p></li><li><p><strong>配置GPIO：把PWM对应的GPIO口初始化为复用推挽输出模式(TIM复用)</strong></p></li><li><p><strong>选择时基单元时钟源</strong></p></li><li><p><strong>配置时基单元</strong></p></li><li><p><strong>配置输出比较单元：输出比较模式、极性选择、输出状态使能、CCR的值等</strong></p></li><li><p><strong>运行控制：启动对应TIM</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*PWM.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PWM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PWM_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*PWM.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//1.RCC开启时钟</span></span><br><span class="line"> RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"> <span class="comment">//2.配置GPIO</span></span><br><span class="line"> GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽模式</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//3.配置时基单元时钟源</span></span><br><span class="line"> TIM_InternalClockConfig(TIM3);</span><br><span class="line"> <span class="comment">//4.配置时基单元</span></span><br><span class="line"> TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up ;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span><span class="number">-1</span>;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">720</span><span class="number">-1</span>;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line"> TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure); </span><br><span class="line"> <span class="comment">//5.配置输出比较单元</span></span><br><span class="line"> TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line"> TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1 ;  <span class="comment">/*PWM1模式*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High ; <span class="comment">/*极性为高：有效电平为高电平*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;  <span class="comment">/*输出状态使能*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">//配置CCR</span></span><br><span class="line"><span class="comment">/*这里时通用定时器，只需要列举需要的参数即可，高级定时器的参数可以不用管*/</span></span><br><span class="line"> TIM_OC2Init(TIM3,&amp;TIM_OCInitStructure);</span><br><span class="line"> <span class="comment">//6.运行控制，TIM使能</span></span><br><span class="line"> TIM_Cmd(TIM3,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> pwmVal = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">PWM_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(;pwmVal&lt;<span class="number">100</span>;pwmVal++)</span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare2(TIM3,pwmVal);</span><br><span class="line">Delay_ms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;pwmVal&gt;<span class="number">0</span>;pwmVal--)</span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare2(TIM3,pwmVal);</span><br><span class="line">Delay_ms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验-PWM驱动舵机">实验-PWM驱动舵机</h3><blockquote><p>驱动舵机工作的频率为50HZ，也就是周期为20ms。</p><p>这里对应PSC设置为72-1，ARR设置为20000-1</p><p>舵机旋转角度对应的周期为500us~2500us(0.5ms~2.5ms)的高电平时长，对应占空比为：0.5ms/20ms = 2.5%  到    2.5ms/20 =12.5%</p><p>即设置ARR的范围应该是500~2500(对应0~180°)</p></blockquote><p><code>配置流程与上一个实验一样</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Servo.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SERVO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SERVO_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_SetAngle</span><span class="params">(<span class="type">float</span> Angle)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Servo.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line"> GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽模式</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;</span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line"> <span class="comment">/*PB8为舵机的信号线*/</span></span><br><span class="line"></span><br><span class="line"> TIM_InternalClockConfig(TIM4);</span><br><span class="line"></span><br><span class="line"> TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up ;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_Period = <span class="number">20000</span><span class="number">-1</span>;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line"> TIM_TimeBaseInit(TIM4,&amp;TIM_TimeBaseInitStructure); </span><br><span class="line"></span><br><span class="line"> TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line"> TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1 ;  <span class="comment">/*PWM1模式*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High ; <span class="comment">/*有效电平为高电平*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;  <span class="comment">/*输出状态使能*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_Pulse = <span class="number">500</span>; <span class="comment">//配置CCR</span></span><br><span class="line"><span class="comment">/*这里时通用定时器，只需要列举需要的参数即可，高级定时器的参数可以不用管*/</span></span><br><span class="line"> TIM_OC3Init(TIM4,&amp;TIM_OCInitStructure);</span><br><span class="line"> </span><br><span class="line"> TIM_Cmd(TIM4,ENABLE);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置舵机角度*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_SetAngle</span><span class="params">(<span class="type">float</span> Angle)</span></span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare3(TIM4,(Angle/<span class="number">180</span>)*(<span class="number">2000</span>)+<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Servo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Key_Init();</span><br><span class="line"></span><br><span class="line">Servo_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"> Num = Key_GetNum();</span><br><span class="line">       <span class="keyword">if</span>(Num == <span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">                <span class="type">static</span> <span class="type">float</span> angle=<span class="number">0</span>;</span><br><span class="line">                  angle+=<span class="number">30</span>;</span><br><span class="line">                  <span class="keyword">if</span>(angle &gt; <span class="number">180</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        angle = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">              Servo_SetAngle(angle);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>按键按下，舵机旋转30度</strong></p></blockquote><h3 id="实验-PWM驱动DRV8833电机">实验-PWM驱动DRV8833电机</h3><p>DRV8833相关知识见HAL库笔记</p><blockquote><p>DRV8833对应两个输入引脚，一个PWM输入，一个给高/低电平可以实现正反转，对应查表见HAL库对应章节。</p><p><strong>对应PWM占空比越高，电机转速越快</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DRV8833.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DRV8833_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DRV8833_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_SetSpeed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>这里两个输入引脚为：PA0，PA1。PA0为PWM引脚，PA1为低电平引脚</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DRV8833.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//1.</span></span><br><span class="line"> RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line"> RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">      </span><br><span class="line">     <span class="comment">//2.</span></span><br><span class="line"> GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;</span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"> <span class="comment">/*配置PA1引脚为输出模式*/</span></span><br><span class="line">  </span><br><span class="line"> GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽模式</span></span><br><span class="line"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line"> GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"> GPIO_Init(GPIOA,&amp;GPIO_InitStructure); </span><br><span class="line"> <span class="comment">/*配置PWM引脚PA0，为复用推挽输出模式*/</span> </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//3.</span></span><br><span class="line"> TIM_InternalClockConfig(TIM2);</span><br><span class="line"> <span class="comment">//4.</span></span><br><span class="line"> TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up ;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span><span class="number">-1</span>;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;</span><br><span class="line"> TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line"> TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure); </span><br><span class="line"> </span><br><span class="line">     <span class="comment">//5.</span></span><br><span class="line"> TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line"> TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1 ;  <span class="comment">/*PWM1模式*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High ; <span class="comment">/*有效电平为高电平*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;  <span class="comment">/*输出状态使能*/</span></span><br><span class="line"> TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">//修改CCR的值可以改变转速</span></span><br><span class="line"><span class="comment">/*这里时通用定时器，只需要列举需要的参数即可，高级定时器的参数可以不用管*/</span></span><br><span class="line"> TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//6.</span></span><br><span class="line"> TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">   </span><br><span class="line"> GPIO_ResetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line"> <span class="comment">/*设置PA1为低电平*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DRV8833_SetSpeed</span><span class="params">(<span class="type">uint8_t</span> speed)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(speed&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TIM_SetCompare1(TIM2,speed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DRV8833.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">DRV8833_Init();</span><br><span class="line">    DRV8833_SetSpeed(<span class="number">50</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>转速最大值可以设置100，为ARR最大值</strong></p></blockquote><h2 id="输入捕获功能-IC">输入捕获功能(IC)</h2><h3 id="IC简介">IC简介</h3><p><strong>IC(Input Capture)--------输入捕获</strong></p><p>输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR(捕获寄存器)中，<strong>可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数。</strong></p><blockquote><p><strong>CCR全称：Capture/Compare Register  –   捕获/比较寄存器</strong></p><p><strong>使用输入捕获时：就是捕获寄存器</strong></p><p><strong>使用输出比较时：就是比较寄存器</strong></p></blockquote><p>每个高级定时器和通用定时器都拥有4个输入捕获通道：</p><ul><li><p>可配置为<code>PWMI模式</code>，同时测量频率和占空比</p></li><li><p>可配合主从触发模式，实现硬件全自动测量</p></li></ul><h3 id="频率测量">频率测量</h3><p><img src="../assets/5-17375297555839.png" alt="image-20241125154510808"></p><blockquote><p><strong>测频法(测频率)</strong>：适合测量<code>高频</code>信号，<strong>计次数量多一些，有助于减小误差</strong></p><p><strong>特点</strong>：测量结果更新速度较慢，但是平均值，相当于均值滤波，结果比较稳定</p><p>fx = N / T</p><hr><p><strong>测周法(测周期)</strong>：适合测量<code>低频</code>信号，<strong>周期比较长，计次比较多，有助于减小误差</strong></p><p><strong>特点：只测量一个周期</strong>，测量结果更新速度较快，但结果值会受噪声的影响，波动比较大</p><p>fx = fc / N     fc为标准频率：标准频率就是经过PSC分频后的时钟频率</p><p><strong>在这里fc可以是使用输入捕获时定时器的频率，使用时需要每次触发后将CNT的值清0才是一个周期</strong></p><hr><p><strong>中界频率</strong>fm：</p><p>待测<code>信号频率&lt;中界频率</code>时，选用<code>测频法</code>误差更小</p><p>待测<code>信号频率&gt;中界频率</code>时，选用<code>测周法</code>误差更小</p><p>fm = 根号下(fc / T)</p></blockquote><h3 id="输入捕获通道">输入捕获通道</h3><p><img src="../assets/6-173752975558410.png" alt="image-20241125161551723"></p><blockquote><p>同一个引脚TIx的输入信号映射到两个输入通道IC1和IC2，且两个通道的<code>极性检测相反</code>即这里的</p><p><strong>TI1引脚的输入信号可以映射到TI1FP1和TI1FP2</strong></p><p>TI1FP1连接到的是输入通道1，TI1FP2连接到的是输入通道2，可以使用两个捕获寄存器CCR</p><p><strong>T2引脚的输入信号可以映射到TI2FP1和TI2FP2</strong></p><p>TI2FP1连接到的是输入通道1，TI2FP2连接到的是输入通道2，也可以使用两个捕获寄存器CCR</p><p>一共四种连接方式</p></blockquote><blockquote><p><code>输入捕获的直接模式和间接模式</code>：信号从TI1引入，在自己的捕获寄存器1上进行输入捕获，就叫做<strong>输入捕获的直接模式</strong>。信号从TI1引入借用捕获寄存器2进行输入捕获，则叫做<strong>输入捕获的间接模式(交叉模式)</strong>。</p></blockquote><h3 id="主从触发模式">主从触发模式</h3><p>主从触发模式是：<code>主模式</code>、<code>从模式</code>、<code>触发源</code>选择这三个功能的简称</p><p><img src="../assets/7-173752975558411.png" alt="image-20241125162539989"></p><blockquote><p><code>主模式</code>：可以将定时器内部信号映射到TRGO 引脚，用于触发别的外设</p><p><code>从模式</code>：接收其他外设或者自身外设的一些信号，用于控制自身定时器的运行，也就是被别的信号控制</p><p><code>触发源选择</code>：就是选择从模式的触发信号源的，可以认为是从模式的一部分。选择指定的一个信号，得到TRGI，TRGI去触发从模式，在从模式列表中选择一项操作自动执行</p><p><strong>如：选择TI1FP1触发源，选择Reset操作就可以自动触发从模式，从模式自动清零CNT</strong></p></blockquote><blockquote><p><code>主模式选择</code>可以在对应手册<strong>TIMx_CRx控制寄存器</strong>中查看</p><p><code>从模式选择</code>可以在对应手册<strong>TIMx_SMCR从模式控制寄存器</strong>中查看</p></blockquote><h3 id="输入捕获和PWMI基本结构图">输入捕获和PWMI基本结构图</h3><p><img src="../assets/8-173752975558412.png" alt="image-20241125163454859"></p><blockquote><p><strong>特点</strong>：只使用了一个通道，<code>只能测量频率</code>，使用的是测周法测量频率，所以需要每次触发后将CNT的值清0，使用从模式实现信号触发后自动清0</p><p><strong>F = fc / N</strong></p><p><strong>fc为标准频率：标准频率就是经过PSC分频后的时钟频率</strong></p><p><strong>因为CNT要自增，所以ARR的值要设置的足够大，设置为上限65535</strong></p></blockquote><p><img src="../assets/9-173752975558413.png" alt="image-20241125164342932"></p><blockquote><p><code>PWMI模式（PWM输入模式）</code>：<strong>使用两个通道来捕获，可以测量<code>频率</code>和<code>占空比</code>，使用的是测周法测量频率，所以需要每次触发后将CNT的值清0，使用从模式实现信号触发后自动清0</strong></p><p><strong>下面部分</strong>：</p><p>TI1FP1和TI1FP2以相反的极性检测(TI1FP1检测上升沿，TI1FP2检测下降沿)</p><p>CCR1：一整个周期的计数值，每一次上升沿到来时对应CNT都会清零</p><p>CCR2：高电平期间的计数值</p><p>占空比：duty = CCR2 / CCR1</p><p><strong>因为CNT要自增，所以ARR的值要设置的足够大，设置为上限65535</strong></p><hr><p><strong>上面部分</strong>：选择TI1FP1触发源，使用从模式配合输入捕获，实现CNT自动清零(Reset)，完成硬件自动化</p></blockquote><p><code>相关介绍对应在参考手册的输入捕获和PWM输入模式对应部分</code></p><h3 id="库函数-4">库函数</h3><p><code>初始化函数：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ICInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;</span><br><span class="line"><span class="comment">/*配置输入捕获单元函数，输出比较是四个通道分别有一个函数，而输入捕获配置是4个通道共用一个函数，具体通道选择在结构体中*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_PWMIConfig</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;</span><br><span class="line"><span class="comment">/* 也是配置输入捕获单元的函数，但是这个函数可以快速配置两个通道，将外设电路配置为PWMI模式</span></span><br><span class="line"><span class="comment"> * 传入一个结构体之后，该函数会根据传入结构体通道配置自动初始化另外一个通道为相反的配置</span></span><br><span class="line"><span class="comment"> * 比如：传入结构体配置为通道1，上升沿触发，直接模式，调用该函数就会配置通道2为下降沿触发，且为交叉模式(间接模式)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 该函数只支持通道1和通道2，不能传入通道3和通道4!!!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ICStructInit</span><span class="params">(TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;</span><br><span class="line"><span class="comment">/*输入捕获结构体初始化，一般在某些参数不用初始化的时后调用，防止没有初始化某些值造成意外错误*/</span></span><br></pre></td></tr></table></figure><p><code>主从模式相关函数</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectOutputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_TRGOSource)</span>;</span><br><span class="line"><span class="comment">/*选择输出触发源TRGO，对应主模式输出的触发源*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectInputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_InputTriggerSource)</span>;</span><br><span class="line"><span class="comment">/*选择输入触发源TRGI，对应从模式的触发源选择*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectSlaveMode</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_SlaveMode)</span>;</span><br><span class="line"><span class="comment">/*选择从模式，对应从模式执行操作*/</span></span><br></pre></td></tr></table></figure><p><code>预分频配置</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC1Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC2Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC3Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC4Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;</span><br><span class="line"><span class="comment">/*分别配置通道1~4的预分频值，这个参数可以在结构体中配置*/</span></span><br></pre></td></tr></table></figure><p><code>获取捕获寄存器值</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture1</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture2</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture3</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture4</span><span class="params">(TIM_TypeDef* TIMx)</span>;</span><br><span class="line"><span class="comment">/*分别获取四个通道的捕获寄存器CCR的值*/</span></span><br></pre></td></tr></table></figure><h3 id="输入捕获配置流程">输入捕获配置流程</h3><p><code>根据上面的结构图可以得到输入捕获配置流程:</code></p><ol><li><p><strong>RCC开启时钟，将GPIO和TIM的时钟打开</strong></p></li><li><p><strong>GPIO初始化，配置GPIO为输入模式(上拉或者浮空)</strong></p></li><li><p><strong>配置时基单元的时钟源</strong></p></li><li><p><strong>配置时基单元，让CNT计数器在内部时钟的驱动下自增运行</strong></p></li><li><p><strong>配置输入捕获单元，包括滤波器、极性、直连通道还是交叉通道、分频器等参数</strong></p></li><li><p><strong>配置从模式触发源，触发源选择TI1FP1等</strong> (调用库函数)</p></li><li><p><strong>配置从模式执行的操作</strong>（调用库函数）</p></li><li><p><strong>运行控制，开启定时器TIM</strong></p></li></ol><h3 id="实验-输入捕获模式测频率-输入捕获直接模式">实验-输入捕获模式测频率(输入捕获直接模式)</h3><blockquote><p>这个地方没有信号发生器，选择将另外一个引脚TIM输出信号输入到该TIM引脚。从PB8输入到PA0</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __IC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IC_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.开启对应GPIO和TIM时钟</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"> <span class="comment">//2.配置GPIO为</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_0;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">      GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"><span class="comment">//3.时基单元时钟源配置</span></span><br><span class="line">  TIM_InternalClockConfig(TIM2);</span><br><span class="line"><span class="comment">//4.时基单元配置</span></span><br><span class="line">      TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>;<span class="comment">//ARR</span></span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;<span class="comment">//PSC,标准频率fc = 72M/72 = 1MHz</span></span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span> ;</span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//5.输入捕获单元配置</span></span><br><span class="line">  TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">  TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; <span class="comment">//CH1</span></span><br><span class="line">  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; <span class="comment">//滤波值，越大滤波效果越好</span></span><br><span class="line">  TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//上升沿捕获</span></span><br><span class="line">  TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; <span class="comment">//对应触发信号分频器，不分频DIV1就是每次触发都有效，2分频就是每隔一次生效一次</span></span><br><span class="line">      TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;<span class="comment">//输入捕获直接模式</span></span><br><span class="line">  TIM_ICInit(TIM2,&amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.从模式触发源配置</span></span><br><span class="line">TIM_SelectInputTrigger(TIM2,TIM_TS_TI1FP1);<span class="comment">//配置从模式输入触发源</span></span><br><span class="line">    <span class="comment">//7.从模式执行操作</span></span><br><span class="line">TIM_SelectSlaveMode(TIM2,TIM_SlaveMode_Reset);<span class="comment">//配置从模式操作</span></span><br><span class="line"><span class="comment">//8.运行控制，启动TIM</span></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1000000</span>/TIM_GetCapture1(TIM2)<span class="number">-1</span>; <span class="comment">//这里的-1是为了弥补+-1的误差</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个地方标准频率fc = 72MHz / 72 = 1MHz = 1000000</p><p>fc即为经过PSC分频过后的频率</p><p>测量最低频率为：1MHz / 65535 = 15Hz，再低会溢出。</p><p><strong>如果想要降低最低频率，只需要增大PSC的值</strong></p><p><strong>如果想要增大最低频率，只需要减小PSC的值</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">  PWM_Init();<span class="comment">//输出PWM信号</span></span><br><span class="line">  PWM_SetPrescaler(<span class="number">720</span><span class="number">-1</span>);</span><br><span class="line">  PWM_SetCompare3(<span class="number">25</span>);<span class="comment">//CCR = 25</span></span><br><span class="line">   </span><br><span class="line">  IC_Init();<span class="comment">//输入捕获</span></span><br><span class="line"></span><br><span class="line">  OLED_Init();</span><br><span class="line">  OLED_ShowString(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&quot;Freq:00000HZ&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">5</span>,<span class="number">6</span>,IC_GetFreq(),<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验-PWMI模式测频率和占空比-输入捕获交叉-间接模式">实验-PWMI模式测频率和占空比(输入捕获交叉/间接模式)</h3><blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __IC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __IC_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*IC.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.开启对应GPIO和TIM时钟</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"> <span class="comment">//2.配置GPIO为</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_0;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">      GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"><span class="comment">//3.时基单元时钟源配置</span></span><br><span class="line">  TIM_InternalClockConfig(TIM2);</span><br><span class="line"><span class="comment">//4.时基单元配置</span></span><br><span class="line">      TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>;<span class="comment">//ARR</span></span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;<span class="comment">//PSC,标准频率fc = 72M/72 = 1MHz</span></span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span> ;</span><br><span class="line">TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//5.输入捕获单元配置</span></span><br><span class="line">  TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; <span class="comment">//CH1</span></span><br><span class="line">  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; <span class="comment">//滤波值，越大滤波效果越好</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//上升沿捕获</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; <span class="comment">//对应触发信号分频器，不分频DIV1就是每次触发都有效，2分频就是每隔一次生效一次</span></span><br><span class="line">TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;<span class="comment">//输入捕获直接模式</span></span><br><span class="line">    TIM_PWMIConfig(TIM2,&amp;TIM_ICInitStructure);</span><br><span class="line">        <span class="comment">/*输入捕获模式和PWMI模式差别就在这里*/</span></span><br><span class="line"><span class="comment">//  TIM_ICInit(TIM2,&amp;TIM_ICInitStructure);</span></span><br><span class="line"><span class="comment">//  TIM_ICInitStructure.TIM_Channel = TIM_Channel_2; //CH2</span></span><br><span class="line"><span class="comment">//  TIM_ICInitStructure.TIM_ICFilter = 0xF; </span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling ;//下降沿捕获，与通道一相反</span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; </span></span><br><span class="line"><span class="comment">//TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_IndirectTI;//输入捕获交叉模式</span></span><br><span class="line"><span class="comment">//TIM_ICInit(TIM2,&amp;TIM_ICInitStructure);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.从模式触发源配置</span></span><br><span class="line">TIM_SelectInputTrigger(TIM2,TIM_TS_TI1FP1);<span class="comment">//配置从模式输入触发源</span></span><br><span class="line">    <span class="comment">//7.从模式执行操作</span></span><br><span class="line">TIM_SelectSlaveMode(TIM2,TIM_SlaveMode_Reset);<span class="comment">//配置从模式操作</span></span><br><span class="line"><span class="comment">//8.运行控制，启动TIM</span></span><br><span class="line">TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取频率*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1000000</span>/TIM_GetCapture1(TIM2)<span class="number">-1</span>; <span class="comment">//这里的-1是为了弥补+-1的误差</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取占空比*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetDuty</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TIM_GetCapture2(TIM2)*<span class="number">100</span>/TIM_GetCapture1(TIM2)+<span class="number">1</span>;<span class="comment">//弥补误差</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><strong>使用TIM_PWMIConfig(TIM2,&amp;TIM_ICInitStructure)函数可以快速配置两个通道，见源码可知，该函数自动初始化该通道和初始化另外一个通道为相反的配置。</strong></p></li><li><p><strong>不使用该函数，就配置两次即可，即上方注释部分，通道1配置为上升沿捕获，直接模式，通道2就配置为下降沿捕获，交叉模式，调用两次初始化函数即可。</strong></p></li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">  PWM_Init();<span class="comment">//输出PWM信号</span></span><br><span class="line">  PWM_SetPrescaler(<span class="number">720</span><span class="number">-1</span>);</span><br><span class="line">  PWM_SetCompare3(<span class="number">25</span>);<span class="comment">//CCR = 25</span></span><br><span class="line">   </span><br><span class="line">  IC_Init();<span class="comment">//输入捕获</span></span><br><span class="line"></span><br><span class="line">  OLED_Init();</span><br><span class="line">  OLED_ShowString(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&quot;Freq:00000HZ&quot;</span>);</span><br><span class="line">  OLED_ShowString(<span class="number">10</span>,<span class="number">1</span>,<span class="string">&quot;Duty:00%&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">5</span>,<span class="number">6</span>,IC_GetFreq(),<span class="number">5</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">10</span>,<span class="number">6</span>,IC_GetDuty(),<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编码器接口">编码器接口</h2><h3 id="编码器接口简介">编码器接口简介</h3><p>Encoder Interface - 编码器接口</p><p>编码器接口可接收增量(正交编码器)的信号，根据编码器旋转产生的正交信号脉冲，自动控制<code>CNT</code>自增或自减，从而指示编码器的位置、<strong>旋转方向和旋转速度</strong></p><ul><li><p>每个高级定时器和通用定时器都拥有1个编码器接口，基本定时器没有编码器接口</p></li><li><p>两个输入引脚(CH1、CH2)借用了输入捕获通道的<code>通道1</code>和<code>通道2</code></p></li></ul><blockquote><p>之前我们使用了编码器中断来手动计次，使用编码器接口可以实现自动计次，减少资源浪费，避免频繁中断</p></blockquote><h3 id="正交编码器介绍">正交编码器介绍</h3><p>拥有A相和B相，输出的两个<code>正交方波信号</code>，相位相差90°，超前90°和滞后90°代表正传和反转。</p><p>编码器测速使用的是<code>测频法</code>测量</p><p><img src="../assets/10-173752975558414.png" alt="image-20241126213304783"></p><blockquote><p><code>编码器的上升沿和下降沿都有效</code></p><p>正传CNT自增</p><p>反转CNT自减</p></blockquote><p><img src="../assets/12-173752975558415.png" alt="image-20241126222220541"></p><blockquote><p><strong>三种工作方式</strong>：</p><p>1.仅在T1计数</p><p>2.仅在T2计数</p><p>3.在T1和T2都计数</p><p><code>一般我们使用第三种</code></p><p><strong>编码器接口执行逻辑总结下来就一句话</strong>：</p><p>正转的时候向上计数，反转的时候向下计数</p></blockquote><hr><p><img src="../assets/13-173752975558416.png" alt="image-20241126222801623"></p><blockquote><p><code>正交编码器是抗噪声的原理</code>：</p><p>当遇到毛刺现象时，CNT的值会来回跳动，一会自增一会自减，但最终的值保持不变。</p></blockquote><p><img src="../assets/14-173752975558417.png" alt="image-20241126223216790"></p><blockquote><p>当TI极性选择反相时，需要将图中TI的波形反向后才能得到正确的计数方向。</p><p>当我实际使用过程中如果出现想要正传计数+1，但是却出现-1的情况，我们把任意一个引脚极性反相，就能反转计数方向了。或者直接交换A、B相引脚即可</p></blockquote><h3 id="应用">应用</h3><p>比较常见的应用场景：</p><p>编码器测速一般应用在电机控制的项目上，使用PWM驱动电机，再使用编码器测量电机的速度，然后再用PID算法进行闭环控制。</p><p>一般电机旋转速度较高，会使用无接触式的霍尔传感器或者光栅进行测速。</p><p>这里为了方便，我们使用触点式的旋转编码器。电机旋转呢，我们就用人工旋转来模拟，但实际上旋转编码器和电机的霍尔，光栅编码器都是一样的效果</p><h3 id="编码器接口基本结构图">编码器接口基本结构图</h3><p><img src="../assets/11-173752975558418.png" alt="image-20241126221118178"></p><blockquote><p>对应CH1的TI1FP1和CH2的TI2FP2，与CH3和CH4无关。</p><p>ARR是有效的，一般设置为65535，利用补码的特性可以CNT从0自减时得到的是65535、65534…</p><p><code>编码器的时钟会直接托管驱动计数器，所以在编码器接口模式下时基单元不需要配置内部时钟并且计数模式无效</code></p><hr><p><code>同时输入捕获单元并没有完全使用，只需要配置滤波器和极性选择即可</code></p></blockquote><p><code>更多内容可以在参考手册中的TIM编码器接口模式中查看</code></p><h3 id="库函数-5">库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_EncoderInterfaceConfig</span></span><br><span class="line"><span class="params">(TIM_TypeDef* TIMx,</span></span><br><span class="line"><span class="params"> <span class="type">uint16_t</span> TIM_EncoderMode,</span></span><br><span class="line"><span class="params"> <span class="type">uint16_t</span> TIM_IC1Polarity, </span></span><br><span class="line"><span class="params"> <span class="type">uint16_t</span> TIM_IC2Polarity)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**配置编码器接口的函数</span></span><br><span class="line"><span class="comment"> * 参数1：哪个定时器</span></span><br><span class="line"><span class="comment"> * 参数2：编码器模式,三种：1.仅在T1计数 2.仅在TI2计数 3.T1和T2都计数</span></span><br><span class="line"><span class="comment"> * 一般我们使用第三种T1,T2都计数</span></span><br><span class="line"><span class="comment"> * 参数3：通道1极性,Rising为不反相，Falling为反相</span></span><br><span class="line"><span class="comment"> * 参数4：通道2极性,Rising为不反相，Falling为反相</span></span><br><span class="line"><span class="comment"> * 参数3和参数4根据实际情况选择</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="编码器接口配置流程">编码器接口配置流程</h3><ol><li><p><strong>RCC开启时钟，开启GPIO和对应TIM的时钟</strong></p></li><li><p><strong>配置GPIO，将对应引脚配置为输入模式</strong></p></li><li><p><strong>配置时基单元，预分频器不分频，ARR设置为65535</strong>(不用配置时基单元的内部时钟，编码器会托管相当于外部时钟)</p></li><li><p><strong>配置输入捕获单元，此处输入捕获单元只有滤波器和极性两个参数有用，其他参数没用到</strong></p></li><li><p><strong>配置编码器接口模式</strong></p></li><li><p><strong>运行控制，启动定时器</strong></p></li></ol><blockquote><p>初始化完成后，CNT就会随着编码器旋转而自增自减。</p><p>如果想要读出编码器位置，直接读出CNT的值就行了</p><p>如果想要测量编码器的速度和方向，就需要每隔一定阀门时间，取出一次CNT，然后再把CNT清零，即<code>测频法</code>测量速度</p></blockquote><h3 id="实验-正交编码器测速">实验-正交编码器测速</h3><p>我们使用的是A相：PA8，B相PA9，对应定时器TIM1_CH1和TIM1_CH2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Encoder.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ENCODER_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ENCODER_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Encoder.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//1.配置RCC，开启GPIO和对应TIM </span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB2Periph_TIM1,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//2.GPIO端口配置，配置A，B相端口为输入</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_8 | GPIO_Pin_9;</span><br><span class="line">  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  TIM_InternalClockConfig(TIM1); </span></span><br><span class="line">  <span class="comment">/*编码器接口就不用这个，因为编码器接口就是一个带方向控制的外部时钟，内部时钟没有用了*/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3.时基单元配置</span></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//参数无效，编码器托管</span></span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span><span class="number">-1</span>;<span class="comment">//ARR</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span><span class="number">-1</span>;<span class="comment">//不分频，编码器的时钟直接驱动计数器</span></span><br><span class="line">  TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span> ;</span><br><span class="line">TIM_TimeBaseInit(TIM1,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//4.输入捕获单元配置</span></span><br><span class="line">  TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">TIM_ICStructInit(&amp;TIM_ICInitStructure);<span class="comment">//部分参数未使用，调用该函数防止未初始化参数产生影响</span></span><br><span class="line">TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; </span><br><span class="line">  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; </span><br><span class="line">TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//编码器上升沿和下降沿都有效，所以此处代表极性不反转</span></span><br><span class="line">  TIM_ICInit(TIM1,&amp;TIM_ICInitStructure);</span><br><span class="line"> </span><br><span class="line">TIM_ICInitStructure.TIM_Channel = TIM_Channel_2; </span><br><span class="line">  TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>; </span><br><span class="line">TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising ;<span class="comment">//编码器上升沿和下降沿都有效，所以此处代表极性不反转</span></span><br><span class="line">    TIM_ICInit(TIM1,&amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.编码器接口配置</span></span><br><span class="line">TIM_EncoderInterfaceConfig(TIM1,TIM_EncoderMode_TI12,TIM_ICPolarity_Rising,TIM_ICPolarity_Rising);<span class="comment">//这里的极性与上方极性配置的同一个寄存器，可以删除上方极性配置</span></span><br><span class="line">    <span class="comment">//6.运行控制TIM使能</span></span><br><span class="line">TIM_Cmd(TIM1,ENABLE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> speed = TIM_GetCounter(TIM1);</span><br><span class="line">TIM_SetCounter(TIM1,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> speed;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*放到缓存的speed当中，再清零CNT即可，最终在主循环中实现延时即可*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Encoder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> OLED_Init();</span><br><span class="line"> Encoder_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>,<span class="number">5</span>,Encoder_Get(),<span class="number">5</span>);</span><br><span class="line">        Delay_ms(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">/*1s测一次速*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果实现效果与想要的不符合，修改编码器接口配置中任意一个引脚的极性参数即可</p><p><code>此处在循环中使用了Delay函数，影响了效率，更加好的办法是开启一个1s的定时器中断，在定时器中断中更新speed的值即可</code></p></blockquote><h1>ADC</h1><h2 id="ADC简介">ADC简介</h2><p>ADC(Analog-Digital Converter)模拟-数字转换器</p><p>ADC可以将引脚上连续变化的模拟电压转换为内存中储存的数字变量，建立模拟电路到数字电路的桥梁</p><p>12位逐次逼近型ADC，1us的转换时间(ADC转化频率为1MHz)</p><p><strong>输入电压范围：0~3.3V，转化结果范围：0~4095(2的12次方)</strong></p><p>一共<code>18个输入通道</code>，可测量<code>16个外部信号</code>和<code>2个内部信号源</code><strong>(内部温度传感器和内部参考电压，不随外部电压变化)</strong></p><p>分为<code>规则组(规则通道)</code>和<code>注入组(注入通道)</code>两个转换单元</p><p>可模拟看门狗自动监测输入电压范围</p><p>STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p><p><code> 对应所有的知识都能在芯片参考手册中查看</code></p><h2 id="ADC内部结构">ADC内部结构</h2><p><img src="../assets/15-173752975558419.png" alt="image-20241127201536862"></p><blockquote><p>逐次逼近型通过二分法给DAC值进行比较，直到找到未知电压编码</p><p>比如8位：0~255，先给128，再给64…相当于二进制的高位到低位</p><p>对于8位ADC，高位到低位判断8次即可找到位置电压编码</p><p>对于12位ADC，高位到低位判断12次即可找到位置电压编码</p></blockquote><hr><p><code>STM32的ADC</code></p><p><img src="../assets/16-173752975558420.png" alt="image-20241127202456782"></p><blockquote><p>ADCx_IN0~15 就是对应的16个外部信号</p><p>温度传感器和Vrefint就是内部2个信号源</p><hr><p>通道分为<strong>注入通道(注入组)<strong>和</strong>规则通道(规则组)</strong></p><p><code>规则通道</code>：可以同时转选择16个通道，但是对于转化结果，因为<strong>规则通道只有一个数据寄存器</strong>，所以存在<code>数据覆盖问题</code>。如果不想结果被覆盖，需要在转换完成后尽快把数据拿走。此时一般配合DMA进行搬运</p><p><code>注入通道</code>：可以同时选择4个通道，拥有四个数据寄存器，不用担心数据被覆盖</p><p><code>对应规则通道和注入通道可以在参考手册中找到对应介绍</code></p><hr><p><code>流程</code>：</p><p>前面的通道选择后到模拟至数字转换器，</p><p>然后模拟至数字转换器中就执行逐次比较的过程，最终结果放在了注入通道/规则通道数据寄存器中。</p><p><strong>转换结束后会有一个EOC信号，该信号是规则组或注入组的完成信号，还有个JEOC是注入组完成的信号，会置状态寄存器标志位，可以读取该标志位判断是否转换完成</strong></p><p><strong>同时这两个标志位也可以去到NVIC申请中断，如果开启对应NVIC通道就可以触发中断</strong></p></blockquote><hr><p><strong>触发转换部分</strong>：对应START信号启动ADC的转换</p><p><img src="../assets/17-173752975558421.png" alt="image-20241127203720470"></p><blockquote><p>对应STM32ADC，触发ADC开始转换的信号有两种：<code>软件触发</code>和<code>硬件触发</code></p><p><code>硬件触发</code>：对应图中注入组的触发源和规则组的触发源，主要来自<strong>定时器</strong>，在定时器章节中我们知道，定时器可以通向ADC、DAC外设，用于触发转换。也可以使用<strong>外部中断引脚</strong>触发</p><p>比如图中我们给TIM3指定1ms时间，将TIM3的更新事件选择为TIM3_TRGO输出，再把ADC选择开始触发信号为TIM3_TRGO，这样TIM3的更新事件就能通过硬件自动触发ADC转换了，不需要进中断</p><p><code>软件触发</code>：程序中调用代码完成ADC转换触发。</p></blockquote><hr><p><code>ADC时钟</code></p><p><img src="../assets/18-173752975558422.png" alt="image-20241127204615868"></p><blockquote><p>ADC时钟来自RCC，经过ADC预分频器到达，注意此处最大位14MHz，2分频和4分频结果超过了最大值，不建议使用，这里<strong>至少6分频</strong></p><p>ADC预分频器小于14MHz即可</p></blockquote><p><code>模拟看门狗</code></p><p><img src="../assets/19-173752975558424.png" alt="image-20241127204756265"></p><blockquote><p><strong>模拟看门狗用于监测转换结果的范围</strong>，其中可以存一个阈值高限和阈值低限，如果启动了看门狗并且设定了通道，该看门狗就会关注看门的通道，一旦超过阈值范围就可以申请一个通向NVIC的ADC中断。</p></blockquote><h2 id="ADC输入通道">ADC输入通道</h2><p><img src="../assets/21-173752975558423.png" alt="image-20241127210445125"></p><blockquote><p>我们可以在引脚定义表中找到对应ADC通道0~9的通道对应引脚，这代表该芯片只有10个通道</p><p>同时我们可以发现ADC12_INx 这样写代表ADC1和ADC2都是这个引脚。我们可以单独使用一个ADC，也可以同时使用。</p><p><strong>ADC还有一种高级模式叫双ADC模式，就是ADC1和ADC2一起配贼和使用，可以配合组成同步、交叉模式等，可以进一步提高采样率</strong></p></blockquote><h2 id="ADC转换模式">ADC转换模式</h2><p><strong>一共有四种转换方式：多通道只能使用后面两种模式，必须开启扫描模式</strong></p><ol><li><code>单次转换，非扫描模式</code></li></ol><p><img src="../assets/22-173752975558525.png" alt="image-20241127211229845"></p><blockquote><p>只会转换第一个序列的通道，每次转换都需要触发一次</p><p>想要更换通道转换只需要更改序列1的通道即可</p></blockquote><ol start="2"><li><code>连续转换，非扫描模式</code></li></ol><p><img src="../assets/23-173752975558526.png" alt="image-20241127211310674"></p><blockquote><p>只会转换第一个序列的通道，但触发转换后不会停止，会一直持续转换。只需要第一次触发即可</p></blockquote><ol start="3"><li><code>单次转换，扫描模式</code></li></ol><p><img src="../assets/24-173752975558527.png" alt="image-20241127211656061"></p><blockquote><p><strong>按顺序依次转换一组通道</strong>，可以指定通道数目，指定的所有通道转换完成后才会触发EOC信号。每次转换都需要触发</p></blockquote><ol start="4"><li><code>连续转换，扫描模式</code></li></ol><p><img src="../assets/25-173752975558528.png" alt="image-20241127211932067"></p><blockquote><p><strong>按顺序依次转换一组通道</strong>，可以指定通道数目，指定的所有通道转换完成后才会触发EOC信号。只需要一次触发就可以一直转换</p></blockquote><p><code>其实还有个间断模式</code>：可以说是对扫描模式的补充</p><blockquote><p>触发一次，转换一个通道，在触发，在转换。在所选转换通道循环，**由触发信号启动新一轮的转换，直到转换完成为止。**例如：可以把0,1,4,5这四个通道进行分组。可以分成0,1一组，4,5一组。也可以每个通道单独配置为一组。这样每一组转换之前都需要先触发一次。</p></blockquote><h2 id="ADC触发控制">ADC触发控制</h2><p><img src="../assets/26-173752975558529.png" alt="image-20241127212108346"></p><h2 id="ADC数据对齐">ADC数据对齐</h2><p><img src="../assets/27-173752975558531.png" alt="image-20241127212138053"></p><blockquote><p>寄存器总共16位需要对齐，高位或低位补0</p><p><strong>一般使用右对齐，可以直接读取寄存器就是结果</strong></p><p>左对齐得到的结果比实际值偏大16倍，对于裁剪分辨率使用</p></blockquote><h2 id="ADC转换时间">ADC转换时间</h2><p><img src="../assets/28-173752975558530.png" alt="image-20241127212422377"></p><blockquote><p><code>量化、编码</code>：就是ADC逐次比较的过程，位数越多花费时间越长</p><p><code>采样、保持</code>：量化编码需要时间，通过开启采样开关，一段时间后断开后使电压在量化编码时保持不变</p><hr><p><strong>ADC总转换时间中</strong>：</p><p><code>采样时间：</code>就是采样保持时间，采样时间可以在程序中配置，时间越长越能避免毛刺信号的干扰，但会导致转换时间延长。</p><p><code>12.5个ADC周期：</code>量化编码所花费时间，因为是12位，所以需要12个周期，多余的0.5周期可能做了一些其他事情</p><p>14个周期：14/14MHz = 1μs</p><hr><p><code>采样时间选择</code>：</p><p><strong>需要更快的转换，就选小的参数，但容易受干扰</strong></p><p><strong>需要更稳定的转换，就选大的参数，转换时间长</strong></p></blockquote><h2 id="ADC校准">ADC校准</h2><p><img src="../assets/29-173752975558532.png" alt="image-20241127220041612"></p><blockquote><p><strong>校准过程我们不需要理解，校准过程固定，只需要在ADC初始化的最后，加几行代码就行了，至于怎么计算、怎么校准的，我们不需要管</strong></p><hr><p><strong>流程</strong>：</p><p><code>复位校准</code>-<code>等待复位校准(判断标志位)</code>-<code>开始校准</code>-<code>等待校准(判断标志位)</code></p></blockquote><h2 id="硬件电路">硬件电路</h2><p><img src="../assets/30-173752975558533.png" alt="image-20241127220346370"></p><blockquote><p>第一个是电位器产生可调电路，通过滑动变阻器可以调节电压0~3.3V</p><hr><p>第二个是传感器输出电压电路，光敏电阻、热敏电阻等都可等效为一个可变电阻，电阻阻值没法直接测量，<strong>一般直接通过和一个固定电阻串联分压来得到反应电阻值电压</strong>的电路。</p><p><code>固定电阻一般可以选择和传感器阻值相近的电阻较好</code></p><p>传感器阻值变小时，下拉作用变强，输出端电压就下降，传感器阻值变大时，下拉作用变弱，输出端受上拉作用电压就会升高</p><hr><p>第三个是一个简易电压转换电路，使用电阻分压。根据分压公式可以得到中间的电压位(VIN/50K) * 33K，高电压一般不适用比较危险，高电压一般使用一些采集芯片，做好高低电压的隔离</p></blockquote><h2 id="ADC基本结构图">ADC基本结构图</h2><p><img src="../assets/20-173752975558534.png" alt="image-20241127205844255"></p><h2 id="库函数-6">库函数</h2><p><code>配置ADCCLK分频器</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_ADCCLKConfig</span><span class="params">(<span class="type">uint32_t</span> RCC_PCLK2)</span>;</span><br><span class="line"><span class="comment">/*在stm32f10x_rcc.h中可以找到，该函数用于配置ADCCLK分频器，可以对APB2的72MHz时钟选择2、4、6、8分频，输入到ADCCLK*/</span></span><br></pre></td></tr></table></figure><p><code>ADC初始化:stm32f10x_adc.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_DeInit</span><span class="params">(ADC_TypeDef* ADCx)</span>;<span class="comment">//恢复缺省配置</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Init</span><span class="params">(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_StructInit</span><span class="params">(ADC_InitTypeDef* ADC_InitStruct)</span>;</span><br></pre></td></tr></table></figure><p><code>ADC启动</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_Cmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;<span class="comment">//开启ADC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DMACmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;<span class="comment">//开启DMA输出信号，使用DMA需要调用</span></span><br></pre></td></tr></table></figure><p><code>ADC通道配置</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_RegularChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel, <span class="type">uint8_t</span> Rank, <span class="type">uint8_t</span> ADC_SampleTime)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 规则组通道配置，为序列添加通道</span></span><br><span class="line"><span class="comment"> * 参数1：对应ADC</span></span><br><span class="line"><span class="comment"> * 参数2：指定ADC通道</span></span><br><span class="line"><span class="comment"> * 参数3：对应序列号</span></span><br><span class="line"><span class="comment"> * 参数4：指定通道采样时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多个通道指定时，多次调用该函数配置即可</span></span><br></pre></td></tr></table></figure><p><code>ADC外部触发转换控制</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*是否允许外部触发转换*/</span></span><br></pre></td></tr></table></figure><p><code>ADC中断</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_ITConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*用于控制某个中断，能否通往NVIC*/</span></span><br></pre></td></tr></table></figure><p><code>ADC控制校准：在ADC初始化完成后依次调用即可</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_ResetCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*复位校准*/</span></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetResetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*获取复位校准状态*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_StartCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*开始校准*/</span></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*获取开始校准复位状态*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ADC触发控制</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_SoftwareStartConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*ADC软件触发控制，调用即可设置为软件触发*/</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetSoftwareStartConvStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">/*ADC获取软件开始转换状态，返回SWSTART状态，与转换是否结束无关，一般不适用*/</span></span><br></pre></td></tr></table></figure><p><code>ADC间断模式配置</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_DiscModeChannelCountConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> Number)</span>;</span><br><span class="line"><span class="comment">/*ADC间断模式配置，设置Number可以设置每隔几个通道间断一次*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DiscModeCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*使能间断模式*/</span></span><br></pre></td></tr></table></figure><p><code>ADC转换结束判断</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">ADC_GetFlagStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;</span><br><span class="line"><span class="comment">/*参数给EOC标志位可以判断是否转换完成*/</span></span><br></pre></td></tr></table></figure><p><code>ADC获取转换值</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetConversionValue</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="comment">//获取AD转换数据寄存器，读取转换结果</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ADC_GetDualModeConversionValue</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//双ADC模式读取转换结果</span></span><br></pre></td></tr></table></figure><p><code>ADC注入组</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_AutoInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedDiscModeCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigInjectedConvConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint32_t</span> ADC_ExternalTrigInjecConv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_SoftwareStartInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line">FlagStatus <span class="title function_">ADC_GetSoftwareStartInjectedConvCmdStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel, <span class="type">uint8_t</span> Rank, <span class="type">uint8_t</span> ADC_SampleTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedSequencerLengthConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_SetInjectedOffset</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_InjectedChannel, <span class="type">uint16_t</span> Offset)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetInjectedConversionValue</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_InjectedChannel)</span>;</span><br></pre></td></tr></table></figure><p><code>ADC模拟看门狗</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogCmd</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint32_t</span> ADC_AnalogWatchdog)</span>;</span><br><span class="line"><span class="comment">/*是否启动看门狗*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogThresholdsConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> HighThreshold, <span class="type">uint16_t</span> LowThreshold)</span>;</span><br><span class="line"><span class="comment">/*配置看门狗高低阈值*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogSingleChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel)</span>;</span><br><span class="line"><span class="comment">/*配置看门通道*/</span></span><br></pre></td></tr></table></figure><p><code>ADC内部信号配置</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_TempSensorVrefintCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*ADC温度传感器，内部参考电压控制，用于开启内部两个通道，需要使用时调用开启即可*/</span></span><br></pre></td></tr></table></figure><p><code>ADC标志位</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">ADC_GetFlagStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ClearFlag</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;</span><br><span class="line"></span><br><span class="line">ITStatus <span class="title function_">ADC_GetITStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ClearITPendingBit</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT)</span>;</span><br><span class="line"><span class="comment">//常用的标志位相关函数，带IT的应该在中断服务函数中使用</span></span><br></pre></td></tr></table></figure><h2 id="ADC配置流程">ADC配置流程</h2><p>打通上方ADC基本结构图即可：</p><ol><li><p><strong>RCC开启时钟，开启ADC和GPIO时钟，配置ADCCLK分频器</strong></p></li><li><p><strong>配置GPIO，配置对应GPIO为<code>模拟输入</code>的模式</strong></p></li><li><p><strong>配置多路开关，将左边对应通道接入规则组/注入组中(规则/注入通道配置)</strong></p></li><li><p><strong>配置ADC转换器，结构体(单次转换/连续转换、扫描/非扫描，几个通道等)</strong></p></li><li><p>如果需要模拟看门狗，配置阈值和监测通道，没有就跳过</p></li><li><p>如果想要使用中断，使用ADITConfig开启对应中断输出，配置NVIC即可，没有跳过</p></li><li><p><strong>开启ADC，调用ADC_Cmd函数</strong></p></li><li><p><strong>校准ADC，减小误差</strong></p></li></ol><h2 id="实验-ADC读取电位器电压-ADC单通道">实验-ADC读取电位器电压(ADC单通道)</h2><p>对应引脚定义可知电位器PA5对应通道为ADC_IN5，选择ADC_Channel_5即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*AD.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __AD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __AD_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetValue</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*AD.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.开启RCC时钟，ADC和GPIO</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.ADC预分频器配置，72Mhz / 6 =12Mhz，不能超过14Mhz，至少6分频</span></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.GPIO配置为模拟输入</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.规则通道配置,将通道5写入规则通道的第一个位置(序列1)</span></span><br><span class="line">  ADC_RegularChannelConfig(ADC1,ADC_Channel_5,<span class="number">1</span>,ADC_SampleTime_239Cycles5);</span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_1,2,ADC_SampleTime_55Cycles5); 如果还有其他通道，继续调用配置即可</span></span><br><span class="line"><span class="comment">//ADC_RegularChannelConfig(ADC1,ADC_Channel_2,3,ADC_SampleTime_239Cycles5); 如果还有其他通道，继续调用配置即可</span></span><br><span class="line"><span class="comment">//5.ADC转换器配置</span></span><br><span class="line">ADC_InitTypeDef ADC_InitStruct;</span><br><span class="line">ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; <span class="comment">//ADC转换模式，该参数为独立ADC工作，剩余的其他参数都是双ADC模式</span></span><br><span class="line">ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;<span class="comment">//数据右对齐</span></span><br><span class="line">ADC_InitStruct.ADC_ExternalTrigConv =ADC_ExternalTrigConv_None;<span class="comment">//这里选择软件触发，剩下的都为硬件触发</span></span><br><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;<span class="comment">//启动连续转换模式</span></span><br><span class="line">ADC_InitStruct.ADC_ScanConvMode = DISABLE;<span class="comment">//是否启动扫描模式</span></span><br><span class="line">ADC_InitStruct.ADC_NbrOfChannel = <span class="number">1</span>; <span class="comment">// 指定扫描模式下总共使用的通道数</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStruct);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5.开启ADC</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.ADC校准</span></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1)== SET)&#123;&#125;;<span class="comment">//RSTCAL寄存器由软件置1后开始复位校准，完成后硬件自动清0该位</span></span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET)&#123;&#125;;<span class="comment">//CAL寄存器由软件置1后开始校准，校准结束后硬件自动清0该位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ADC_SoftwareStartConvCmd(ADC1, ENABLE);在启动连续转换模式时，只需要在这里触发转换一次即可，不需要每次获取值都调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取ADC值流程：</span></span><br><span class="line"><span class="comment"> *  1.触发转换</span></span><br><span class="line"><span class="comment"> *  2.判断标志位等待转换完成</span></span><br><span class="line"><span class="comment"> *  3.读取转换结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.触发转换,上面没开启连续转换模式，开启连续转换模式只需要启动一次即可</span></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1, ENABLE);<span class="comment">//启动软件触发转换,也可以使用硬件触发</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.判断标志位,等待转换完成</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC) == RESET)&#123;&#125;;<span class="comment">//在手册中有介绍，转换完成前为0，转换完成后自动置1</span></span><br><span class="line"><span class="comment">/*等待转换时间为上面设置的采样周期，239+12.5=251.5个周期，时间为251.5/12Mhz=20.9us*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.读取转换结果</span></span><br><span class="line"><span class="keyword">return</span> ADC_GetConversionValue(ADC1);<span class="comment">//读取DR寄存器时自动清除EOC位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"><span class="type">float</span> Voltage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> OLED_Init();</span><br><span class="line"> AD_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> adValue = ADC_GetValue();</span><br><span class="line">Voltage = (<span class="type">float</span>)adValue / <span class="number">4095</span> * <span class="number">3.3</span>;<span class="comment">//根据精度对应计算出电压值</span></span><br><span class="line">OLED_ShowNum(<span class="number">5</span>,<span class="number">5</span>,adValue,<span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">10</span>,<span class="number">5</span>,Voltage,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意实验中OLED得到的AD值末尾持续抖动，这是正常波动</p><p><strong>但是如果我们需要对该AD值进行判断，再执行一些操作时，比如AD值大于某一值开灯，小于某一值就关灯。此时由于AD值存在波动就可能会来回开灯关灯。</strong></p><p><code>解决方法</code>：</p><ol><li><strong>使用迟滞比较法，设置上下阈值，高于上阈值开灯，低于下阈值关灯，类似于施密特触发器</strong></li><li><strong>如果数据跳变太厉害，可以使用均值滤波的方式，读取10~20个值取平均值作为输出结果</strong></li><li><strong>还可以裁剪分辨率去掉数据的尾数，也可以避免跳动</strong></li></ol></blockquote><h2 id="实验-ADC多通道采集">实验- ADC多通道采集</h2><blockquote><p>多通道采集，我们想到的是启动扫描模式，但是存在<code>数据覆盖</code>的问题。扫描模式是会一次将所有通道全部转换完之后才会发出EOC信号，每一个通道单独转换完成不会产生任何标志位，也不会有中断，同时AD转换很快，所以我们很难做到在一个通道转换完成后将数据手动转移。</p><p>但是很难不是不行，我们可以使用间断模式，扫描时没转换一个通道就暂停一次，我们此时可以转移数据，再继续触发，继续下一次转换。由于没有单个通道转换完成后没有标志位，我们只能通过Delay的方式延时等待转换时间，所以这种方式不推荐</p><p><strong>所以如果我们想用扫描模式实现多通道，最好配合DMA来实现</strong></p><p><code>扫描模式+DMA搬运实现ADC多通道采集见下一节DMA实验</code></p></blockquote><p>其实我们可以使用<strong>单次转换非扫描模式</strong>实现，只需要为AD_GetValue添加一个ADC_Channel的参数，调用时都重新配置规则通道再触发转换即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    adValue1 = ADC_GetValue(ADC_Channel_0);</span><br><span class="line">    adValue2 = ADC_GetValue(ADC_Channel_1);</span><br><span class="line">    adValue3 = ADC_GetValue(ADC_Channel_2);</span><br><span class="line">    adValue4 = ADC_GetValue(ADC_Channel_3);</span><br><span class="line">    Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>DMA</h1><h2 id="DMA简介">DMA简介</h2><p><img src="../assets/31-173752975558535.png" alt="image-20241128195544055"></p><blockquote><p><strong>DMA-直接内存访问，是一个数据转运小助手，主要是协助CPU完成数据转运的工作，无须CPU干预，CPU就可以干其他更重要的事</strong></p><p>这里的<code>外设</code>一般指<code>外设数据寄存器</code>，<code>存储器</code>一般指<code>运行内存SRAM和程序存储器</code>(存储变量数组和程序代码的地方)</p><hr><p><strong>存储器到存储器</strong>的数据转运，一般使用<code>软件触发</code>，比如从FLASH到SRAM，因为软件触发是以最快的方式一股脑搬运过去，越快越好</p><p><strong>存储器到外设</strong>的数据转运，一般使用<code>特定硬件触发</code>(每个外设对应DMA通道)，比如ADC一个通道转换完成后，硬件触发一次DMA，DMA再转运。这样得到的值才正确</p></blockquote><blockquote><p><code>常见的用途：</code></p><ul><li><strong>最常见：配合ADC的扫描模式，解决ADC数据覆盖问题</strong></li><li><strong>各外设提高效率</strong></li></ul></blockquote><p><code>阅读参考手册获得所有介绍!!!</code></p><h2 id="STM32存储器映像">STM32存储器映像</h2><p><img src="../assets/32-173752975558536.png" alt="image-20241128201135199"></p><blockquote><p><code>FLASH：</code>存放我们编译后的程序以及常量数据(const等)</p><p><code>SRAM：</code>程序的临时变量存储，变量地址都是以20开头</p><p><code>外设寄存器：</code>对应每个外设的寄存器</p><p><code>内核外设</code>：<strong>只有NVIC和Systick</strong>，与其他外设不是一个厂家设计的，所以地址被分开了</p><hr><p><code>1.在STM32的数据手册，也会有个存储器映像的图,里面可以查看各外设起始地址等</code></p><p><code>2.在对应代码的宏定义不断跳转我们可以看到定义的SRAM、外设等基地址也是上表中给出的地址，通过基地址+偏移量可以得到各外设地址等</code></p></blockquote><h2 id="DMA框图">DMA框图</h2><p><img src="../assets/image-20241129210721223-173752975558537.png" alt="image-20241129210721223"></p><p><strong>主要包括</strong>：</p><ul><li><p><strong>用于访问各个存储器的DMA总线</strong></p></li><li><p><strong>内部的多个通道，可以进行独立的数据转运</strong></p></li><li><p><strong>仲裁器，用于调度各个通道，防止产生冲突</strong></p></li><li><p><strong>AHB从设备：是DMA自身的寄存器，用于配置DMA参数</strong></p></li><li><p><strong>DMA请求，用于硬件触发DMA的数据转运</strong></p></li></ul><p><img src="../assets/34-173752975558538.png" alt="image-20241129204758768"></p><blockquote><p><code>寄存器：</code></p><p>各个外设都可以看成是寄存器，也是一种SRAM存储器，寄存器是一种特殊的存储器，一方面，CPU可以对寄存器进行读写，另一方面寄存器的每一位背后，都连接了一个线，这些线可以用于控制外设电路的状态，比如设置引脚高低电平，导通和断开开关等，或者多位组合起来当做计数器、数据寄存器等</p><p>寄存器是连接软件和硬件的桥梁，软件读写寄存器就相当在控制硬件的执行</p><hr><p>外设寄存器，有些是只读的，有些是可读可写的，具体看参考手册上的介绍</p></blockquote><p><img src="../assets/image-20241129205958030-173752975558539.png" alt="image-20241129205958030"></p><blockquote><p><code>DMA请求：</code></p><p>请求就是触发的意思，DMA请求线路的触发源是各个外设，DMA请求就是DMA的硬件触发源，比如ADC转换完成、串口接收到数据时，需要触发DMA转运数据时，就会通过这条线路向DMA发出硬件触发信号，之后DMA就可以在执行数据转运的工作了。</p></blockquote><blockquote><p><code>FLASH :</code></p><p>这里是ROM只读存储器的一种，如果通过总线直接访问，无论是CPU还是DMA都是只读的，如果DMA转运的目的地址填写的是FLASH就会出错。</p><p><code>SRAM:</code>可以任意读写</p></blockquote><h2 id="DMA-基本结构图">DMA 基本结构图</h2><p><img src="../assets/image-20241129213600867-173752975558540.png" alt="image-20241129213600867"></p><blockquote><p><code>图中所有参数都是使用结构体配置</code></p><p>有个方向控制的参数可以控制外设寄存器到存储器的方向</p><p>外设寄存器和存储器(Flash、SRAM)都有三个参数：</p><ol><li>起始地址</li><li>数据宽度</li><li>地址是否自增</li></ol><hr><p><code>传输计数器：</code>用于指定转运次数，是一个自建计数器，每转运一次，值减1，直到减小到0之后DMA停止转运，对应自增过后的地址恢复到起始地址的位置，以方便DMA开始新一轮转换</p><p><strong>注意：不能在DMA开启时，写传输计数器，这是手册的规定！！！</strong></p><p><strong>需要写计数器时按照即可：DMA失能–写传输计数器–DMA使能</strong></p><p><code>自动重装器：</code>传输计数器减小到0之后是否需要恢复到最初的值，指定重装就是循环模式</p><hr><p><strong>触发控制</strong>：决定DMA什么时间进行转运，由M2M(Memory to Memory)参数决定软件触发还是硬件触发</p><p><code>软件触发：</code><strong>一般用于存储器到存储器的转运，这些转运不需要一定时机</strong>，参数<code>M2M为1时</code>为软件触发，并不是调用一个函数一次就触发一次，而是以最快的速度，连续不断的触发DMA，以最快速度将传输计数器减少到0，与外部中断和ADC的软件触发可能不太一样，可以理解为<strong>自动连续触发</strong></p><p><strong>软件触发和循环模式不能同时使用，因为软件触发是想把计数器清0，而循环模式会重载，DMA就停不下来了</strong></p><p><code>硬件触发：</code><strong>一般用于与外设有关的转运，转运需要一定时机当硬件达到这些时机时传一个信号，触发DMA进行转运，比如ADC转换完成等</strong>，<code>参数M2M为0</code>时为硬件触发，触发源可以选择ADC、串口、定时器等等</p><hr><p><code>开关控制</code>：</p><p>DMA_Cmd函数</p></blockquote><blockquote><p><code>DMA转运需要有三个条件：</code></p><ol><li>使能DMA，开关控制</li><li>传输计数器不为0</li><li>必须要有触发源</li></ol></blockquote><h2 id="DMA请求映像">DMA请求映像</h2><p><img src="../assets/image-20241129223925869-173752975558541.png" alt="image-20241129223925869"></p><blockquote><p>每个通道有一个数据选择器，选择硬件触发或者软件触发，EN位决定数据选择器是否工作</p><p><code>硬件触发注意</code>：<strong>M2M = 0</strong></p><p><strong>每个外设触发通道都不一样，所以我们在选择硬件触发源时，一定要先找到对应通道触发</strong>，比如ADC1在通道1，定时器更新事件(TIM2_UP)在通道2</p><p>对应的有ADC_DMACmd、TIM_DMACmd函数等</p><p><code>软件触发</code>：<strong>M2M = 1</strong></p><p><strong>DMA和通道任意选择，每个通道软件触发都是一样的</strong></p><hr><p><code>优先级:</code></p><p>类似与中断优先级判断，通道号越小优先级越高，也可在程序中配置</p></blockquote><h2 id="数据宽度与对齐">数据宽度与对齐</h2><p><img src="../assets/image-20241129224639834-173752975558542.png" alt="image-20241129224639834"></p><blockquote><p><code>源端宽度</code>和<code>目标宽度</code>相同时和不同时的数据传输处理：与变量赋值类似</p><p>源端宽度=目标宽度，不变</p><p>源端宽度&lt;目标宽度，高位补0</p><p>源端宽度&gt;目标宽度，高位舍弃</p></blockquote><h2 id="例子">例子</h2><h3 id="数据转运-DMA-存储器到存储器转运">数据转运+DMA(存储器到存储器转运)</h3><p><img src="../assets/image-20241129225329602-173752975558543.png" alt="image-20241129225329602"></p><blockquote><p>不需要转运时间同步等，使用软件触发即可</p></blockquote><h3 id="ADC扫描模式-DMA-外设到存储器">ADC扫描模式+DMA(外设到存储器)</h3><p><img src="../assets/image-20241129225519836-173752975558544.png" alt="image-20241129225519836"></p><blockquote><p>我们需要在每个单独的通道转换完成后，进行一个DMA转运，并且使目的地址自增，源地址不自增，方向为外设到存储器，传输计数器7次</p><p>ADC连续扫描，DMA可以使用自动重装，使ADC和DMA同时工作</p><p>DMA转运时机需要和ADC单个通道转换同步，所以DMA触发要选择ADC硬件触发。</p><p><strong>单个通道转换完成时应该可以触发DMA传输，否则无法完成</strong></p></blockquote><h2 id="库函数-7">库函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化相关函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_DeInit</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Init</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_StructInit</span><span class="params">(DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使能DMA对应通道,第一个参数不再是DMAx，而是DMAy_x,即选择了哪个DMA，又选择了DMA的通道，DMA几的通道几</span></span><br><span class="line"><span class="comment">  * 软件触发随意选择通道</span></span><br><span class="line"><span class="comment">  * 硬件触发，先查看手册找到对应外设的通道在设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Cmd</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*DMA中断输出使能*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ITConfig</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="type">uint32_t</span> DMA_IT, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*传输计数器值设置和获取*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_SetCurrDataCounter</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="type">uint16_t</span> DataNumber)</span>; </span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">DMA_GetCurrDataCounter</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关函数*/</span></span><br><span class="line">FlagStatus <span class="title function_">DMA_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> DMAy_FLAG)</span>;<span class="comment">//获取标志位状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> DMAy_FLAG)</span>;<span class="comment">//清除标志位</span></span><br><span class="line">ITStatus <span class="title function_">DMA_GetITStatus</span><span class="params">(<span class="type">uint32_t</span> DMAy_IT)</span>;<span class="comment">//获取中断状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ClearITPendingBit</span><span class="params">(<span class="type">uint32_t</span> DMAy_IT)</span>;<span class="comment">//清除中断挂起位</span></span><br></pre></td></tr></table></figure><h2 id="DMA配置流程">DMA配置流程</h2><p><code>根据DMA基本结构图配置如下：</code></p><ol><li><strong>RCC开启DMA时钟</strong></li><li><strong>配置DMA，调用DMA_Init，初始化各个参数(外设和存储器站点的起始地址、数据宽度、地址是否自增、方向、传输计数器、是否需要自动重装、选择触发源等参数)</strong></li><li>如果需要DMA中断，调用DMA_ITConfig开启中断输出，配置NVIC各个参数，写好对应中断服务函数即可，<strong>不用中断可以直接跳过</strong></li><li><strong>DMA使能，DMA_Cmd函数(别忘了对应在外设XXX_DMACmd开启触发信号输出)</strong></li></ol><h2 id="实验-DMA数据转运-存储器到存储器">实验-DMA数据转运(存储器到存储器)</h2><p><code>DMA不涉及外围硬件电路，故.c/.h文件放在System文件夹中</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DMA.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DMA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DMA_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMAInit</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint32_t</span> Size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Transfer</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*DMA.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> DMA_Size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMAInit</span><span class="params">(<span class="type">uint32_t</span> AddrA,<span class="type">uint32_t</span> AddrB,<span class="type">uint32_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.RCC开启DMA时钟</span></span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.配置DMA</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line">DMA_InitStruct.DMA_PeripheralBaseAddr = AddrA;<span class="comment">//外设站点起始地址</span></span><br><span class="line">DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;<span class="comment">//外设站点数据宽度,这里以字节传输</span></span><br><span class="line">DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Enable;<span class="comment">//地址是否自增(Increment)，这里启用</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryBaseAddr = AddrB;<span class="comment">//存储器站点起始地址</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;<span class="comment">//存储器站点数据宽度</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//地址是否自增</span></span><br><span class="line">DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC ; <span class="comment">// 传输方向(direction),这里选择的是外设站点作为数据源</span></span><br><span class="line">DMA_InitStruct.DMA_BufferSize = Size; <span class="comment">// 传输计数器的值,其实就是传输次数,一次传输上面设置的数据宽度的值</span></span><br><span class="line">DMA_InitStruct.DMA_Mode = DMA_Mode_Normal; <span class="comment">// 传输模式，就是是否使用自动重装。Normal不重装，circular是循环重装</span></span><br><span class="line">DMA_InitStruct.DMA_M2M = DMA_M2M_Enable; <span class="comment">//配置软件触发还是硬件触发位(0,1),Enable是软件触发</span></span><br><span class="line">DMA_InitStruct.DMA_Priority = DMA_Priority_Medium; <span class="comment">// 配置优先级，选择中等</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStruct);<span class="comment">//软件触发使用任意通道都可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.DMA使能</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line"></span><br><span class="line">DMA_Size = Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改传输计数器的值，使DMA能循环传输*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Transfer</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">DMA_SetCurrDataCounter(DMA1_Channel1,DMA_Size); </span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET)&#123;&#125;;<span class="comment">//等待转换完成</span></span><br><span class="line"></span><br><span class="line">DMA_ClearFlag(DMA1_FLAG_TC1);<span class="comment">//清除标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DMA.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> DataA[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x03</span>,<span class="number">0x04</span>&#125;;<span class="comment">//加上const发现存储在FLASH区</span></span><br><span class="line"><span class="type">uint8_t</span> DataB[] =  &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">DMAInit((<span class="type">uint32_t</span>)DataA,(<span class="type">uint32_t</span>)DataB,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;DataA:&quot;</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataA,<span class="number">8</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">5</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">8</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">11</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">2</span>,<span class="string">&quot;DataB:&quot;</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>,<span class="number">8</span>,(<span class="type">uint32_t</span>)DataB,<span class="number">8</span>);</span><br><span class="line">  OLED_ShowHexNum(<span class="number">4</span>,<span class="number">2</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">5</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">8</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">11</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//DataA[0]++;</span></span><br><span class="line"><span class="comment">//DataA[1]++;</span></span><br><span class="line"><span class="comment">//DataA[2]++;</span></span><br><span class="line"><span class="comment">//DataA[3]++;</span></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;DataA:&quot;</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,DataA[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">5</span>,DataA[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">8</span>,DataA[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>,<span class="number">11</span>,DataA[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">      </span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">DMA_Transfer();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">3</span>,<span class="number">2</span>,<span class="string">&quot;DataB:&quot;</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">2</span>,DataB[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">5</span>,DataB[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">8</span>,DataB[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>,<span class="number">11</span>,DataB[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验-DMA-ADC多通道采集">实验-DMA+ADC多通道采集</h2><p><code>ADC多通道(连续转换+扫描模式+DMA循环转移):</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*AD.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __AD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __AD_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> ADValue[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void ADC_GetValue();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> ADValue[<span class="number">2</span>];<span class="comment">//有几个通道的结果长度就设定为几</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.开启RCC时钟，ADC和GPIO,以及DMA</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.ADC预分频器配置，72Mhz / 6 =12Mhz，不能超过14Mhz，至少6分频</span></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.GPIO配置为模拟输入</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_4;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.规则通道配置,将通道4,5,分贝写入规则通道的第一个位置和第二个位置(序列1，序列2)</span></span><br><span class="line">  ADC_RegularChannelConfig(ADC1,ADC_Channel_4,<span class="number">1</span>,ADC_SampleTime_239Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1,ADC_Channel_5,<span class="number">2</span>,ADC_SampleTime_55Cycles5);</span><br><span class="line"><span class="comment">//  ADC_RegularChannelConfig(ADC1,ADC_Channel_6,3,ADC_SampleTime_55Cycles5); 还有通道继续配置即可</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.ADC转换器配置</span></span><br><span class="line">ADC_InitTypeDef ADC_InitStruct;</span><br><span class="line">ADC_InitStruct.ADC_Mode = ADC_Mode_Independent; <span class="comment">//ADC转换模式，该参数为独立ADC工作，剩余的其他参数都是双ADC模式</span></span><br><span class="line">ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;<span class="comment">//数据右对齐</span></span><br><span class="line">ADC_InitStruct.ADC_ExternalTrigConv =ADC_ExternalTrigConv_None;<span class="comment">//这里选择软件触发，剩下的都为硬件触发</span></span><br><span class="line">ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;<span class="comment">//启动连续转换模式</span></span><br><span class="line">ADC_InitStruct.ADC_ScanConvMode = ENABLE;<span class="comment">//是否启动扫描模式,这里多通道启动</span></span><br><span class="line">ADC_InitStruct.ADC_NbrOfChannel = <span class="number">2</span>; <span class="comment">// 指定扫描模式下总共使用的通道数，使用了几个通道就填几</span></span><br><span class="line">ADC_Init(ADC1,&amp;ADC_InitStruct);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.配置DMA</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStruct;</span><br><span class="line">DMA_InitStruct.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//ADC1寄存器地址</span></span><br><span class="line">DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;<span class="comment">//ADC选择半字16位传输,对于12位，舍弃4位</span></span><br><span class="line">DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;<span class="comment">//地址是否自增(Increment)，这里对同一个地方的值运输，不启用</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)ADValue;<span class="comment">//存放到SRAM中的数组中</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;<span class="comment">//以半字16位传输</span></span><br><span class="line">DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//由于多个值，需要移动数组的地址，需要自增</span></span><br><span class="line">DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralSRC ; <span class="comment">// 传输方向(direction),这里选择的是外设站点作为数据源</span></span><br><span class="line">DMA_InitStruct.DMA_BufferSize = <span class="number">2</span>; <span class="comment">//其实就是传输次数,一次传输上面设置的数据宽度的值，这里两个通道一共传输2次</span></span><br><span class="line">DMA_InitStruct.DMA_Mode = DMA_Mode_Circular; <span class="comment">// 传输模式，就是是否使用自动重装。Normal不重装，circular是循环重装</span></span><br><span class="line">DMA_InitStruct.DMA_M2M = DMA_M2M_Disable; <span class="comment">// 配置硬件触发，M2M位为0</span></span><br><span class="line">DMA_InitStruct.DMA_Priority = DMA_Priority_Medium; <span class="comment">// 配置优先级，选择中等</span></span><br><span class="line">DMA_Init(DMA1_Channel1,&amp;DMA_InitStruct);<span class="comment">//查看手册得到ADC1通道为1，只能使用通道1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.使能DMA和开启ADC到DMA输出</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1,ENABLE);<span class="comment">//必须在ADC使能之前开启输出到DMA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//8.使能ADC</span></span><br><span class="line">ADC_Cmd(ADC1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.ADC校准</span></span><br><span class="line">ADC_ResetCalibration(ADC1);<span class="comment">//复位校准</span></span><br><span class="line"><span class="keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1)== SET)&#123;&#125;;<span class="comment">//RSTCAL寄存器由软件置1后开始复位校准，完成后硬件自动清0该位</span></span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET)&#123;&#125;;<span class="comment">//CAL寄存器由软件置1后开始校准，校准结束后硬件自动清0该位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//10.ADC触发转换</span></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1, ENABLE);</span><br><span class="line">    <span class="comment">/*连续转换，扫描模式下，DMA循环模式下只需要触发一次，ADC和DMA都不用等待，ADC和DMA就同时开始持续协同工作了*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里是触发使用单次转换时需要的*/</span></span><br><span class="line"><span class="comment">//void ADC_GetValue()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//DMA_Cmd(DMA1_Channel1,DISABLE);</span></span><br><span class="line"><span class="comment">//DMA_SetCurrDataCounter(DMA1_Channel1,2); </span></span><br><span class="line"><span class="comment">//DMA_Cmd(DMA1_Channel1,ENABLE);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//ADC_SoftwareStartConvCmd(ADC1, ENABLE);//启动软件触发转换</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">///*不需要等待ADC转换完成了，只需要等待DMA*/</span></span><br><span class="line"><span class="comment">//while(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET)&#123;&#125;;//等待DMA传输完成</span></span><br><span class="line"><span class="comment">//DMA_ClearFlag(DMA1_FLAG_TC1);//清除标志位</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Voltage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">OLED_Init();</span><br><span class="line">AD_Init();</span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Voltage = (<span class="type">float</span>)ADValue[<span class="number">1</span>] / <span class="number">4095</span> * <span class="number">3.3</span>;<span class="comment">//根据精度对应计算出电压值</span></span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">5</span>,<span class="number">5</span>,ADValue[<span class="number">0</span>],<span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">10</span>,<span class="number">5</span>,ADValue[<span class="number">1</span>],<span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">15</span>,<span class="number">5</span>,Voltage,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>ADC连续转换+扫描模式下，配合DMA，只需要触发ADC转换后，每当有一个通道转换完成，DMA迅速将值转运到ADValue中，我们直接对ADValue的值进行读取即可</strong></p><hr><p><strong>这里我们其实还可以再加一个定时器，ADC用单次扫描，再用定时器去定时触发</strong></p><p><code>即：定时器触发ADC-&gt;ADC触发DMA</code></p><p><strong>这样的好处就是整个过程完全自动，不需要手动进行操作，节省软件资源，实现硬件自动化</strong></p></blockquote><h1>通信接口</h1><h2 id="接口简介">接口简介</h2><p><img src="../assets/image-20241130220652564-173752975558545.png" alt="image-20241130220652564"></p><blockquote><p><strong>这里列举的是最常用，最简单的配置，还有很多配置没有列出</strong></p><p><strong>全双工一般都有两根数据线，比如串口、SPI</strong></p></blockquote><h2 id="串口通信">串口通信</h2><h3 id="介绍-3">介绍</h3><p><img src="../assets/image-20241201171647997-173752975558546.png" alt="image-20241201171647997"></p><blockquote><p><strong>串口是点对点通信，就是一对一之间通讯</strong></p><p><strong>图一</strong>：<strong>USB转串口模块</strong>，上面是<strong>CH340芯片</strong>，可以将串口协议转换为USB协议，USB端可以接在电脑上，另一端串口引脚接在支持串口的芯片上</p><p><strong>图二</strong>：<strong>陀螺仪传感器模块</strong>，测量加速度，角速度，一边是串口引脚，一边是I2C引脚</p><p><strong>图三</strong>：<strong>蓝牙串口模块</strong>，上面的芯片可以和手机互联，实现手机遥控单片机的功能</p></blockquote><h3 id="CH340串口驱动">CH340串口驱动</h3><p>CH340芯片作为USB和串行通信之间的桥梁，它允许你的电脑通过USB端口与仅支持串行通信协议的设备（如许多基于STM32的开发板）进行通信。安装了正确的驱动后，电脑上的应用程序（例如串口调试工具、编程软件等）才能通过这个虚拟出来的COM端口与STM32开发板交换数据。</p><p><strong>串口连接我们电脑时，对应设备管理器中找到是否有CH340的驱动，没有的安装即可，有的话就可以使用了。</strong></p><p><img src="../assets/image-20241203185913944-173752975558547.png" alt="image-20241203185913944"></p><h3 id="硬件电路-2">硬件电路</h3><p><img src="../assets/image-20241201172828258-173752975558548.png" alt="image-20241201172828258"></p><blockquote><p><strong>一般串口通信模块有四个引脚：VCC、TX、RX、GND</strong></p><p><strong>简单的串口通信只有RX和TX两个信号线，复杂的还有时钟线</strong></p><p>TX和RX是单端信号，它们的高低电平都是相对于GND，所以串口通信的RX、TX、GND是必须接的</p><p>对于VCC，如果两个设备都有独立供电，VCC可以不用接。如果其中一个设备没有供电，比如设备1是STM32，设备2是蓝牙串口模块，STM32有独立供电，蓝牙串口模块没有独立供电，此时就需要把蓝牙串口的VCC和STM32的VCC接在一起</p><hr><p><strong>两根通信线为全双工，只接一根通信线的情况下就变成了单工通信</strong></p><hr><p><strong>电平标准不一致需要加电平转换芯片才能通信，一般设备直接出来的是TTL电平，需要另外一个也是TTL电平才能通信</strong></p></blockquote><h3 id="电平标准">电平标准</h3><p><img src="../assets/image-20241201173753315-173752975558549.png" alt="image-20241201173753315"></p><blockquote><p><code>TTL电平</code>：单片机这种低压小型设备，使用的都是TTL电平，最远几十米。所以在单片机中如果线路对地是3.3V，就代表发送了逻辑1，对地是0V，就代表发送了逻辑0</p><p><code>RS232</code>：最远几十米。</p><p><code>RS485</code>：两线压差，所以电平是差分信号，差分信号的抗干扰能力非常强，使用RS485电平标准，通讯距离可以达到上千米</p><p><strong>不同的电平间，加上电平转换芯片即可使用</strong></p></blockquote><h3 id="串口参数及时序">串口参数及时序</h3><p><img src="../assets/image-20241201174831622-173752975558550.png" alt="image-20241201174831622"></p><blockquote><p><code>波特率</code>：每秒传送码元的个数，单片机中的话一个码元对应一位，码元/s对应bit/s</p><p><code>起始位</code>：空闲状态时为<strong>高电平</strong>，起始位为<strong>低电平</strong>产生一个下降沿，标志数据发送的开始</p><p><code>数据位</code>：<strong>低位先行</strong>，从数据的低位开始发送。可以把校验位算在数据位中，也可以把校验位单独出来</p><p><code>校验位</code>：三种方式，无校验，奇校验，偶校验，根据数据来决定是0还是1</p><p><code>停止位</code>：固定为<strong>高电平</strong>为下个起始位做准备</p><hr><p><code>数据帧格式：</code></p><p>&lt;--------10位/11位 -----------&gt;</p><p><strong>起始位(低电平)+数据位+停止位(高电平)</strong></p><p>​            1位               8/9位        1 位</p><p>8位数据位：不含有奇偶校验位</p><p>9位数据为：最后一位添加了一位奇偶校验位</p><hr></blockquote><h3 id="USART简介">USART简介</h3><p><img src="../assets/image-20241201231743375-173752975558551.png" alt="image-20241201231743375"></p><blockquote><p><strong>一般串口很少使用同步功能，只是多了个时钟输出，只支持输出不支持输入，同步模式更多是为了兼容别的协议和其他用途，并不支持两个USART之间进行同步通信</strong></p><hr><p><code>硬件流控制:</code>在A、B之间有一根单独的一根线，高低电平可以决定接收方是否准备好，准备好了再发送，可以防止接收方处理慢而导致数据丢失的问题。我们一般不使用</p><p><code>DMA:</code>串口有大量的数据时，可以使用DMA，减小CPU负担，提高效率</p></blockquote><h3 id="USART框图">USART框图</h3><p><img src="../assets/image-20241202174332315-173752975558552.png" alt="image-20241202174332315"></p><blockquote><p><code>发送数据寄存器TDR</code>：只写，当数据从TDR全部到发送移位寄存器中后，<code>TXE标志位</code>(TX Empty)-<strong>发送数据寄存器为空</strong>，会置1，此时检查这个标志位为1的话就可以就可以写入下一个数据到TDR</p><p><code>发送移位寄存器</code>：把一个字节的数据一位一位地移出去，正好对应串口协议的波形数据位。通过下方发送器控制，向右移位，一位一位地把数据输出到TX引脚，正好对应串口的低位先行，当数据移位完成后，新的数据会再次自动的从TDR移动到发送移位寄存器中(移位未完成时TDR会等待完成)。</p><p>发送整个过程连续，效率高</p><hr><p><code>接收数据寄存器RDR</code>：只读</p><p><code>接收移位寄存器</code>：数据从RX引脚通向接收移位寄存器，在接受器控制下，一位一位地读取RX电平，先放在最高位，然后向右移。当这一个字节数据移位完成后，整体全部转移到<strong>接收数据寄存器RDR</strong>中，此时将<code>RXNE</code>(RX Not Empty )-<strong>接收数据寄存器非空</strong>，检测到RXNE置1之后，就可以将数据从RDR读走</p><hr><p><code>硬件数据流控(流控)</code>：<strong>如果发送设备发得太快，接收设备来不及处理，就会出现丢弃或覆盖数据得现象，有了流控就可以避免这个问题。一般不使用！！！</strong></p><p>对应有两个引脚：</p><p><code>nRTS(Request To Send)：</code>请求发送，是输出脚，告诉别人当前是否能接收，n代表低电平有效</p><p><code>nCTS(Clear To Send)：</code>是清除发送，是输入脚，用于接收别人nRTS信号b，n代表低电平有效</p><p>两个有流控的设备RTS和CTS交叉连接即可，CTS引脚接对方RTS引脚，用于判断对方能否接收，RTS引脚接对方CTS引脚，用于告诉对方我能不能接收</p><hr><p><code>右边边的SCLK</code>：</p><p>产生同步的时钟信号，用于配合发送移位寄存器输出。只支持输出不支持输入，两个USART之间不能实现同步的串口通信。我们一般不使用</p><p>作用：</p><ol><li>兼容别的协议，串口加上时钟后和SPI很像，所以可以兼容SPI协议</li><li>自适应波特率</li></ol><hr><p><code>唤醒单元：</code></p><p>实现多设备功能，一般不使用</p><hr><p><code>中断控制：</code></p><p>两个标志位比较重要，<code>TXE</code>(发送中断标志位)和<code>RXNE</code>(接收中断标志位)，这两个标志位可以去申请接收中断和发送中断，就可以在接收或者发送数据时，直接进入中断服务函数</p><p><strong>其他的标志位看手册可以知道有什么作用</strong></p><hr><p><code>波特率发生器：</code></p><p>波特率发生器其实就是<strong>分频器</strong>，对APB时钟进行分频，得到发送器和接收器的时钟</p></blockquote><p><code>对应所有的寄存器等更多知识都能在参考手册中查看！！！！</code></p><h3 id="USART基本结构">USART基本结构</h3><p><img src="../assets/image-20241202164204771-173752975558553.png" alt="image-20241202164204771"></p><blockquote><p><code> 波特率发生器</code>：用于产生约定的通信速率</p><p><code>对于TDR和RDR</code>：在软件层面，只有一个DR寄存器可以让我们读写，只不过是在接收或者发送时走上面或者下面这条路</p><p><code>开关控制</code>：对应的Cmd函数</p></blockquote><h3 id="数据帧">数据帧</h3><p><code>发送电路：</code></p><p><img src="../assets/image-20241202164659015-173752975558554.png" alt="image-20241202164659015"></p><blockquote><p><strong>四种选择：</strong></p><p><strong>8位字长，无校验</strong></p><p><strong>8位字长，有校验</strong></p><p><strong>9位字长，无校验</strong></p><p><strong>9位字长，有校验</strong></p></blockquote><h3 id="起始位侦测">起始位侦测</h3><p><code>接收电路:</code></p><p><img src="../assets/image-20241202165836050-173752975558655.png" alt="image-20241202165836050"></p><blockquote><p><strong>以波特率的16倍进行采样，一位的长度中，每三位至少有2个0，否则认为是噪声。</strong></p><p><strong>采样位设置在8，9，10，之后也这样采样就能保证在数据中间</strong></p></blockquote><h3 id="数据采样">数据采样</h3><p><img src="../assets/image-20241202170417412-173752975558656.png" alt="image-20241202170417412"></p><blockquote><p><strong>连续采样三次，无噪声下三次采样都为0或1</strong></p><p><strong>如果有噪声，以2:1进行确定，2次0，数据就为0，2次1，采样的数据就为1。此时会对噪声标志位NE置1，告诉收到数据，但有噪声</strong></p></blockquote><h3 id="波特率发生器">波特率发生器</h3><p><img src="../assets/image-20241202170724981-173752975558657.png" alt="image-20241202170724981"></p><blockquote><p><strong>DIV(分频系数)分为整数部分和小数部分，可以实现更细腻的分频</strong></p><p>16是因为内部有一个16倍波特率的采样时钟，所以**（fpclk2/1 / DIV)= 16  * 波特率(16倍波特率)**，最终计算波特率要多除以一个16</p><p><strong>例：配置9600波特率</strong></p><p>带公式：9600 = 72MHz /(16*DIV) ，得到DIV = 468.75</p><p>然后将DIV写入到该波特比率寄存器USART_BRR中，转换为2进制写入，有整数位和小数位</p><p><code>我们使用库函数直接输入需要的波特率9600即可，自动计算配置完成</code></p></blockquote><h3 id="数据模式">数据模式</h3><p><img src="../assets/image-20241203190308931-173752975558658.png" alt="image-20241203190308931"></p><blockquote><p><strong>通过串口助手显示的数据有以上两种方式：HEX和ASCII</strong></p><p>HEX：以原始数据(0x41等)的形式显示，为十六进制</p><p>ASCII：将原始数据(0x41)按照ASCII编码码表对应显示(0x41对应编码为‘A’)</p></blockquote><h3 id="库函数-8">库函数</h3><p>stm32f10x_usart.h中找到</p><p><code>初始化函数：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_DeInit</span><span class="params">(USART_TypeDef* USARTx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_Init</span><span class="params">(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_StructInit</span><span class="params">(USART_InitTypeDef* USART_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这两个函数用于配置同步时钟输出的，包括时钟使能，极性，相位等参数使用结构体*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClockInit</span><span class="params">(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClockStructInit</span><span class="params">(USART_ClockInitTypeDef* USART_ClockInitStruct)</span>;</span><br></pre></td></tr></table></figure><p><code>中断配置：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_ITConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><p><code>USART相关使能：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_Cmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*使能USART*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_DMACmd</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_DMAReq, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">/*开启对应的USART到DMA的触发通道*/</span></span><br></pre></td></tr></table></figure><p><code>USART发送和接收数据：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_SendData</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="comment">//写DR寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">USART_ReceiveData</span><span class="params">(USART_TypeDef* USARTx)</span>;</span><br><span class="line"><span class="comment">//读DR寄存器</span></span><br></pre></td></tr></table></figure><p><code>标志位相关：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">USART_GetFlagStatus</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClearFlag</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_FLAG)</span>;</span><br><span class="line"><span class="comment">/*终端外使用的标志位函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断服务程序中使用的标志位函数*/</span></span><br><span class="line">ITStatus <span class="title function_">USART_GetITStatus</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClearITPendingBit</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT)</span>;</span><br></pre></td></tr></table></figure><hr><p><code>不常用</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_SetAddress</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint8_t</span> USART_Address)</span>;<span class="comment">//设置地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_WakeUpConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_WakeUp)</span>;<span class="comment">//唤醒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ReceiverWakeUpCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_LINBreakDetectLengthConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_LINBreakDetectLength)</span>;<span class="comment">//LIN</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_LINCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一大段函数，智能卡、IrDA等相关函数不怎么使用*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendBreak</span><span class="params">(USART_TypeDef* USARTx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SetGuardTime</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint8_t</span> USART_GuardTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SetPrescaler</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint8_t</span> USART_Prescaler)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SmartCardCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SmartCardNACKCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_HalfDuplexCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_OverSampling8Cmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_OneBitMethodCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_IrDAConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IrDAMode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_IrDACmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="USART配置流程">USART配置流程</h3><ol><li><p><strong>RCC开启时钟，打开需要的USART和GPIO时钟</strong></p></li><li><p><strong>配置GPIO，对应TX配置为复用输出，RX配置为上拉或浮空输入</strong></p></li><li><p><strong>配置USART，使用结构体配置即可</strong></p></li><li><p>如果需要接收中断，加上ITConfig和NVIC配置即可。如果不需要中断跳过配置即可</p></li><li><p><strong>使能USART，USART_Cmd</strong></p></li></ol><h3 id="实验-串口发送和串口接收">实验-串口发送和串口接收</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*包括对Usart的初始化，和对一些常用的函数封装*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSend</span><span class="params">(<span class="type">uint8_t</span> Data)</span>;<span class="comment">//发送一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendArray</span><span class="params">(<span class="type">uint8_t</span>* Array,<span class="type">uint8_t</span> Length)</span>;<span class="comment">//发送数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendString</span><span class="params">(<span class="type">char</span>* String)</span>;<span class="comment">//发送字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">UsartPow</span><span class="params">(<span class="type">uint32_t</span> x,<span class="type">uint8_t</span> y)</span>;<span class="comment">//幂函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendNum</span><span class="params">(<span class="type">uint32_t</span> Num,<span class="type">uint8_t</span> Length)</span>;<span class="comment">//发送数字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1. RCC开启时钟，打开需要的USART和GPIO时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.配置GPIO，对应TX配置为复用输出，RX配置为上拉或浮空输入，如果只选择一种模式，那么就只配置一个引脚即可</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//TX引脚配置</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//RX引脚配置</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//3.配置USART，使用结构体配置即可</span></span><br><span class="line">USART_InitTypeDef USART_InitStruct;</span><br><span class="line">USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;<span class="comment">//波特率配置</span></span><br><span class="line">USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//硬件流控配置,这里不适用</span></span><br><span class="line">USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; <span class="comment">//这里配置串口接收和发送模式都使用，可以只配置一个</span></span><br><span class="line">USART_InitStruct.USART_Parity = USART_Parity_No; <span class="comment">//校验位，不使用校验</span></span><br><span class="line">USART_InitStruct.USART_StopBits = USART_StopBits_1; <span class="comment">//停止位配置1位</span></span><br><span class="line">USART_InitStruct.USART_WordLength = USART_WordLength_8b;<span class="comment">//数据位长度，没有奇偶校验位，所以选择8位数据位</span></span><br><span class="line">USART_Init(USART2,&amp;USART_InitStruct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果需要使用中断，需要在此处调用USART_ITConfig函数，然后再配置NVIC即可*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.使能USART，USART_Cmd</span></span><br><span class="line">USART_Cmd(USART2,ENABLE);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSend</span><span class="params">(<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">USART_SendData(USART2,Data);</span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(USART2,USART_FLAG_TXE) == RESET);<span class="comment">//等待数据移动到移位寄存器中，避免发生数据覆盖</span></span><br><span class="line"><span class="comment">/*手册中可以知道，下一次调用SendData时该TXE标志位会自动清0*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendArray</span><span class="params">(<span class="type">uint8_t</span>* Array,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">UsartSend(Array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendString</span><span class="params">(<span class="type">char</span>* String)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;String[i]!=<span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">UsartSend(String[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">UsartPow</span><span class="params">(<span class="type">uint32_t</span> x,<span class="type">uint8_t</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(y--)</span><br><span class="line">&#123;</span><br><span class="line">result*=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendNum</span><span class="params">(<span class="type">uint32_t</span> Num,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">UsartSend((Num/UsartPow(<span class="number">10</span>,Length-i<span class="number">-1</span>))%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);<span class="comment">//加上一个字符0得到对应数字的ascii码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> myArray[] = &#123;<span class="number">0x42</span>,<span class="number">0x43</span>,<span class="number">0x44</span>,<span class="number">0x45</span>&#125;;</span><br><span class="line"></span><br><span class="line">  UsartInit();</span><br><span class="line">    </span><br><span class="line">  UsartSend(<span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">UsartSendArray(myArray,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">UsartSendString(<span class="string">&quot;hello\r\nworld&quot;</span>);<span class="comment">//需要两个转义字符才能换行，\r代表回车，\n代表换行</span></span><br><span class="line"></span><br><span class="line">UsartSendNum(<span class="number">65535</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验-串口接收单字节-轮询-中断">实验-串口接收单字节(轮询+中断)</h3><p><code>在while循环中轮询读取：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(USART_GetFlagStatus(USART2,USART_FLAG_RXNE)== SET)<span class="comment">//手册可知该RXNE标志位再下方调用读取时会自动清0</span></span><br><span class="line">&#123;</span><br><span class="line">rData = USART_ReceiveData(USART2);</span><br><span class="line">&#125;</span><br><span class="line">      OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,rData,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>使用中断:</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSend</span><span class="params">(<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendArray</span><span class="params">(<span class="type">uint8_t</span>* Array,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendString</span><span class="params">(<span class="type">char</span>* String)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">UsartPow</span><span class="params">(<span class="type">uint32_t</span> x,<span class="type">uint8_t</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendNum</span><span class="params">(<span class="type">uint32_t</span> Num,<span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetFlag</span><span class="params">()</span>;<span class="comment">//自定义标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetData</span><span class="params">()</span>;<span class="comment">//自定义Get方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData;</span><br><span class="line"><span class="type">uint8_t</span> rFlag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartInit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1. RCC开启时钟，打开需要的USART和GPIO时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.配置GPIO，对应TX配置为复用输出，RX配置为上拉或浮空输入，如果只选择一种模式，那么就只配置一个引脚即可</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//TX引脚配置</span></span><br><span class="line"></span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);<span class="comment">//RX引脚配置</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//3.配置USART，使用结构体配置即可</span></span><br><span class="line">USART_InitTypeDef USART_InitStruct;</span><br><span class="line">USART_InitStruct.USART_BaudRate = <span class="number">9600</span>;<span class="comment">//波特率配置</span></span><br><span class="line">USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//硬件流控配置,这里不适用</span></span><br><span class="line">USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; <span class="comment">//这里配置串口接收和发送模式都使用，可以只配置一个</span></span><br><span class="line">USART_InitStruct.USART_Parity = USART_Parity_No; <span class="comment">//校验位，不使用校验</span></span><br><span class="line">USART_InitStruct.USART_StopBits = USART_StopBits_1; <span class="comment">//停止位配置1位</span></span><br><span class="line">USART_InitStruct.USART_WordLength = USART_WordLength_8b;<span class="comment">//数据位长度，没有奇偶校验位，所以选择8位数据位</span></span><br><span class="line">USART_Init(USART2,&amp;USART_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果需要使用中断，需要在此处调用USART_ITConfig函数，然后再配置NVIC即可*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.配置中断和NVIC</span></span><br><span class="line">USART_ITConfig(USART2,USART_IT_RXNE,ENABLE);</span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStruct;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannel = USART2_IRQn;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.使能USART，USART_Cmd</span></span><br><span class="line">USART_Cmd(USART2,ENABLE);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetData</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> rData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用extern也是同样的效果’</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">UsartGetFlag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(rFlag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">rFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//自定义清除标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART2,USART_IT_RXNE)== SET)</span><br><span class="line">&#123;</span><br><span class="line">  rData = USART_ReceiveData(USART2);</span><br><span class="line">  rFlag = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">USART_ClearITPendingBit(USART2,USART_IT_RXNE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中断服务函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Data;</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">  UsartInit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(UsartGetFlag()== <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Data = UsartGetData();</span><br><span class="line">UsartSend(Data);</span><br><span class="line">&#125;</span><br><span class="line">      OLED_ShowHexNum(<span class="number">2</span>,<span class="number">2</span>,Data,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>该实验只能实现对单字符的接收</strong></p></blockquote><h3 id="实验-USART串口数据包">实验-USART串口数据包</h3><h3 id="实验-printf函数的移植">实验-printf函数的移植</h3><blockquote><p><strong>在Keil中，使用printf函数之前我们需要打开工程选项，找到Target，勾选Use MicroLIB(使用微库)</strong></p><p>MicroLIB：是Keil为嵌入式平台优化的一个精简库</p></blockquote><p><code>方法1：printf的重定向：</code>printf默认输出到屏幕，但是单片机没有屏幕，所以需要我们重定向到串口</p><p>在对应串口模块中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*该定义usart.c的结尾加上*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//该stdio.h头文件在usart.h中再进行引用一次，即可在调用usart.h时使用printf了</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE* f)</span></span><br><span class="line">&#123;</span><br><span class="line">    UsartSend(ch);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*fputc是printf函数底层，使用printf时，是不断调用fputc进行打印的，我们把fputc函数重定向到串口，printfzi*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c中*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    UsartInit();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Num=%d\r\n&quot;</span>,<span class="number">66666</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方法只能将printf输出到调用串口发送函数的那一个串口当中，无法在其他串口中使用。</p><p>解决方法：使用标准库函数sprintf</p></blockquote><p><code>方法2：sprintf函数使用</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c中*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    UsartInit();</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line"> <span class="built_in">sprintf</span>(String,<span class="string">&quot;Num=%d\r\n&quot;</span>,<span class="number">99999</span>);</span><br><span class="line">UsartSendString(String);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>sprintf的作用是：发动格式化字符串到指定str中，可以实现拼接字符串，这样即可实现每个串口的格式化打印</strong></p></blockquote><p><code>方法三：使用可变参数封装sprintf</code></p><p>使用头文件<code>&lt;stdarg.h&gt;</code></p><p>具体封装过程百度即可</p><h3 id="数据包">数据包</h3><h4 id="数据包介绍">数据包介绍</h4><p><strong>数据包分为</strong>：<code>HEX数据包</code>和<code>文本数据包</code>，分别对应<strong>文本模式和HEX模式</strong></p><p><strong>作用</strong>：将属于同一批的数据进行打包和分割。</p><ol><li><code>HEX数据包:</code></li></ol><p><img src="../assets/image-20241204165308342-173752975558659.png" alt="image-20241204165308342"></p><blockquote><p>通过添加包头包尾分割数据</p><p>数据包头：0xFF</p><p>数据包尾：0xFE</p><hr><p><code>优点:</code><strong>传输最直接，解析数据非常简单，比较适合一些模块发送原始的数据，比如一些使用串口通信的陀螺仪、温湿度传感器数据</strong></p><p><code>缺点：</code>灵活性不足，载荷容易和包头包尾重复(可能传输的数据是包头包尾的数据)</p><p><code>解决方案：</code></p><ol><li><strong>限制载荷数据的范围，在发送时对数据变化范围显示</strong></li><li><strong>如果无法避免载荷数据和包头包尾重复，我们就尽量使用固定长度的数据包，经过几个数据包的数据对齐后，剩下的数据包应该就没有问题了</strong></li><li><strong>增加包头包尾的数量，并且尽量呈现出载荷数据出现不了的状态</strong></li></ol><hr><p><code>HEX数据包格式选择</code>：</p><ol><li>如果数据容易出现与包头包尾重复的情况，就最好选择固定包长</li><li>如果数据不容易出现与包头包尾重复的情况，可以选择可变包长，这样就非常的灵活，只需要确定唯一的包头包尾就知道数据包长度</li></ol></blockquote><ol start="2"><li><code>文本数据包:</code></li></ol><p><img src="../assets/image-20241204184721167-173752975558661.png" alt="image-20241204184721167"></p><blockquote><p>在HEX数据包中，数据是以原始字节数据本身呈现，而在文本数据包中，每个字节都经过了编码和译码，表现出的就是文本格式，但实际上都还是一个字节的HEX数据</p></blockquote><blockquote><p><strong>文本数据包基本不用担心载荷和包头包尾重复的问题</strong></p><p><strong>包头：‘@’</strong></p><p><strong>包尾：‘\r’  ‘\n’</strong></p><p><strong>载荷数据：除了包头包尾的数据</strong></p><hr><p><code>优点:</code><strong>数据直观易理解，非常灵活，比较适合一些输入指令进行人机交互的场合，比如蓝牙模块常用的AT指令，CNC和3D打印机常用的G代码</strong></p><p><code>缺点：</code>解析效率低，比如100，HEX发送的就是一个字节100，文本数据包却是三个字符’1’，‘1’，‘0’。</p></blockquote><h4 id="数据包的发送和接收">数据包的发送和接收</h4><ol><li><p><code>数据包的发送:</code>使用串口对应发送**数组(HEX数据包)<strong>或者</strong>字符串函数(文本数据包)**即可</p></li><li><p><code>数据包的接收</code>：</p></li></ol><ul><li>固定包长HEX数据包接收</li></ul><p><img src="../assets/image-20241204190804966-173752975558660.png" alt="image-20241204190804966"></p><blockquote><p><strong>使用状态机编程思想</strong>：先根据项目要求定义状态，画几个圈，然后考虑号各个状态会在什么情况下会进行转移，如何转移，画好线和转移条件，最后根据这个来编程</p></blockquote><ul><li>可变包长文本数据包接收</li></ul><p><img src="../assets/image-20241204192226109-173752975558662.png" alt="image-20241204192226109"></p><h3 id="实验-串口收发HEX数据包">实验-串口收发HEX数据包</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*此处只列举出了新添加的变量和函数，具体的见上方*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> RxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> TxPacket[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendPacket</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*发送数据包,包头包尾自定义*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UsartSendPacket</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">UsartSend(<span class="number">0xFF</span>);<span class="comment">//包头</span></span><br><span class="line">UsartSendArray(TxPacket,<span class="number">4</span>);<span class="comment">//固定长度为4的数据</span></span><br><span class="line">  UsartSend(<span class="number">0xFE</span>);<span class="comment">//包尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用状态机的编程思想，每次中断接收一个字节数据*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART2,USART_IT_RXNE)== SET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="number">0xFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxPacket[count++] = RxData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(count&gt;=<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="number">0xFE</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">rFlag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART2,USART_IT_RXNE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">LED_Init();</span><br><span class="line">Key_Init();</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">  UsartInit();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(UsartGetFlag()== <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">                UsartSendPacket(TxPacket);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">0</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">1</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">2</span>],<span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>,<span class="number">2</span>,TxPacket[<span class="number">3</span>],<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用串口助手发送FF 05 06 07 08 FE，可以发现串口回显FF 05 06 07 08 FE，OLED上显示05 06 07 08的数据</p></blockquote><h3 id="实验-串口收发文本数据包">实验-串口收发文本数据包</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> RxTextPacket[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> rFlag=<span class="number">0</span>;<span class="comment">//接受完成标志,还可以避免接收太快来不及使用数据就被覆盖了</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*usart.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART2_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART2,USART_IT_RXNE)== SET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(RxState == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">&#x27;@&#x27;</span>&amp;&amp;rFlag == <span class="number">0</span>)<span class="comment">//接收慢一点，等主函数使用完,避免主函数中的数据可能是上一个数据包和这个数据包中的内容</span></span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">RxTextPacket[count++] = RxData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(RxState == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(RxData == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxTextPacket[count] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//组成完成字符串</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">rFlag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART2,USART_IT_RXNE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">LED_Init();</span><br><span class="line">OLED_Init();</span><br><span class="line">  UsartInit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(rFlag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(RxTextPacket,<span class="string">&quot;LED_ON&quot;</span>)== <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> LED1_ON();</span><br><span class="line"> UsartSendString(<span class="string">&quot;LED1_ON_OK\r\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(RxTextPacket,<span class="string">&quot;LED_OFF&quot;</span>)== <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> LED1_OFF();</span><br><span class="line"> UsartSendString(<span class="string">&quot;LED1_OFF_OK\r\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> UsartSendString(<span class="string">&quot;ERROR\r\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> rFlag = <span class="number">0</span>;<span class="comment">//使用完成数据标志，可以避免接收太快，之前那种方式可能会造成接收过快数据覆盖问题</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>使用串口助手发送@LED_ON + 换行回车，LED灯亮起</strong></p><p><strong>使用串口助手发送@LED_OFF + 换行回车，LED灯熄灭</strong></p></blockquote><h2 id="I2C">I2C</h2><h3 id="I2C介绍">I2C介绍</h3><p><img src="../assets/image-20241206141429374-173752975558663.png" alt="image-20241206141429374"></p><blockquote><p><strong>SPI特点</strong>：同步、半双工，两根通信线SCL和SDA</p><hr><p>第1个模块：MPU6050模块，进行姿态测量，使用I2C通信协议</p><p>第2个模块：OLED模块，显示图片，字符灯信息，使用I2C协议</p><p>第3个模块：AT24C02，存储器模块，使用I2C协议</p><p>第4个模块：DS3231，实时时钟模块，使用I2C协议</p><hr><p>I2C多主多从：相当于发生总线冲突，I2C协议会进行仲裁，胜利的一方取得总线控制权，失败的一方变回从机。同时在多主机的模型下，还要进行时钟同步</p></blockquote><h3 id="硬件电路与优缺点">硬件电路与优缺点</h3><p><img src="../assets/image-20241206144150840-173752975558664.png" alt="image-20241206144150840"></p><blockquote><p><code>一主多从模式：</code></p><p>SCL上挂载多个从设备，任何情况下从机不允许控制SCL，对于SDA数据线，从机不允许主动发起对SDA的控制，只有等待主机发送请求时，从机响应才能短暂获取</p><hr><p><strong>I2C采用外置<code>弱上拉电阻加开漏输出</code>的电路结构</strong>：</p><p><code>1.选择开漏输出，而不选择推挽输出：</code></p><p>如果使用推挽输出，如果总线时序没调整好，可能主机和从机都处于输出状态，且一个输出高电平，一个输出低电平，此时就会出现电源短路的问题。</p><p>而开漏输出只能直接输出低电平，高电平下没有驱动能力，输出取决于外部电路。</p><p>这样的话，就保证了所有设备都只能输出低电平而不能输出高电平</p><p><code>2.加上拉电阻:</code></p><p>为了避免开漏输出高电平时造成的引脚浮空，同时I2C通信需要输出高电平的能力，由于开漏输出下不能直接输出高电平，此时需要在外部加一个上拉电阻，此时为弱上拉，使能被外部拉高</p><p><code>这样设计电路的好处:</code></p><ol><li>完全杜绝电源短路现象，保证电路安全</li><li>避免引脚模式的频繁切换，开漏加弱上拉的模式，同时兼具了输入和输出的功能</li><li><strong>开漏模式下具有&quot;线与&quot;的特性，即：只要有任意一个或多个设备输出了低电平，总线就处于低电平，只有所有的设备输出高电平，总线才输出高电平。I2C可以利用这个特性，执行多主机模式下的时钟同步和总线仲裁。</strong></li></ol><p><code>限制：</code></p><p>​<strong>由于I2C开漏外加上拉电阻的电路结构，使得通信线高电平的驱动能力比较弱，导致通信线由低电平转换为高电平时，上升沿耗时会比较长，这样就限制了I2C的最大通信速度，所以I2C标准模式为100Khz，快速模式也只有400Khz，一般来说我们就认为I2C最快速度为400khz，相对于SPI的速度来说慢了许多</strong></p></blockquote><h3 id="I2C时序基本单元">I2C时序基本单元</h3><ul><li><code>1.起始条件和终止条件:</code></li></ul><p><img src="../assets/image-20241206170442283-173752975558665.png" alt="image-20241206170442283"></p><blockquote><p><strong>正常情况下：SCL和SDA都处于高电平</strong></p><p><strong>起始条件：S/Sr</strong></p><p><strong>终止条件：P</strong></p><p>从机收到起始条件后，自身复位，等待主机发送信息</p></blockquote><ul><li><code>2.主机发送字节时序</code>：</li></ul><p><img src="../assets/image-20241206170806836-173752975558666.png" alt="image-20241206170806836"></p><blockquote><p><strong>I2C发送字节与串口不同，I2C是高位先行，串口是低位先行</strong></p><p><code>发送字节过程总结下来就是</code>：</p><p><strong>时钟线SCL处于低电平时，主机设置数据线SDA的电平</strong></p><p><strong>时钟线SCL处于高电平时，从机读取数据线SDA的电平。</strong></p><p>显然，从机读取到的电平就是主机在时钟线低电平时设置的电平</p><hr><p><code>对中断处理：</code></p><p>如果主机一个字节发送一半，突然进中断了，那么此时SCL和SDA上的电平暂停变化，会不断拉长，传输完全暂停，等中断结束后，主机回来继续操作</p><hr><p><code>SCL和SDA控制权：</code></p><p><strong>该过程中，SCL和SDA都由主机掌控，从机只能被动读取</strong></p></blockquote><ul><li><code>主机接收字节时序:</code></li></ul><p><img src="../assets/image-20241206172222919-173752975558667.png" alt="image-20241206172222919"></p><blockquote><p><code>发送字节过程总结下来就是</code>：</p><p><strong>时钟线SCL处于低电平时，从机设置数据线SDA的电平</strong></p><p><strong>时钟线SCL处于高电平时，主机读取数据线SDA的电平。</strong></p><p>显然，主机读取到的电平就是从机在时钟线低电平时设置的电平</p><hr><p><code>SCL和SDA控制权:</code></p><p>SCL全程由主机控制</p><p><strong>主机在接收之前，需要释放SDA(SDA拉高)，此时让从机获得SDA控制权才能将数据放到SDA上!!!</strong></p></blockquote><ul><li><code>3.应答机制:</code></li></ul><p><img src="../assets/image-20241206172908982-173752975558668.png" alt="image-20241206172908982"></p><blockquote><p>根据应答机制，可以判断对方是否接收到了该数据</p><p>0：表示从机应答</p><p>1：表示从机非应答</p></blockquote><h3 id="I2C从机地址">I2C从机地址</h3><blockquote><p><code>从机地址介绍:</code></p><p>从机地址，每个从机设备出厂时都会分配一个7位或者10位地址，对应地址是什么可以在对应模块找到地址，比如MPU6050的7位地址为1101 000，AT24C02的7位地址为1010 000</p><hr><p><code>相同芯片挂载时对地址的处理:</code></p><p>一般不同芯片地址不同，相同型号芯片地址相同。</p><p>当相同芯片挂载在同一条总线时，此时需要用到地址中的可变部分，一般地址最后几位是可以在电路中改变的，比如MPU6050，最后一位由芯片上的AD0引脚决定，当该引脚接低电平就是1101 000，接高电平就是1101 001。而AT24C02地址的最后三位分明由引脚A0,A1,A2决定</p><p>一般I2C的从机设备地址，高位都是厂商确定，低位可以由不同引脚切换，这样就可以保证多个相同芯片挂载时地址都不一样</p></blockquote><h3 id="I2C时序">I2C时序</h3><p><code>时序1：指定地址写(常用)</code></p><p><img src="../assets/image-20241206174948487-173752975558669.png" alt="image-20241206174948487"></p><p><img src="../assets/image-20241206175159856-173752975558670.png" alt="image-20241206175159856"></p><blockquote><p><strong>该时序是对指定设备的指定寄存器写入指定数据的操作</strong></p><p>上图为逻辑分析仪的结果：</p><ol><li><p><strong>最开始为起始条件</strong></p></li><li><p><strong>之后，必须是发送一个字节的时序，内容为从机地址+读写位(7+1共8位)</strong></p></li></ol><p>上图对应为：1101 000 0(前七位为MPU6050地址，最后一位为0代表写入操作)</p><ol start="3"><li><strong>紧跟着的单元就是，接收从机的应答位(ACK，RA)。RA之后有个上升沿，代表从机释放SDA产生，交出了SDA控制权。</strong></li></ol><p>上图对应为：高电平器件，主机读取SDA，发现是0，代表主机进行寻址，有人应答了</p><ol start="4"><li><strong>然后的一个字节为寄存器地址。</strong></li></ol><p>上图为00011001(0x19)，即操作0x19地址的寄存器</p><ol start="5"><li><p><strong>紧接着又是从机应答位</strong></p></li><li><p><strong>然后发送写入寄存器的内容</strong></p></li></ol><p>上图为10101010，即发送数据为0xAA</p><ol start="7"><li><p><strong>又是一个从机应答位</strong></p></li><li><p><strong>最后一个为终止条件</strong></p></li></ol><hr><p><code>指定地址连续写入多个字节：</code></p><p><strong>如果想要发送多个字节，只需要将第6步发送写入字节和接收应答重复N次即可，写入几个字节就重复几次。</strong></p><p><strong>因为地址指针会在写入一个数据后自动+1，所以不用移动地址指针</strong></p></blockquote><p><code>时序2：当前地址读(不怎么使用):</code></p><p><img src="../assets/image-20241206213240665-173752975558671.png" alt="image-20241206213240665"></p><p><img src="../assets/image-20241206213259135-173752975558672.png" alt="image-20241206213259135"></p><blockquote><ol><li><strong>起始条件</strong></li><li><strong>主机发送一个字节(从机地址+读写位)，发送完后紧跟一个从机应答ACK</strong></li></ol><p><strong>图上为1101000 1 表示读取1101000的数据</strong></p><ol start="3"><li><strong>然后SDA控制权移交给从机，主机开始读取从机发送数据(不用发送读取寄存器地址，从机会将当前地址指针指向的寄存器的值发送)，不能指定读的地址。接收完后紧跟发送一个非应答(SA:1)，这样从机读取到主机非应答后，就知道主机不想要继续了，交还SDA控制权</strong></li></ol><p><strong>图上接收的数据为00001111(0x0F)</strong></p><ol start="4"><li><strong>结束条件</strong></li></ol><p><code>由于不能指定读的地址。所以该时序(当前地址读)用的不多</code></p><hr><p><code>当前地址连续读多个字节：</code></p><p><strong>如果想要读取多个字节，3处的读取一个字节后，就应该发送<code>应答</code>(RA:0)，然后重复读取字节，发送应答，最后一个字节读取完后，跟上一个<code>非应答</code>就可以结束读取</strong></p><p><strong>因为地址指针也会在读取一个数据后自动+1，所以不用移动地址指针</strong></p></blockquote><p><code>时序3：指定地址读(常用):</code></p><p><img src="../assets/image-20241206214232444-173752975558673.png" alt="image-20241206214232444"></p><p><img src="../assets/image-20241206214817354-173752975558674.png" alt="image-20241206214817354"></p><p><img src="../assets/image-20241206214842186-173752975558675.png" alt="image-20241206214842186"></p><blockquote><p><strong>指定地址读为复合格式，是指定地址写和当前地址读的混合</strong></p><p>复合格式：前面部分为指定地址写(写的数据的前面)，后面部分为当前地址读</p><hr><ol><li><strong>起始条件</strong></li><li><strong>发送一个字节，从机地址+读写位(此处应为写位为0)，然后是从机应答位ACK(RA:0)</strong></li><li><strong>在发送一个字节，指定写入的地址，指定完成后从机寄存器指针就指向该地址，然后是从机应答位ACK(RA:0</strong>)</li></ol><p><code>该部分为指定地址写前面部分</code></p><hr><ol start="4"><li><strong>(这里前面可以加一个停止，也可以不加)不发送写入的内容，而重复起始条件Sr(Start Repeat)，相当于另起一个时序</strong></li><li><strong>重新发送一个字节，从机地址+读写位(此处应为读位为0），从机应答位ACK(RA:0)</strong></li><li><strong>主机接收一个字节，主机接收到的数据就是指定写入地址处的数据，然后发送一个非应答(SA:1)</strong></li><li><strong>停止条件</strong></li></ol><p><strong>连起来就是：先起始，写入地址，停止。再起始，读当前位置，停止</strong></p><hr><p><code>指定地址连续读多个字节：</code></p><p><strong>如果想要读取多个字节，6处的读取一个字节后，就应该发送<code>应答</code>(RA:0)，然后重复读取字节，发送应答，最后一个字节读取完后，跟上一个<code>非应答</code>就可以结束读取</strong></p><p><strong>因为地址指针也会在读取一个数据后自动+1，所以不用移动地址指针</strong></p></blockquote><h3 id="MPU6050">MPU6050</h3><h4 id="MPU6050简介">MPU6050简介</h4><p><img src="../assets/image-20241207201409336-173752975558676.png" alt="image-20241207201409336"></p><blockquote><p><code>6轴姿态传感器：</code>3轴加速度(加速度计) + 3轴角速度(陀螺仪传感器)</p><p><code>9轴姿态传感器：</code>3轴加速度 + 3轴角速度 + 3轴磁场强度(磁力计)</p><p><code>10轴姿态传感器：</code>3轴加速度 + 3轴角速度 + 3轴磁场强度 + 1个气压强度(气压计)</p></blockquote><blockquote><p><code>一些术语：</code></p><p><code>加速度计：</code>简称为Accel或者Acc或A，X,Y,Z三轴都有一个测量加速度。<strong>上面第二幅图就是加速度计</strong>，实际上加速度就是一个就是一个测力计。</p><p>使用加速度计求角度的时候只能在物体静止的时候使用，当物体运动起来时，这个角度会受运动加速度的影响而变得不准确。</p><p><code>即特性：</code>加速度计具有静态稳定性，不具有动态稳定性</p><hr><p><code>陀螺仪传感器：</code>简称为Gyro或者G，可以测量三轴的角速度值，分别表示芯片绕X轴、Y轴、Z轴旋转的角速度，<strong>对应上面第三幅图，为陀螺仪的机械模型</strong>。该芯片只能测得角速度，而不能直接测得角度，通过对角速度积分可以得到角度</p><p>当物体静止时，角速度的值会因为噪声无法完全归零，经过积分的不断累积，小噪声就会导致计算出来的角度产生缓慢的漂移，角速度积分得到的角度经不起时间的考验，但角度无论是运动还是静止都是没问题的</p><p><code>特性：</code>陀螺仪具有动态稳定性，不具有静态稳定性</p><hr><p><code>姿态解算：</code></p><p>这两个传感器特性刚好互补，通过互补滤波就能融合得到静态和动态都稳定的姿态角了。</p><hr><p><code>了解姿态角/欧拉角:</code></p><p><a href="https://blog.csdn.net/sinolover/article/details/90671784">什么是欧拉角/姿态角？_欧拉角和姿态角区别-CSDN博客</a></p></blockquote><h4 id="MPU6050参数">MPU6050参数</h4><p><img src="../assets/image-20241207205112946-173752975558677.png" alt="image-20241207205112946"></p><blockquote><p><code>部分重要参数，具体参数清查看MPU6050手册</code></p><p>芯片输出的是一个随姿态变化而变化的电压，要想量化电压那么就需要AD转换器，芯片自带16位ADC，输出结果是有符号数</p><hr><p><code>满量程：</code>决定对应16位ADC值达到最大值时对应的物理参量，具有多个选择，根据具体物体运动的剧烈程度(实际情况)选择，避免超过满量程。</p><p>量程越小，分辨率越高，量程越大，范围越广</p><hr><p><code>低通滤波:</code>如果输出数据抖动很厉害，可以加一点低通滤波，这样就会更平缓</p><p><code>可配置时钟源和采样分频:</code>两个参数配合使用，时钟源通过采样分频为AD转换和内部其他电路提供时钟，控制分频系数就可以控制AD转换的快慢了</p><hr><p><code>对从机地址的处理</code>：</p><p>第一种从机地址：110 1000(0x68)</p><p>第二种从机地址(读写位)：1101 0000(0xD0)或者1101 0001(0xD1)</p><p>所以这两种从机地址说法都是正确的，一个是没带上读写位的从机地址，一个是带上从机位的地址。</p><p>实际发送一个字节时，只需要不带读写为的从机地址左移1位，再或上读写位即可</p><p>(0x68 &lt;&lt; 1 ) |   1/0</p><p>也可以直接就写融入读写位的从机地址</p><p>0xD1/0xD0</p></blockquote><h4 id="硬件电路-3">硬件电路</h4><p><img src="../assets/image-20241207221537437-173752975558678.png" alt="image-20241207221537437"></p><blockquote><p><strong>最右边的是MPU6050的芯片</strong>：</p><p>芯片本身引脚非常多，包括I2C通信引脚，供电，帧同步等，很多引脚用不到，还有些引脚是芯片最小系统里的固定连接，一般手册中有</p><hr><p><strong>左下角是8针的排针</strong>：</p><ul><li><strong>VCC和GND</strong>：电源供电</li><li><strong>SCL和SDA</strong>：I2C通信引脚，可以看到外部电路已经内置两个4.7K上拉电阻了，直接接即可，不用再接上拉电阻了</li><li><strong>XCL、XDA</strong>：主机I2C引脚，设计是为了扩展芯片功能，6轴传感器不够时，这个XCL和XDL用于外接磁力计或者气压计扩展为9轴传感器等，接上后MPU6050主机接口可以直接访问这些扩展芯片的数据，将数据读入MPU6050,里面有DMP单元进行数据融合和姿态解算。</li></ul><p>如果不需要解算功能，可以直接把磁力计或气压计挂载到SCL和SDA上，因为I2C本来就可以挂载多设备</p><ul><li><strong>AD0</strong>：7位从机地址最低位，电路中可以看到默认若下拉到低电平所以悬空状态下为0。对应从机地址为1101 000，接VCC的话就是1101 001</li><li><strong>INT</strong>：中断输出引脚，可以配置芯片内部事件触发中断引脚输出，如：数据准备好了、I2C主机错误等，不使用可以不配置</li></ul><p>除此之外，芯片内部还内置了一些实用的小功能：自由落体监测、运动监测、零运动监测等，这些信号都可以触发INT引脚产生电平跳变，可以进行中断信号的配置</p><hr><p><strong>左上角是LDO，低压差线性稳压器</strong>：</p><p>这部分是供电的逻辑，手册中可以看到MPU6050的VDD供电为2.375~3.46V，属于3.3V供电设备，不能直接接5V，为了扩大供电范围，就加了个3.3V的稳压器，使输入端电压VCC_5V可以再3.3V到5V之间，经过3.3V的稳压器给芯片端供电。最后跟上的是一个电源知识灯，如果有点就会亮。</p><p>这一模块是否需要可以根据需求来，如果已经有稳定的3.3V的电源就不需要这部分了</p></blockquote><h4 id="MPU6050框图">MPU6050框图</h4><p><img src="../assets/image-20241207225256921-173752975558679.png" alt="image-20241207225256921"></p><blockquote><p><strong>时钟部分</strong>：一般使用内部时钟，硬件电路上也是直接接地和没有引出</p><hr><p><strong>灰色部分</strong>：</p><p>是芯片内部传感器，包括XYZ轴的加速度计(X Accel等)，XYZ轴的角速度计(X Gyro等)</p><p>还内置了一个温度传感器(Temp Sensor)，也可用于测量温度。</p><p>这些传感器转换完成后，数据统一放在传感器寄存器(Sensor Register)中，读取该数据寄存器就能得到传感器测量的值。</p><p>芯片内部转换都是全自动进行(类似与AD连续转换+DMA转运)，每个ADC输出对应都是16位数据寄存器，不存在数据覆盖问题。需要数据直接读取即可</p><hr><p><strong>最左边Self test</strong>：</p><p>这是芯片的自测单元，当启动自测后，芯片内部会模拟一个外力施加在传感器上，这个外力导致传感器数据会比平时大一些。</p><p><strong>自测方法：先使能自测，读取数据，再失能自测，读取数据。两个数据相减得到的数据叫做自测响应，芯片手册中给出了一个范围，如果在这个范围内，代表芯片没问题。如果不在，就说明芯片可能坏了，使用的话就要小心点。</strong></p><p><code>手册找到自测范围如下：在这个范围内就代表芯片正常</code></p><p><img src="../assets/image-20241207235118026-173752975558680.png" alt="image-20241207235118026"></p><hr><p><strong>最下方Charge Pump</strong>：电荷泵，进行升压操作</p><hr><p><strong>最右边是寄存器和通信接口部分：</strong></p><p>很多寄存器：配置寄存器等</p><p>通信接口：从机I2C和SPI接口，主机I2C接口用于扩展设备通信</p><p>里面有个Digital Motion Processor-数字运动处理器简称DMP，是芯片内部自带的一个姿态解算的硬件算法，配合官方DMP库可以进行姿态解算</p><hr><p><strong>右下角为供电部分</strong>：按照手册电压要求和参考电路接线即可</p></blockquote><h4 id="MPU6050产品手册">MPU6050产品手册</h4><p>I2C通信，电气特性等知识均可查看</p><h4 id="MPU6050寄存器映像手册">MPU6050寄存器映像手册</h4><p>所有的寄存器都在里面，但是不需要全部了解</p><p><strong>需要了解的如下：每个寄存器具体介绍在手册向下翻即可</strong></p><p><img src="../assets/image-20241207233440068-173752975558681.png" alt="image-20241207233440068"></p><blockquote><p><code>SMPLRT_DIV</code>：<strong>采样频率分频寄存器</strong>，配置采样寄存器的分频系数，分频越小，内部AD转换越快，数据刷新越快。</p><p>采样频率 = (陀螺仪晶振)陀螺仪输出时钟频率/(1+分频值)</p><p><img src="../assets/image-20241218223941780-173752975558682.png" alt="image-20241218223941780"></p><p>Bit7~Bit0：值越小，越快，根据实际需求来</p><p><strong>对应配置：0x09 (对应10分频)</strong></p><hr><p><code>CONFIG</code>：<strong>配置寄存器</strong>，分为外部同步设置和低通滤波器配置，外部同步这里不使用不看。低通滤波器可以使输出数据更平滑，选择值为0~7，数值越大，抖动越下，0代表不滤波</p><p><img src="../assets/image-20241218224001365-173752975558683.png" alt="image-20241218224001365"></p><p>Bit7~6：无关位</p><p>Bit5~3：外部同步，不需要，给0即可</p><p>Bit2~0：数字低通滤波器，也是根据需求配置。我们给个110，比较平滑的配置</p><p><strong>对应配置为：0x06</strong></p><hr><p><code>GYRO_CONFIG</code>：<strong>陀螺仪配置寄存器</strong>，高3位是XYZ轴的自测使能位，中间两位是满量程选择位，最后三位没使用</p><p><img src="../assets/image-20241218224017264-173752975558684.png" alt="image-20241218224017264"></p><p>Bit7~Bit5：自测使能位，不自测给0即可</p><p>Bit4~Bit3:满量程选择，根据实际需求选择。我们给11为最大量程</p><p>Bit2~Bit0：无关位</p><p><strong>对应配置为：0x18</strong></p><p><img src="../assets/image-20241207235348661-173752975558685.png" alt="image-20241207235348661"></p><hr><p><code>ACCEL_CONFIG</code>：<strong>加速度计配置寄存器</strong>，高3位是XYZ轴的自测使能位，中间两位是满量程选择位，最后三位用于配置高通滤波器(内置小功能会用到)</p><p><img src="../assets/image-20241218224036938-173752975558686.png" alt=""></p><p>Bit7~Bit5：自测使能位，不自测给0即可</p><p>Bit4~Bit3:满量程选择，根据实际需求选择。我们给11为最大量程</p><p>Bit2~Bit0：高通滤波器，不使用给00</p><p><strong>对应配置为：0x18</strong></p></blockquote><p><img src="../assets/image-20241207233637672-173752975558687.png" alt="image-20241207233637672"></p><blockquote><p><code>加速度计XYZ轴寄存器：</code>_L 表示低8位，_H表示高8位</p><p>ACCEL_XOUT_H ：</p><p>ACCEL_XOUT_L ：</p><p>ACCEL_YOUT_H ：</p><p>ACCEL_YOUT_L ：</p><p>ACCEL_ZOUT_H ：</p><p>ACCEL_ZOUT_L ：</p><p><code>加速度计XYZ轴寄存器：</code>_L 表示低8位，_H表示高8位</p><p>GYRO_XOUT_H：</p><p>GYRO_XOUT_L ：</p><p>GYRO_YOUT_H ：</p><p>GYRO_YOUT_L ：</p><p>GYRO_ZOUT_H ：</p><p>GYRO_ZOUT_L ：</p><p><code>温度传感器寄存器：</code></p><p>TEMP_OUT_H ：</p><p>TEMP_OUT_L ：</p><p><code>查看对应手册的寄存器讲解部分即可</code></p></blockquote><p><img src="../assets/image-20241207234205598-173752975558688.png" alt="image-20241207234205598"></p><blockquote><p><code>具体某位干什么查看手册对应寄存器功能</code></p><p><code>PWR_MGMT_1：电源管理寄存器1:</code></p><p><img src="../assets/image-20241208000537943-173752975558689.png" alt="image-20241208000537943"></p><p><img src="../assets/image-20241218222543311-173752975558790.png" alt="image-20241218222543311"></p><p>Bit7(DEVICE)：设备复位，配置给0不复位</p><p>Bit6(SLEEP)：设备睡眠，配置时给0不睡眠</p><p>Bit5(CYCLE)：循环模式，配置给0不循环</p><p>Bit4(无关位)：配置给0即可</p><p>Bit3(温度传感器失能)：配置给0，不失能</p><p>Bit2~0(选择时钟)：000选择内部时钟，手册非常建议选择陀螺仪时钟，我们配置为001，选择X轴陀螺仪时钟</p><p><strong>对应配置为：0x01</strong></p><hr><p><code>PWR_MGMT_2：电源管理寄存器2:</code></p><p><img src="../assets/image-20241218223451238-173752975558791.png" alt="image-20241218223451238"></p><p>Bit7~6：循环模式唤醒频率，给00，不需要</p><p>Bit5~0：后六位为每个轴的待机位，不需要待机，全部给0即可</p><p><strong>对应配置为：0x00</strong></p><hr><p><code>WHO_AM_I：器件ID号:</code>只读的，中间六位固定为110100</p><p><img src="../assets/image-20241208000027373-173752975558792.png" alt="image-20241208000027373"></p></blockquote><p><img src="../assets/image-20241208000214450-173752975558893.png" alt="image-20241208000214450"></p><blockquote><p>注意这里写的是：所有寄存器上电后默认都是0x00，除了107号寄存器和117号寄存器</p><p><strong>107号</strong>：<strong>电源管理寄存器1</strong>，默认为0x40(01000000)，可以看到SLEEP位为1，及<strong>上电默认睡眠模式，使用时记得解除睡眠模式，否则操作其他寄存器是无效的</strong></p></blockquote><blockquote><p><strong>117号</strong>：器件ID寄存器配置初始化值为0x68</p><p><img src="../assets/image-20241208000407336-173752975558894.png" alt="image-20241208000407336"></p></blockquote><h3 id="软件模拟I2C读写">软件模拟I2C读写</h3><blockquote><p><strong>使用任意GPIO口模拟即可，步骤为：</strong></p><ol><li><strong>开启对应RCC时钟</strong></li><li><strong>配置GPIO口为开漏输出</strong></li><li><strong>配置SCL和SDA引脚默认高电平</strong></li></ol></blockquote><h4 id="软件I2C代码实现">软件I2C代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyI2C.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYI2C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYI2C_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元1：起始条件SCL高电平期间，SDA从高电平切换到低电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元1：结束条件SCL高电平期间，SDA从低电平切换到高电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：发送一个字节，1位1位的发送，从最高位开始*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：接收一个字节，SCL低从机设置，SCL高主机读取*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveByte</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：发送应答，逻辑和发送字节类似*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendAck</span><span class="params">(<span class="type">uint8_t</span> AckBit)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：接收应答，逻辑和接收字节类似*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveAck</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyI2C.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SCL</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line"> GPIO_WriteBit(GPIOA,GPIO_Pin_2,(BitAction)BitVal);</span><br><span class="line"> Delay_ms(<span class="number">10</span>);<span class="comment">//延时用于控制每个时序步骤之间的时间，确保I2C时序的稳定性。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SDA</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line"> GPIO_WriteBit(GPIOA,GPIO_Pin_3,(BitAction)BitVal);</span><br><span class="line"> Delay_ms(<span class="number">10</span>);<span class="comment">//延时用于控制每个时序步骤之间的时间，确保I2C时序的稳定性。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_R_SCL</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">uint8_t</span> bitValue;</span><br><span class="line">   bitValue = GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2);</span><br><span class="line"> Delay_ms(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bitValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_R_SDA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">uint8_t</span> bitValue;</span><br><span class="line">   bitValue = GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_3);</span><br><span class="line"> Delay_ms(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bitValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通过前面几个函数的封装我们实现了函数名称、端口号的替换，需要替换端口或者移植时就只需要对前四个函数修改即可,这样编程很方便*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">  GPIO_SetBits(GPIOA,GPIO_Pin_2 | GPIO_Pin_3);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元1：起始条件SCL高电平期间，SDA从高电平切换到低电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//Sr重复起始条件时SCL是低电平，SDA高低电平不确定，所以先拉高SDA再拉高SCL确保都能回归高电平</span></span><br><span class="line"> MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"> MyI2C_W_SDA(<span class="number">0</span>);<span class="comment">//SDA先拉低</span></span><br><span class="line"> MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*基本单元1：结束条件SCL高电平期间，SDA从低电平切换到高电平*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> MyI2C_W_SDA(<span class="number">0</span>);<span class="comment">//SCL一定为低电平，SDA高低电平不确定，为了确保释放SDA时能产生上升沿，要先拉低SDA</span></span><br><span class="line"></span><br><span class="line"> MyI2C_W_SCL(<span class="number">1</span>);<span class="comment">//SCL先拉高</span></span><br><span class="line"> MyI2C_W_SDA(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：发送一个字节，1位1位的发送，从最高位开始*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// /*发送最高位*/</span></span><br><span class="line"><span class="comment">//   进来时SCL为低电平</span></span><br><span class="line"><span class="comment">// MyI2C_W_SDA(Byte &amp; 0x80);//因为保证了SCL是低电平，所以此时直接放入数据即可</span></span><br><span class="line"><span class="comment">// MyI2C_W_SCL(1);//SCL先拉高后从机会立刻读取刚刚放入的数据</span></span><br><span class="line"><span class="comment">// MyI2C_W_SCL(0);//SCL拉低完成一个脉冲</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// /*发送次高位*/</span></span><br><span class="line"><span class="comment">// MyI2C_W_SDA(Byte &amp; 0x40);</span></span><br><span class="line"><span class="comment">// MyI2C_W_SCL(1);</span></span><br><span class="line"><span class="comment">// MyI2C_W_SCL(0);</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里使用循环直接实现8个字节的发送，SCL低主机设置，SCL高从机读取*/</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">  MyI2C_W_SDA(Byte &amp; (<span class="number">0x80</span> &gt;&gt; i));</span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元2：接收一个字节，SCL低从机设置，SCL高主机读取*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveByte</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> Byte = <span class="number">0x00</span>;</span><br><span class="line">  </span><br><span class="line">MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//主机在接受数据前需要将SDA释放让从机获取SDA控制权，使从机能够将数据放入SDA</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(MyI2C_R_SDA()==<span class="number">1</span>) <span class="comment">//从机发送的数据</span></span><br><span class="line">&#123;</span><br><span class="line">Byte |= (<span class="number">0x80</span> &gt;&gt; i); <span class="comment">// 设置第i位为1,否则为0</span></span><br><span class="line">&#125;</span><br><span class="line">MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Byte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：发送应答，逻辑和发送字节类似*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendAck</span><span class="params">(<span class="type">uint8_t</span> AckBit)</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//进来时SCL为低电平</span></span><br><span class="line">MyI2C_W_SDA(AckBit);<span class="comment">//主机发送ACK</span></span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);<span class="comment">//SCL为高，从机接收ACK</span></span><br><span class="line">MyI2C_W_SCL(<span class="number">0</span>);<span class="comment">//结束一个脉冲</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基本单元3：接收应答，逻辑和接收字节类似*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveAck</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> AckBit = <span class="number">0x00</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//进来时SCL为低电平</span></span><br><span class="line">MyI2C_W_SDA(<span class="number">1</span>);<span class="comment">//释放SDA使从机能操控SDA线(使其具有能拉高或拉低SDA的能力)，在SCL置高电平之前，从机将ACK放到SDA线上</span></span><br><span class="line"></span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">AckBit = MyI2C_R_SDA();<span class="comment">//读取ACK</span></span><br><span class="line">MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> AckBit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyI2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  UsartInit();</span><br><span class="line">  MyI2C_Init();</span><br><span class="line">    </span><br><span class="line">  MyI2C_Start();</span><br><span class="line">  MyI2C_SendByte(<span class="number">0xD0</span>); <span class="comment">// 1101000 0 MPU6050地址+写位</span></span><br><span class="line">   <span class="comment">//  MyI2C_SendByte(0xB0); // 1101000 0 MPU6050地址+写位</span></span><br><span class="line">  <span class="type">uint8_t</span> ack = MyI2C_ReceiveAck();</span><br><span class="line">  MyI2C_Stop();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">UsartSend(ack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试是否能收到ACK，改变对应从机地址后是否应答</p></blockquote><h4 id="MPU6050-测试读写">MPU6050-测试读写</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyI2C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">MyI2C_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*1.起始，对应从机地址MPU6050，应答*/</span></span><br><span class="line">MyI2C_Start();</span><br><span class="line">  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">MyI2C_ReceiveAck();<span class="comment">//可以对应答位判断是否收到从机数据进行处理，这里默认应答</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*2.发送要写入的寄存器地址，应答*/</span></span><br><span class="line">  MyI2C_SendByte(RegAddress);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*3.发送写入数据*/</span></span><br><span class="line">MyI2C_SendByte(Data);</span><br><span class="line">MyI2C_ReceiveAck(); <span class="comment">//这里只发送一个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">//  MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">/*当要写入多个字节时，使用循环依次将数组的各个字节发送出去*/</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/*4.结束*/</span></span><br><span class="line">  MyI2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> Data;</span><br><span class="line"></span><br><span class="line">MyI2C_Start();</span><br><span class="line">  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line"></span><br><span class="line">  MyI2C_SendByte(RegAddress);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*前一半为写的时序*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*后一半为读的时序*/</span></span><br><span class="line">  MyI2C_Start();<span class="comment">//Sr</span></span><br><span class="line">  MyI2C_SendByte(MPU6050_ADDRESS|<span class="number">0x01</span>);<span class="comment">//最后一位改成读</span></span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*接收从机数据*/</span></span><br><span class="line">  Data = MyI2C_ReceiveByte();</span><br><span class="line">MyI2C_SendAck(<span class="number">1</span>);<span class="comment">//想继续读数据给应答，这里只读一位，直接不应答了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    Datas[i] = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">//        if(i==7)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//MyI2C_SendAck(1);//最后一位读取后不应答</span></span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//MyI2C_SendAck(0);//读取多个数据给应答</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//多个数据读取</span></span><br><span class="line">    </span><br><span class="line">  MyI2C_Stop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="读功能">读功能</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> Id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> UsartInit();</span><br><span class="line"> MPU6050_Init();</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*读取寄存器*/</span></span><br><span class="line">    Id = MPU6050_ReadReg(<span class="number">0x75</span>);<span class="comment">//WHO_AM_I，ID寄存器</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">UsartSend(Id);</span><br><span class="line">Delay_ms(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../assets/image-20241218220447684-173752975558895.png" alt="image-20241218220447684"></p><blockquote><p>读读取0x75后，得到的结果是0x68，与手册对应代表一字节时序正确</p></blockquote><h5 id="写功能">写功能</h5><p><code>在使用写功能是必须先接触睡眠模式，否则操控其他寄存器无效</code></p><p><img src="../assets/image-20241218220917107-173752975558996.png" alt="image-20241218220917107"></p><blockquote><p>睡眠模式由该电源资源管理寄存器的SLEEP位控制，对应寄存器地址为0x6B，初始值为0x40(0100000)，SLEEP位为1</p><p><strong>只需要对该寄存器写入0x00即可</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="type">uint8_t</span> Data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">LED_Init();</span><br><span class="line"></span><br><span class="line">  UsartInit();</span><br><span class="line">  MPU6050_Init();</span><br><span class="line">  </span><br><span class="line">  MPU6050_WriteReg(<span class="number">0x6B</span>,<span class="number">0x00</span>);<span class="comment">//电源资源管理寄存器，必选先接触睡眠模式</span></span><br><span class="line">  </span><br><span class="line">  MPU6050_WriteReg(<span class="number">0x19</span>,<span class="number">0xAA</span>);<span class="comment">//采样分频寄存器</span></span><br><span class="line">    </span><br><span class="line">  Data = MPU6050_ReadReg(<span class="number">0x19</span>);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">UsartSend(Data);</span><br><span class="line">Delay_ms(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试发现对应寄存器值修改成功，串口显示AA</p></blockquote><h4 id="MPU6050-读取加速度-角速度">MPU6050-读取加速度/角速度</h4><blockquote><p>当需要使用的寄存器宏定义比较多时，建议单独创建头文件管理。</p><p>该头文件为MPU6050部分寄存器，从MPU6050寄存器手册搬过来即可</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_REG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_REG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_SMPLRT_DIV0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_CONFIG0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_CONFIG0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_CONFIG0x1C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_XOUT_H0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_XOUT_L0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_YOUT_H0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_YOUT_L0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_ZOUT_H0x3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_ZOUT_L0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_TEMP_OUT_H0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_TEMP_OUT_L0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_XOUT_H0x43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_XOUT_L0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_YOUT_H0x45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_YOUT_L0x46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_ZOUT_H0x47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_ZOUT_L0x48</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_PWR_MGMT_10x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_PWR_MGMT_20x6C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_WHO_AM_I0x75</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ, <span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">()</span></span><br><span class="line"><span class="comment">/*读取对应MPU6050ID*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyI2C.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_Reg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0 <span class="comment">//1101000 0</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*1.起始，对应从机地址MPU6050，应答*/</span></span><br><span class="line">MyI2C_Start();</span><br><span class="line">  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">MyI2C_ReceiveAck();<span class="comment">//可以对应答位判断是否收到从机数据进行处理，这里默认应答</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*2.发送要写入的寄存器地址，应答*/</span></span><br><span class="line">  MyI2C_SendByte(RegAddress);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*3.发送写入数据*/</span></span><br><span class="line">MyI2C_SendByte(Data);</span><br><span class="line">MyI2C_ReceiveAck(); <span class="comment">//这里只发送一个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">//  MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">/*当要写入多个字节时，使用循环依次将数组的各个字节发送出去*/</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/*4.结束*/</span></span><br><span class="line">  MyI2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> Data;</span><br><span class="line"></span><br><span class="line">MyI2C_Start();</span><br><span class="line">  MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line"></span><br><span class="line">  MyI2C_SendByte(RegAddress);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*前一半为写的时序*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*后一半为读的时序*/</span></span><br><span class="line">  MyI2C_Start();<span class="comment">//Sr</span></span><br><span class="line">  MyI2C_SendByte(MPU6050_ADDRESS|<span class="number">0x01</span>);<span class="comment">//最后一位改成读</span></span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*接收从机数据*/</span></span><br><span class="line">  Data = MyI2C_ReceiveByte();</span><br><span class="line">MyI2C_SendAck(<span class="number">1</span>);<span class="comment">//想继续读数据给应答，这里只读一位，直接不应答了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    Datas[i] = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">//        if(i==7)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//MyI2C_SendAck(1);//最后一位读取后不应答</span></span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//MyI2C_SendAck(0);//读取多个数据给应答</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//多个数据读取</span></span><br><span class="line">    </span><br><span class="line">  MyI2C_Stop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主要修改如下*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">MyI2C_Init();</span><br><span class="line">  MPU6050_WriteReg(MPU6050_PWR_MGMT_1,<span class="number">0x01</span>);<span class="comment">//配置电源管理寄存器1,解除睡眠选择陀螺仪时钟</span></span><br><span class="line">  MPU6050_WriteReg(MPU6050_PWR_MGMT_2,<span class="number">0x00</span>);<span class="comment">//配置电源管理寄存器2,6个轴均不待机</span></span><br><span class="line"></span><br><span class="line">  MPU6050_WriteReg(MPU6050_SMPLRT_DIV,<span class="number">0x09</span>);<span class="comment">//配置采样分频寄存器，选择10分频，滤波参数给最大</span></span><br><span class="line">MPU6050_WriteReg(MPU6050_CONFIG,<span class="number">0x06</span>);<span class="comment">//配置寄存器，滤波参数110</span></span><br><span class="line">  MPU6050_WriteReg(MPU6050_GYRO_CONFIG,<span class="number">0x18</span>);<span class="comment">//陀螺仪最大量程</span></span><br><span class="line">  MPU6050_WriteReg(MPU6050_ACCEL_CONFIG,<span class="number">0x18</span>);<span class="comment">//加速度计最大量程</span></span><br><span class="line"><span class="comment">/*这里配置完后，陀螺仪内部就在不停的转换了，对应数据存放在对应各轴数据寄存器中*/</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对应6轴的数据都是16位，分为高8位和低8位，分别读取高8位和低8位拼接后*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,<span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> DataH,DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">  </span><br><span class="line">*AccX =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">  DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line"></span><br><span class="line">  *AccY =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">  </span><br><span class="line">  DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line"></span><br><span class="line">  *AccZ =    (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">  DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line"></span><br><span class="line">  *GyroX = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line"></span><br><span class="line">  *GyroY =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line"></span><br><span class="line">  *GyroZ =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里的读取分为12次，我们可以改进，使用连续读取的时序，大大提升效率*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050.h&quot;</span></span></span><br><span class="line"><span class="type">int16_t</span> AX=<span class="number">0</span>,AY=<span class="number">0</span>,AZ=<span class="number">0</span>,GX=<span class="number">0</span>,GY=<span class="number">0</span>,GZ=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="type">uint8_t</span> Data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  LED_Init();</span><br><span class="line">   </span><br><span class="line">  UsartInit();</span><br><span class="line"></span><br><span class="line">  MPU6050_Init();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">MPU6050_GetData(&amp;AX,&amp;AY,&amp;AZ,&amp;GX,&amp;GY,&amp;GZ);</span><br><span class="line">UsartSend(AX);</span><br><span class="line">UsartSend(AY);</span><br><span class="line">UsartSend(AZ);</span><br><span class="line">UsartSend(GX);</span><br><span class="line">UsartSend(GY);</span><br><span class="line">UsartSend(GZ);</span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>对应数据：</code></p><p>X轴加速度：水平基本没加速度</p><p>Y轴加速度：水平基本没加速度</p><p>Z轴加速度：平放在水面通过得到AZ，我们选择的是满量程16g(看手册上)</p><p>对应加速度计算公式为 AZ / 32768 =  x / 16g ，解方程的得到的x为Z轴方向加速度，这个值理论上来说应该是重力加速度g</p><hr><p>X轴角速度：</p><p>Y轴角速度：</p><p>Z轴角速度：</p><hr><p><strong>上方所有数据计算的公式为：</strong></p><p><strong>（读取的数据）/（32768） = （x）  /（ 满量程）</strong></p><p><strong>解出对应x的值即可</strong></p></blockquote><h3 id="I2C外设-硬件读写I2C">I2C外设(硬件读写I2C)</h3><p><img src="../assets/image-20241220151445355-173752975558997.png" alt="image-20241220151445355"></p><blockquote><p>由硬件电路自动实现引脚电平反转，软件只需要写入<strong>控制寄存器CR</strong>和<strong>数据寄存器DR</strong>即可。</p><p>为了监控时序状态，软件还得读取<strong>状态寄存器SR</strong>来了解当前的外设电路处于什么状态</p><p><strong>这就像开车一样：写入控制寄存器CR，就像是踩油门、打方向盘来控制汽车的运行，读取状态寄存器SR，就像是观看仪表盘，来了解汽车的运行状态。</strong></p><p>使用库函数封装后，有了I2C外设，硬件就可以自动实现时序，就可以减轻CPU的负担，节省软件资源</p><hr><p><strong>一主多从</strong>：一个主机多个从设备…</p><p><strong>多主机模式</strong>：分为固定多主机和可变多主机</p><ul><li>固定多主机：固定有几个主机，多个主机控制产生冲突时需要仲裁</li><li>可变多主机：总线上无固定主机和从机，任何设备可以在总线空闲时主动跳出作为主机与其他从机通信，通信完成后回归从机</li></ul><p><code>对于STM32使用的是可变多主机模型</code></p><hr><p><strong>地址模式</strong>：7/10位</p><p>7位：一个字节中的前7位为设备地址，最后一位是读写位。</p><p>10位：使用两个字节，如果第二个字节也是寻址的话，第一个字节的前5位必须是11110<code>(10位地址标志位)</code>，第一个字节剩下2位和第二个字节的8位一共10位作为寻址</p><p>7位与10位区别：前5位是否为11110</p><hr><p><strong>通讯速度</strong>：</p><ul><li><p>标准速度：100KHz</p></li><li><p>快速速度：400KHz</p></li></ul><hr><p><strong>DMA</strong>：…</p><hr><p><strong>兼容SMBus：System Management Bus-系统管理总线</strong></p><p>类似于I2C，是兼容的另一种总线</p></blockquote><p><strong>对应寄存器，标志位查看芯片参考手册的I2C接口模块阅读即可!!!</strong></p><h4 id="I2C框图">I2C框图</h4><p><img src="../assets/image-20241221144132847-173752975558998.png" alt="image-20241221144132847"></p><blockquote><p><strong>对应使用时一般是GPIO口复用，查询对应引脚定义表即可，使用<code>硬件I2C时只能使用指定的引脚</code>，不能像<code>软件I2C那样引脚任意指定</code></strong></p><hr><p>由于I2C是半双工，只有<code>一组移位寄存器和数据寄存器</code>，接收和发送都是使用这组，而串口有两组</p><hr><p><code>比较器和地址寄存器：</code>从机模式使用，支持同时响应两个从机地址，在多主机模式下使用</p><hr><p><code>帧错误校验PEC计算</code>：CRC校验算法，数据有效性验证，对应数据错误标志位置位</p><hr><p><code>中断</code>：某个紧急事件发生后可以申请中断</p><hr><p><code>DMA</code>：配合提高效率</p></blockquote><blockquote><p>SMBALERT是SMBus相关，I2C使用时不用管它</p></blockquote><h4 id="I2C基本结构">I2C基本结构</h4><p><img src="../assets/image-20241221150048169-173752975558999.png" alt="image-20241221150048169"></p><blockquote><p>图中是简化的一主多从结构，如果是多主机应该还有时钟输入</p><p>图中的两个GPIO：一个是复用输入，另一个是复用输出</p><hr><p><strong>移位寄存器和数据寄存器DR</strong>：</p><p><code>发送时数据先写入数据寄存器DR，如果移位寄存器没有数据，就会转到移位寄存器进行发送</code></p></blockquote><h4 id="主机发送流程">主机发送流程</h4><p><img src="../assets/image-20241221162408618-1737529755589100.png" alt="image-20241221162408618"></p><blockquote><p><code>EV事件</code> 是多个标志位的集合，所有标志位在手册中都可以找到</p><p>EV5,EV6,EV8…</p><p>流程简化下来就是：操作-等待-操作-等待…</p></blockquote><h4 id="主机接收流程">主机接收流程</h4><p><img src="../assets/image-20241221162433975-1737529755590101.png" alt="image-20241221162433975"></p><blockquote><p>图中给的时序是当前地址读的，想要指定地址读数据需要组合一下即可</p><p>具体的流程见下面的代码</p></blockquote><h4 id="从机发送接收">从机发送接收</h4><p>见手册！！！</p><h4 id="库函数-9">库函数</h4><p><code>初始化函数：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_DeInit</span><span class="params">(I2C_TypeDef* I2Cx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Init</span><span class="params">(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_StructInit</span><span class="params">(I2C_InitTypeDef* I2C_InitStruct)</span>;</span><br></pre></td></tr></table></figure><p><code>起始条件和终止条件：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_GenerateSTART</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//调用该函数生成起始条件，对I2C_CR1寄存器中的START位置1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_GenerateSTOP</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//调用该函数生成终止条件，对I2C_CR1寄存器中的STOP位置1</span></span><br></pre></td></tr></table></figure><p><code>应答ACK：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_AcknowledgeConfig</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;<span class="comment">//手动ACK配置，在收到一个字节后，是否给从机应答</span></span><br></pre></td></tr></table></figure><p><code>发送和接收数据：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_SendData</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint8_t</span> Data)</span>;<span class="comment">//写入数据到数据寄存器DR</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">I2C_ReceiveData</span><span class="params">(I2C_TypeDef* I2Cx)</span>;<span class="comment">//读取数据寄存器DR作为返回值，接收到下一个字节之前读出数据寄存器，防止数据覆盖，实现连续数据流</span></span><br></pre></td></tr></table></figure><p><code>发送地址专用函数:</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_Send7bitAddress</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint8_t</span> Address, <span class="type">uint8_t</span> I2C_Direction)</span>;<span class="comment">//主要用于设置自动设置读写位</span></span><br></pre></td></tr></table></figure><blockquote><p>这个函数可以不使用，而是自己确定读写位的最后一位，直接使用SendData函数进行发送</p></blockquote><p><code>中断配置：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_ITConfig</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint16_t</span> I2C_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><p><code>DMA相关：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_DMACmd</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_DMALastTransferCmd</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><p><code>使能函数：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_Cmd</span><span class="params">(I2C_TypeDef* I2Cx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><p><code>标志位：</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">I2C_GetFlagStatus</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_ClearFlag</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_FLAG)</span>;</span><br><span class="line"><span class="comment">/*中断外使用*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ITStatus <span class="title function_">I2C_GetITStatus</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_ClearITPendingBit</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_IT)</span>;</span><br><span class="line"><span class="comment">/*中断中使用*/</span></span><br></pre></td></tr></table></figure><p><code>状态监控：给了三种方法</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一种：基本状态监控，同时判断一个或多个标志位，来确定EV几EV几这个状态是否发生,对应发送接收流程*/</span></span><br><span class="line">ErrorStatus <span class="title function_">I2C_CheckEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span>;<span class="comment">//推荐使用！！！,第二个参数为监测的事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第二种：高级状态监控，实际上并不高级，对应库函数注释可以找到是将SR1和SR2这两个状态寄存器拼接成16位数据然后给你就完了*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">I2C_GetLastEvent</span><span class="params">(I2C_TypeDef* I2Cx)</span>;。<span class="comment">//一般不使用，了解即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三种：基于标志位的状态监控，我们一直使用的判断某个标志位方法*/</span></span><br><span class="line">FlagStatus <span class="title function_">I2C_GetFlagStatus</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_FLAG)</span>;</span><br></pre></td></tr></table></figure><h4 id="I2C外设配置">I2C外设配置</h4><p><code>参考上方I2C框图和基本结构进行配置：</code></p><ol><li><strong>开启I2C外设和对应GPIO口的时钟</strong></li><li><strong>结构体配置对应GPIO口为复用开漏输出模式(区别：软件模拟I2C是直接开漏没有复用开漏)</strong></li><li><strong>结构体配置I2C</strong></li><li><strong>使能I2C，I2C_Cmd</strong></li></ol><h4 id="实验-硬件I2C读取MPU6050数据">实验-硬件I2C读取MPU6050数据</h4><blockquote><p>部分与软件I2C相同，去掉了软件I2C最底层的部分，使用库函数代替</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MPU6050.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,<span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;MyI2C.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_Reg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS 0xD0 <span class="comment">//1101000 0</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序中出现大量while等待的情况比较危险，容易发生卡死的现象，所以我们需要让它超时退出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *不必使用定时器，我们只需要简单用一个计数值循环判断即可，该Timeout值根据实际情况更改大小，while循环正常不会执行到Timeout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">uint32_t</span> Timeout;</span><br><span class="line"> Timeout = <span class="number">10000</span>;</span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2Cx,I2C_EVENT)!=SUCCESS)</span><br><span class="line"> &#123;</span><br><span class="line"> Timeout --;</span><br><span class="line"> <span class="keyword">if</span>(Timeout ==<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该函数为CheckEvent的封装</span></span><br><span class="line"><span class="comment"> * 下方没有替换，该函数使用时只需要将使用while循环的部分直接使用该函数全部替换即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址写对应时序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress,<span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*软件I2C代码：*/</span></span><br><span class="line"><span class="comment">//  /*1.起始，对应从机地址MPU6050，应答*/</span></span><br><span class="line"><span class="comment">//MyI2C_Start();</span></span><br><span class="line"><span class="comment">//  MyI2C_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">//MyI2C_ReceiveAck();//可以对应答位判断是否收到从机数据进行处理，这里默认应答</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  /*2.发送要写入的寄存器地址，应答*/</span></span><br><span class="line"><span class="comment">//  MyI2C_SendByte(RegAddress);</span></span><br><span class="line"><span class="comment">//MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  /*3.发送写入数据*/</span></span><br><span class="line"><span class="comment">//MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">//MyI2C_ReceiveAck(); //这里只发送一个字节</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">////&#123;</span></span><br><span class="line"><span class="comment">////MyI2C_SendByte(Data);</span></span><br><span class="line"><span class="comment">////  MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">////&#125;</span></span><br><span class="line"><span class="comment">//    /*当要写入多个字节时，使用循环依次将数组的各个字节发送出去*/</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">///*4.结束*/</span></span><br><span class="line"><span class="comment">//  MyI2C_Stop();</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*硬件I2C下使用的都是非阻塞的函数，需要等待标志位结束才能保证对应波形执行完成*/</span></span><br><span class="line"> <span class="comment">/*对应等待的事件根据硬件I2C发送流程中来写*/</span></span><br><span class="line"> </span><br><span class="line"> I2C_GenerateSTART(I2C1,ENABLE);<span class="comment">//1.发送起始条件</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)!=SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">&#125;<span class="comment">//等待EV5事件完成</span></span><br><span class="line"> </span><br><span class="line"> I2C_Send7bitAddress(I2C1,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//2.发送从机地址，第三个参数自动置读写位,应答位会自动处理</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)!=SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">&#125;<span class="comment">//等待发送模式的EV6事件完成</span></span><br><span class="line"> </span><br><span class="line"> I2C_SendData(I2C1,RegAddress);<span class="comment">//3.发送指定寄存器地址</span></span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTING)!=SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">&#125;<span class="comment">//等待EV8事件</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*发送多个字节数据时，中间的数据发送完成后等待EV8事件，而最后一个字节变为等待EV8_2事件*/</span></span><br><span class="line"> </span><br><span class="line"> I2C_SendData(I2C1,Data);<span class="comment">//4.发送要写入的数据</span></span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)!=SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">&#125;<span class="comment">//发送最后一个字节完成后，等待EV8_2事件</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> I2C_GenerateSTOP(I2C1,ENABLE);<span class="comment">//5.终止条件</span></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指定地址读对应时序，指定写+当前读*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*软件模拟I2C:*/</span></span><br><span class="line"><span class="comment">//MyI2C_Start();</span></span><br><span class="line"><span class="comment">//  MyI2C_SendByte(MPU6050_ADDRESS);</span></span><br><span class="line"><span class="comment">//MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  MyI2C_SendByte(RegAddress);</span></span><br><span class="line"><span class="comment">//MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">///*前一半为写的时序*/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">///*后一半为读的时序*/</span></span><br><span class="line"><span class="comment">//  MyI2C_Start();//Sr</span></span><br><span class="line"><span class="comment">//  MyI2C_SendByte(MPU6050_ADDRESS|0x01);//最后一位改成读</span></span><br><span class="line"><span class="comment">//MyI2C_ReceiveAck();</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">///*接收从机数据*/</span></span><br><span class="line"><span class="comment">//  Data = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">//MyI2C_SendAck(1);//想继续读数据给应答，这里只读一位，直接不应答了</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////  for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">////&#123;</span></span><br><span class="line"><span class="comment">////    Datas[i] = MyI2C_ReceiveByte();</span></span><br><span class="line"><span class="comment">////        if(i==7)</span></span><br><span class="line"><span class="comment">////&#123;</span></span><br><span class="line"><span class="comment">////MyI2C_SendAck(1);//最后一位读取后不应答</span></span><br><span class="line"><span class="comment">////break;</span></span><br><span class="line"><span class="comment">////&#125;</span></span><br><span class="line"><span class="comment">////MyI2C_SendAck(0);//读取多个数据给应答</span></span><br><span class="line"><span class="comment">////&#125;</span></span><br><span class="line"><span class="comment">////多个数据读取</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//  MyI2C_Stop();</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*硬件I2C:实现指定地址接收一个字节，使用的是复合形式*/</span></span><br><span class="line"> I2C_GenerateSTART(I2C1,ENABLE);<span class="comment">//1.发送起始条件</span></span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)!=SUCCESS);<span class="comment">//起始条件等待EV5事件完成</span></span><br><span class="line"> </span><br><span class="line"> I2C_Send7bitAddress(I2C1,MPU6050_ADDRESS,I2C_Direction_Transmitter);<span class="comment">//2.发送从机地址，第三个参数自动置读写位,应答位会自动处理</span></span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)!=SUCCESS)<span class="comment">//等待发送模式的EV6事件完成</span></span><br><span class="line"> </span><br><span class="line"> I2C_SendData(I2C1,RegAddress);<span class="comment">//3.发送指定寄存器地址</span></span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)!=SUCCESS)<span class="comment">//这里因为是数据流最后一个字节所以变成了等待EV8_2事件</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*前一半为写的时序*/</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*后一半为读的时序*/</span></span><br><span class="line"> </span><br><span class="line"> I2C_GenerateSTART(I2C1,ENABLE);<span class="comment">//4.重复起始条件。这个地方会等待上方字节发送完成后才会产生，所以上方用TRANSMITTING或TRANSMITTED都可以</span></span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)!=SUCCESS);<span class="comment">//起始条件等待EV5事件完成</span></span><br><span class="line"></span><br><span class="line"> I2C_Send7bitAddress(I2C1,MPU6050_ADDRESS,I2C_Direction_Receiver);<span class="comment">//2.发送从机地址，这个地方应变成读的方向，第三个参数修改</span></span><br><span class="line"> <span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)!=SUCCESS)<span class="comment">//等待接收模式的EV6事件完成，与上方EV6事件不同</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> <span class="comment">//如果只需要读取一个字节，需要恰好在EV6之后，立刻把ACK置0，STOP置1，避免在本次ACK发送之后才去置0，这样时序会多一个字节</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果是需要读取多个字节，直接等待EV7事件，读取DR,就能收到数据，依次接收，直到最后一个字节之前也就是EV7_1事件(EV7_1不用等待)，提前把ACK置0，STOP置1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> I2C_AcknowledgeConfig(I2C1, DISABLE);</span><br><span class="line">I2C_GenerateSTOP(I2C1,ENABLE);<span class="comment">//STOP置1后该终止条件不会截断当前字节，会等当前字节接收完成后，再产生终止条件波形</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)!=SUCCESS)<span class="comment">//等待EV7事件完成</span></span><br><span class="line">Data = I2C_ReceiveData(I2C1);<span class="comment">//5.接收从机数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//     for(int i=0;i&lt;N;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//if(i==N-1)</span></span><br><span class="line"><span class="comment">//I2C_AcknowledgeConfig(I2C1, DISABLE);</span></span><br><span class="line"><span class="comment">//I2C_GenerateSTOP(I2C1,ENABLE);//STOP置1后该终止条件不会截断当前字节，会等当前字节接收完成后，再产生终止条件波形</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)!=SUCCESS)//等待EV7事件完成</span></span><br><span class="line"><span class="comment">//Data = I2C_ReceiveData(I2C1);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//   接收多个字节:使用循环处理，最后一个字节前执行一次ACK=0和STOP</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">I2C_AcknowledgeConfig(I2C1, ENABLE);<span class="comment">//最后再恢复默认ACK=1，方便收多个字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*软件I2C:*/</span></span><br><span class="line"><span class="comment">//MyI2C_Init();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*硬件I2C:*/</span></span><br><span class="line">  <span class="comment">/*第1步*/</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1,ENABLE);</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*第2步*/</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2|GPIO_Pin_3;</span><br><span class="line">GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*第3步*/</span></span><br><span class="line">  I2C_InitTypeDef I2C_InitStruct;</span><br><span class="line">I2C_InitStruct.I2C_Mode = I2C_Mode_I2C ;</span><br><span class="line">I2C_InitStruct.I2C_Ack = I2C_Ack_Enable;<span class="comment">//确认要发送应答位</span></span><br><span class="line">I2C_InitStruct.I2C_ClockSpeed = <span class="number">100000</span>;<span class="comment">//最大为400KHZ，0~100KHZ为标准速度，100~400khz为快速</span></span><br><span class="line">  I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_2;<span class="comment">//时钟占空比参数，用与快速模式，只有当时钟频率大于100Khz才有效，小于100Khz是占空比固定为1：1</span></span><br><span class="line">I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;<span class="comment">//响应7或10位地址，stm32作为从机时才使用。作为主机随便给</span></span><br><span class="line">I2C_InitStruct.I2C_OwnAddress1 = <span class="number">0x00</span>;<span class="comment">//自身地址1，stm32作为从机才使用，方便别的主机呼叫，指定地址位数=上一个参数选择响应的位数。作为主机随便给</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*第4步*/</span></span><br><span class="line">  I2C_Cmd(I2C1,ENABLE);</span><br><span class="line">  </span><br><span class="line">MPU6050_WriteReg(MPU6050_PWR_MGMT_1,<span class="number">0x01</span>);<span class="comment">//配置电源管理寄存器1,解除睡眠选择陀螺仪时钟</span></span><br><span class="line">  MPU6050_WriteReg(MPU6050_PWR_MGMT_2,<span class="number">0x00</span>);<span class="comment">//配置电源管理寄存器2,6个轴均不待机</span></span><br><span class="line"></span><br><span class="line">  MPU6050_WriteReg(MPU6050_SMPLRT_DIV,<span class="number">0x09</span>);<span class="comment">//配置采样分频寄存器，选择10分频，滤波参数给最大</span></span><br><span class="line">MPU6050_WriteReg(MPU6050_CONFIG,<span class="number">0x06</span>);<span class="comment">//配置寄存器，滤波参数110</span></span><br><span class="line">  MPU6050_WriteReg(MPU6050_GYRO_CONFIG,<span class="number">0x18</span>);<span class="comment">//陀螺仪最大量程</span></span><br><span class="line">  MPU6050_WriteReg(MPU6050_ACCEL_CONFIG,<span class="number">0x18</span>);<span class="comment">//加速度计最大量程</span></span><br><span class="line"><span class="comment">/*这里配置完后，陀螺仪内部就在不停的转换了，对应数据存放在对应各轴数据寄存器中*/</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对应6轴的数据都是16位，分为高8位和低8位，分别读取高8位和低8位拼接后*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX,<span class="type">int16_t</span> *AccY,<span class="type">int16_t</span> *AccZ,</span></span><br><span class="line"><span class="params"> <span class="type">int16_t</span> *GyroX,<span class="type">int16_t</span> *GyroY,<span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> DataH,DataL;</span><br><span class="line"></span><br><span class="line">DataH =  MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">  </span><br><span class="line">*AccX =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">  DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">  DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line"></span><br><span class="line">  *AccY =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">  </span><br><span class="line">  DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line"></span><br><span class="line">  *AccZ =    (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">  DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line"></span><br><span class="line">  *GyroX = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line"></span><br><span class="line">  *GyroY =  (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">  DataL =  MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line"></span><br><span class="line">  *GyroZ =   (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里的读取分为12次，我们可以改进，使用连续读取的时序，大大提升效率*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>程序中出现大量while等待的情况比较危险，容易发生卡死的现象，所以我们需要让它超时退出。</p><p>不必使用定时器，我们只需要简单用一个计数值循环判断即可，该Timeout值根据实际情况更改大小，while循环正常不会执行到Timeout</p></blockquote><h3 id="软件和硬件I2C对比">软件和硬件I2C对比</h3><p><code>波形对比：</code></p><p><strong>上方是软件波形，下方是硬件波形</strong></p><p><img src="../assets/image-20241221171144668-1737529755590102.png" alt=""></p><blockquote><p><strong>从时钟线的规整程度上看：</strong></p><p>硬件I2C：SCL波形会更加规整，每个时钟的周期、占空比都非常一致</p><p>软件I2C：由于操作引脚后都加了延时，有时候加的多有时候加的少，所以软件时序的时钟周期、占空比可能不规整，但由于是同步时序不规整也不会影响通信</p><hr><p>在SCL低电平写，高电平读的时候，可以在整个电平的任意时候都可以读写，但是一般要求保证尽早原则，所以可以认为SCL下降沿写，上升沿读。</p><p>软件波形中，因为操作端口后有延时，所以都是等了一会在写的</p><p>硬件波形中，可以看到SCL下降沿的时候，SDA也立马切换数据。读写都是紧贴上下沿进行</p><hr><p><strong>应答结束时最为明显：</strong></p><p>从机在SCL下降沿立刻释放SDA，但是软件I2C由于有延时，所以在应答结束后主机等了一会才变换数据，所以在软件I2C中有一个短暂的高电平后才拉低SDA。</p><p>硬件I2C中应答结束后，从机在SCL下降沿立刻释放SDA，同时主机也立刻拉低SDA，所以就是直接一个小尖峰。</p></blockquote><blockquote><p><code>软件模拟I2C (Bit-Banging)：</code></p><p><strong>优点：</strong></p><ul><li><strong>灵活性高</strong>：可以完全控制每个I2C数据位的发送和接收过程，适用于没有硬件I2C模块的STM32型号，或者需要多个I2C总线时，可以通过软件模拟多个I2C设备。</li><li><strong>成本低</strong>：不依赖硬件I2C外设，因此适合成本敏感的应用。</li><li><strong>可以在任意GPIO上运行</strong>：可以自定义SCL和SDA引脚，不需要专用的硬件I2C引脚。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>效率低</strong>：每个数据位的发送和接收都需要进行软件延时处理，导致比硬件I2C慢得多。对于高速通信，可能无法满足实时性要求。</li><li><strong>占用CPU资源</strong>：模拟I2C需要CPU不断参与数据的传输，可能影响系统其他任务的执行，尤其是当系统负载较高时。</li><li><strong>稳定性差</strong>：如果系统中有其他任务需要占用大量CPU时间，可能会导致I2C通信不稳定，或者丢失数据。</li></ul><hr><p><code>硬件I2C (利用硬件I2C模块)：</code></p><p><strong>优点：</strong></p><ul><li><strong>高效</strong>：硬件I2C通过专用的I2C控制器进行数据传输，不需要CPU参与数据位的传送，速度快且稳定，通常能够提供更高的传输速率。</li><li><strong>节省CPU资源</strong>：硬件I2C控制器可以自动完成数据传输任务，释放CPU处理其他任务，特别适合多任务或实时系统。</li><li><strong>稳定性强</strong>：硬件I2C模块有专门的硬件实现，避免了由于软件延迟或CPU占用过高导致的通信不稳定问题。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>硬件资源有限</strong>：不同型号的STM32有不同数量的硬件I2C模块，因此可用的硬件I2C通道有限。如果需要多个I2C总线，可能无法满足需求。</li><li><strong>引脚固定</strong>：硬件I2C通常需要专用的引脚（SCL和SDA），不能任意选择GPIO。如果这些引脚已被占用或在项目设计中不方便，可能会限制设计的灵活性。</li><li><strong>复杂性较高</strong>：硬件I2C需要配置硬件相关的寄存器和管理中断等，比软件模拟I2C配置复杂一些。</li></ul><hr><p><strong>使用场景总结</strong>：</p><p>**软件模拟I2C：**灵活、成本低，但效率低、占用CPU资源。不受限制，引脚够基本上就是想开几路就是几路</p><p>硬件I2C不足时可以使用软件I2C</p><p>**硬件I2C：**效率高、稳定，节省CPU资源，但受硬件资源和引脚限制。</p><p>对性能指标要求比较高，实时性、多任务等时使用硬件I2C</p></blockquote><h2 id="SPI">SPI</h2><h3 id="SPI介绍">SPI介绍</h3><p><img src="../assets/image-20250101153932297-1737529755591103.png" alt="image-20250101153932297"></p><blockquote><p>图中的四种使用SPI通信的芯片：引脚名称可能不标注，可以查看对应手册了解</p><ol><li>W25QXX，FLASH存储芯片，作为从机，引脚写的DI和DO</li><li>OLED屏幕</li><li>2.4G无线通信模块，芯片型号为NRF24L01</li><li>Micro SD卡：官方通信协议为SDIO，但也支持SPI协议，可以对其进行读写操作</li></ol></blockquote><blockquote><p><strong>SPI特点：同步，全双工，四根通信线</strong></p><hr><p><code>SPI的四根线：</code></p><ol><li><strong>SCK(Serial Clock)</strong>：时钟线，也叫做SCLK、CLK、CK等</li><li><strong>MOSI(Master Output Slave Input)</strong>：主机输出从机输入线，也叫做DI(Data Output-对应从机输入)</li><li><strong>MISO(Master Output Slave Input)</strong>：主机输入从机输出线，也叫做DO(Data Input-对应从机输出))</li><li><strong>SS(Slave Select)</strong>：从机选择线，片选，也叫做NSS(Not Slave Select)、CS(Chip Select-片选)，有几个从机就用几条线。这样以后就不用像I2C那样先发送一个字节寻址、分配地址等操作</li></ol><p>注意：主机和从机不能同时配置为输入或输出</p><hr><p><strong>SPI没有应答位，SPI是不管你有没有收到信息的</strong></p><hr><p><code>SPI相对于I2C的优缺点：</code></p><ul><li><p><code>速度上：</code>SPI传输比I2C更快，SPI协议并没有严格规定最大传输速度，最大传输速度一般由芯片厂商的设计需求，如W25Q64存储器芯片，手册中写的是最大可达80MHz</p></li><li><p><code>设计上：</code>SPI设计比较简单粗暴，实现的功能没有I2C那么多，<strong>仅支持一主多从，不支持多主机</strong></p></li><li><p><code>开销上：</code>SPI的硬件开销比较大，通信线的个数比较多，通信过程中经常会有资源浪费的情况</p></li></ul></blockquote><h3 id="硬件电路-4">硬件电路</h3><p><img src="../assets/image-20250101165230579-1737529755591104.png" alt="image-20250101165230579"></p><blockquote><p>主机一般是STM32，从机一般是存储器、显示屏、通信 模块、传感器等，对应有几个从设备就有几个SS线</p><hr><p><code>SCK：</code>时钟线完全由主机掌控，对于主机来说时钟线为输出，对于从机来说时钟线为输入</p><p><code>MOSI：</code>主机输出从机输入，左边主机对应MO，主机输出，右边从机SI，从机输入。数据从MOSI输出，所有从机从MOSI输入</p><p><code>MISO：</code>主机输入从机输入，与MOSI类似</p><p><code>SS：</code>从机选择线，低电平有效，主机初始化后所有的SS都输出高电平，代表都不指定，需要与谁通信，就将对应的SS线拉低即可，当对应从机通信完之后，对应SS线就重新置回高电平。同一时间只能选择一个从机(只能置一个为低电平)</p><hr><p><strong>输出引脚配置为推挽输出</strong>：高低电平均有很强驱动能力，使得SPI信号引脚上升沿和下降沿信号非常迅速，不像I2C那样下降沿迅速上升沿缓慢，所以SPI信号变化的快所以SPI具有更快的传输速度，一般的SPI信号都能轻松达到Mhz的速度级别。</p><p><code>输出引脚为：SCK、MOSI、SS</code></p><p><strong>输入引脚配置为浮空或上拉输入</strong></p><p><code>输入引脚为：MISO</code></p><p><code>SPI可能存在的冲突</code>：</p><p>​对于SPI的从机MISO引脚，当某个从机的SS引脚被选择后，其他从机的SS引脚会被保持为高阻态，相当于断开不输出，这样可以防止一条线有多个输出而导致的电平冲突的问题</p></blockquote><h3 id="数据移位示意图">数据移位示意图</h3><p><img src="../assets/image-20250101173950632-1737529755591105.png" alt="image-20250101173950632"></p><blockquote><p><strong>SPI数据是高位先行，通信基础是<code>交换一个字节</code>，数据收发都是基于<code>字节交换</code>这个基本单元进行</strong>。主机要发送的数据跑到从机，从机要发送的数据跑到主机，这样就可以实现发送一个字节、接收一个字节、发送同时接收一个字节<code>三种功能</code></p><p><strong>对于只想接收数据时</strong>：我们会随便发送数据(一般统一为0x00或0xFF)，把数据置换过来即可</p><p><strong>对于只想发送数据时</strong>：只需要把数据发送过去，对方置换过来的数据不管即可</p><hr><p><strong>这里波特率发生器就是时钟</strong></p><p>主机移位寄存器左边出去的数据通过MOSI引脚，输入到从机移位寄存器的右边，从机移位寄存器左边移出去的数据通过MISO引脚，输入到主机移位寄存器的右边，形成一个环</p><p><strong>每当规定的时钟沿(上升沿/下降沿)到来时，对应移位寄存器的最高位分别移动，分别放到MOSI和MISO的通信线上，然后对应的时钟沿(上升沿或下降沿)再次到来时，数据分别从MOSI和MISO线上，采样到从机和主机的最低位。这样就完成了一个时钟</strong></p><p>例：规定上升沿数据移动，下降沿数据采集。就是在上升沿时移位寄存器的最高位到对应的线上。下降沿时，会采样输入到对应的最低位。</p><hr></blockquote><h3 id="SPI时序基本单元">SPI时序基本单元</h3><ul><li><code>起始条件和终止条件:</code></li></ul><p><img src="../assets/image-20250101174746261-1737529755591106.png" alt="image-20250101174746261"></p><blockquote><p>起始条件：SS由高到低，代表选中从机通信开始</p><p>结束条件：SS由低到高，代表结束选中从机通信结束</p><p>所以SS低电平期间就代表正在通信</p></blockquote><hr><p>​<strong>SPI中有两个可以配置的位，每一位可以配置为1或0，组合起来就有模式0、模式1、模式2、模式共四种模式，但功能实际都是一样的，任意选择一种使用即可。</strong></p><p><code>CPOL(Clock Polarity)：</code><strong>时钟极性</strong>，决定空闲时SCK的低电平，值为0或1</p><p><code>CPHA(Clock Phase)：</code><strong>时钟相位</strong>，决定第一个时钟采样移入还是第二时钟采样移入，并不是规定上升沿采样还是下降沿采样，值为0或1</p><hr><ul><li><code>模式0：使用最多重点掌握！！！</code></li></ul><p><img src="../assets/image-20250101175308487-1737529755591107.png" alt="image-20250101175308487"></p><blockquote><p>CPOL = 0：代表空闲状态SCK低电平</p><p>CPHA = 0：SCK<code>第一个</code>边沿<code>移入数据</code>，<code>第二个</code>边沿<code>移出数据</code>。</p><p><strong>由于数据需要先移出来，才能移入，所以SCK第一个边沿之前就要提前开始移出数据了。</strong></p><p>​这里把SS当作了时钟下降沿所以要移出数据，MOSI就提前移出数据，等SCK上升沿来到，两个数据B7分别移入到主机和从机。然后SCK到下降沿，两个B6数据就移出，上升沿的两个B6数据采样输入到主机和从机…一直到B0最后一位，SS拉高，MOSI任意，MISO高阻态，这样一个字节的交换就完成。</p><p><strong>如果想要交换多个字节，只需要在B0最后继续紧跟第二个字节的B7重复前述过程即可</strong></p><hr><p><strong>总结交换字节步骤</strong>：</p><ol><li>SS拉低后，主机和从机立刻移出数据(主机移出它的数据最高位放到MOSI上，从机移出它的最高位数据放到MISO上)。从机的事主机不管，所以我们直接写MOSI即可</li><li>SCK上升沿，主机和从机同时移入数据(从机会自动把这位数据读走)，主机只需要读入MISO的数据位即可</li><li>SCK下降沿，主机和从机同时移出次高位数据，开始循环8次，共1字节8bit</li></ol></blockquote><ul><li><code>模式1：与上方的移位过程相同</code></li></ul><p><img src="../assets/image-20250101180327881-1737529755591108.png" alt="image-20250101180327881"></p><blockquote><p><strong>模式1与模式0的区别：模式0把数据变化的实际提前了，而模式1没有</strong></p><hr><p>CPOL = 0：代表空闲状态SCK低电平</p><p>CPHA = 1：SCK<code>第一个</code>边沿<code>移出数据</code>，<code>第二个</code>边沿<code>移入数据</code>。</p><p>也能表述为：CPHA=1表示SCK的第二个边沿进行数据采样，或SCK的偶数边沿进行数据采样</p><p>MOSI为主机发送的B7，B6…，默认状态下没有规定高低电平(均可)</p><p>MISO为从机发送的B7，B6…，默认状态下应为高阻态</p></blockquote><ul><li><code>模式2：</code></li></ul><p><img src="../assets/image-20250101183828210-1737529755591109.png" alt="image-20250101183828210"></p><blockquote><p><strong>模式2与模式0区别：就把SCK极性取反即可</strong></p></blockquote><ul><li><code>模式3：</code></li></ul><p><img src="../assets/image-20250101183921953-1737529755592110.png" alt="image-20250101183921953"></p><blockquote><p><strong>模式1与模式3区别：就把SCK极性取反即可</strong></p></blockquote><h3 id="SPI时序">SPI时序</h3><p>​SPI对字节流功能的规定与I2C不同，I2C是有效数据流第一个字节是寄存器地址，之后依次是读写的数据，<strong>使用的是读写寄存器的模型</strong>。</p><p>​而在SPI中，通常<strong>采用指令码加读写数据的模型</strong>，即SPI第一个发送给从机的数据叫做指令码，在从机中对应的会定义一个指令集，只需要发送指令集中对应的数据即可指定想要完成的功能。</p><p>​不同的指令，可以有不同的数据个数，有的指令只需要一个字节的指令码就可以完成，比如：W25Q64的写使能失能等。而写数据时，包含指令码+在哪里写+写的数据</p><p>​       <code>对应的指令集都会在SPI从机芯片手册中可以找到！！！！</code></p><p><strong>时序举例</strong>：</p><ul><li><code>写使能</code></li></ul><p><img src="../assets/image-20250101184358794-1737529755592112.png" alt="image-20250101184358794"></p><p><img src="../assets/image-20250101185239046-1737529755592111.png" alt="image-20250101185239046"></p><blockquote><p>在W25Q64中0x06代表写使能。</p><p><strong>这里使用SPI模式0，SS拉低后，立马准备移出数据，这里数据第一个Bit为0，所以没有变化，SCK第一个上升沿采样移入数据，从机采样输入(MOSI)得到0，主机采样输入(MISO)得到1。然后第一个下降沿移除数据…一直到最后一位交换完成一个字节。SS置回高电平结束</strong></p><p><code>结果：</code>主机用收到从机的0xFF，即从机输出不使用(0xFF为默认值)，从机收到主机的0x06，就会进行写使能</p><p><strong>由于使用软件模拟时序有延时，所以图中的MOSI数据变化有些延迟，没有紧贴SCK的下降沿是正常的</strong></p></blockquote><ul><li><code>指定地址写一个/多个字节</code></li></ul><p><img src="../assets/image-20250101191437487-1737529755592114.png" alt="image-20250101191437487"></p><blockquote><p>由于W25Q64有8M的存储空间，一个字节的8位地址不够，所以这里的指定地址使用24位分成3个字节发送</p></blockquote><p><img src="../assets/image-20250101191742942-1737529755592113.png" alt="image-20250101191742942">`</p><blockquote><p><strong>在0x123456的地址下写入0x55数据</strong>：</p><p><code>指令码</code></p><p>第一个字节：主机先发送0x02指令代表写数据，收到从机数据为0xFF不使用</p><hr><p><code>指定地址</code></p><p>第二个字节：主机发送地址前8位(第23~16位)为0x12，收到从机数据0xFF</p><p>第三个字节：主机发送地址中8位(第15~8位)为0x34，收到从机数据0xFF</p><p>第四个字节：主机发送地址后8位(第7~0位)为0x56，收到从机数据0xFF</p><p><strong>从机收到的地址为0x123456</strong></p><hr><p><code>发送的数据</code></p><p>第五个字节：主机写入的数据0x55，收到从机数据0xFF</p><p>到这里便写入一个字节，没有应答位，一个接一个交换字节即可</p><hr><p><code>如果想指定地址，写入多个字节：</code></p><p>SPI中也有类似于I2C中的地址指针，每读写一个字节，地址指针自动+1，如果发送一个字节后不停止，继续发送的字节就会依次写入到后续的存储空间里，这样即实现多个字节写入</p></blockquote><ul><li><code>指定地址读一个/多个字节：</code></li></ul><p><img src="../assets/image-20250101193028026-1737529755592115.png" alt="image-20250101193028026"></p><p><img src="../assets/image-20250101193633764-1737529755592116.png" alt="image-20250101193633764"></p><blockquote><p><strong>和指定地址写时序差不多</strong></p><p>指令码：0x03</p><p>地址三个字节：0x123456</p><p>读取的数据：主机随便发送数据0xFF，交换数据后得到0x55。</p><p>这样就读取到了0x123456地址的数据为0x55</p><hr><p><code>实现读取指定地址的多个字节：</code></p><p>也是有地址指针，读取自动+1，实现连续读取即可</p><hr><p><strong>时序细节</strong>：</p><p>图中MISO是硬件控制波形，所以数据变化紧贴下降沿</p></blockquote><h3 id="W25Q64介绍">W25Q64介绍</h3><p><img src="../assets/image-20250101193816880-1737529755592117.png" alt="image-20250101193816880"></p><blockquote><p><code>容量：</code></p><p>该芯片存储为M级别，在手机可能很小，但是在嵌入式领域还是挺大的</p><p>还有的芯片是KB级别的，例如AT24C02芯片，使用的I2C通信的E2PROM芯片</p><hr><p><code>存储器分类：</code></p><p>分为非易失性存储器(FLASH、E2PROM)和易失性存储器(SRAM、DRAM)</p><p>该芯片是非易失性存储器，数据掉电不丢失，存储介质为Nor Flash</p><hr><p><code>通信协议：</code></p><p>使用SPI串行通信，SCK时钟线频率最大为80MHz，双重SPI模式等效频率为160Mhz，四重SPI模式等效的频率为320MHz</p><p>频率相对于stm32非常快</p><hr><p><code>应用：</code></p><p>数据存储：</p><p>字库存储：可以存放中文字库等，使用时读取数据后显示中文</p><hr><p><code>型号：</code></p><p><strong>芯片使用24位地址，3个字节</strong></p><p>2的24方 = 16MB，所以24位地址的最大寻址空间为16MB，所W25Q40~W25Q128都是够用的，但是W25Q256是32MB的存储不够用</p><p>W25Q256分为3字节地址模式和4字节地址模式，使用3字节模式下只能读写到前16MB地址，而要想读写所有的地址进入4字节地址模式即可</p><p>更换芯片型号，硬件电路和底层驱动程序都不用更改</p></blockquote><h4 id="硬件电路-5">硬件电路</h4><p><img src="../assets/image-20250101233710004-1737529755592118.png" alt="image-20250101233710004"></p><blockquote><p>该芯片的供电VCC接3.3V</p><hr><p>WP：写保护，低电平不允许写，高电平可以写</p><p>HOLD：数据保持，低电平有效</p><p>作用：在正常读写时突然产生中断，然后想用SPI通信线去操控其他器件，此时如果把CS置回高电平，那时序就会终止，但如果不想终止总线又想操作其他器件，此时就可以将HOLD引脚置低电平，芯片释放总线，芯片的时序也不会终止，会记住当前的状态，操作完后可以回来HOLD置高电平，继续之前的时序。</p><p>相当于SPI总线进了一次中断</p><p><strong>HOLD和WP如果想用就接到GPIO引脚上，如果不想用就直接接VCC即可</strong></p><hr><p>IO1 、IO2与双重SPI和四重SPI有关</p></blockquote><h4 id="框图">框图</h4><p><img src="../assets/image-20250102170255168-1737529755592120.png" alt="image-20250102170255168"></p><blockquote><p><code>几个基本概念：块、扇区、页:</code></p><p><code>块大小：</code>64KB</p><p><code>扇区大小：</code>4KB</p><p><code>页大小：</code>256B</p><p>8MB的地址空间从0x000000到0x7FFFFF</p><p><strong>右边</strong>：以64KB为一个基本单元块划分为若干个块Block  8MB/64KB = 128块(块0~127)</p><p><strong>左上</strong>：以4KB为一个基本单元再将每个Block划分为若干个单元，每个单元叫做Sector-扇区 64KB/4KB = 16个扇区(扇区0~15)</p><p>我们在写入数据时其实还有一个划分叫做页，是对扇区进行的一个更细的划分，一页为256字节 4KB/256 = 16页(0~15页)</p><hr><p><strong>左下角：芯片的控制逻辑</strong></p><p>芯片内部的地址锁存、数据读写等操作都由控制逻辑自动完成</p><p>控制逻辑的左边连接的是SPI的引脚</p><p>控制逻辑上方是状态寄存器，可以知道芯片是否处于忙状态、是否写使能等</p><p>状态寄存器上方是写控制逻辑与WP引脚连接，实现硬件写保护</p><p>内部集成了高电压发生器(High Voltage Generators)，用于实现掉电不丢失</p><hr><p><strong>最下方：字节地址锁存/计数器</strong></p><p>用于指定地址，SPI放过来3个字节的地址，前2个字节进到<strong>页地址锁存计数器</strong>，最后一个字节进入<strong>字节地址锁存计数器</strong>中</p><p>然后页地址锁存计数器通过写保护和行解码选择操作的哪一页</p><p>字节地址锁存计数器通过列解码和256字节页缓存来进行指定字节的读写操作</p><p>其中的计数器与地址指针自动+1有关</p><hr><p><strong>右下方：列解码和256Byte 页缓冲区</strong></p><p>实际上是个RAM缓冲区，写入数据时先放到这个RAM缓冲区，时序结束后，芯片对应状态BUSY会置1，芯片再将缓冲区的数据复制到对应的Flash中，此时不会响应新的写入</p><p><strong>缓冲区作用</strong>：SPI的写入频率是非常高的，而Flash的写入速度比较慢(掉电不丢失特性)，所以需要使用一个RAM页缓存区来存储写入的数据，从而可以跟得上SPI总线的速度。</p></blockquote><h4 id="Flash操作注意事项">Flash操作注意事项</h4><p><img src="../assets/image-20250102173909328-1737529755592119.png" alt="image-20250102173909328"></p><blockquote><p>第1条规定：直接使能即可</p><p>第2条规定：不擦除写入数据可能会与实际不符，实际值为(写入数据&amp;芯片内数据)</p><p><code>第3条规定：</code>是为了弥补第2条规定设立，保证每次写入数据不出错，由专门的擦除电路自动进行，我们只需要发送擦除的指令即可</p><p><code>一定要在每次写入前擦除数据!!!</code></p><p>第4条规定：擦除时只能选择整个芯片擦除、按块擦除、按扇区擦除，所以最小的擦除单元是一个扇区为4KB-4096字节。不能指定对某个字节擦除，如果想要擦除某一个字节，只能对该字节所在的扇区的4096个字节进行擦除</p><p>为了弥补这个缺点，我们需要在程序逻辑上进行一些优化：比如上电后先将Flash备份一份到RAM中</p><p>第5条规定：一次性不能写太多，一个写入时序最多写256字节(由缓冲区限制)</p><p>第6条规定：写入时序结束或者擦除芯片之后，芯片进入忙状态(BUSY位=1)，当状态寄存器BUSY位为0后才会继续响应</p><p>第7条规定：读取时序基本没有限制，唯一就是不能在忙状态时读取</p><hr><p>由于Flash掉电不丢失的特性，成本低，存储量大，所以在操作的便携性上不是很友好，以及速度不是很快。但在非易失性存储器中速度却是很快的。</p><p>与RAM想在哪些就在哪写，想写多少就写多少不同，且可以覆盖写入区别较大</p></blockquote><h4 id="芯片手册">芯片手册</h4><p>主要包含写保护配置表、状态寄存器、指令集，以及对每条指令的详细解释。还有芯片电器特性(供电电压范围等)</p><ul><li><code>状态寄存器:</code></li></ul><blockquote><p><img src="../assets/image-20250102191517893-1737529755592121.png" alt="image-20250102191517893"></p><p><code>BUSY位：</code></p><p>当设备执行页编程（Page Program）、扇区擦除（Sector Erase）、块擦除（Block Erase）、芯片擦除（Chip Erase）或写状态寄存器指令时会被设置为1。在该位为1时，表示设备正在忙碌，不会响应其他指令，除了读取状态寄存器和进入/擦除挂起操作的指令。程序、擦除或写状态寄存器操作完成后，“BUSY”位会清零，表明设备已准备好接收新的指令。</p><p><code>WEL位(写使能锁存位)：</code></p><p>WEL 是一个状态寄存器（Status Register）中的位，仅在执行了 Write Enable 指令后被设置为。在数据写入完成后，该位会被清零以禁用写操作。 当电源关闭或者执行以下任一指令时，WEL也会被禁用：Write Disable、Page Program(页编程)、Sector Erase（扇区擦除）、Block Erase（块擦除）、Chip Erase(芯片擦除) 和 <strong>Write Status Register(写入数据后会自动进行写使能)。</strong></p><p>例子说明： 假设你有一块闪存芯片，在你想要向其写入数据之前，必须先发送 Write Enable 指令来激活WEL位。只有当这个位是激活状态（即值为1），才能对芯片进行编程或擦除操作。一旦这些操作完成或者直接通过发送特定指令显式地禁用它（比如Write Disable），WEL会回到未激活状态（即值为0），从而防止意外改变数据。</p><p><code>注意：一条写指令只能保证后续的一条写指令可以执行，所以每次写入都要进行写使能</code></p><hr><p><code>其他的位请自行查看手册！！</code></p></blockquote><ul><li><code>指令集(Instruction):</code></li></ul><blockquote><p><img src="../assets/image-20250102193355258-1737529755592122.png" alt="image-20250102193355258"></p><p>厂商ID是：0xEF</p><p>设备ID：</p><p>0x16 (如果使用0xAB和0x90来读)</p><p>0x4017 (使用0x9F来读)</p><hr><p><img src="../assets/image-20250102193817312-1737529755592123.png" alt="image-20250102193817312"></p><p><code>Write Enable：</code>写使能，发送0x06</p><p><code>Write Disable：</code>写失能，发送0x04</p><hr><p><code>Read Status Register-1：</code>读取状态寄存器第1位，发送0x05，用于查看忙状态，S0是BUSY位，S1是WEL位</p><hr><p><code>Page Program：</code>页编程就是写数据，发送0x02，然后继续发送地址23-16位，15-8位，7-0位三个字节，然后发送写入的数据</p><p><strong>注意：该芯片不能跨页写入，在执行跨页写入时，多出来的数据会从页首的地方覆盖写入，一页为256B对应16进制为0x000000~0x0000FF。</strong></p><p><strong>若确实需要跨页写入，需要连续写入很大的数组，只能从软件上进行分批次写入，先计算数组要跨多少也，擦除对应区域,最后分批次一页一页写，最后封装成一个函数</strong></p><hr><p><code>Block Erase：</code>块擦除，包括按64KB的块擦除、32KB的块擦除、4KB的扇区擦除。发送0xD8/0x62，再发送三个字节的地址即可</p><p><code>Sector Erase：</code>扇区擦除，包括4KB的扇区擦除。发送0x20，再发送三个字节的地址即可，对应一个扇区为0x000000~0x000FFF</p><p><code>Chip Erase：</code>发送0xC7或0x60h即可</p><hr><p><code>JEDEC ID：</code>读取ID指令，发送0x9F，然后连续交换三个字节数据，得到的第一个字节是厂商ID，后两个字节是设备ID</p></blockquote><blockquote><p><img src="../assets/image-20250102195113035-1737529755592124.png" alt="image-20250102195113035"></p><p><code>Read Data：</code>读取数据，发送0x03，之后交换发送3个字节地址，接下来读取的就是该地址下的数据</p></blockquote><ul><li><code>执行所用时间：</code></li></ul><blockquote><p><img src="../assets/image-20250102200118784-1737529755592125.png" alt="image-20250102200118784"></p><p>页编程以及各种擦除所用时间，基本都是ms级别</p></blockquote><ul><li><code>dummy数据：</code></li></ul><blockquote><p><img src="../assets/image-20250104225524682-1737529755592126.png" alt="image-20250104225524682"></p><p><strong>手册中可以看到发送的数据为dummy，这个dummy就代表无用数据，发送0xFF即可此时发送和接收的数据都没有意义。</strong></p><p><strong>作用：可能是做一些延时</strong></p></blockquote><h3 id="软件SPI读写W25Q64">软件SPI读写W25Q64</h3><h4 id="软件SPI底层代码">软件SPI底层代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MySPI.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSPI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSPI_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//void MySPI_W_SS(uint8_t BitVal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void MySPI_W_SCK(uint8_t BitVal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void MySPI_W_MOSI(uint8_t BitVal);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//uint8_t MySPI_W_MISO()；</span></span><br><span class="line"><span class="comment">/*上面四个函数只有MySPI.c中会使用，所以我们不用放在头文件中，保持模块的独立，封装！！！！！！*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写SS</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SS</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写SCK</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SCK</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_5,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写MOSI</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_MOSI</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_7,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读MISO</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_R_MISO</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_6);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*由于SPI速度很快，操作引脚后就不用加延时了*/</span></span><br><span class="line"><span class="comment">/*上面这样单独对写入引脚的封装，有利于单片机移植或者添加延时*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//1.开启对应引脚RCC</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//2.配置GPIO</span></span><br><span class="line">  <span class="comment">/*三个推挽输出引脚*/</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*一个上拉/浮空输入引脚*/</span></span><br><span class="line">  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.配置默认电平：初始化SS引脚为高电平，由于使用模式0，所以初始化SCK引脚为低电平</span></span><br><span class="line">  MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI起始条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_W_SS(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI终止条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI字节交换,由于是交换1字节，所以需要有返回值得到从机发送的1字节</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> ByteReceive = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*1.依次1位，1位操作*/</span></span><br><span class="line"><span class="comment">//MySPI_W_MOSI(ByteSend &amp;= 0x80); //移出第一位数据</span></span><br><span class="line"><span class="comment">//  MySPI_W_SCK(1);</span></span><br><span class="line"><span class="comment">//if(MySPI_W_MISO() == 1)  //接收从机发送的第一位数据(最高位)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//ByteReceive |= 0x80;   </span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//MySPI_W_SCK(0);</span></span><br><span class="line"><span class="comment">///*一个时序的结束*/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//MySPI_W_MOSI(ByteSend &amp;= 0x40);//移出第二位数据</span></span><br><span class="line"><span class="comment">//MySPI_W_SCK(1);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//if(MySPI_W_MISO() == 1)  //接收从机发送的第二位数据(次高位)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//ByteReceive |= 0x40;   </span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//.....一位一位发送，可以简化为循环</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*2.通过掩码，依次挑出每一位进行操作*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">MySPI_W_MOSI(ByteSend &amp; (<span class="number">0x80</span> &gt;&gt; i)); <span class="comment">//移出第i位数据，每次只发送了1bit</span></span><br><span class="line">MySPI_W_SCK(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(MySPI_R_MISO() == <span class="number">1</span>)  <span class="comment">//接收从机发送的第i位数据(i=0时为最高位)，每次只接收了1bit</span></span><br><span class="line">&#123;</span><br><span class="line">ByteReceive |= (<span class="number">0x80</span> &gt;&gt; i);   </span><br><span class="line">&#125;</span><br><span class="line">MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3.通过SPI中主机和从机移位寄存器交换字节的方式，更加契合SPI的移位模型讲解*/</span></span><br><span class="line"><span class="comment">//for(int i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//MySPI_W_MOSI(ByteSend &amp;= 0x80); //移出第i位数据，每次只发送了1bit</span></span><br><span class="line"><span class="comment">//ByteSend &lt;&lt;= 1 ; //最高位发送后，左移1位后最低位为0，空出最低为</span></span><br><span class="line"><span class="comment">//MySPI_W_SCK(1);</span></span><br><span class="line"><span class="comment">//if(MySPI_W_MISO() == 1)  //接收从机发送的第i位数据(i=0时为最高位)，每次只接收了1bit</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//ByteSend |= 0x01; //主机发送数据的移位寄存器最后1bit置为从机移位发送的1bit</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//MySPI_W_SCK(0);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">////最终得到的ByteSend就是移位交换后的数据，就可以不用定义ByteReceive,提高效率</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ByteReceive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面演示的是SPI模式0的时序，如果需要修改模式，只需要对照时序图进行修改即可</p><p>比如修改为模式1，对照模式1的时序图只需要将for循环中的前两行代码交换顺序即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">         MySPI_W_SCK(<span class="number">1</span>);</span><br><span class="line">         <span class="comment">/*这两行*/</span></span><br><span class="line">MySPI_W_MOSI(ByteSend &amp;= (<span class="number">0x80</span> &gt;&gt; i)); </span><br><span class="line"><span class="keyword">if</span>(MySPI_W_MISO() == <span class="number">1</span>)  </span><br><span class="line">&#123;</span><br><span class="line">ByteReceive |= (<span class="number">0x80</span> &gt;&gt; i);   </span><br><span class="line">&#125;</span><br><span class="line">MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>这里的模式0和模式1的时钟极性相同，如果改为模式2或模式3时，只需要将所有出现SCK的地方电平全部翻转一下即可</code></p></blockquote><h4 id="W25Q64测试代码">W25Q64测试代码</h4><p><code>由于指令码直接书写不太美观，也不够清楚，所以我们可以对指令集进行宏定义。新建一个头文件，单独存放指令集的宏定义！！！</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64_Ins*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q64_INS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q64_INS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据W25Q64的手册将所有的指令码抄过来*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_ENABLE0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_DISABLE0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_STATUS_REGISTER_10x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_STATUS_REGISTER_20x35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_STATUS_REGISTER0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_PAGE_PROGRAM0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_QUAD_PAGE_PROGRAM0x32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_BLOCK_ERASE_64KB0xD8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_BLOCK_ERASE_32KB0x52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_SECTOR_ERASE_4KB0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_CHIP_ERASE0xC7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_ERASE_SUSPEND0x75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_ERASE_RESUME0x7A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_POWER_DOWN0xB9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_HIGH_PERFORMANCE_MODE0xA3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_CONTINUOUS_READ_MODE_RESET0xFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_RELEASE_POWER_DOWN_HPM_DEVICE_ID0xAB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_MANUFACTURER_DEVICE_ID0x90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_UNIQUE_ID0x4B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_JEDEC_ID0x9F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_DATA0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ0x0B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_DUAL_OUTPUT0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_DUAL_IO0xBB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_QUAD_OUTPUT0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_QUAD_IO0xEB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_OCTAL_WORD_READ_QUAD_IO0xE3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_DUMMY_BYTE0xFF</span></span><br><span class="line"><span class="comment">//用于表示接受时交换过去的无用数据</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q64_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q64_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySPI.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  MySPI_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看芯片手册对应指令集编写时序*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span></span><br><span class="line">&#123;</span><br><span class="line">  MySPI_Start();</span><br><span class="line"></span><br><span class="line">MySPI_SwapByte(<span class="number">0x9F</span>);<span class="comment">//发送读取厂商ID和设备ID的指令码</span></span><br><span class="line"></span><br><span class="line">*mId = MySPI_SwapByte(<span class="number">0xFF</span>);<span class="comment">//交换数据得到从机返回的第一个字节厂商ID，主机随便发送什么默认0xFF</span></span><br><span class="line"></span><br><span class="line">*dId = MySPI_SwapByte(<span class="number">0xFF</span>);<span class="comment">//交换数据得到从机返回的第二个字节设备ID(前8bit为存储器类型，后8bit为存储器大小)，主机随便发送什么默认0xFF</span></span><br><span class="line">*dId &lt;&lt;= <span class="number">8</span>; <span class="comment">//设置16bit高8位</span></span><br><span class="line"></span><br><span class="line">*dId |= MySPI_SwapByte(<span class="number">0xFF</span>);<span class="comment">//设置16bit低8位，不能直接等于，否则高八位会被置0</span></span><br><span class="line"></span><br><span class="line">  MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>测试代码：先使用该读取ID的代码测试是否能使用SPI</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c业务代码*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> mid=<span class="number">0x00</span>;</span><br><span class="line"><span class="type">uint16_t</span> did=<span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">  UsartInit();</span><br><span class="line"></span><br><span class="line">W25Q64_Init();</span><br><span class="line"></span><br><span class="line">W25Q64_ReadID(&amp;mid,&amp;did);</span><br><span class="line">  UsartSendNum(mid,<span class="number">2</span>);</span><br><span class="line">  UsartSendNum(did,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们读取的指令码为0x9F，对应手册上收到的应该是</p><p>厂商ID：0xEF</p><p>设备ID：0x4017</p><p>将OLED上显示或者串口发送的结果对比发现正确</p></blockquote><h4 id="W25Q64完整代码">W25Q64完整代码</h4><blockquote><p><strong>由于每次操作需要我们判断是否芯片是否处于BUSY，所有我们可以在每次写操作的时候进行等待BUSY位。等待分为事前等待和事后等待</strong></p><p><code>事前等待</code>：在写操作开始前调用W25Q64_WaitBusy等待BUSY位置0</p><p><code>事后等待</code>：在写操作结束后需要调用W25Q64_WaitBusy</p><p><strong>两者区别：</strong></p><ol><li><p><strong>事后等待比事前等待更保险，事后等待可以保证在进行写操作之外的地方芯片肯定不处于BUSY状态，保证安全。</strong></p></li><li><p><strong>事前等待效率比事后等待效率高，可以在执行完写操作后执行其他代码，刚好可以利用这段代码来消耗等待时间</strong></p></li><li><p><strong>事前等待需要在读取和写入前都要调用。因为读的时候也需要在BUSY位不为1的时候。而事后等待只需要在写入后调用</strong></p></li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q64_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q64_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_PageProgram</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint16_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_SectorErase</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadData</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint32_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//void W25Q64_WriteEnble();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void W25Q64_WaitBusy();</span></span><br><span class="line"><span class="comment">/*这两个函数为了模块化，不用外部调用了*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*W25Q64.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySPI.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64_Ins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  MySPI_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看芯片手册对应指令集编写时序！！！*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span>* mId,<span class="type">uint16_t</span>* dId)</span></span><br><span class="line">&#123;</span><br><span class="line">  MySPI_Start();</span><br><span class="line"></span><br><span class="line">MySPI_SwapByte(W25Q64_JEDEC_ID);<span class="comment">//发送读取厂商ID和设备ID的指令码</span></span><br><span class="line"></span><br><span class="line">*mId = MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//交换数据得到从机返回的第一个字节厂商ID，主机随便发送什么默认0xFF</span></span><br><span class="line"></span><br><span class="line">*dId = MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//交换数据得到从机返回的第二个字节设备ID(前8bit为存储器类型，后8bit为存储器大小)，主机随便发送什么默认0xFF</span></span><br><span class="line">*dId &lt;&lt;= <span class="number">8</span>; <span class="comment">//设置16bit高8位</span></span><br><span class="line"></span><br><span class="line">*dId |= MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//设置16bit低8位，不能直接等于，否则高八位会被置0</span></span><br><span class="line"></span><br><span class="line">  MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次写之前都要写使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WriteEnble</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_Start();</span><br><span class="line"></span><br><span class="line">MySPI_SwapByte(W25Q64_WRITE_ENABLE);</span><br><span class="line"></span><br><span class="line">MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待状态寄存器BUSY位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WaitBusy</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> Timeout=<span class="number">100000</span>;</span><br><span class="line">MySPI_Start();</span><br><span class="line"></span><br><span class="line">MySPI_SwapByte(W25Q64_READ_STATUS_REGISTER_1);</span><br><span class="line"><span class="keyword">while</span>((MySPI_SwapByte(W25Q64_DUMMY_BYTE) &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>) <span class="comment">//状态寄存器有8位，最低位代表BUSY位，读取判断BUSY位若为1就一直等待</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*状态寄存器可以被连续读取，如果不停止就会一直发送状态寄存器当前的值*/</span></span><br><span class="line">Timeout--;</span><br><span class="line"><span class="keyword">if</span>(Timeout == <span class="number">0</span>)<span class="comment">//超时退出避免程序卡死</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页编程，也就是写入数据到W25Q64。需要先写使能！！</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_PageProgram</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint16_t</span> count)</span><span class="comment">//读取最大值count为256，所以要定义为uint16，uint8=255</span></span><br><span class="line">&#123;</span><br><span class="line">W25Q64_WriteEnble();<span class="comment">//每次写入数据前都要进行写使能！！！，在这里可以方便我们避免每次都要手动写使能</span></span><br><span class="line">MySPI_Start();</span><br><span class="line">MySPI_SwapByte(W25Q64_PAGE_PROGRAM);</span><br><span class="line">  MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);<span class="comment">//取高8位</span></span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>); <span class="comment">//取中8位该函数只会发送8bit数据，高位会舍弃</span></span><br><span class="line">MySPI_SwapByte(Address);<span class="comment">//取低8位发送</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">&#123;</span><br><span class="line">MySPI_SwapByte(DataArray[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySPI_Stop();</span><br><span class="line"></span><br><span class="line">W25Q64_WaitBusy();<span class="comment">//写操作进行事后等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扇区擦除，其他擦除同理,Address为指定擦拭的4个字节，也就是1个扇区。需要先写使能！！</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_SectorErase</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">  W25Q64_WriteEnble(); <span class="comment">//每次写入数据前都要进行写使能！！！，在这里可以方便我们避免每次都要手动写使能</span></span><br><span class="line">MySPI_Start();</span><br><span class="line">MySPI_SwapByte(W25Q64_SECTOR_ERASE_4KB);</span><br><span class="line">  MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);<span class="comment">//取高8位</span></span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>); <span class="comment">//取中8位该函数只会发送8bit数据，高位会舍弃</span></span><br><span class="line">MySPI_SwapByte(Address);<span class="comment">//取低8位发送</span></span><br><span class="line">MySPI_Stop();</span><br><span class="line"></span><br><span class="line">W25Q64_WaitBusy();<span class="comment">//写操作进行事后等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadData</span><span class="params">(<span class="type">uint32_t</span> Address,<span class="type">uint8_t</span>* DataArray,<span class="type">uint32_t</span> count)</span><span class="comment">//读取时数量没有限制</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_Start();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//1.发送读取数据指令码</span></span><br><span class="line">MySPI_SwapByte(W25Q64_READ_DATA);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//2.发送读取的24位地址</span></span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);<span class="comment">//取高8位</span></span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>); <span class="comment">//取中8位该函数只会发送8bit数据，高位会舍弃</span></span><br><span class="line">MySPI_SwapByte(Address);<span class="comment">//取低8位发送</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//3.置换得到数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">&#123;</span><br><span class="line">DataArray[i]= MySPI_SwapByte(W25Q64_DUMMY_BYTE);<span class="comment">//发送0xFF将数据置换过来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> mid=<span class="number">0x00</span>;</span><br><span class="line"><span class="type">uint16_t</span> did=<span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> ArrayWrite[] = &#123;<span class="number">0xA1</span>,<span class="number">0xB2</span>,<span class="number">0xC3</span>,<span class="number">0xD4</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> ArrayRead[<span class="number">4</span>]; </span><br><span class="line"></span><br><span class="line">W25Q64_Init();</span><br><span class="line">  </span><br><span class="line">W25Q64_ReadID(&amp;mid,&amp;did);</span><br><span class="line">   </span><br><span class="line">W25Q64_SectorErase(<span class="number">0x000000</span>);<span class="comment">//指定擦除扇区起始地址，后3位代表一个扇区内地址，6位代表块地址</span></span><br><span class="line">W25Q64_PageProgram(<span class="number">0x000000</span>,ArrayWrite,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">W25Q64_ReadData(<span class="number">0x000000</span>,ArrayRead,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(2,3,ArrayWrite[0],2);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="comment">//OLED_ShowHexNum(3,3,ArrayRead[0],2);</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>1.每次写入数据前要先写使能!!!</code></p><p><code>2.每次写入前一定要记得擦除!!!</code></p><p><strong>最终OLED上显示发送和读取的数据相同，断电后不写入直接读取数据也不变</strong></p></blockquote><h3 id="硬件SPI外设-硬件读写">硬件SPI外设(硬件读写)</h3><p><img src="../assets/image-20250105141343897-1737529755592127.png" alt="image-20250105141343897"></p><blockquote><p>SPI最常用配置就是8位数据帧，高位先行。16位和低位先行用的很少</p><hr><p><code>时钟频率：</code><strong>SPI的时钟由PCLK(外设时钟)分频得来</strong>，可以2~256分频，时钟频率越快，对应传输速率越快。</p><p>频率不能任意指定，也就是说SPI的时钟频率只能是对面8种分频后对应的时钟频率，且对于SPI1和SPI2来说，PCLK也不相同，SPI1挂载在APB2，PCLK是72MHz，SPI2挂载在APB1，PCLK是36MHz</p><hr><p><code>多主机模型：</code>使用较少，可以看手册学习</p><p><code>主机或从机：</code>通常作为主机</p><hr><p><code>精简为半双工/单工通信：</code></p><p>可以节省一条数据线，半双工或单工通信。一般不适用</p><hr><p><code>DMA:</code>大量数据传输时使用</p><hr><p><code>兼容I2S协议：</code>数字音频传输专用协议，与SPI有一些共同特征</p><hr><p><code>以上所有内容都可以查看参考手册进行学习！！！</code></p></blockquote><h4 id="SPI框图">SPI框图</h4><p><img src="../assets/image-20250108114540986-1737529755592128.png" alt="image-20250108114540986"></p><blockquote><p>与对应寄存器描述结合理解</p><hr><p><code>左上角：</code>通过LSBFIRST控制位控制低位先行还是高位先行，移位寄存器通过MOSI和MISO，分别移动和接收一位位数据。SPI发送和接收可以同时进行</p><p>接收缓冲区：就是RDR寄存器</p><p>发送缓冲区：就是TDR寄存器</p><p>TDR和RDR占用同一个地址，统一叫作DR，写入经过RDR，发送数据经过TDR，对应也是TXE(发送寄存器空)和RXNE(接收寄存器非空)两个标志位</p><p><strong>移位寄存器配合数据寄存器实现连续数据流</strong>：</p><p>发送数据先写入TDR，再转到移位寄存器发送，发送的同时接收数据，接收的同时转到RDR，我们再从RDR读取数据</p><hr><p><code>左下角：</code></p><p>波特率发生器：内部有一个分频器，输入时钟为PCLK，72M或36M，经过分频器后输出到SCK，生成时钟与移位寄存器同步</p><hr><p><code>右下角:</code></p><p>LSBFIRST：用于控制高位先行还是低位先行</p><p>SPE：SPI使能位</p><p>BR2，BR1，BR0：用于控制分频系数</p><p>MSTR：配置主从模式</p><p>CPOL和CPHA：选择SPI四种模式</p><hr><p><code>右上角：</code></p><p>一些使能位与控制位，重要的是TXE和RXNE</p><hr><p><code>NSS引脚：</code>与多主机有关</p></blockquote><p><code>SPI外设基本结构:</code></p><p><img src="../assets/image-20250108122752353-1737529755592129.png" alt="image-20250108122752353"></p><blockquote><p><strong>TDR整体转入移位寄存器的时刻，置TXE标志位为1</strong></p><p><strong>移位寄存器数据整体转入RDR的时刻，置RXNE标志位为1</strong></p><hr><p><strong>图中没画出SS引脚，我们使用普通的GPIO口来模拟</strong></p></blockquote><h4 id="主模式全双工连续传输">主模式全双工连续传输</h4><p><img src="../assets/image-20250108172721631-1737529755592130.png" alt="image-20250108172721631"></p><blockquote><p>这里演示的是模式3，低位先行的模式：</p><p><strong>首先等待TXE=1后就软件写入数据到SPI_DR(TDR)，TXE也就变为0，转入完成后，立马将数据再移动到移位寄存器，转入到移位寄存器瞬间把TXE置为1，表示发送寄存器空，波形产生开始传输，但此时又要立马把下个数据写入到TDR中</strong></p><hr><p>流程简述下来就是：</p><p>发送数据1、发送数据2-- 接收数据1 --发送数据3 – 接收数据2 - 发送数据4 – 接收数据3</p><p>数据交换的流程是交叉的，要求很严格，对程序设计不太友好</p><p><strong>如果对效率要求很高，就可以研究这个</strong></p></blockquote><h4 id="非连续传输">非连续传输</h4><p><img src="../assets/image-20250108174720946-1737529755592131.png" alt="image-20250108174720946"></p><blockquote><p>这里演示的是模式3，低位先行的模式：</p><p><strong>接收时序与发送时序是同步的，具体见连续传输的图，因为是主机和从机交换字节发送所以发送的同时也在接收。但是必须先发送才会产生时序，然后才会有接收！！！</strong></p><p>首先等待TXE=1后就软件写入数据到SPI_DR(TDR)，TXE也就变为0，转入完成后，立马将数据再移动到移位寄存器，转入到移位寄存器瞬间把TXE置为1，表示发送寄存器空，一旦移位寄存器有数据了，<strong>时序波形会自动产生</strong>，开始交换数据</p><p><strong>此时不立马将下个数据写入TDR，而是等待第一个字节时序结束，意味着接收第一个字节也结束了，RXNE置1，先把第一个接收到的数据读出来，之后再写入数据2</strong></p><p><strong>流程即：四行代码完成任务</strong></p><p>第1步：等待TXE为1</p><p>第2步：写入发送的数据至TDR</p><p>第3步：等待RXNE为1</p><p>第4步：读取RDR接收的数据</p><p>然后重复第2、3、…字节</p><p>所以我们只需要将这四步封装到一个函数中就可以实现字节的交换，与软件SPI的流程基本上是一样的。</p><hr><p><code>非连续与连续传输的区别：</code>没有及时将数据送入TDR寄存器，等到第一个字节时序完成后，第二个字节还没有送过来，数据传输就会等候，所以时钟和数据的时序在字节与字节之间产生了间隙，拖慢了整体数据传输的速度。</p><p><img src="../assets/image-20250108175801926-1737529755592132.png" alt="image-20250108175801926"></p><p>间隙在SCK频率低时影响不大，但在非常高时就非常严重</p><p>频率在2分频下的波形：</p><p><img src="../assets/image-20250108181920148-1737529755592134.png" alt="image-20250108181920148"></p><p>可以看到等待时间都远大于数据交换时间了</p><p><code>所以我们要在想在极限频率下，进一步提高数据传输速率，我们需要使用连续传输模式，或者使用DMA</code></p></blockquote><h4 id="TXE和RXNE标志位清除问题">TXE和RXNE标志位清除问题</h4><p><img src="../assets/image-20250108211408772-1737529755592133.png" alt="image-20250108211408772"></p><blockquote><p><strong>手册上的描述，TXE和RXNE会在写入DR和读DR的时候由硬件清除</strong></p><p><strong>所以我们不需要手动调用ClearFlag清除标志位</strong></p></blockquote><h4 id="连续和非连续的优缺点">连续和非连续的优缺点</h4><blockquote><p><code>非连续传输：</code></p><p>好处：容易封装，好理解，好用</p><p>缺点：会损失一点点性能</p><hr><p><code>连续传输:对传输效率有要求的话可以使用</code></p><p>好处：传输更快</p><p>缺点：操作起来相对复杂，对软件的需求较高，每个标志位产生后数据都要及时处理</p></blockquote><h4 id="软件硬件波形对比">软件硬件波形对比</h4><p><img src="../assets/image-20250108182601125-1737529755592136.png" alt="image-20250108182601125"></p><blockquote><p><code>区别：</code></p><p>下降沿和低电平期间，都可以作为数据变化的时刻，只是硬件波形一般会紧贴边沿，软件波形，一般只能在电平期间，无论哪种方式都不会影响数据传输。</p><p>对于软件波形，尽量要贴近边沿，否则等待太久贴近下一个边沿了数据也会容易出错</p></blockquote><h4 id="SPI库函数">SPI库函数</h4><p><strong>标准库函数中包含的SPI很多名称中带有I2S相关的函数，因为I2S与SPI共用一套电路。直接使用即可</strong></p><ul><li><code>初始化：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_DeInit</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2S_Init</span><span class="params">(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2S_StructInit</span><span class="params">(I2S_InitTypeDef* I2S_InitStruct)</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_Init</span><span class="params">(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_StructInit</span><span class="params">(SPI_InitTypeDef* SPI_InitStruct)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>外设使能：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_Cmd</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2S_Cmd</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>中断配置：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_ITConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_I2S_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>DMA：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_DMACmd</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_I2S_DMAReq, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>发送和接收数据：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_SendData</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="comment">//数据到DR</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_I2S_ReceiveData</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br><span class="line"><span class="comment">//从DR读数据</span></span><br></pre></td></tr></table></figure><hr><p><code>不常用函数：</code></p><ul><li><code>NSS引脚配置：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_NSSInternalSoftwareConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_NSSInternalSoft)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_SSOutputCmd</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>数据帧位数配置：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_DataSizeConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_DataSize)</span>;</span><br><span class="line"><span class="comment">//8位或16为数据帧配置</span></span><br></pre></td></tr></table></figure><ul><li><code>CRC校验配置：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_TransmitCRC</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_CalculateCRC</span><span class="params">(SPI_TypeDef* SPIx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_GetCRC</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_CRC)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI_GetCRCPolynomial</span><span class="params">(SPI_TypeDef* SPIx)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>半双工时双向线的方向配置：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_BiDirectionalLineConfig</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_Direction)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>标志位：</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FlagStatus <span class="title function_">SPI_I2S_GetFlagStatus</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_I2S_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_ClearFlag</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint16_t</span> SPI_I2S_FLAG)</span>;</span><br><span class="line">ITStatus <span class="title function_">SPI_I2S_GetITStatus</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_I2S_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI_I2S_ClearITPendingBit</span><span class="params">(SPI_TypeDef* SPIx, <span class="type">uint8_t</span> SPI_I2S_IT)</span>;</span><br></pre></td></tr></table></figure><h4 id="硬件SPI初始化流程">硬件SPI初始化流程</h4><blockquote><p>根据SPI框图：</p><ol><li>开启RCC对应SPI和GPIO口的时钟</li><li>初始化GPIO口，SCK和MOSI是硬件控制输出的信号，配置为<strong>复用推挽输出</strong>。MISO是，是硬件外设配置的输入信号，配置为<strong>上拉输入</strong>。还有一个SS引脚，使用软件模拟控制的输出信号，配置为<strong>通用推挽输出</strong>即可</li><li>配置SPI外设，调用SPI_Init配置各参数即可</li><li>使能，开关控制，调用SPI_Cmd即可</li><li>默认SS为高电平，不使用从机</li></ol></blockquote><h4 id="硬件SPI读写W25Q64">硬件SPI读写W25Q64</h4><blockquote><p>对于W25Q64Q驱动层的代码我们不需要修改，我们只需要修改底层SPI代码即可</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MySPI.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSPI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSPI_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MySPI.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写SS</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SS</span><span class="params">(<span class="type">uint8_t</span> BitVal)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_4,(BitAction)BitVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//1.开启对应引脚RCC</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.配置GPIO</span></span><br><span class="line"><span class="comment">/*SCK和MOSI复用推挽输出引脚*/</span></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_7;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*使用软件模拟SS，SS通用推挽输出引脚*/</span>  </span><br><span class="line">  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_4;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">  GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*MISO上拉输入引脚*/</span></span><br><span class="line">  GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">  GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">  GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//3.配置SPI</span></span><br><span class="line">  SPI_InitTypeDef SPI_InitStruct;</span><br><span class="line">  SPI_InitStruct.SPI_Mode = SPI_Mode_Master;<span class="comment">//选择主机</span></span><br><span class="line">  SPI_InitStruct.SPI_Direction = SPI_Direction_2Lines_FullDuplex;<span class="comment">//选择全双工</span></span><br><span class="line">  SPI_InitStruct.SPI_DataSize = SPI_DataSize_8b;</span><br><span class="line">  SPI_InitStruct.SPI_FirstBit = SPI_FirstBit_MSB;<span class="comment">//8位先行</span></span><br><span class="line">  SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;<span class="comment">//频率为72Mhz/128 = 500多khz</span></span><br><span class="line">  SPI_InitStruct.SPI_CPHA = SPI_CPHA_1Edge;</span><br><span class="line">  SPI_InitStruct.SPI_CPOL = SPI_CPOL_Low;</span><br><span class="line">  SPI_InitStruct.SPI_NSS = SPI_NSS_Soft;<span class="comment">//我们使用的GPIO引脚模拟，使用软件NSS</span></span><br><span class="line">  SPI_InitStruct.SPI_CRCPolynomial = <span class="number">7</span>;<span class="comment">//我们不使用CRC校验，只需要随便给个值即可</span></span><br><span class="line">  SPI_Init(SPI1,&amp;SPI_InitStruct);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.使能</span></span><br><span class="line">  SPI_Cmd(SPI1,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.默认不选中从机</span></span><br><span class="line">  MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI起始条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_W_SS(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI终止条件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SPI字节交换，硬件自动控制SCK、MOSI、MISO引脚</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="comment">/*对应非连续传输的四个步骤*/</span></span><br><span class="line"><span class="comment">//1.等待TXE为1，代表发送数据寄存器为空，可以写入数据了</span></span><br><span class="line"><span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) != SET)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写入发送数据到TDR(发送数据寄存器)，同时自动清除TXE</span></span><br><span class="line">SPI_I2S_SendData(SPI1,ByteSend);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.等待RXNE为1，接收数据寄存器非空，代表接收完成</span></span><br><span class="line"><span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE) != SET)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.从RDR(接收数据寄存器)读取接收到的数据，同时自动清除RXNE</span></span><br><span class="line"><span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>RTC</h1><h2 id="常识">常识</h2><h3 id="Unix时间戳">Unix时间戳</h3><p><img src="../assets/image-20250109131815285-1737529755592135.png" alt="image-20250109131815285"></p><blockquote><p><code>时间戳：</code>1970年1月1日0时0分0秒开始所经过的秒数，没有进位，不同时区通过对秒计数器添加偏移就可以得到当地时间</p><p>计算机底层使用时间戳会很方便，只需要一个很大的寄存器存储秒数即可</p><p>给人类观看的时候，只需要将时间戳转换为对应的日期即可</p><p>但是，时间戳比较占用软件资源，在每次进行秒计数器和日期时间转换时，软件都需要经过比较复杂的运算</p></blockquote><h3 id="RTC-GMT">RTC/GMT</h3><p><img src="../assets/image-20250109133115489-1737529755593137.png" alt="image-20250109133115489"></p><blockquote><p><code>闰秒：</code>由于地球自转会越转越慢，地球自转一周的时间会变化，当地球自转一周的时间与原子钟计时一天的时间相差超过0.9s时，UTC就会执行闰秒操作，即多走1s来等等地球，1分钟可能会出现61s。、</p><p>现在世界使用的就是UTC</p></blockquote><h3 id="时间戳转换">时间戳转换</h3><p><img src="../assets/image-20250109134112560-1737529755593138.png" alt="image-20250109134112560"></p><blockquote><p>localtime是在gmtime的基础上，加一个时区偏移得到</p></blockquote><p><img src="../assets/image-20250109134249030-1737529755593139.png" alt="image-20250109134249030"></p><h2 id="BKP简介">BKP简介</h2><p><img src="../assets/image-20250109135916881-1737529755593140.png" alt="image-20250109135916881"></p><blockquote><p>BKP其实就是一个存储器，只有当VDD和VBAT都断电了数据才会清零</p><hr><p>TAMPER引脚：侵入事件将所有备份寄存器内容清除，用于安全等</p><hr><p>RTC引脚：输出RTC校准时钟，或输出RTC闹钟脉冲</p><hr><p>BKP20字节：中容量和小容量</p><p>BKP84字节：大容量和互联型</p></blockquote><h3 id="基本结构">基本结构</h3><p><img src="../assets/image-20250109142941243-1737529755593141.png" alt="image-20250109142941243"></p><blockquote><p>橙色部分叫后备区域，BKP处于后备区域，但后备区域不只有BKP，还有RTC相关电路</p><p><code>后备区域特性：</code>当VDD主电源掉电时，后备区域仍可以由VBAT的备用电池供电，当VDD主电源上电时，后备区域供电会由VBAT切换到VDD，也就是在主电源有电时，VBAT不会用到，这样可以节省电池电量。</p><p>每个数据寄存器空间为2个字节</p><hr><p><code>BKP的几个功能：</code></p><ul><li><strong>侵入检测</strong>：可以从PC13位置的TAMPER引脚引入一个检测信号，当TAMPER产生上升沿或者下降沿时，清除BKP所有的内容，以保证安全</li><li><strong>时钟输出</strong>：可以从PC13位置的RTC引脚输出出去，供外部使用，其中输出RTC校准时钟时配合校准寄存器可以对RTC的误差进行校准</li></ul></blockquote><h3 id="BKP库函数">BKP库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BKP_DeInit</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//手动清空bkp所有寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_TamperPinLevelConfig</span><span class="params">(<span class="type">uint16_t</span> BKP_TamperPinLevel)</span>;</span><br><span class="line"><span class="comment">//配置tamper引脚有效电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_TamperPinCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//是否开启侵入检测功能</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_ITConfig</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//BKP中断配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_RTCOutputConfig</span><span class="params">(<span class="type">uint16_t</span> BKP_RTCOutputSource)</span>;</span><br><span class="line"><span class="comment">//BKP时钟输出配置，可选择输入RTC校准时钟，RTC闹钟脉冲或秒脉冲</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_SetRTCCalibrationValue</span><span class="params">(<span class="type">uint8_t</span> CalibrationValue)</span>;</span><br><span class="line"><span class="comment">//设置RTC校准值，写入RTC校准寄存器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_WriteBackupRegister</span><span class="params">(<span class="type">uint16_t</span> BKP_DR, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="comment">//写备份寄存器</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">BKP_ReadBackupRegister</span><span class="params">(<span class="type">uint16_t</span> BKP_DR)</span>;</span><br><span class="line"><span class="comment">//读备份寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关函数*/</span></span><br><span class="line">FlagStatus <span class="title function_">BKP_GetFlagStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ITStatus <span class="title function_">BKP_GetITStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BKP_ClearITPendingBit</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="读写BKP">读写BKP</h3><blockquote><ul><li><code>使用BKP或RTC必须先执行前两步：</code></li></ul><ol><li>开启PWR和BKP时钟</li><li>设置PWR，使能BKP和RTC的访问</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> test = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.开启对应BKP和PWR时钟</span></span><br><span class="line">  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR|RCC_APB1Periph_BKP,ENABLE);</span><br><span class="line"><span class="comment">//2.使能PWR，使能BKP和RTC的访问</span></span><br><span class="line">  PWR_BackupAccessCmd(ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.写bkp寄存器</span></span><br><span class="line">  BKP_WriteBackupRegister(BKP_DR1,<span class="number">0x1234</span>);<span class="comment">//写入DR1寄存器，uint16_t</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.读bkp寄存器</span></span><br><span class="line">  test = BKP_ReadBackupRegister(BKP_DR1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RTC外设">RTC外设</h2><h3 id="RTC简介">RTC简介</h3><p><img src="../assets/image-20250109144513674-1737529755593142.png" alt="image-20250109144513674"></p><blockquote><p>其中计数都是用一个秒计数器，对应Unix的时间戳，使用c库中的time.h库中localtime函数可以得到年月日时分秒信息了。</p><hr><p>RTC可选三种时钟源输入：HSE、LSE、LSI</p><p><strong>一般都使用LSE：32.768KHz 提供给RTC时钟</strong></p><p>特殊情况下，HSE和LSI为备选时钟</p><p><code>选择LSE原因：</code><strong>HSE和LSI都有自己的用途，而LSE是专用，同时只有LSE时钟可以通过VBAT备用电池供电，HSE和LSI在主电源掉电后是停止运行的。</strong></p><p><code>所以要想实现RTC主电源掉电继续走时的功能，必须选择RTC专用时钟LSE</code></p><hr><p><code>BKP和RTC内容都可以在参考手册中查看！！！</code></p></blockquote><h3 id="RTC框图">RTC框图</h3><p><img src="../assets/image-20250109145649841-1737529755593143.png" alt="image-20250109145649841"></p><blockquote><p><strong>图中灰色部分都处于后备区域，主电源掉电后，可以使用备用电池供电</strong></p><p><code>左边：核心的分频和计数计时部分</code></p><p><strong>RTCCLK</strong>：为时钟来源在RCC配置，主要选择LSE</p><p><strong>RTC预分频器</strong>：实际上就是一个计数器，计几个数就溢出1次就是几分频。由重装载寄存器RTC_PRL(相当于ARR)，和余数寄存器RTC_DIV(相当于CNT计数器，但是为自减计数器)。</p><p>若RTC_PRL=32768，来一个输入时钟RTC_DIV自减一次，直到变为0，然后再来一个输入时钟就会产生一个溢出信号，同时DIV变回32767。也就是每来32768个输入脉冲计数器就溢出一次，产生一个输出脉冲，也就是产生了32768分频，分频后输出的时钟频率为1Hz，也就是1s提供给后续</p><p><strong>RTC_CNT</strong>：就是Unix时间戳的秒计数器</p><p><code>RTC_ALR：</code>闹钟寄存器RTC_ALR，32位值，可以在其写入一个秒数，设定闹钟，当RTC_CNT == RTC_ALR，这时闹钟响了就会产生RTC_Alarm信号，通往右边的中断系统，执行对应操作，同时闹钟信号RTC_Alarm可以让STM32退出待机模式。</p><p><strong>可以实现定时唤醒待机芯片采集数据，完成后继续待机，以节省电源的作用</strong></p><hr><p><code>右边：中断使能和NVIC部分</code></p><p><strong>RTC_Second</strong>：秒信号，触发秒中断，每秒触发一次中断</p><p><strong>RTC_Overflow</strong>：溢出信号，触发溢出中断，计数值溢出触发一次中断，这个一般不会触发</p><p><strong>RTC_Alarm</strong>：闹钟信号，触发闹钟中断，可以设定闹钟或者唤醒待机设备</p><hr><p><code>上边：AP1总线相关部分</code></p><p>读写寄存器可以通过APB1总线完成，且RTC是APB1总线上的设备</p><hr><p><code>下边：PWR关联的部分</code></p></blockquote><h3 id="RTC基本结构">RTC基本结构</h3><p><img src="../assets/image-20250109151703477-1737529755593144.png" alt="image-20250109151703477"></p><h3 id="硬件电路-6">硬件电路</h3><p><img src="../assets/image-20250109151911012-1737529755593145.png" alt="image-20250109151911012"></p><blockquote><p>在最小系统的电路上需要额外添加两个部分：</p><ol><li><p>**备用电池电路：**根据数据手册得到简单连接，参考手册得到推荐连接</p><p>图右上角：使用3V纽扣电池充当备用电池，型号位CR2032/CR1220等，有字的那面为正极</p></li></ol><p><img src="../assets/image-20250109152015914-1737529755593146.png" alt="image-20250109152015914"></p><p><strong>画板子设计产品应该选择推荐连接方案更保险</strong></p><ol start="2"><li>**外部低速晶振：**根据参考手册设计</li></ol><p>图右下角：黑色的为外部低速晶振32.768khz，白色的为外部高速8Mhz晶振</p><p><img src="../assets/image-20250109152430959-1737529755593147.png" alt="image-20250109152430959"></p></blockquote><h3 id="RTC操作注意事项">RTC操作注意事项</h3><p><img src="../assets/image-20250109152914363-1737529755593148.png" alt="image-20250109152914363"></p><blockquote><ul><li><code>使用BKP或RTC必须先执行前两步：</code></li></ul><ol><li>开启PWR和BKP时钟</li><li>设置PWR，使能BKP和RTC的访问</li></ol><hr><ul><li>由于APB1和RTC_CRL使用的是不同时钟，面临着同步问题，所以需要在初始化时，调用一个等待同步的函数</li></ul><hr><ul><li>RTC有一个进入配置模式的标志位，必须先将RTC中的RTC_CRL中的CNF标志位置1才能进入配置模式。</li></ul><p>当然，在每个写入寄存器的库函数中都自动加上了这个操作，我们可以不用写</p><hr><ul><li>每次写入操作，都需要等待RTC_CR中的RTOFF标志位，只有为1时才能写入RTC寄存器。也就是调用一个等待上一个任务函数</li></ul><p>原因：因为PCLK1和RTCCLK时钟频率不一样，使用PCLK1的频率写入后，这个值不能直接更新到RTC寄存器中，因为RTC是由RTCCLK驱动，所以PCLK1写完后需要等一下RTCCLK时钟，RTCCLK来一个上升沿使值更新到RTC寄存器中</p></blockquote><h3 id="RCC库函数">RCC库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_LSEConfig</span><span class="params">(<span class="type">uint8_t</span> RCC_LSE)</span>;<span class="comment">//配置LSE外部低速时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_LSICmd</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//配置LSI内部低速时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_RTCCLKConfig</span><span class="params">(<span class="type">uint32_t</span> RCC_RTCCLKSource)</span>;<span class="comment">//RTCCLK配置，配置时钟源选择</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_RTCCLKCmd</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//在调用上面的RTCCLK配置函数后，需要再次调用该函数使能</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">RCC_GetFlagStatus</span><span class="params">(<span class="type">uint8_t</span> RCC_FLAG)</span>;<span class="comment">//调用时钟启动函数后需要该函数等待LSERDY标志位置1，时钟才算启动完成稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_GetClocksFreq</span><span class="params">(RCC_ClocksTypeDef* RCC_Clocks)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphResetCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphResetCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_BackupResetCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClockSecuritySystemCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_MCOConfig</span><span class="params">(<span class="type">uint8_t</span> RCC_MCO)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">ITStatus <span class="title function_">RCC_GetITStatus</span><span class="params">(<span class="type">uint8_t</span> RCC_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClearITPendingBit</span><span class="params">(<span class="type">uint8_t</span> RCC_IT)</span>;</span><br></pre></td></tr></table></figure><h3 id="RTC库函数">RTC库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RTC_ITConfig</span><span class="params">(<span class="type">uint16_t</span> RTC_IT, FunctionalState NewState)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_EnterConfigMode</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//RTC进入配置模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ExitConfigMode</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//RTC退出配置模式</span></span><br><span class="line"><span class="type">uint32_t</span>  <span class="title function_">RTC_GetCounter</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//RTC获取CNT计数器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetCounter</span><span class="params">(<span class="type">uint32_t</span> CounterValue)</span>;<span class="comment">//写入CNT</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetPrescaler</span><span class="params">(<span class="type">uint32_t</span> PrescalerValue)</span>;<span class="comment">//写入预分频器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_SetAlarm</span><span class="params">(<span class="type">uint32_t</span> AlarmValue)</span>;<span class="comment">//RTC写入闹钟值,该该寄存器是只写的不可读</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span>  <span class="title function_">RTC_GetDivider</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//读取预分频器种的DIV余数寄存器，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意事项中的两个等待函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_WaitForLastTask</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//等待上次操作完成，循环直到RTOFF状态位为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_WaitForSynchro</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//等待同步，等待RSF置1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关函数*/</span></span><br><span class="line">FlagStatus <span class="title function_">RTC_GetFlagStatus</span><span class="params">(<span class="type">uint16_t</span> RTC_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearFlag</span><span class="params">(<span class="type">uint16_t</span> RTC_FLAG)</span>;</span><br><span class="line">ITStatus <span class="title function_">RTC_GetITStatus</span><span class="params">(<span class="type">uint16_t</span> RTC_IT)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_ClearITPendingBit</span><span class="params">(<span class="type">uint16_t</span> RTC_IT)</span>;</span><br></pre></td></tr></table></figure><h3 id="RTC配置">RTC配置</h3><ol><li><strong>开启PWR和BKP时钟，设置PWR，使能BKP和RTC的访问</strong></li><li><strong>使用RCC开启LSE时钟(LSE不行的话换成40khz的LSI)，且使用RCC开启LSE时钟(LSE省电默认关闭)，且等待LSERDY标志位为1</strong></li><li><strong>配置RTCCLK时钟源，指定LSE为RTCCLK时钟源，并且调用RTCCLK_Cmd使能</strong></li><li><strong>调用两个等待函数，注意事项中的等待同步与等待上一次操作完成</strong></li><li><strong>配置预分频器，RTC_SetPrescaler，并且再调用等待上一次操作完成函数</strong></li><li><strong>配置CNT,并且再调用等待上一次操作完成函数</strong></li><li>如果有闹钟值则配置闹钟</li><li>如果有中断就配置中断</li></ol><blockquote><p>RTC没有结构体进行配置，且没有Cmd函数，开启时钟后就会运行</p></blockquote><h3 id="RTC显示当前时间">RTC显示当前时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyRTC.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYRTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYRTC_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> MyRTC_Time[];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_SetTime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_ReadTime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyRTC.C*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> MyRTC_Time[] = &#123;<span class="number">2025</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.开启BKP和PWR时钟,设置PWR，使能BKP和RTC的访问</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP|RCC_APB1Periph_PWR,ENABLE);</span><br><span class="line">PWR_BackupAccessCmd(ENABLE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用RCC开启LSE时钟,等待LSERDY标志位为1</span></span><br><span class="line">RCC_LSEConfig(RCC_LSE_ON);<span class="comment">//使用LSI修改处1：RCC_LSICmd(ENABLE);</span></span><br><span class="line">  <span class="keyword">while</span>(RCC_GetFlagStatus(RCC_FLAG_LSERDY)!= SET)<span class="comment">//使用LSI修改处2：RCC_FLAG_LSIRDY</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.配置RTCCLK数据选择器，指定LSE为RTCCLK，并且调用RTCCLK_Cmd使能</span></span><br><span class="line">RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);<span class="comment">//使用LSI修改处3：RCC_FLAG_LSERDY</span></span><br><span class="line">RCC_RTCCLKCmd(ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.调用两个等待函数，注意事项中的等待同步与等待上一次操作完成</span></span><br><span class="line">RTC_WaitForSynchro();</span><br><span class="line">RTC_WaitForLastTask();</span><br><span class="line"><span class="comment">//这两行代码是安全保障措施，防止因为时钟不同步而出现bug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.配置预分频器，RTC_SetPrescaler，并且再调用等待上一次操作完成函数</span></span><br><span class="line">RTC_SetPrescaler(<span class="number">32768</span><span class="number">-1</span>);<span class="comment">//LSE频率为32768HZ，32768分频后可以使频率为1hz</span></span><br><span class="line"><span class="comment">//使用LSI修改处4：40KHz对应40000-1分频得到1hz</span></span><br><span class="line">RTC_WaitForLastTask();</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.配置CNT,并且再调用等待上一次操作完成函数</span></span><br><span class="line">RTC_SetCounter(<span class="number">1672588795</span>);</span><br><span class="line">RTC_WaitForLastTask();</span><br><span class="line">   </span><br><span class="line">MyRTC_SetTime();<span class="comment">//设置起始时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_SetTime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">time_t</span> time_cnt;<span class="comment">//unsigned int类型数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_date</span>;</span></span><br><span class="line"><span class="comment">//1.数组指定时间填充到struct tm结构体中</span></span><br><span class="line">  time_date.tm_year = MyRTC_Time[<span class="number">0</span>]<span class="number">-1900</span>;</span><br><span class="line">time_date.tm_mon = MyRTC_Time[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">time_date.tm_mday = MyRTC_Time[<span class="number">2</span>];</span><br><span class="line">time_date.tm_hour = MyRTC_Time[<span class="number">3</span>];</span><br><span class="line">time_date.tm_min = MyRTC_Time[<span class="number">4</span>];</span><br><span class="line">time_date.tm_sec = MyRTC_Time[<span class="number">5</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2.使用mktime得到秒数</span></span><br><span class="line">time_cnt = mktime(&amp;time_date) - <span class="number">8</span>*<span class="number">60</span>*<span class="number">60</span>;<span class="comment">//此处是北京时间转为伦敦时间，因为RTC中的秒数是以伦敦时间计算的，写入到CNT中也应该是伦敦时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.写入RTC的CNT中</span></span><br><span class="line">  RTC_SetCounter(time_cnt);</span><br><span class="line">  RTC_WaitForLastTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_ReadTime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">time_t</span> time_cnt;<span class="comment">//unsigned int类型数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_date</span>;</span></span><br><span class="line"></span><br><span class="line">  time_cnt = RTC_GetCounter()+ <span class="number">8</span>*<span class="number">60</span>*<span class="number">60</span>;<span class="comment">//此处是伦敦时间转换为北京时间，东8区，要多8个小时，对应8个小时的秒数</span></span><br><span class="line">    </span><br><span class="line">  time_date = *localtime(&amp;time_cnt);</span><br><span class="line">  </span><br><span class="line">  MyRTC_Time[<span class="number">0</span>] = time_date.tm_year+<span class="number">1900</span>;</span><br><span class="line">MyRTC_Time[<span class="number">1</span>] = time_date.tm_mon+<span class="number">1</span>;</span><br><span class="line">MyRTC_Time[<span class="number">2</span>] = time_date.tm_mday;</span><br><span class="line">MyRTC_Time[<span class="number">3</span>] = time_date.tm_hour ;</span><br><span class="line">MyRTC_Time[<span class="number">4</span>] = time_date.tm_min;</span><br><span class="line">MyRTC_Time[<span class="number">5</span>] = time_date.tm_sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>在程序中由于F103芯片等的BUG，可能使用LSE时不会起振，此时函数会卡死在初始化中，我们可以用示波器观察是否产生波形判断一下</strong></p><p><code>解决方案：</code></p><p><strong>此时我们可以使用LSI作为时钟源，但是就不能实现掉电时间不重置了因为LSI不像LSE一样可以由VBat备用电池供电</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*模块初始化*/</span></span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">MyRTC_Init();<span class="comment">//RTC初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示静态字符串*/</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Date:XXXX-XX-XX&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Time:XX:XX:XX&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;CNT :&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;DIV :&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">MyRTC_ReadTime();<span class="comment">//RTC读取时间，最新的时间存储到MyRTC_Time数组中</span></span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, MyRTC_Time[<span class="number">0</span>], <span class="number">4</span>);<span class="comment">//显示MyRTC_Time数组中的时间值，年</span></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">11</span>, MyRTC_Time[<span class="number">1</span>], <span class="number">2</span>);<span class="comment">//月</span></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">14</span>, MyRTC_Time[<span class="number">2</span>], <span class="number">2</span>);<span class="comment">//日</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, MyRTC_Time[<span class="number">3</span>], <span class="number">2</span>);<span class="comment">//时</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">9</span>, MyRTC_Time[<span class="number">4</span>], <span class="number">2</span>);<span class="comment">//分</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">12</span>, MyRTC_Time[<span class="number">5</span>], <span class="number">2</span>);<span class="comment">//秒</span></span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">3</span>, <span class="number">6</span>, RTC_GetCounter(), <span class="number">10</span>);<span class="comment">//显示32位的秒计数器</span></span><br><span class="line">OLED_ShowNum(<span class="number">4</span>, <span class="number">6</span>, RTC_GetDivider(), <span class="number">10</span>);<span class="comment">//显示余数寄存器</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BKP寄存器解决掉电时间不丢失问题">BKP寄存器解决掉电时间不丢失问题</h3><blockquote><p><strong>在对RTC的初始化中，我们要有判断的去执行</strong>：</p><ol><li><p>当系统完全断电了，备用电池也断电了，我们就执行初始化</p></li><li><p>当系统只是主电源断电，备用电池没断的话，LSE一直都在运行，就不用执行初始化</p></li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*我们只需要修改MyRTC_Init()的代码即可，为其添加一个BKP寄存器自定义标志位的判断*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);<span class="comment">//开启PWR的时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);<span class="comment">//开启BKP的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*备份寄存器访问使能*/</span></span><br><span class="line">PWR_BackupAccessCmd(ENABLE);<span class="comment">//使用PWR开启对备份寄存器的访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (BKP_ReadBackupRegister(BKP_DR1) != <span class="number">0xAAAA</span>)<span class="comment">//通过写入备份寄存器的标志位，判断RTC是否是第一次配置</span></span><br><span class="line"><span class="comment">//if成立则执行第一次的RTC配置</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_LSEConfig(RCC_LSE_ON);<span class="comment">//开启LSE时钟</span></span><br><span class="line"><span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSERDY) != SET);<span class="comment">//等待LSE准备就绪</span></span><br><span class="line"></span><br><span class="line">RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);<span class="comment">//选择RTCCLK来源为LSE</span></span><br><span class="line">RCC_RTCCLKCmd(ENABLE);<span class="comment">//RTCCLK使能</span></span><br><span class="line"></span><br><span class="line">RTC_WaitForSynchro();<span class="comment">//等待同步</span></span><br><span class="line">RTC_WaitForLastTask();<span class="comment">//等待上一次操作完成</span></span><br><span class="line"></span><br><span class="line">RTC_SetPrescaler(<span class="number">32768</span> - <span class="number">1</span>);<span class="comment">//设置RTC预分频器，预分频后的计数频率为1Hz</span></span><br><span class="line">RTC_WaitForLastTask();<span class="comment">//等待上一次操作完成</span></span><br><span class="line"></span><br><span class="line">MyRTC_SetTime();<span class="comment">//设置时间，调用此函数，全局数组里时间值刷新到RTC硬件电路</span></span><br><span class="line"></span><br><span class="line">BKP_WriteBackupRegister(BKP_DR1, <span class="number">0xAAAA</span>);<span class="comment">//在备份寄存器写入自己规定的标志位，用于判断RTC是不是第一次执行配置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//RTC不是第一次配置</span></span><br><span class="line">&#123;</span><br><span class="line">RTC_WaitForSynchro();<span class="comment">//等待同步</span></span><br><span class="line">RTC_WaitForLastTask();<span class="comment">//等待上一次操作完成</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果LSE无法起振导致程序卡死在初始化函数中,可将初始化函数替换为下述代码，使用LSI当作RTCCLK</strong></p><p><code>LSI无法由备用电源供电，故主电源掉电时，RTC走时会暂停</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);</span><br><span class="line">    </span><br><span class="line">    PWR_BackupAccessCmd(ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (BKP_ReadBackupRegister(BKP_DR1) != <span class="number">0xA5A5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       RCC_LSICmd(ENABLE);</span><br><span class="line">       <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET);</span><br><span class="line">       </span><br><span class="line">       RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);</span><br><span class="line">       RCC_RTCCLKCmd(ENABLE);</span><br><span class="line">       </span><br><span class="line">       RTC_WaitForSynchro();</span><br><span class="line">       RTC_WaitForLastTask();</span><br><span class="line">       </span><br><span class="line">       RTC_SetPrescaler(<span class="number">40000</span> - <span class="number">1</span>);</span><br><span class="line">       RTC_WaitForLastTask();</span><br><span class="line">       </span><br><span class="line">       MyRTC_SetTime();</span><br><span class="line">       </span><br><span class="line">       BKP_WriteBackupRegister(BKP_DR1, <span class="number">0xA5A5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       RCC_LSICmd(ENABLE);             <span class="comment">//即使不是第一次配置，也需要再次开启LSI时钟</span></span><br><span class="line">       <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET);</span><br><span class="line">       </span><br><span class="line">       RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);</span><br><span class="line">       RCC_RTCCLKCmd(ENABLE);</span><br><span class="line">       </span><br><span class="line">       RTC_WaitForSynchro();</span><br><span class="line">       RTC_WaitForLastTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>PWR电源控制</h1><h2 id="PWR简介">PWR简介</h2><p><img src="../assets/image-20250110170201038-1737529755593150.png" alt="image-20250110170201038"></p><blockquote><p>实现<code>可编程电压检测器</code>和<code>低功耗模式</code></p><p>**可编程电压检测器PVD：**监视VDD电压，在供电电压下降到PVD阀值以下时或上升到PVD阈值以上时，产生一个中断，通知软件做紧急处理</p><p>**低功耗模式：**睡眠模式Sleep、停机模式stop、待机模式standby。在空闲状态时关闭不必要的硬件，比如把CPU断电或关闭时钟，但需要保留必要的唤醒电路</p></blockquote><p><code>所有知识在手册上可以找到</code></p><h2 id="电源框图">电源框图</h2><p><img src="../assets/image-20250110170713455-1737529755593149.png" alt="image-20250110170713455"></p><blockquote><p>STM32内部供电方案图可分为三个部分：</p><p><code>模拟部分供电：</code>VDDA(VDD Analog)</p><p>包括A/D转换器、温度传感器、复位模块、PLL</p><p>供电正极为：VDDA</p><p>供电负极为：VSSA</p><p>其中还有两个参考电压供电脚：VREF- 和VREF+</p><p>在该芯片中直接接入了VSSA和VDDA，也可能会单独引出去</p><hr><p><code>数字部分供电：</code>VDD供电区域和1.8V供电区域</p><p><strong>VDD供电区域</strong>：I/O电路、待机电路、电压调节器(为1.8V区域供电)</p><p><strong>1.8V供电区域</strong>：CPU、存储器、外设</p><p>我们可以看到CPU、存储器和外设都是以1.8V的低电压运行的，当需要与外界交流时，才会通过I/O电路转换为3.3V</p><hr><p><code>后备供电区域：</code>VBAT为以下供电</p><p>LSE 32K晶体振荡器后备寄存器</p><p>RCC BDCR寄存器，即备份域控制寄存器</p><p>RTC</p><p>低电压检测器：控制开关，VDD有电时由VDD供电，VDD没电时由VBAT供电</p><p><img src="../assets/image-20250110171925509-1737529755593151.png" alt="image-20250110171925509"></p></blockquote><h2 id="上电复位和掉电复位-POR-PDR">上电复位和掉电复位(POR/PDR)</h2><p><img src="../assets/image-20250110181242741-1737529755593153.png" alt="image-20250110181242741"></p><blockquote><p>设置了阈值电压：40mV迟滞避免电压来回波动，造成输出也来回抖动</p><p>Reset：低电平有效</p><p>对应滞后时间在stm32数据手册可以找到</p><p><img src="../assets/image-20250110181444794-1737529755593152.png" alt="image-20250110181444794"></p></blockquote><h2 id="可编程电压检测器PVD">可编程电压检测器PVD</h2><p><img src="../assets/image-20250110181535199-1737529755593154.png" alt="image-20250110181535199"></p><blockquote><p><strong>PVD-(Programmable Votage Detector)作用</strong>：</p><p>监视VDD电压，在供电电压下降到PVD阀值以下时或上升到PVD阈值以上时，产生一个中断，通知软件做紧急处理。</p><p>PVD在电压过低时为1，正常时输出0</p><p>PVD在上升沿或下降沿时触发中断，通过<strong>外部中断</strong>实现，提醒用户处理。</p><hr><p>PVD的阈值电压可以使用程序指定，配置PLS寄存器3位，迟滞电压上限为100mV</p><p><img src="../assets/image-20250110181653488-1737529755593155.png" alt="image-20250110181653488"></p></blockquote><h2 id="低功耗模式介绍">低功耗模式介绍</h2><p><code>手册中的低功耗模式介绍：</code></p><p><img src="../assets/image-20250110182653384-1737529755593156.png" alt="image-20250110182653384"></p><blockquote><p>三种模式从上到下：<code>睡眠</code>、<code>停机(止)</code>、<code>待机</code></p><ol><li>关闭的电路越来越多</li><li>越来越省电</li><li>越来越难唤醒</li></ol><p>图中可以知道关闭电路通常由两个做法：<code>关闭时钟</code>或<code>关闭电源</code></p><p><strong>关闭时钟</strong>：所有的运算和涉及时序的操作都会暂停，寄存器和存储器保存的数据可以维持不会消失</p><p><strong>关闭电源</strong>：电路直接断电，电路操作和寄存器数据都丢失，比关闭时钟更省电</p><hr><p><code>睡眠模式：一般省电</code></p><p>**WFI(wait for interrupt)：**等待中断，对应唤醒条件为<code>中断唤醒</code>，意思就是处于睡眠状态，如果有中断发生再叫我起来。</p><p>调用WFI进入的睡眠模式，<strong>任何外设发生任何中断时</strong>，芯片都会立刻醒来，进入中断处理程序</p><p>**WFE(wait for event)：**等待事件，对应唤醒条件为<code>唤醒事件</code>，可以是外部中断配置为事件模式，也可以是使能了中断但没有配置NVIC</p><p>调用WFE进入的睡眠模式，产生唤醒事件时，会立刻醒来。一般不需要进中断函数</p><p><code>对电路影响：</code>只关闭了CPU时钟，其他电路没有影响。<strong>看上图中描述</strong></p><hr><p><code>停机模式：非常省电</code></p><p><strong>SLEEPDEEP位</strong>：置1进入深度睡眠</p><p><strong>PDDS位</strong>：区分停机和待机。PDDS=0，进入停机模式，PDDS=1，进入待机模式</p><p><strong>LPDS位</strong>：<strong>设置电压调节器</strong>，开启或进入低功耗模式。LPDS=0,电压调节器开启LPDS=1，电压调节器进入低功耗(更省电但唤醒延迟更高)。</p><p><strong>设置流程：SLEEPDEEP=1，PDDS=0，LPDS=0/1，再调用WFI或WFE，芯片就可以进入停止模式了</strong></p><p><strong>唤醒条件</strong>：只有任一的外部中断能唤醒，其他中断不能唤醒</p><p>WFI用外部中断中断模式唤醒，WFE用外部中断事件唤醒</p><p><code>对电路影响：</code>关闭所有1.8V区域的时钟(CPU、AD、外设)，以及HSI和HSE振荡器，但不会关闭LSI和LSE，电压调节器开启(1.8V区域电源仍开启)。<strong>看上图中描述</strong></p><hr><p><code>待机模式:极为省电</code></p><p><strong>设置流程：SLEEPDEEP=1，PDDS=1，再调用WFI或WFE，芯片就可以进入停止模式了</strong></p><p>**唤醒条件：**普通外设中断或外部中断都无法唤醒待机模式，只能由以下四个信号唤醒</p><ol><li>WKUP引脚上升沿(如PA0-Wakeup，即PA0)</li><li>RTC闹钟事件</li><li>NRST引脚的外部复位(Reset一下)</li><li>IWDG复位</li></ol><p><code>对电路影响：</code>关闭所有1.8V区域的时钟(CPU、AD、外设)，两个高速时钟关闭，两个低速时钟不会关闭，电压调节器关闭(即1.8V区域电源关闭)。<strong>看上图中描述</strong></p></blockquote><h2 id="模式选择的图">模式选择的图</h2><p><img src="../assets/image-20250110195522341-1737529755593157.png" alt="image-20250110195522341"></p><blockquote><p>配置其他寄存器在执行WFI或WFE之前。</p><p>图中最左边是执行WFI/WFE后，根据各个寄存器判断启动什么模式的流程</p></blockquote><h2 id="三种模式特性及注意事项">三种模式特性及注意事项</h2><p><img src="../assets/image-20250110211426203-1737529755593158.png" alt="image-20250110211426203"></p><blockquote><p><strong>GPIO高低电平保持睡眠前运行时的状态，唤醒后程序从暂停的地方继续运行</strong></p><p>手册对事件唤醒描述：</p><p><img src="../assets/image-20250110211647415-1737529755593159.png" alt="image-20250110211647415"></p><p>比较麻烦所以还是使用中断唤醒吧</p></blockquote><hr><p><img src="../assets/image-20250110211742039-1737529755593161.png" alt="image-20250110211742039"></p><blockquote><p><strong>GPIO高低电平保持睡眠前运行时的状态，唤醒后程序从暂停的地方继续运行</strong></p><p><strong>注意：</strong></p><p>停止模式唤醒时，因为HSI被选为了系统时钟，所以变成了8MHz的主频，<code>所以我们在停止模式唤醒后第一时间应该重新启动HSE，配置主频为72MHz(调用SystemInit即可)</code></p></blockquote><hr><p><img src="../assets/image-20250110212325583-1737529755593162.png" alt="image-20250110212325583"></p><blockquote><p><strong>待机模式下，GPIO输出引脚变为高阻态(浮空输入)，唤醒后程序从头开始运行</strong></p><p>仅备份寄存器和待机电路供电</p><p>仅四种方式退出待机模式</p></blockquote><h2 id="节电方法">节电方法</h2><p>在数据手册工作条件的供电电流特性测试电流部分可以得到省电方法</p><ol><li><strong>关闭不需要的外设对应时钟</strong></li><li><strong>降低主频，耗电电流下降，对于省电也挺划算的。设备需要连续运行，但是对于主频和性能没这么高要求的话，就可以选择降低主频</strong></li></ol><blockquote><p>产品使用电池的话低功耗模式也是很必要使用的</p></blockquote><h2 id="SLEEPDEEP和SLEEPONEXIT位配置">SLEEPDEEP和SLEEPONEXIT位配置</h2><blockquote><p>这两个位位于内核系统控制块，没有提供什么简单的配置方法，只能通过操作寄存器来配置，默认值为0</p><p>我们需要打开Cortex-M3编程手册，第4章内核外设的系统控制块SCB中找到寄存器介绍</p><p><img src="../assets/image-20250111155405959-1737529755593160.png" alt="image-20250111155405959"></p><p>对应SCB-&gt;SCR寄存器等按照配置编程手册上的位配置即可</p></blockquote><h2 id="修改主频">修改主频</h2><p>在system_stm32f10x.c文件中可以看到的描述是有两个函数和一个变量与系统主频有关</p><p>在system_stm32f10x.h文件中也可以找到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> SystemCoreClock;<span class="comment">//系统时钟</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//系统时钟初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">SystemCoreClockUpdate</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//系统时钟更新</span></span><br></pre></td></tr></table></figure><p>在system_stm32f10x.c文件中，对应部分找到自己的型号然后进行修改主频即可</p><p><img src="../assets/image-20250111152640885-1737529755593165.png" alt="image-20250111152640885"></p><blockquote><p>修改主频后，使用主频的地方需要修改，比如Delay函数</p><p><img src="../assets/image-20250111152842134-1737529755593163.png" alt="image-20250111152842134"></p><p>在72Mhz下是正确延时指定时间，但是变为36Mhz后，就会变为原来的1/2。所以最好将SystemCoreClock变量带入计算中做自适应</p><hr><p><code>所以一般条件下不推荐修改主频，除非有需求</code></p></blockquote><h2 id="睡眠模式实例">睡眠模式实例</h2><p>睡眠模式使用寄存器都是内核中的，与PWR没什么关系，所以没使用PWR库函数</p><h3 id="串口收发">串口收发</h3><blockquote><p><strong>对于这种靠任意中断触发，没中断就没什么事的，平时主循环会耗电</strong></p><p><strong>我们就可以给它加入低功耗模式</strong></p><p><code>根据分析，这种情况下串口只能使用睡眠模式</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Serial.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RxData;<span class="comment">//定义用于接收串口数据的变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;RxData:&quot;</span>);<span class="comment">//显示静态字符串</span></span><br><span class="line"></span><br><span class="line">Serial_Init();<span class="comment">//串口初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Serial_GetRxFlag() == <span class="number">1</span>)<span class="comment">//检查串口接收数据的标志位</span></span><br><span class="line">&#123;</span><br><span class="line">RxData = Serial_GetRxData();<span class="comment">//获取串口接收的数据</span></span><br><span class="line">Serial_SendByte(RxData);<span class="comment">//串口将收到的数据回传回去，用于测试</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, RxData, <span class="number">2</span>);<span class="comment">//显示串口接收的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);<span class="comment">//OLED闪烁Running，指示当前主循环正在运行</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">__WFI();<span class="comment">//执行WFI指令，CPU睡眠，并等待中断唤醒</span></span><br><span class="line">        <span class="comment">//__WFE();WFE,事件唤醒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>对于睡眠模式我们在while循环中加入WFI或WFE即可实现睡眠模式，唤醒后继续执行上一次执行的操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__WFI();<span class="comment">//执行WFI指令，CPU睡眠，并等待中断唤醒</span></span><br><span class="line">__WFE();<span class="comment">//WFE,事件唤醒</span></span><br></pre></td></tr></table></figure><p><code>现象：</code></p><p>OLED上不再持续显示Running，此时用串口助手发送信息，每发送一次，Running闪烁显示一次，说明只有接收中断后才会唤醒工作一次，然后立马睡眠</p></blockquote><h2 id="停机模式实例">停机模式实例</h2><h3 id="库函数-10">库函数</h3><p>停机模式涉及内核外的电路操作，需要使用库函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWR_DeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_BackupAccessCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//使能后备区域的访问，在RTC初始化时需要使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_PVDCmd</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//PVD使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_PVDLevelConfig</span><span class="params">(<span class="type">uint32_t</span> PWR_PVDLevel)</span>;<span class="comment">//PVD阈值电压配置</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_WakeUpPinCmd</span><span class="params">(FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//WKUP引脚唤醒功能使用需要调用此函数开启</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_EnterSTOPMode</span><span class="params">(<span class="type">uint32_t</span> PWR_Regulator, <span class="type">uint8_t</span> PWR_STOPEntry)</span>;</span><br><span class="line"><span class="comment">//停机模式：调用该函数就可以进入停止模式了</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_EnterSTANDBYMode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//待机模式：调用该函数就可以进入待机模式了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//PWR标志位相关函数</span></span><br><span class="line">FlagStatus <span class="title function_">PWR_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> PWR_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PWR_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> PWR_FLAG)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="对射式红外传感器外部中断-停机模式">对射式红外传感器外部中断(停机模式)</h3><blockquote><p>使用<strong>外部中断触发</strong>的可以考虑使用<strong>更省电的停机模式</strong></p><p>虽然停机模式关闭了外设时钟，但是外部中断使用不需要时钟就能工作</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CountSensor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*模块初始化*/</span></span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">CountSensor_Init();<span class="comment">//红外计数传感器初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);<span class="comment">//开启PWR的时钟！！！</span></span><br><span class="line"><span class="comment">//停止模式和待机模式一定要记得开启</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示静态字符串*/</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Count:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">7</span>, CountSensor_Get(), <span class="number">5</span>);<span class="comment">//OLED不断刷新显示CountSensor_Get的返回值</span></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);<span class="comment">//OLED闪烁Running，指示当前主循环正在运行</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI);<span class="comment">//STM32WFI指令进入停止模式，并等待中断唤醒</span></span><br><span class="line">        </span><br><span class="line">SystemInit();<span class="comment">//唤醒后，要重新配置时钟</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI):</code></p><p>该函数最后调用了WFI或WFE指令之后就进入了静止模式</p><hr><p><code>SystemInit()：</code>唤醒后时钟变为了HSI的8M，需要我们重新启动HSE，配置72M的主频，调用该函数即可</p></blockquote><blockquote><p><code>现象：</code>红外传感器计数一次，Running闪烁一次，确实进入了停机模式</p></blockquote><h2 id="待机模式实例">待机模式实例</h2><h3 id="RTC闹钟-待机模式">RTC闹钟(待机模式)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*模块初始化*/</span></span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">MyRTC_Init();<span class="comment">//RTC初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*开启时钟*/</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);<span class="comment">//开启PWR的时钟</span></span><br><span class="line"><span class="comment">//停止模式和待机模式一定要记得开启时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示静态字符串*/</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;CNT :&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;ALR :&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;ALRF:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使能WKUP引脚*/</span></span><br><span class="line">PWR_WakeUpPinCmd(ENABLE);<span class="comment">//使能位于PA0的WKUP引脚，WKUP引脚上升沿唤醒待机模式,接上VCC即可唤醒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设定闹钟：由于该寄存器是只写的不可读，所以我们使用变量显示*/</span></span><br><span class="line"><span class="type">uint32_t</span> Alarm = RTC_GetCounter() + <span class="number">10</span>;<span class="comment">//闹钟为唤醒后当前时间的后10s</span></span><br><span class="line">RTC_SetAlarm(Alarm);<span class="comment">//写入闹钟值到RTC的ALR寄存器</span></span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, Alarm, <span class="number">10</span>);<span class="comment">//显示闹钟值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, RTC_GetCounter(), <span class="number">10</span>);<span class="comment">//显示32位的秒计数器</span></span><br><span class="line">OLED_ShowNum(<span class="number">3</span>, <span class="number">6</span>, RTC_GetFlagStatus(RTC_FLAG_ALR), <span class="number">1</span>);<span class="comment">//显示闹钟标志位</span></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);<span class="comment">//OLED闪烁Running，指示当前主循环正在运行</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">9</span>, <span class="string">&quot;STANDBY&quot;</span>);<span class="comment">//OLED闪烁STANDBY，指示即将进入待机模式</span></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">9</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">OLED_Clear();<span class="comment">//OLED清屏，模拟关闭外部所有的耗电设备，以达到极度省电</span></span><br><span class="line"></span><br><span class="line">PWR_EnterSTANDBYMode();<span class="comment">//STM32进入停止模式，并等待指定的唤醒事件（WKUP上升沿或RTC闹钟）</span></span><br><span class="line"><span class="comment">/*待机模式唤醒后，程序会重头开始运行*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>PWR_EnterSTANDBYMode():</code></p><p>该函数最后统一调用WFI指令进入待机模式</p><hr><p><strong>待机模式下只有这四种可以唤醒</strong>：</p><ol><li>WKUP引脚上升沿(如PA0-Wakeup，即PA0)：手册中对应描述不需要GPIO初始化，被强制下拉，只需要接VCC即可唤醒</li><li>RTC闹钟事件</li><li>NRST引脚的外部复位(Reset一下)</li><li>IWDG复位</li></ol></blockquote><blockquote><p><code>现象：</code>等待10s后，Running闪烁一下后消失，CNT和ALR的值都更新，说明待机模式下唤醒后，程序从头开始运行，所以我们不用重新调用SystemInit了。</p></blockquote><p><code>最大化省电：</code><strong>进入待机模式前把外接的模块能关的全关，需要精心设计电路。否则待机模式无法做到真正的极度省电！！！</strong></p><h1>看门狗WDG</h1><h2 id="看门狗简介">看门狗简介</h2><p><img src="../assets/image-20250111173313542-1737529755593164.png" alt="image-20250111173313542"></p><blockquote><p><code>看门狗</code>：由于程序出现漏洞、硬件故障、电磁干扰等原因出现卡死或跑飞现象时可以及时复位程序。</p><p>本质是一个<strong>定时器</strong>，在指定时间范围内，程序没有执行<strong>喂狗</strong>(手动重装计数器)操作时，看门狗硬件电路就自动产生复位信号。</p><p><code>作用：</code>提高系统的可靠性和健壮性，避免程序陷入长时间罢工状态</p><p>可以预料的漏洞应该尽量解决，开门狗只是一个复位的作用，可能会出现复位也不能解决的问题</p><hr><p>STM32内置两个看门狗：独立看门狗(IWDG)和窗口看门狗(WWDG)</p><p><strong>独立看门狗(IWDG)</strong>：使用专门的LSI时钟，即使主时钟出现问题，独立看门狗也能正常工作，这就是<strong>独立的命名</strong>。对时间精度要求较低，只有一个喂狗最晚界限。</p><p><strong>窗口看门狗(WWDG)</strong>：使用APB1时钟，要求看门狗在精确的计时窗口作用，有喂狗最早界限和最晚界限，必须在这个界限窗口内喂狗，这就是窗口的命名。喂早和喂晚都会发生复位</p><p><code>对应更多内容请查看参考手册!!!</code></p></blockquote><h2 id="独立看门狗IWDG">独立看门狗IWDG</h2><h3 id="IWDG框图">IWDG框图</h3><p><img src="../assets/image-20250112155237497-1737529755593166.png" alt="image-20250112155237497"></p><blockquote><p>IWDG_PR：其实就是定时器中的预分频Prescaler缩写，8位，最大为256</p><p>IWDG_RLR：就是定时器中的ARR=Auto Reloader，RLR = Reloader，12位最大为4096</p><p>IWDG_SR：状态寄存器</p><p><strong>工作流程</strong>：计数器为递减计数器，自减到0之前执行喂狗操作，重置计数器为4096-1，当计数器自减到0时，就会进行复位</p><hr><p>上面寄存器处于1.8V供电区，而下面的电路处于VDD供电区，所以在停机和待机模式下只会关闭1.8V时钟，所以可以在停机和待机模式下可以运行。</p><p>待机模式下的唤醒条件之一就包含看门狗</p></blockquote><h3 id="IWDG键寄存器">IWDG键寄存器</h3><p><img src="../assets/image-20250112160401346-1737529755593167.png" alt="image-20250112160401346"></p><blockquote><p><strong>在多个位确定代替一位的情况下，该寄存器就算值变化，也很难恰巧出现以上的值，这样就更保险。</strong></p><p>同时对IWDG_PR、IWDG_RLR设计了写保护，只有写入键寄存器的值为0x5555时才会解除写保护，其他情况下都不允许写入</p><p>IWDG_SR由于是只读的就不用管</p></blockquote><h3 id="IWDG超时时间">IWDG超时时间</h3><p><img src="../assets/image-20250112160724383-1737529755593168.png" alt="image-20250112160724383"></p><blockquote><p>就是定时器溢出时间，和定时器溢出时间相同</p><p>最大值只能是</p><p>PR[2:0]：写入0~7，固定上面几个分频系数</p></blockquote><h2 id="窗口看门狗WWDG">窗口看门狗WWDG</h2><h3 id="WWDG框图">WWDG框图</h3><p><img src="../assets/image-20250112161153418-1737529755593169.png" alt="image-20250112161153418"></p><blockquote><p>**时钟源：**PCK1 = 36M，进入预分频器前还进行了4096分频，图中没画出</p><p>**看门狗的预分频器WDGTB：**与独立看门狗PR和定时器的PSC都是一样的道理</p><hr><p>**看门狗控制寄存器(WWDG_CR)：<strong>包</strong>WDGA(看门狗使能位)**和计数器，与计数器合二为一了。</p><p>**6/7位递减计数器CNT：**CNT的有效位为T0~T5，T6位用于判断是否溢出。<strong>启动时必须将此位写入1，值为1代表计数器没有溢出，值为0代表计数器溢出，产生看门狗复位</strong>。位于控制寄存器CR中，计数器和控制寄存器合二为一。</p><p>窗口看门狗没有重装寄存器，直接向CNT写数据。</p><p><strong>当T6~T0位为1 0 0 0 0 0 0 (<code>0x40</code>)，第1位为标志位T6为1，6位计数器的值为000000。再减一次后T6位变为0，计数器溢出，T6通过图中线路产生复位信号</strong>。</p><ul><li><p><strong>如果把T0~T5看成计数器，就是6位计数器，那么就是自减到0时溢出</strong></p></li><li><p><strong>如果把T0~T6为看成计数器，就是7位计数器，那么就是自减小于0x40时溢出</strong></p></li></ul><p><code>喂狗操作：</code>写入WWDG_CR寄存器，也就是写入CNT</p></blockquote><blockquote><hr><p><strong>看门狗配置寄存器WWDG_CFR：</strong></p><p>用于设置喂狗的<code>窗口值的最早界限</code>，写入W6~W0，7位数据，固定不变</p><hr><p>最左边是比较器逻辑，什么时候产生复位操作的逻辑</p><hr><p><code>工作流程：</code></p><p>首先时钟从PCLK1(36M时钟进入)，然后经过预分频器分频，驱动计数器进行计数，每来一个时钟自减一次。最终比较进行复位</p></blockquote><h3 id="WWDG工作特性">WWDG工作特性</h3><p><img src="../assets/image-20250112163354916-17366708495051-1737529755594170.png" alt="image-20250112163354916"></p><p><img src="../assets/image-20250112182947095-1737529755594171.png" alt="image-20250112182947095"></p><blockquote><p>定期写入WWDG_CR寄存器喂狗，避免WWDG复位</p><p><strong>W[6:0]</strong>：喂狗的最早界限，对应<code>窗口时间</code></p><p><strong>T[6:0]：</strong> 喂狗的计数器值，对应<code>超时时间</code></p><p><strong>0x3F</strong>：喂狗的最晚界限，由0x40-1得到，对应<code>超时时间的最大值</code></p><p><code>窗口时间~超时时间:</code>之间喂狗才不会复位</p><hr><p>递减计数器T[6:0] = 0X40 产生早期唤醒中断EWI</p></blockquote><h3 id="WWDG超时时间">WWDG超时时间</h3><p><img src="../assets/image-20250112164040798-1737529755594172.png" alt="image-20250112164040798"></p><h2 id="IWDG和WWDG对比">IWDG和WWDG对比</h2><p><img src="../assets/image-20250112164553712-1737529755594173.png" alt="image-20250112164553712"></p><blockquote><p><strong>窗口看门狗的精度比独立看门狗高</strong></p></blockquote><h2 id="独立看门狗代码">独立看门狗代码</h2><h3 id="相关库函数">相关库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*stm32f10x_iwdg.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_WriteAccessCmd</span><span class="params">(<span class="type">uint16_t</span> IWDG_WriteAccess)</span>;</span><br><span class="line"><span class="comment">//写使能控制，键寄存器写入ENABLE就是0x5555，Disable就是0x0000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_SetPrescaler</span><span class="params">(<span class="type">uint8_t</span> IWDG_Prescaler)</span>;</span><br><span class="line"><span class="comment">//设置预分频</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_SetReload</span><span class="params">(<span class="type">uint16_t</span> Reload)</span>;</span><br><span class="line"><span class="comment">//设置重装载值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_ReloadCounter</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//喂狗操作：重新装载寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IWDG_Enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//启用独立看门狗，键寄存器写入0xCCCC</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">IWDG_GetFlagStatus</span><span class="params">(<span class="type">uint16_t</span> IWDG_FLAG)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*RCC库函数，stm32f10x_rcc.c*/</span></span><br><span class="line">FlagStatus <span class="title function_">RCC_GetFlagStatus</span><span class="params">(<span class="type">uint8_t</span> RCC_FLAG)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* *   For @b other_STM32_devices, this parameter can be one of the following values:        </span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_PLLRDY: PLL clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_PINRST: Pin reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_PORRST: POR/PDR reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_SFTRST: Software reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset</span></span><br><span class="line"><span class="comment">   *     @arg RCC_FLAG_LPWRRST: Low Power reset</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">     </span><br></pre></td></tr></table></figure><blockquote><p>使用RCC中的获取标志位函数可以根据可选参数得到是什么造成的复位，这里用于判断复位是否由看门狗完成</p><p><code>同时我们的看门狗标志位必须手动清除，因为及时按下复位键也不会手动清0。如果不清零下次即使是复位键复位也会判断为看门狗复位</code></p></blockquote><h3 id="配置流程-2">配置流程</h3><ol><li>开启时钟LSI**(不需要我们写代码，开启看门狗时会自动强制开启LSI)**</li></ol><blockquote><p><strong>在手册的看门狗时钟部分可以看到，开启独立看门狗后LSI会被强制打开，等LSI稳定后，就可以自动为独立看门狗提供时钟</strong></p></blockquote><ol start="2"><li><p>写入键寄存器0x5555关闭写保护，再写入预分频值和重装值**(直接调用库函数，不需要我们寄存器操作)**</p></li><li><p>写入键寄存器0xCCCC启动看门狗**(直接调用库函数IWDG_Enable)**</p></li><li><p><strong>主循环执行喂狗操作</strong></p></li></ol><h3 id="按键触发独立看门狗">按键触发独立看门狗</h3><blockquote><p><img src="../assets/image-20250112171912193-1737529755594174.png" alt="image-20250112171912193"></p><p><code>设置1000ms超时：</code><strong>图中可以看到前两个分频系数最大超时时间&lt;1000ms不满足,所以选下面的,优先选择预分频系数小的最大化利用计数器值</strong></p><p><strong>LSI时钟</strong>：40kHz -&gt; 0.025ms</p><p><strong>计算预分频系数PR</strong>：16</p><p><strong>计算重载寄存器RL</strong>： 1000/(0.025*16) = 2499+1</p><p>重载寄存器RL值：2499</p><p>0.025ms * 16 * (2499+1) = 1000ms</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*模块初始化*/</span></span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">Key_Init();<span class="comment">//按键初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示静态字符串*/</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;IWDG TEST&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断复位信号来源*/</span></span><br><span class="line"><span class="keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) == SET)<span class="comment">//如果是独立看门狗复位</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;IWDGRST&quot;</span>);<span class="comment">//OLED闪烁IWDGRST字符串</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">RCC_ClearFlag();<span class="comment">//清除标志位!!!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//否则，即为其他复位</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;RST&quot;</span>);<span class="comment">//OLED闪烁RST字符串</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*IWDG初始化*/</span></span><br><span class="line">IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);<span class="comment">//1.独立看门狗写使能</span></span><br><span class="line">IWDG_SetPrescaler(IWDG_Prescaler_16);<span class="comment">//2.设置预分频为上面计算的16,</span></span><br><span class="line">IWDG_SetReload(<span class="number">2499</span>);<span class="comment">//2.设置重装值为双面计算的2499，独立看门狗的超时时间为1000ms</span></span><br><span class="line">IWDG_ReloadCounter();<span class="comment">//3.重装计数器，喂狗，这样更严谨一点使下个周期为1000ms</span></span><br><span class="line">IWDG_Enable();<span class="comment">//4.独立看门狗使能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Key_GetNum();<span class="comment">//调用阻塞式的按键扫描函数，模拟主循环卡死</span></span><br><span class="line"></span><br><span class="line">IWDG_ReloadCounter();<span class="comment">//重装计数器，喂狗，避免复位</span></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;FEED&quot;</span>);<span class="comment">//OLED闪烁FEED字符串</span></span><br><span class="line">Delay_ms(<span class="number">200</span>);<span class="comment">//喂狗间隔为200+600=800ms,没到1000ms不会重装</span></span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;    &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">600</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Delay_ms(1010);//模拟超时喂狗，多留一点冗余时间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>按键使用的是阻塞式消抖，其中包含while循环，一直按着不松就会卡死在while循环，这样就会造成超时主循环阻塞没喂狗，触发看门狗复位</p></blockquote><blockquote><p>现象：正常情况下屏幕间断显示FEED</p><p>正常按下Reset按键，屏幕显示&quot;RST&quot;复位。</p><p>按下按键不松手，屏幕显示&quot;IWDGRST&quot;</p></blockquote><h2 id="窗口看门狗代码">窗口看门狗代码</h2><h3 id="库函数-11">库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_DeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_SetPrescaler</span><span class="params">(<span class="type">uint32_t</span> WWDG_Prescaler)</span>;<span class="comment">//写入预分频器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_SetWindowValue</span><span class="params">(<span class="type">uint8_t</span> WindowValue)</span>;<span class="comment">//设置窗口最早界限</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_EnableIT</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//使能EWI中断</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_SetCounter</span><span class="params">(<span class="type">uint8_t</span> Counter)</span>;<span class="comment">//喂狗操作</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_Enable</span><span class="params">(<span class="type">uint8_t</span> Counter)</span>;<span class="comment">//使能看门狗,手册上说明了计数器时刻自减，所以可能是任何值，所以需要使能的时候喂一下狗</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">WWDG_GetFlagStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_ClearFlag</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="配置流程-3">配置流程</h3><ol><li><p><strong>RCC开启APB1总线上的WWDG时钟。</strong></p></li><li><p><strong>设置预分频值，窗口值</strong></p></li><li><p><strong>使能看门狗(带有喂狗值，需要使能的时候喂一下狗)</strong></p></li><li><p><strong>主循环在窗口时间~超时时间内喂狗</strong></p></li></ol><h3 id="按键触发窗口看门狗">按键触发窗口看门狗</h3><blockquote><p><img src="../assets/image-20250112174602385-1737529755594175.png" alt="image-20250112174602385"></p><p><code>设定超时时间50ms</code>：图中看到只能选择最后一个分频系数</p><p>PCLK1的T：1/36M</p><p>4096是进入预分频前对PCLK1的一个分频</p><p>**计算预分频系数：**2的3次方 = 8</p><p><strong>计算T[5:0]写入计数器的值：</strong> 50ms /[(1/36M)*4096 *8] = 54.931640625  = 55(取整) = 54+1</p><p><code>喂狗值：</code>54</p><p><strong>超时时间</strong> = 1/36M * 4096 * 8 * (54+1) = 约为50ms</p><hr><p><img src="../assets/image-20250112180841188-1737529755594176.png" alt="image-20250112180841188"></p><p><code>设定窗口时间为30ms:</code></p><p>PCLK1的T：1/36M</p><p>4096是进入预分频前对PCLK1的一个分频</p><p>计算窗口值W[5:0]：54 - 30ms /[(1/36M)*4096 *8] = 54 - 33(取整) = 21</p><p><code>窗口值：</code> 21</p><p><strong>窗口时间</strong> = 1/36M * 4096 * 8 * (54-33) = 约为30ms</p><hr><p><code>最终我们主循环的喂狗周期为：</code><strong>30ms ~ 50ms</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*模块初始化*/</span></span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">Key_Init();<span class="comment">//按键初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示静态字符串*/</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;WWDG TEST&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断复位信号来源*/</span></span><br><span class="line"><span class="keyword">if</span> (RCC_GetFlagStatus(RCC_FLAG_WWDGRST) == SET)<span class="comment">//如果是窗口看门狗复位</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;WWDGRST&quot;</span>);<span class="comment">//OLED闪烁WWDGRST字符串</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">RCC_ClearFlag();<span class="comment">//清除标志位！！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//否则，即为其他复位</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;RST&quot;</span>);<span class="comment">//OLED闪烁RST字符串</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*1.开启时钟*/</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);<span class="comment">//开启WWDG的时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*WWDG初始化*/</span></span><br><span class="line">WWDG_SetPrescaler(WWDG_Prescaler_8);<span class="comment">//设置预分频为8</span></span><br><span class="line">WWDG_SetWindowValue(<span class="number">21</span> | <span class="number">0x40</span>);<span class="comment">//设置窗口值，窗口时间为30ms</span></span><br><span class="line">WWDG_Enable(<span class="number">54</span> | <span class="number">0x40</span>);<span class="comment">//使能并第一次喂狗，超时时间为50ms</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Key_GetNum();<span class="comment">//调用阻塞式的按键扫描函数，模拟主循环卡死</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*如果把喂狗放在这里的话程序会一直触发看门狗复位，因为距离第一次喂狗时间&lt;30ms，就会触发看门狗复位*/</span></span><br><span class="line">        </span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;FEED&quot;</span>);<span class="comment">//OLED闪烁FEED字符串</span></span><br><span class="line">Delay_ms(<span class="number">20</span>);<span class="comment">//喂狗间隔为20+20=40ms</span></span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;    &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">WWDG_SetCounter(<span class="number">54</span> | <span class="number">0x40</span>);<span class="comment">//重装计数器，喂狗</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>代码中的或上0x40操作：</code></p><p>每次喂狗或上0x40是对计数器的T6位设置为1，避免每次喂狗后立即产生一个复位</p><p>而设置窗口时的或上0x40是为了使W6位也为1，这样才能将该窗口值与喂狗值比较，否则窗口值一直小于喂狗值</p></blockquote><h1>FLASH 闪存</h1><h2 id="FLASH简介">FLASH简介</h2><p><img src="../assets/image-20250112184103510-1737529755594177.png" alt="image-20250112184103510"></p><blockquote><p><img src="../assets/image-20250113122739972-1737529755594178.png" alt="image-20250113122739972"></p><p><code>FLASH：</code>程序存储器、系统存储器、选项字节三部分。</p><p>通过<code>闪存存储器接口(外设)：</code><strong>可以对程序存储器和选项字节进行擦除和编程</strong></p><hr><p><code>读写FLASH的用途：</code></p><ol><li><strong>利用程序存储器Flash的剩余空间来保存掉电不丢失的用户数据</strong></li><li><strong>通过在程序中编程IAP，实现程序的自我更新</strong></li></ol><hr><p><code>在线编程</code>(In-Circuit Programming-ICP)：用于更新程序存储器的全部内容，它通过JTAG、SWD协议或系统加载程序(Bootloader)下载程序</p><p><code>在程序中编程</code>(In-Application Programming-lAP)： 可以使用微制器支持的任一种通信接口下载程序</p><hr><p><code>下图各个流程都是闪存编程参考手册中的内容，可以观看闪存编程手册编程!!!</code></p></blockquote><blockquote><p>当有些参数数据需要掉电不丢失的时候，我们可以将其写入内部FLASH中，这样不用外挂存储器芯片，节省了资源</p></blockquote><h2 id="闪存模块组织">闪存模块组织</h2><p><img src="../assets/image-20250113123459899-1737529755594179.png" alt="image-20250113123459899"></p><blockquote><p><code>闪存三部分：</code></p><p><strong>主存储器</strong>对应：<code>1.程序存储器Flash</code>，起始地址0x0800 0000。也是我们平时说的闪存容量的部分，另外两部分也属于闪存，但不统计进入容量内。</p><p><strong>信息块</strong>：</p><ul><li><p><strong>启动程序代码</strong>对应：<code>2.系统存储器</code>，存放bootloader。起始地址0x1FFF F000</p></li><li><p><strong>用户选择字节</strong>对应：<code>3.选项字节</code>，起始地址0x1FFF F800</p></li></ul><p><strong>闪存存储器接口寄存器(外设)</strong>：从地址来看就是普通的外设寄存器，SRAM的内容</p><hr><p>与W25Q64分为块、扇区、页不同</p><p><strong>内部Flash只有页为基本单位，每页大小为</strong><code>1K</code></p><p>以000、400、800、C00结尾的都一定是页的起始地址。</p><hr><p><code>对于不同容量产品，闪存的分配方式有些区别，参考单独的闪存编程参考手册！！！</code></p></blockquote><h2 id="FLASH基本结构">FLASH基本结构</h2><p><img src="../assets/image-20250113143613020-1737529755594180.png" alt="image-20250113143613020"></p><blockquote><ol><li><p><strong>闪存存储器接口也叫闪存编程和擦除控制器FPEC</strong>。可以对程序存储器擦除和编程、选项字节擦除和编程</p></li><li><p>选项字节可以配置程序存储器的读写保护</p></li></ol></blockquote><h2 id="FLASH解锁">FLASH解锁</h2><p><img src="../assets/image-20250113143920049-1737529755594181.png" alt="image-20250113143920049"></p><blockquote><p><code>FPEC：</code>闪存存储器接口/闪存编程和擦除控制器，其中的键寄存器有三个键值</p><p><strong>通过向键寄存器写入指定值可以解锁FLASH的写操作，对于读操作不用执行解锁操作</strong></p><p><code>解锁方式：</code></p><ol><li>先向FLASH_KEYR写入KEY1</li><li>再向FLASH_KEYR写入KEY2</li></ol><p>保护机制：一旦没有先写入KEY1，再写入KEY2就会锁死，除非复位</p><p><code>加锁方式：</code></p><ol><li>设置FLASH_CR中给的LOCK位锁住FPEC和FLASH_CR</li></ol><p><code>操作闪存方式：</code>先解锁，操作完后，再加锁即可</p></blockquote><h2 id="使用指针访问存储器-指针写入操作">使用指针访问存储器(指针写入操作)</h2><p><img src="../assets/image-20250113144515473-1737529755594182.png" alt="image-20250113144515473"></p><blockquote><p>想以什么形式的方式读出数据，就把uint16_t* 改为对应类型即可，比如想以8位读取，将uint16_t*改为uint8_t*即可</p></blockquote><blockquote><p><code>使用 __IO原因：</code></p><p>当单片机通过指针访问外部硬件设备的寄存器时，<strong>由于这些寄存器的值可能会由硬件自动更新</strong>（例如，一个定时器寄存器的值会随时间变化），因此应该将这些寄存器对应的变量声明为volatile。 这样，每次访问这些变量时，都会直接从硬件寄存器中读取值，而不是使用可能已过时的缓存值。</p></blockquote><h2 id="程序存储器FLASH的擦除和编程">程序存储器FLASH的擦除和编程</h2><p>以下内容对应stm32闪存编写手册的2.3.4节和2.3.3节</p><p><img src="../assets/image-20250113151653732-1737529755594183.png" alt="image-20250113151653732"></p><p><img src="../assets/image-20250113151600875-1737529755594184.png" alt="image-20250113151600875"></p><h3 id="程序存储器FLASH的全擦除">程序存储器FLASH的全擦除</h3><p><img src="../assets/image-20250113145605786-1737529755594185.png" alt="image-20250113145605786"></p><blockquote><p><strong>程序的全擦除在库函数中使用了一个函数，我们可以直接使用，以下就是函数的底层寄存器操作步骤</strong></p><p><code>步骤如下：</code></p><ol><li>读取FLASH_CR的<code>LOCK位</code>，如果锁住了需要先解锁(库函数都是直接解锁)</li><li>置FLASH_CR的<code>MER = 1</code> (MER表示执行的是全擦除)，置FLASH_CR的<code>STRT = 1</code> (STRT为触发条件，置1后芯片开始干活)</li><li>检测FLASH_SR的<code>BSY位是否为1</code>，为1就一直等待，直到BSY位置0后全擦除结束</li></ol><p>读出并验证被擦除页的数据我们可以不管</p></blockquote><h3 id="程序存储器FLASH的页擦除">程序存储器FLASH的页擦除</h3><p><img src="../assets/image-20250113172548064-1737529755594186.png" alt="image-20250113172548064"></p><blockquote><p><strong>程序的页擦除在库函数中使用了一个函数，我们可以直接使用，以下就是函数的底层寄存器操作步骤</strong></p><p><code>步骤如下：</code></p><ol><li><p>读取FLASH_CR的<code>LOCK位</code>，如果锁住了需要先解锁(库函数都是直接解锁)</p></li><li><p>置FLASH_CR的<code>PER = 1</code> (PER表示执行的是页擦除)，</p><p>然后在FLASH_AR中选择要擦除的页，此地址提前写入</p><p>最后置FLASH_CR的<code>STRT = 1</code> (STRT为触发条件，置1后芯片开始干活)</p></li><li><p>检测FLASH_SR的<code>BSY位是否为1</code>，为1就一直等待，直到BSY位置0后全擦除结束</p></li></ol><p>读出并验证被擦除页的数据我们可以不管</p></blockquote><h3 id="程序存储器FLASH编程">程序存储器FLASH编程</h3><p><img src="../assets/image-20250113145516235-1737529755594188.png" alt="image-20250113145516235"></p><blockquote><p><code>注：STM32的闪存会在写入前检查指定地址有没有擦除，如果没有擦除，STM32不执行写入操作，除非写入的全为0!!!</code></p><p><strong>程序的全擦除在库函数中使用了一个函数，我们可以直接使用，以下就是函数的底层寄存器操作步骤</strong></p><p><code>步骤如下：</code></p><ol><li>读取FLASH_CR的<code>LOCK位</code>，如果锁住了需要先解锁(库函数都是直接解锁)</li><li>置FLASH_CR的<code>PG = 1</code> (PG表示执行的是编程操作)</li><li>在指定地址写入半字(16位)，只能以半字写入16位(使用指针写入操作)</li><li>检测FLASH_SR的<code>BSY位是否为1</code>，为1就一直等待，直到BSY位置0后全擦除结束</li></ol><p><code>每次流程只能写入半字，如果想要写入很多字节，只需循环调用上面的步骤即可</code></p><hr><p><code>字、半字、字节：</code></p><p>Word(字)：32位数据</p><p>HalfWord(半字)：16位数据</p><p>Byte(字节)：8位数据</p></blockquote><h2 id="选项字节">选项字节</h2><p><img src="../assets/image-20250113151106010-1737529755594187.png" alt="image-20250113151106010"></p><blockquote><p><code>选项字节：</code>存放独立于程序代码的配置参数</p></blockquote><p><strong>内容对应闪存编程手册2.5节</strong></p><p><img src="../assets/image-20250113151906094-1737529755594189.png" alt="image-20250113151906094"></p><h3 id="选项字节擦除">选项字节擦除</h3><p><img src="../assets/image-20250113151712143-1737529755594190.png" alt="image-20250113151712143"></p><blockquote><ol><li><p>先解锁闪存</p></li><li><p>检查FLASH SR的BSY位，以确认没有其他正在进行的闪存操作</p></li><li><p>解锁FLASH_CR的OPTWRE(Option Write Enable)位，即：对FLASH_OPTKEY写入类似对FLASH_KEYR解锁的两个KEY操作</p></li><li><p>设置FLASH CR的OPTER位为1，设置FLASH CR的STRT位为1</p></li><li><p>等待BSY位变为0，即擦除结束</p></li><li><p>读出被擦除的选择字节并做验证(不必要操作)</p></li></ol></blockquote><h3 id="选项字节的编程">选项字节的编程</h3><p><img src="../assets/image-20250113151403201-1737529755595191.png" alt="image-20250113151403201"></p><blockquote><ol><li><p>先解锁闪存</p></li><li><p>检查FLASH SR的BSY位，以确认没有其他正在进行的闪存操作</p></li><li><p>解锁FLASH_CR的OPTWRE(Option Write Enable)位，即：对FLASH_OPTKEY写入类似对FLASH_KEYR解锁的两个KEY操作</p></li><li><p>设置FLASH CR的OPTPG位为1</p></li><li><p>写入要编程的半字到指定地址</p></li><li><p>等待BSY位变为0，即写入结束</p></li><li><p>读出被擦除的选择字节并做验证(不必要操作)</p></li></ol></blockquote><h2 id="器件电子签名">器件电子签名</h2><p><img src="../assets/image-20250113152633326-1737529755595192.png" alt="image-20250113152633326"></p><blockquote><p><code>器件电子签名相关内容对应参考手册第28章的内容!!!</code></p><p><strong>电子签名其实就是芯片ID号</strong></p><p>**存放在系统存储器区域：**包含BootLoader和几个字节的电子签名</p><p><img src="../assets/image-20250113152728389-1737529755595193.png" alt="image-20250113152728389"></p></blockquote><h2 id="FLASH-库函数">FLASH 库函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*stm32f10x_flash.h*/</span></span><br><span class="line"><span class="comment">/*------------ Functions used for all STM32F10x devices -----*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_SetLatency</span><span class="params">(<span class="type">uint32_t</span> FLASH_Latency)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_HalfCycleAccessCmd</span><span class="params">(<span class="type">uint32_t</span> FLASH_HalfCycleAccess)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_PrefetchBufferCmd</span><span class="params">(<span class="type">uint32_t</span> FLASH_PrefetchBuffer)</span>;</span><br><span class="line">FlagStatus <span class="title function_">FLASH_GetPrefetchBufferStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*内核运行代码相关，我们不需要使用*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*加锁解锁：*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_Unlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_Lock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//芯片的加锁和解锁，KEY1,KEY2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*芯片擦除：*/</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ErasePage</span><span class="params">(<span class="type">uint32_t</span> Page_Address)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseAllPages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseOptionBytes</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//分别是页擦除、全擦除、选项字节擦除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*芯片写入(编程):*/</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ProgramWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint32_t</span> Data)</span>;<span class="comment">//指定地址写入字</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ProgramHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint16_t</span> Data)</span>;<span class="comment">////指定地址写入半字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*选项字节读写相关:*/</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ProgramOptionByteData</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint8_t</span> Data)</span>;<span class="comment">//选项字节写入Data</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EnableWriteProtection</span><span class="params">(<span class="type">uint32_t</span> FLASH_Pages)</span>;<span class="comment">//选项字节写保护使能</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_ReadOutProtection</span><span class="params">(FunctionalState NewState)</span>;<span class="comment">//选项字节都保护</span></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_UserOptionByteConfig</span><span class="params">(<span class="type">uint16_t</span> OB_IWDG, <span class="type">uint16_t</span> OB_STOP, <span class="type">uint16_t</span> OB_STDBY)</span>;<span class="comment">//用户选项的三个配置位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*选项字节状态获取：*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">FLASH_GetUserOptionByte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">FLASH_GetWriteProtectionOptionByte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FlagStatus <span class="title function_">FLASH_GetReadOutProtectionStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标志位相关*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_ITConfig</span><span class="params">(<span class="type">uint32_t</span> FLASH_IT, FunctionalState NewState)</span>;</span><br><span class="line">FlagStatus <span class="title function_">FLASH_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> FLASH_FLAG)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> FLASH_FLAG)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_GetStatus</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">FLASH_Status <span class="title function_">FLASH_WaitForLastOperation</span><span class="params">(<span class="type">uint32_t</span> Timeout)</span>;<span class="comment">//等待上一次操作，也就是等待BSY为0，在上面读写擦除的库函数内部已经调用了，我们不需要调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--我们这里用不到下面的函数</span><br><span class="line"><span class="comment">/*------------ New function used for all STM32F10x devices -----*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_UnlockBank1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_LockBank1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseAllBank1Pages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_GetBank1Status</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_WaitForLastBank1Operation</span><span class="params">(<span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> STM32F10X_XL</span></span><br><span class="line"><span class="comment">/*---- New Functions used only with STM32F10x_XL density devices -----*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_UnlockBank2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_LockBank2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_EraseAllBank2Pages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_GetBank2Status</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_WaitForLastBank2Operation</span><span class="params">(<span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line">FLASH_Status <span class="title function_">FLASH_BootConfig</span><span class="params">(<span class="type">uint16_t</span> FLASH_BOOT)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上面三个库函数分为部分：<strong>通用函数、新加的通用函数、新加的只能被大容量XL系列使用的函数</strong></p><p>图中的Bank2是后面新推出加大容量XL系列新加的一块Flash</p></blockquote><h2 id="实验">实验</h2><h3 id="简单读写FLASH-FLASH底层代码实现">简单读写FLASH(FLASH底层代码实现)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取一个字32bit</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">MyFlash_ReadWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span>  *((__IO <span class="type">uint32_t</span>*)(Address));<span class="comment">////使用指针访问指定地址下的数据并返回</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取半字16bit</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">MyFlash_ReadHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span>  *((__IO <span class="type">uint16_t</span>*)(Address));<span class="comment">//使用指针访问指定地址下的数据并返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将32位地址强转为指向uint16_t数据的指针，Address值也就是该指针不会变，仅仅将这个指针(地址)指向的数据变为了uint16_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字节8bit</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyFlash_ReadByte</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span>  *((__IO <span class="type">uint8_t</span>*)(Address));<span class="comment">//使用指针访问指定地址下的数据并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_EraseAllPages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">FLASH_EraseAllPages();<span class="comment">//全擦除</span></span><br><span class="line">FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ErasePage</span><span class="params">(<span class="type">uint32_t</span> Page_Address)</span></span><br><span class="line">&#123;</span><br><span class="line">FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">FLASH_ErasePage(Page_Address);<span class="comment">//全擦除</span></span><br><span class="line">FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选项字节擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFLash_EraseOptionBytes</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">FLASH_EraseOptionBytes();<span class="comment">//全擦除</span></span><br><span class="line">  FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入字32bit</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint32_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">FLASH_ProgramWord(Address, Data);<span class="comment">//编程字</span></span><br><span class="line">FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入半字16bit</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint16_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">FLASH_Unlock();<span class="comment">//解锁</span></span><br><span class="line">FLASH_ProgramHalfWord(Address, Data);<span class="comment">//编程半字</span></span><br><span class="line">FLASH_Lock();<span class="comment">//加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*MyFlash.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYFLASH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYFLASH_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">MyFlash_ReadWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">MyFlash_ReadHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyFlash_ReadByte</span><span class="params">(<span class="type">uint32_t</span> Address)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_EraseAllPages</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ErasePage</span><span class="params">(<span class="type">uint32_t</span> Page_Address)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFLash_EraseOptionBytes</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint32_t</span> Data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFlash_ProgramHalfWord</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint16_t</span> Data)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyFlash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> data1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> data2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> data3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyFlash_ErasePage(<span class="number">0x0800FC00</span>);<span class="comment">//写入前要先擦除，写入区域</span></span><br><span class="line"></span><br><span class="line">MyFlash_ProgramWord(<span class="number">0x0800FC00</span>,<span class="number">0x12345678</span>);<span class="comment">//写入Flash最后的区域一个字,数据为0x12345678</span></span><br><span class="line">      MyFlash_ProgramHalfWord(<span class="number">0x0800FC10</span>,<span class="number">0xABCD</span>);<span class="comment">//写入半个字，数据为0xABCD</span></span><br><span class="line">      </span><br><span class="line">    data1 = MyFlash_ReadWord(<span class="number">0x0800FC00</span>);</span><br><span class="line">data2 = MyFlash_ReadHalfWord(<span class="number">0x0800FC00</span>);</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最终读取的结果如下keil变量的值，以及内存中的值如图</p><p><strong>我们也可以使用STM32 ST-LINK Utility软件直接观察</strong></p></blockquote><p><img src="../assets/image-20250113194907167-1737529755595195.png" alt="image-20250113194907167"></p><p><img src="../assets/image-20250113194929798-1737529755595194.png" alt="image-20250113194929798"></p><h3 id="在SRAM中定义数组和标志位对FLASH数据存储">在SRAM中定义数组和标志位对FLASH数据存储</h3><blockquote><p><strong>在SRAM定义数组写入数据到FLASH，并且实现上电FLASH数据读取到SRAM操作</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*store.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STORE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STORE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint16_t</span> Store_Data[]; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Save</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*store.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyFLASH.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*对于这种在很多地方出现，对应不同芯片有不同值得数据我们使用宏定义，提高程序的复用*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORE_START_ADDRESS0x0800FC00<span class="comment">//存储的起始地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORE_COUNT512<span class="comment">//存储数据的个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> Store_Data[STORE_COUNT];<span class="comment">//定义SRAM数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块初始化</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*地址的第一个半字存储标志位以此判断是不是第一次使用,*/</span></span><br><span class="line"><span class="keyword">if</span> (MyFLASH_ReadHalfWord(STORE_START_ADDRESS) != <span class="number">0xA5A5</span>)<span class="comment">//读取第一个半字的标志位，if成立，则执行第一次使用的初始化</span></span><br><span class="line">&#123;</span><br><span class="line">MyFLASH_ErasePage(STORE_START_ADDRESS);<span class="comment">//擦除指定页</span></span><br><span class="line">MyFLASH_ProgramHalfWord(STORE_START_ADDRESS, <span class="number">0xA5A5</span>);<span class="comment">//在第一个半字写入自己规定的标志位，用于判断是不是第一次使用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">1</span>; i &lt; STORE_COUNT; i ++)<span class="comment">//循环STORE_COUNT次，除了第一个标志位</span></span><br><span class="line">&#123;</span><br><span class="line">MyFLASH_ProgramHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>, <span class="number">0x0000</span>);<span class="comment">//除了标志位的有效数据全部清0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上电时，将闪存数据加载回SRAM数组，实现SRAM数组的掉电不丢失*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; STORE_COUNT; i ++)<span class="comment">//循环STORE_COUNT次，包括第一个标志位</span></span><br><span class="line">&#123;</span><br><span class="line">Store_Data[i] = MyFLASH_ReadHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>);<span class="comment">//将闪存的数据加载回SRAM数组</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块保存数据到闪存</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Save</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MyFLASH_ErasePage(STORE_START_ADDRESS);<span class="comment">//擦除指定页</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; STORE_COUNT; i ++)<span class="comment">//循环STORE_COUNT次，包括第一个标志位</span></span><br><span class="line">&#123;</span><br><span class="line">MyFLASH_ProgramHalfWord(STORE_START_ADDRESS + i * <span class="number">2</span>, Store_Data[i]);<span class="comment">//将SRAM数组的数据备份保存到闪存</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函    数：参数存储模块将所有有效数据清0</span></span><br><span class="line"><span class="comment">  * 参    数：无</span></span><br><span class="line"><span class="comment">  * 返 回 值：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Store_Clear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">1</span>; i &lt; STORE_COUNT; i ++)<span class="comment">//循环STORE_COUNT次，除了第一个标志位</span></span><br><span class="line">&#123;</span><br><span class="line">Store_Data[i] = <span class="number">0x0000</span>;<span class="comment">//SRAM数组有效数据清0</span></span><br><span class="line">&#125;</span><br><span class="line">Store_Save();<span class="comment">//保存数据到闪存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Store.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> KeyNum;<span class="comment">//定义用于接收按键键码的变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*模块初始化*/</span></span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line">Key_Init();<span class="comment">//按键初始化</span></span><br><span class="line">Store_Init();<span class="comment">//参数存储模块初始化，在上电的时候将闪存的数据加载回Store_Data，实现掉电不丢失</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*显示静态字符串*/</span></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Flag:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Data:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KeyNum = Key_GetNum();<span class="comment">//获取按键键码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (KeyNum == <span class="number">1</span>)<span class="comment">//按键1按下</span></span><br><span class="line">&#123;</span><br><span class="line">Store_Data[<span class="number">1</span>] ++;<span class="comment">//变换测试数据</span></span><br><span class="line">Store_Data[<span class="number">2</span>] += <span class="number">2</span>;</span><br><span class="line">Store_Data[<span class="number">3</span>] += <span class="number">3</span>;</span><br><span class="line">Store_Data[<span class="number">4</span>] += <span class="number">4</span>;</span><br><span class="line">Store_Save();<span class="comment">//将Store_Data的数据备份保存到闪存，实现掉电不丢失</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (KeyNum == <span class="number">2</span>)<span class="comment">//按键2按下</span></span><br><span class="line">&#123;</span><br><span class="line">Store_Clear();<span class="comment">//将Store_Data的数据全部清0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">6</span>, Store_Data[<span class="number">0</span>], <span class="number">4</span>);<span class="comment">//显示Store_Data的第一位标志位</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>, <span class="number">1</span>, Store_Data[<span class="number">1</span>], <span class="number">4</span>);<span class="comment">//显示Store_Data的有效存储数据</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>, <span class="number">6</span>, Store_Data[<span class="number">2</span>], <span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, Store_Data[<span class="number">3</span>], <span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">6</span>, Store_Data[<span class="number">4</span>], <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>实现按键1按下存入FLASH中，按键2按下清除数据</p></blockquote><h3 id="读取芯片ID-使用指针直接访问读取">读取芯片ID(使用指针直接访问读取)</h3><p><img src="../assets/image-20250113152633326-1737529755595192.png" alt="image-20250113152633326"></p><p><code>对应手册28章内容：</code></p><p><img src="../assets/image-20250113204952775-1737529755595196.png" alt="image-20250113204952775"></p><p><img src="../assets/image-20250113205028352-1737529755595197.png" alt="image-20250113205028352"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();<span class="comment">//OLED初始化</span></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;F_SIZE:&quot;</span>);<span class="comment">//显示静态字符串</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, *((__IO <span class="type">uint16_t</span> *)(<span class="number">0x1FFFF7E0</span>)), <span class="number">4</span>);<span class="comment">//使用指针读取指定地址下的闪存容量寄存器</span></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;U_ID:&quot;</span>);<span class="comment">//显示静态字符串</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">6</span>, *((__IO <span class="type">uint16_t</span> *)(<span class="number">0x1FFFF7E8</span>)), <span class="number">4</span>);<span class="comment">//使用指针读取指定地址下的产品唯一身份标识寄存器</span></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">11</span>, *((__IO <span class="type">uint16_t</span> *)(<span class="number">0x1FFFF7E8</span> + <span class="number">0x02</span>)), <span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>, <span class="number">1</span>, *((__IO <span class="type">uint32_t</span> *)(<span class="number">0x1FFFF7E8</span> + <span class="number">0x04</span>)), <span class="number">8</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, *((__IO <span class="type">uint32_t</span> *)(<span class="number">0x1FFFF7E8</span> + <span class="number">0x08</span>)), <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>**闪存容量寄存器：**使用半字读取</p><p>**产品唯一身份标识寄存器：**2个半字和2个字读取</p><p>全部显示到OLED上去</p></blockquote><h2 id="存在的BUG-当程序很大时覆盖用户存储参数区">存在的BUG-当程序很大时覆盖用户存储参数区</h2><p><code>问题描述：</code></p><p><strong>我们上面由于程序较小，程序存储在Flash的靠前区域，我们使用最后一页存储用户数据，但是如果程序很大的时候，可能就会到最后一页，造成程序和用户数据存储的位置冲突。</strong></p><p><code>解决方法：</code>给程序文件限定一个存储范围，不让它分配到后面我们的用户数据空间来。</p><ol><li><strong>打开工程管理</strong></li></ol><p><img src="../assets/image-20250113203529438-1737529755595198.png" alt="image-20250113203529438"></p><ol start="2"><li><strong>目前使用的是起始地址为0x80000000，Size大小为0x10000(64KB)，刚好使用完了程序存储区</strong></li></ol><p><img src="../assets/image-20250113203606973-1737529755595199.png" alt="image-20250113203606973"></p><ol start="3"><li><strong>如果我们想把程序区的最后自己使用，修改Size为0xFC00，这样到FC00之前就是程序存储的地方，后面地址我们可以自己存放用户参数</strong></li></ol><p><img src="../assets/image-20250113203950691-1737529755595200.png" alt="image-20250113203950691"></p><blockquote><p>注意修改size大小不能太小，太小了也会报错</p></blockquote><h2 id="Flash写入之前的擦除必要性">Flash写入之前的擦除必要性</h2><p><strong>1.Flash 默认状态是“全 1”</strong>：</p><ul><li>Flash 存储器在擦除之前的默认值是“1”，即每个字节的每一位都设为 1。当你想要写入数据时，必须将目标区域从“1”改为“0”。但是 Flash 存储器并不支持直接将 “0” 恢复为 “1”，只能将其设置为“0”。</li></ul><p><strong>2.擦除是将区域复位为“全 1”</strong>：</p><ul><li>擦除操作是将整个存储单元（如页面或扇区）恢复为“全 1”状态，为后续的写入做好准备。只有当区域恢复为全 1 后，才能写入新的数据。</li></ul><p><strong>3.Flash 的写入操作是“增量”</strong>：</p><ul><li>你可以在一个已擦除区域中写入数据，但不能直接覆盖其中的</li></ul><h2 id="STM32-ST-LINK-Utility">STM32 ST-LINK Utility</h2><p><img src="../assets/image-20250113171621586-1737529755595201.png" alt="image-20250113171621586"></p><blockquote><p>我们可以使用STM32 ST-LINK Utility这个软件直接查看和修改我们芯片内部的各个地址的内容。</p><p>关于上方的内部FLASH和选项字节模块对应都可以查看和修改</p><p>使用代码配置读写保护时如果造成了芯片自锁，但程序里没有预留解除写保护的代码，造成没法下载程序了，我们可以使用这个这个软件直接去掉读写保护就可以解除芯片的自锁。</p></blockquote>]]></content>
    
    
    <summary type="html">STM32标准库笔记</summary>
    
    
    
    <category term="嵌入式" scheme="https://www.thekqd.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="https://www.thekqd.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="https://www.thekqd.top/posts/ad4f1e09.html"/>
    <id>https://www.thekqd.top/posts/ad4f1e09.html</id>
    <published>2024-02-21T10:16:23.000Z</published>
    <updated>2025-01-22T07:00:55.129Z</updated>
    
    <content type="html"><![CDATA[<h1>C++学习笔记：</h1><h2 id="名称空间std">名称空间std</h2><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113132517924.png" alt="image-20221113132517924"></p><p>&lt;math.h&gt;新式为<cmath></p><p>&lt;string.h&gt;新式为<cstring></p><p>如果使用iostream，而不是iostream.h，即当头文件中没有扩展名h时，iostream中定义的用于输出的cout变量实际是<strong>std::cout</strong>,而endl实际上是<strong>std::endl</strong>.因此，可以省略编译指令using，用下述方式进行编码:</p><p>std::cout&lt;&lt;&quot; xxxxxx&quot;;</p><p>std::cout&lt;&lt;std::endl;</p><p>但如果使用using编译指令:<strong>using namespace std;</strong></p><p><strong>便可以直接使用cin和cout…，而不必加上std::前缀</strong></p><h2 id="控制符endl">控制符endl</h2><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113133422849.png" alt="image-20221113133422849"></p><p><strong>C++中的旧版换行采用的是&quot;\n</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113133633328.png" alt="image-20221113133633328"></p><h2 id="cin和cout">cin和cout</h2><p><strong>（1）.</strong><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113135231199.png" alt="image-20221113135231199"></p><p><strong>（2）.</strong></p><p><strong>输出可以拼接:</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113140118344.png" alt="image-20221113140118344">**</p><h2 id="每次读取一行字符串-string-输入">每次读取一行字符串(string)输入</h2><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113193250853.png" alt="image-20221113193250853"></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113194203451.png" alt="image-20221113194203451"></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113194311275.png" alt="image-20221113194311275"></p><h2 id="总结">总结:</h2><p><strong>1.cin(&gt;&gt;)</strong></p><p>虽然可以使用 cin 和 &gt;&gt; 来输入字符串，当 cin 读取数据时，<strong>一旦它接触到第一个非空格字符即开始阅读，当它读取到下一个空白字符时，它将停止读取。</strong></p><p>可以输入 “Mark” 或 “Twain”，但不能输入 “Mark (停止读取)  Twain”，<br><strong>因为 cin 不能输入包含嵌入空格的字符串。</strong></p><p><strong>2.cin.get(char ch)/(array_name,size)</strong></p><p>无参数时，读入一个字符，包括换行符，常用来处理输入缓冲区中的换行符。</p><p>有参数时，从缓冲区读取数据，到达行尾或size-1个字符**(剩下的空间储存在结尾添加的空字符)**后结束读取(超过规定字符数不会出现错误,会直接截断)，不会对换行符进行处理，将其留在缓冲区</p><p><strong>3.cin.getline(array_name,size)</strong></p><p>从缓冲区读取数据,到达行尾或size-1**(剩下的空间储存在结尾添加的空字符)**个字符结束读取(超过规定的字符数会出现错误,中断)，会读取换行符将其替换为空字符，并且丢弃。</p><p>**4.getline(cin,array_name） **/  <strong>std::getline(std::cin,array_name)</strong></p><p>例如：getline(cin,str);</p><p>从缓冲区中读取数据，遇到换行符时将其替换为空字符，并且丢弃。</p><h2 id="补">补:</h2><p><strong>(1)cin.getline(char*s,streamsize n,char delim)</strong></p><p>所需的头文件为<iostream>(这里的参数char s是输入的字符串变量， n是输入字符串的字符个数（第n个补’\0’）， delim是输入终止条件，即遇到delim所代表的字符就终止输入,正常使用时 char delim可以省略，c++语言默认为’\0’)   例 :   cin.getline(name,20,‘C’)或cin.getline(name,20)</p><p><strong>(2)getline(istream&amp; is, string&amp; str, char delim)</strong></p><p>所需的头文件为<string>(s是标准输入流函数， str是用来存字符的变量名， delim是结束标志,作用与cin.getline()里的相同）例: getline(cin,str,‘A’)</p><p>==<strong>注:</strong> <strong>getline()是string流的函数，只能用于string类型(不能用于输入char*类型)的输入操作.</strong>==</p><p>==<strong>cin.getline()是std流的函数，只能用于char*类型的输入操作（不能用于string类型输入）</strong>。==       <strong>char*为数组</strong></p><p><strong>当你定义了一个char*类型变量，只能用cin/cin.getline()输入。！！！！！</strong></p><p>**(3).**在使用getline读入一整行时，<br>若是前面是使用getchar()、cin这类读入了一个字母，<br>但是不会读入后续换行\n符号或者空格的输入时，再接getline()就容易出现问题。</p><p>这是因为输入数字之后，敲回车，产生的换行符仍然滞留在输入流了，<br>接着就被getline(cin,s)给读进去了，<br>此时的s=“\n”,所以实际上s只是读入了一个换行符\n。</p><p>而若是前面使用getline()，再又用getline()进行读入，此时不会发生问题。<br><strong>getline()中读入结束的回车后，结束符不放入缓存区，会将读入的\n直接去除，</strong><br><strong>下一个输入前，缓冲区为空，并不会因为回车留下\n。</strong></p><p>而cin的结束后，以及getchar()此类的读入结束后,按下回车或者使用空格读入下一个，<br>此时按下的回车或空格会还在缓存区,继续用getline()就会出现前面所提到的情况。<br>那么如何解决前面用了cin、getchar()后的输入呢？<br><strong>可以直接在cin和getchar()后使用一个getchar()吃掉接下来的换行.</strong></p><h1>string类(头文件&quot;string&quot;)</h1><p><strong>1.</strong><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202153066.png" alt="image-20221113202153066"></p><p><strong>2.</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202108337.png" alt="image-20221113202108337"></p><p><strong>3.数组和string类的不同点:</strong></p><p>**(1)**在数组中，不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象。</p><p>**(2)**可以使用+让两个string对象合并起来，还可以使用+=将字符串附加到string对象的末尾。</p><p>同时可以对字符串实现运算符（==，=），可以直接比较</p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202543882.png" alt="image-20221113202543882"></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202618980.png" alt=""></p><p><strong>4.用getline将输入读取到string对象</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221113202709793.png" alt="image-20221113202709793"></p><h2 id="补：获取字符串长度">补：获取字符串长度</h2><p><strong>1.length()函数</strong><br>直接获取字符串长度，包括空格在内</p><p>表示方法:    **str.length()**即可表示str字符串的长度</p><p><strong>2.strlen()函数</strong><br>需要添加头文件&lt;string.h&gt;,而且<strong>参数只能是char数组</strong>（不能是string类）<br>而且结尾必须是\0(即字符数组不能满，因为满了结尾就不是\0，会接着向下检索到\0为止)<br>啊哦char c[6]{“kunkun”}; 这样是错误的嗷 直接没法进行编译，编译器直接帮我们解决问题2。</p><p>表示方法：  <strong>strlen(数组名)</strong></p><p><strong>3.size()</strong></p><p>需要添加&lt;string.h&gt;头文件，用法类似于length()。<br>size()表示的是string这个容器中的元素个数。（还可以获取vector类型的长度）<br>如果使用过std::vector之类的容器的话，可以把string看做是一个vector(这里只是举例，并不能等价)， char就是这个容器的元素类型。那么size()表示的就是这个vector(容器)中char的个数。<br>表示方法:</p><p>**str.size()**即可表示str字符串的长度（不包含’\0’）</p><h1>数组的替代品</h1><p><strong>具体见CSDN</strong></p><h2 id="模板类vector">模板类vector</h2><ul><li><p>vector是向量类型，可以容纳许多类型的数据，因此也被称为容器</p></li><li><p>(可以理解为<strong>动态数组</strong>，是封装好了的类）</p></li><li><p>进行<code>vector</code>操作前应添加头文件<code>#include &lt;vector&gt;</code></p></li><li><p>.2 vector初始化：<br>方式1.</p><p>定义具有10个整型元素的向量（尖括号为元素类型名，它可以是任何合法的数据类型），不具有初值，其值不确定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>方式2.</p><p>定义具有10个整型元素的向量，且给出的每个元素初值为1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">10</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>方式3.</p><p>用向量b给向量a赋值，a的值完全等价于b的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b);</span><br></pre></td></tr></table></figure><p>方式4.</p><p>将向量b中从0-2（共三个）的元素赋值给a，a的类型为int型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(b.<span class="built_in">begin</span>(),b.begin+<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>方式5.</p><p>//从数组中获得初值<br>int b[7]={1,2,3,4,5,6,7};</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>）;</span></span></span><br></pre></td></tr></table></figure><h4 id="1-3-vector对象的常用内置函数使用（举例说明）">1.3 vector对象的常用内置函数使用（举例说明）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a,b;</span><br><span class="line"><span class="comment">//b为向量，将b的0-2个元素赋值给向量a</span></span><br><span class="line">a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//a含有4个值为2的元素</span></span><br><span class="line">a.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//返回a的最后一个元素</span></span><br><span class="line">a.<span class="built_in">back</span>();</span><br><span class="line"><span class="comment">//返回a的第一个元素</span></span><br><span class="line">a.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//返回a的第i元素,当且仅当a存在</span></span><br><span class="line">a[i];</span><br><span class="line"><span class="comment">//清空a中的元素</span></span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//判断a是否为空，空则返回true，非空则返回false</span></span><br><span class="line">a.<span class="built_in">empty</span>();</span><br><span class="line"><span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">a.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入数值5,</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//在a的第一个元素（从第0个算起）位置插入3个数，其值都为5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//b为数组，在a的第一个元素（从第0个元素算起）的位置插入b的第三个元素到第5个元素（不包括b+6）</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>);</span><br><span class="line"><span class="comment">//返回a中元素的个数</span></span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">a.<span class="built_in">capacity</span>();</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值随机</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//将a的现有元素个数调整至10个，多则删，少则补，其值为2</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//将a的容量扩充至100，</span></span><br><span class="line">a.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//b为向量，将a中的元素和b中的元素整体交换</span></span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">//b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt;</span></span><br><span class="line">a==b;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="size">size()</h2><p>C++中，在获取<strong>字符串长度</strong>时，size()函数与length()函数作用相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;str.<span class="built_in">length</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><strong>size()函数以及length()函数</strong>都用于计算字符串（string）长度，不能用char*作为参数。除此之外，size()函数还可以获取vector类型的长度。</p><p>size()函数返回值为unsigned int 类型为正数</p><p>注意 让其作为返回值赋给变量时，变量类型要为<br>unsigned int 或 size_t型</p><p>补:<strong>size_t</strong></p><p><strong>size_t</strong> 是一些C/C++标准在stddef.h中定义的，size_t 类型表示C中任何对象所能达到的最大长度，它是无符号整数。</p><p>32位上的定义:  等价于 unsigned int</p><p>64位上的定义:  等价于 unsigned long</p><h2 id="empty">empty()</h2><p>C++中empty()作为判断容器是否为空的函数</p><p>用法为 <strong>对象名.empty()</strong>    例: <strong>s.empty()</strong></p><p><strong>如果对象为空就返回1(ture)，</strong></p><p><strong>不为空返回0(false)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;&quot;</span>；</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; “字符串为空”;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串不为空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="swap-swap-交换">swap()         swap(交换)</h2><p><strong>具体见CSDN</strong></p><p>标准库的<strong>C ++中</strong>的<code>swap()</code>函数是一个在两个<strong>相同类型</strong>的给定变量之间直接交换值的函数。<strong>元素个数不相等也可以进行交换</strong></p><p>用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">swap</span>(a,b);</span><br></pre></td></tr></table></figure><h2 id="insert-insert-插入">insert()      insert(插入)</h2><p><strong>对象.insert()</strong></p><p><strong>几种用法:</strong>         <strong>下标（索引）都是默认从第0个位置开始（第0个位置，第1个位置）</strong></p><p><strong>1、在第index位置插入count个字符c----&gt;str.insert(index,count,c);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;012356789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;<span class="number">012356789</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="number">1</span>,<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串----&gt;&quot;</span>  &lt;&lt; str &lt;&lt; endl;  <span class="number">0123456789</span></span><br></pre></td></tr></table></figure><p><strong>2、在第index位置插入一个常量字符串----&gt;str.insert(index,str);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;0156789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;  <span class="number">0156789</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">2</span>,<span class="string">&quot;234&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;   <span class="number">0123456789</span></span><br></pre></td></tr></table></figure><p><strong>3、第index位置插入常量字符串str中的count个字符----&gt;str.insert(index,str,count);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;456789&quot;</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl; <span class="number">0123456789</span></span><br></pre></td></tr></table></figure><p>4、<strong>第index位置插入常量str----&gt;str.insert(index,str);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;45&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl; <span class="number">0123456789</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5、第index位置插入常量str的从index_str开始的count个字符----&gt;str.insert(index,str,index_str,count);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;2345678&quot;</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;   <span class="number">0123456789</span></span><br></pre></td></tr></table></figure><p><strong>6、index位置插入常量str从index_str开始以后的字符串----&gt;str.insert(index,str,index_str,string::npos);</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;01236789&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入前的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="string">&quot;012345&quot;</span>,<span class="number">4</span>,string::npos);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;插入后的字符串-----&gt;&quot;</span> &lt;&lt; str &lt;&lt; endl;  <span class="number">0123456789</span></span><br></pre></td></tr></table></figure><h1>NULL和nullptr</h1><p>c中用NULL表示空指针</p><p>但在c++中用nullptr表示空指针，把NULL当作0来使用</p><p><strong>具体的见CSDN</strong></p><h2 id="对类的定义：">对类的定义：</h2><p><strong>首先用class+标记名对类进行定义</strong>：<strong>1.private部分，2.public部分</strong></p><p><strong>(1)private</strong>中的数据为隐藏数据（通常是变量），只能通过public中的成员函数对其进行访问，外部没有访问权力。</p><p><strong>(2)public</strong>中通常是成员函数，可以在成员函数中访问该类的private中的数据，<strong>通常只在里面声明函数原型,在其他地方定义</strong>（此处用的链表，链表的下一个结点）</p><p>**注：**访问成员函数要作用域解析符 <strong>: :</strong>  ，格式为 : <strong>类标记名+ : : + 函数名</strong>   <strong>尤其是在定义时</strong> 例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Input</span><span class="params">()</span></span>&#123;<span class="comment">//定义一个全新的函数Input,不是成员函数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Classroom::Input</span><span class="params">()</span></span>&#123;<span class="comment">//对成员函数进行定义</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处用了友元类，具体见笔记</p><h2 id="类对象（变量）的创建">类对象（变量）的创建</h2><p><strong>标记名 + 对象名</strong> 例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classroom</span>&#123;</span></span><br><span class="line">    private：</span><br><span class="line">        </span><br><span class="line">    public：</span><br><span class="line">        <span class="type">void</span> <span class="title function_">Input</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br><span class="line">Classroom a<span class="comment">//创建一个Classroom类的对象a</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Classroom::Input();<span class="comment">//错误写法</span></span><br><span class="line">    a.Input()<span class="comment">//正确写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重点！！   注意：在调用成员函数之前，必须创建对象,不能直接像定义成员函数那样调用成员函数.   如上方</strong></p><p><strong>调用成员函数的方式是通过 点关系符 ”  .  “</strong></p><p>！！！！ <strong>类访问==成员函数==时用&quot;.&quot;访问,并且如果没有参数访问的时候必须带上后面的括号，否则认为访问的是变量；</strong></p><p>格式为：   <strong>对象名 . 函数名()</strong></p><p><strong>例如:       a.Input();</strong></p><p><strong>下为类对象（变量）在学生管理程序中使用：</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221120220212245.png" alt="image-20221120220212245"></p><h2 id="new和delete">new和delete</h2><p><strong>该处以链表+类为例：</strong></p><p>![image-20221120200903909](E:\！！！！Markdown\C++.assets\image-20221120200903909.png![image-20221120202508583](E:\！！！！Markdown\C++.assets\image-20221120202508583.png<img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221120202614633.png" alt="image-20221120202614633"></p><h3 id="1-New">1.New</h3><p>（1）用malloc分配内存时需要头文件cstdlib,但是new 不需要引用新的头文件。</p><p>（2）new为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配的内存</p><p>通用格式如下：<strong>typename * pointer_name = new typeName</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);<span class="comment">//申请了一个初值为10的整型数据,括号中为初始化的值</span></span><br><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//申请了能存放10个整型数据元素的数组，其首地址为arr</span></span><br></pre></td></tr></table></figure><p>注意:</p><p>*<em>int <em>p=new int 此时解引用p的值将会是一个随机值，未初始化。</em></em></p><p>*<em>int <em>p=new int() 此时括号里为空，解引用p的值将自动初始化为0</em></em></p><p>此处文件中<strong>current</strong> 是一个指针 ，<strong>Student</strong>是类标记，<strong>new + 类型名 返回的值是一个地址</strong></p><p>（3）new 从被称为<strong>堆</strong>或<strong>自由储存区</strong>的内存区域分配内存，除了主动释放外不会被回收。而局部变量通常储存在<strong>栈</strong>的内存区域中</p><h3 id="2-Delete">2.Delete</h3><p><strong>delete 用来释放new分配的内存</strong></p><p>通常    delete + 指针名    即可（注意:delete不一定使用用于new的指针，而是用于new的地址）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p；</span><br><span class="line"><span class="keyword">delete</span>[] arr;<span class="comment">//注意要删除数组时，需要加[]，以表示arr为数组。</span></span><br></pre></td></tr></table></figure><p><strong>使用new 和 delete 应该遵守以下规则：</strong></p><p>1.不要使用delete来释放不是new分配的内存。</p><p>2.不要使用delete来释放同一个内存块两次。</p><p>3.如果使用new [ ]为数组分配内存，则应该使用delete [ ]来释放</p><p>4.如果使用new为一个实体分配内存，则应该使用delete（没有方括号）来释放。</p><p>5.对空指针使用delete是安全的。</p><h2 id="C-中文件的输入输出">C++中文件的输入输出</h2><h3 id="写入到文本文件中">写入到文本文件中</h3><p>==要求==：</p><p><strong>1.包含头文件iostream，</strong></p><p><strong>包含头文件fstream</strong></p><p><strong>iostream: 头文件中定义了一个处理输出的ostream类</strong></p><p><strong>fstream：头文件定义了一个用于处理输出的ofstream类</strong></p><p><strong>2.<strong>声明一个或多个</strong>ofstream</strong>（<strong>output fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为outFile</strong></p><p>**3.**必须指明名称空间std，为引用ofstream，必须使用编译指令using或者前缀的std：：</p><p>**4.**将ofstream对象与文件关联起来。为此，方法之一是使用open()方法</p><p>**5.**使用完文件后，应使用close()将其关闭</p><p>**6.**可结合ofstream对象 和运算符&lt;&lt;来输出各种类型的数据。</p><p>**总结：**文件的输出主要步骤如下:</p><p>1.包含头文件fstream</p><p>2.创建一个ofstream（output fstream）对象（<strong>通常取名为outFile</strong>）</p><p>3.将该ofstream 对象同一个文件关联起来。</p><p>**4.向cout那样使用ofstream对象（通常outFile）**重点：<strong>cout在屏幕上输出，而outFile是在文件中输出（写入）</strong></p><p><strong>例子见下方</strong></p><h3 id="从文本文件中读取数据">从文本文件中读取数据</h3><p>==要求==：</p><p><strong>1.包含头文件iostream，包含头文件fstream</strong></p><p><strong>iostream: 头文件中定义了一个处理输出的istream类</strong></p><p><strong>fstream：头文件定义了一个用于处理输入的ifstream类</strong></p><p><strong>2.<strong>声明一个或多个</strong>ifstream</strong>（<strong>input fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为inFile</strong></p><p>**3.**必须指明名称空间std，为引用ifstream，必须使用编译指令using或者前缀的std：：</p><p>**4.**将ifstream对象与文件关联起来。为此，方法之一是使用open()方法</p><p>**5.**使用完文件后，应使用close()将其关闭</p><p>**6.**可结合ifstream对象 和运算符&lt;&lt;来输出各种类型的数据。</p><h4 id="检查文件">检查文件</h4><p>格式为: 对象名.isopen()  例:    <strong>inFile.is_open()</strong></p><p>如果文件成功被打开，返回<strong>true</strong>；如果文件没有被打开，<strong>因此表达式   !inFile.is_open()  将为true</strong></p><p>通常使用下方代码判断是否打开成功</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exit(0)程序正常结束</strong></p><p><strong>exit(1)程序异常结束</strong></p><p><strong>exit()使用需要用到头文件==cstdlib==</strong></p><h4 id="文件读取结尾">文件读取结尾</h4><p><strong>eof在遇到EOF（文件结束标志）时返回ture ，否则返回false</strong></p><p>通常和while循环一起用作文件读取结束，<strong>!inFile.eof</strong>在文件结束前为真，结束为假（退出循环）</p><p>具体格式为：   <strong>while(  !inFile.eof（）)</strong></p><h4 id="文件的打开和关闭">文件的打开和关闭</h4><p>**1.对象名.open(“文件名”) **（一个参数）例：<strong>outFile.open(“student.txt”)</strong> 如果文件不存在，将会自动创建一个相同名字的文件,如果文件存在，将会打开该文件，首先截断该文件，将其长度截短到0，丢弃原有的内容，然后将新的输入加入到该文件中</p><p><strong>2.对象名.open(“文件名”，打开方式)</strong> （两个参数）例如 : **outFile.open(“student.txt”,std::ios::in)**只读模式  见下方</p><p>格式：对象名.close()  例: <strong>outFile.close()</strong></p><p>注意方法close()，不需要使用文件名作为参数，因为outFile已经同特定的文件关联起来，如果忘记关闭文件，程序正常终止的时候将自动关闭它。</p><p><strong>下面时学生管理程序中的例子:</strong></p><p><strong>读取数据到文件中（output输出数据到文件）：</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221120212115308.png" alt="image-20221120212115308"></p><p><strong>从该文件中读取数据（input从文件中输入数据到外）：</strong></p><p><img src="E:%5C%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81Markdown%5CC++.assets%5Cimage-20221120212136110.png" alt="image-20221120212136110"></p><p><strong>从文件中读取数据时，也需要用到new分配新的内存，与Input（）函数在输入数据时相同</strong></p><p><strong>inFile 对应的c中的fscanf（从文件中读取数据）</strong></p><p><strong>outFile对应的时c中的fprintf（写入数据到文件）</strong></p><h1>构造函数和析构函数</h1><h2 id="构造函数">构造函数</h2><ul><li>按参数种类分：无参构造函数、有参构造函数、有默认参构造函数</li><li>按类型分为：普通构造函数、拷贝构造函数(赋值构造函数)</li></ul><p><a href="https://blog.csdn.net/Viewinfinitely/article/details/115017678?ops_request_misc=%7B%22request%5Fid%22%3A%22170626893616800185850269%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170626893616800185850269&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115017678-null-null.142%5Ev99%5Epc_search_result_base4&amp;utm_term=C%2B%2B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">C++构造函数的各种用法全面解析（C++初学面向对象编程）_c++ 构造函数-CSDN博客</a></p><h1>运算符重载</h1><h2 id="运算符重载的概念和原理">运算符重载的概念和原理</h2><p>如果不做特殊处理，C++ 的 +、-、*、/ 等运算符只能用于对基本类型的常量或变量进行运算，不能用于对象之间的运算。</p><p>有时希望对象之间也能用这些运算符进行运算，以达到使程序更简洁、易懂的目的。例如，复数是可以进行四则运算的，两个复数对象相加如果能直接用+运算符完成，不是很直观和简洁吗？</p><p>利用 C++ 提供的“运算符重载”机制，赋予运算符新的功能，就能解决用+将两个复数对象相加这样的问题。</p><p>运算符重载，就是对已有的运算符赋予多重含义，使同一运算符作用于不同类型的数据时产生不同的行为。运算符重载的目的是使得 C++ 中的运算符也能够用来操作对象。</p><p>运算符重载的实质是编写以运算符作为名称的函数。不妨把这样的函数称为运算符函数。运算符函数的格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">返回值类型  <span class="keyword">operator</span>  运算符(形参表)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符可以是+、-、*、/等，必须是有效的C++运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值可以是一个引用，也可以是一个对象，但一定注意！！！，不要返回一个指向局部变量或临时对象的引用，因为函数执行完毕后，局部变量和临时对象将消失，引用将指向一个不存在的数据</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一个简单的重载+运算符*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="type">int</span> testData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> testData;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>-&gt;testData = data;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Test <span class="keyword">operator</span>+(<span class="type">const</span> Test&amp; t)</span><br><span class="line">     &#123;</span><br><span class="line">         Test test;</span><br><span class="line">         test.testData = testData+t.testData;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> test;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Test t1,t2;</span><br><span class="line">    Test t3,t4;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">setData</span>(<span class="number">5</span>);</span><br><span class="line">    t2.<span class="built_in">setData</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    t3 = t1+t2;</span><br><span class="line"></span><br><span class="line">    t4 = t1.<span class="keyword">operator</span>+(t3);</span><br><span class="line">    <span class="comment">//t4 = t1+t2+t3 这是允许的，得出的结果相同</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t1:&quot;</span> &lt;&lt; t1.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t2:&quot;</span> &lt;&lt; t2.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t3:&quot;</span> &lt;&lt; t3.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;t4:&quot;</span> &lt;&lt; t4.<span class="built_in">getData</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：重载后的+号允许大于两个对象相加，如t4 = t1+ t2 + t3</span></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>该函数有两种调用方式</strong>：</p><ul><li>通过对象调用方法来调用，如上边的t4</li><li>直接通过重载的符号调用，如上方t1+t2</li></ul></div><h2 id="运算符重载限制">运算符重载限制:</h2><p>运算符重载规则，即允许重载的运算符，不允许重载的运算符见：</p><p><a href="https://blog.csdn.net/qq_72157449/article/details/128664136?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=c++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E9%99%90%E5%88%B6&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-128664136.142%5Ev96%5Epc_search_result_base1&amp;spm=1018.2226.3001.4187">【⑤C++ | 运算符重载】意义 | 限制 | 方法 | 规则 | 特殊运算符重载 | 应用场景-CSDN博客</a></p><p>注：在 <strong>C++ 中，类型的名字（包括类的名字）本身也是一种运算符</strong>，即类型强制转换运算符。 类型强制转换运算符是单目运算符，也可以被重载，但只能重载为成员函数，不能重载为全局函数。</p><h1>类的继承</h1><h2 id="继承的定义">继承的定义</h2><p>定义：</p><p>继承(inheritance)机制是面向对象程序设计中使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能。这样产生的新类，称派生类（或子类），被继承的类称基类（或父类）。</p><p>继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。之前接触的复用都是函数复用，继承是类设计层次的复用。</p><h2 id="继承：is-a-关系">继承：is-a 关系</h2><p>因为派生类可以在基类上添加新特性，所以这种关系成为is-a-kind-of(是一种)关系更加准确，通常术语是is-a关系。例如：香蕉是一种水果</p><p>同时在指针指向的对象上面也有讲究：</p><ul><li>可以将基类指针指向派生类对象(多态性体现)</li><li>不能将派生类指针指向基类对象(不允许这样做)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span>:<span class="keyword">public</span> Fruit</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fruit *pFruit1 = <span class="keyword">new</span> <span class="built_in">Fruit</span>();<span class="comment">//正确</span></span><br><span class="line">    Fruit *pBanana = <span class="keyword">new</span> <span class="built_in">Banana</span>();<span class="comment">//正确，满足香蕉一种水果，水果包含香蕉的关系</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用基类指针引用派生类对象的能力允许多态性。在这种情况下，你可以通过基类指针调用基类的函数或访问基类的成员，而在运行时，将调用正确的派生类方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    Banana* pFruit2 = <span class="keyword">new</span> <span class="built_in">Fruit</span>();<span class="comment">//错误，水果不是一种香蕉，香蕉不包含水果，不允许这样做</span></span><br><span class="line">    Banana* pBanana1 =<span class="keyword">new</span> <span class="built_in">Banana</span>();<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承的格式">继承的格式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 新类的名字: 继承方式 继承类的名字</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一个简单的例子*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">people</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">people</span>(string name,<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:<span class="keyword">public</span> people</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> schoolnum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">student</span>(string name,<span class="type">int</span> age,<span class="type">int</span> schoolNum):<span class="built_in">people</span>(name,age)<span class="comment">//使用成员初始化列表语法,会先调用基类的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;schoolnum = schoolNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*上面的构造函数等价于</span></span><br><span class="line"><span class="comment">    student(string name,int age,int schoolnum)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        this-&gt;name = name;</span></span><br><span class="line"><span class="comment">        this-&gt;age = age;</span></span><br><span class="line"><span class="comment">        this-&gt;schoolnum = schoolnum;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    这两种方法都可以</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; name &lt;&lt; endl &lt;&lt; age &lt;&lt; endl &lt;&lt; schoolnum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">student <span class="title">s</span><span class="params">(<span class="string">&quot;keqiudi&quot;</span>,<span class="number">18</span>,<span class="number">2022124018</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>在继承的时候可以使用类名加上作用域解析符(:)来调用基类的方法，通常在私有继承中使用，第二种便是使用this指针调用继承过来的基类的方法</strong></p></div><p>更多详细内容学习：</p><p><a href="https://blog.csdn.net/qq_62718027/article/details/125922249?ops_request_misc=%7B%22request%5Fid%22%3A%22170126212316800222846414%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170126212316800222846414&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-125922249-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=C%2B%2B%E7%B1%BB%E7%BB%A7%E6%89%BF&amp;spm=1018.2226.3001.4187">c++：继承（超详解）</a></p><h2 id="继承的总结：">继承的总结：</h2><ol><li>基类private成员无论以什么方式继承到派生类中都是不可见的。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它。</li><li>基类private成员在派生类中不能被访问，如果基类成员不想在派生类外直接被访问，但需要在派生类中访问，就定义为protected。可以看出保护成员限定符是因继承才出现的。</li><li>基类的私有成员在子类都是不可见；基类的其他成员在子类的访问方式就是访问限定符和继承方式中权限更小的那个（权限排序：public&gt;protected&gt;private）。</li><li>使用关键字class时<strong>默认的继承方式是private</strong>，使用struct时默认的继承方式是public，但最好显式地写出继承方式。</li></ol><h2 id="多态公有继承">多态公有继承</h2><p>简单来说就是一个方法的行文随上下文而异，有两种重要机制可用于实现多态的公有继承</p><ol><li>在派生类中重新定义基类的方法</li><li>使用虚方法</li></ol><h3 id="虚方法">虚方法</h3><ul><li>关键词：virtual</li><li>在基类中将<strong>派生类会重新定义的方法</strong>声明为虚方法。使用了virtual，程序将根据<strong>引用或指针指向的对象</strong>的类型来选择方法，而未使用时程序将仅仅根据<strong>引用或指针的类型</strong>来选择方法，与<strong>多态性</strong>紧密相关。</li><li>virtual关键词只用于类声明的方法原型中，而不用于类方法实现中</li><li>派生类中覆盖的方法后要加上override标注</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//brass.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BRASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BRASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string fullName; <span class="comment">//客户姓名</span></span><br><span class="line"><span class="type">long</span> acctNum; <span class="comment">//账号</span></span><br><span class="line"><span class="type">double</span> balance; <span class="comment">//当前结余</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Brass</span>(<span class="type">const</span> string &amp;s = <span class="string">&quot;Nullbody&quot;</span>, <span class="type">long</span> an = <span class="number">-1</span>, <span class="type">double</span> bal = <span class="number">0.0</span>); <span class="comment">//创建账户</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Deposit</span><span class="params">(<span class="type">double</span> amt)</span></span>; <span class="comment">//存款</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span></span>; <span class="comment">//取款</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Balance</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//显示账户信息</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//显示</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Brass</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrassPlus</span> : <span class="keyword">public</span> Brass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> maxLoan; <span class="comment">//透支上限</span></span><br><span class="line"><span class="type">double</span> rate; <span class="comment">//透支贷款利率</span></span><br><span class="line"><span class="type">double</span> owesBank; <span class="comment">//当前的透支总额</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BrassPlus</span>(<span class="type">const</span> string &amp;s = <span class="string">&quot;Nullbody&quot;</span>, <span class="type">long</span> an = <span class="number">-1</span>, <span class="type">double</span> bal = <span class="number">0.0</span>, <span class="type">double</span> m1 = <span class="number">500</span>, <span class="type">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line"><span class="built_in">BrassPlus</span>(<span class="type">const</span> Brass &amp;ba, <span class="type">double</span> m1 = <span class="number">500</span>, <span class="type">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//覆盖基类实现，函数重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Withdraw</span><span class="params">(<span class="type">double</span> amt)</span> <span class="keyword">override</span></span>; <span class="comment">//覆盖基类实现，函数重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResetMax</span><span class="params">(<span class="type">double</span> m)</span> </span>&#123; maxLoan = m; &#125; <span class="comment">//透支上限</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResetRate</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123; rate = r; &#125; <span class="comment">//透支贷款利率</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResetOwes</span><span class="params">()</span> </span>&#123; owesBank = <span class="number">0</span>; &#125; <span class="comment">//当前透支总额</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设计的Brass基类指针既可以指向Brass对象，也可以指向BrassPlus对象，因此可以使用一个数组来表示多种类型的对象，这就是多态性。下面在一个数组中可以很清楚的看清virtual的作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> CLIENTS = <span class="number">2</span>;</span><br><span class="line">Brass *clients[CLIENTS];<span class="comment">//Brass类型的指针</span></span><br><span class="line">clients[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">Brass</span>(<span class="string">&quot;Test0&quot;</span>, <span class="number">1234</span>, <span class="number">1234.56</span>);<span class="comment">//指向Brass类型对象</span></span><br><span class="line">clients[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">BrassPlus</span>(<span class="string">&quot;Test1&quot;</span>, <span class="number">5678</span>, <span class="number">5678.91</span>);<span class="comment">//指向BrassPlus类型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; CLIENTS;++i)</span><br><span class="line">&#123;</span><br><span class="line">    clients[i]-&gt;<span class="built_in">ViewAcct</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>多态性说明</strong>：</p><ul><li>假如ViewAcct()是使用关键字virtual声明</li></ul><p>如果数组成员(指针)指向的是Brass对象，则调用的是Brass::ViewAcct()。<br>如果数组成员(指针)指向的是BrassPlus对象，则调用的是BrassPlus::ViewAcct()。</p><ul><li>假如ViewAcct()不是虚方法</li></ul><p>则在任何情况下都将调用Brass::ViewAcct()。</p><h3 id="虚析构函数">虚析构函数</h3><p>基类要声明一个虚析构函数，为了确保释放派生类对象时，按正确的顺序调用析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Brass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string fullName; <span class="comment">//客户姓名</span></span><br><span class="line"><span class="type">long</span> acctNum; <span class="comment">//账号</span></span><br><span class="line"><span class="type">double</span> balance; <span class="comment">//当前结余</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Brass</span>() &#123;&#125; <span class="comment">//这是虚析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>为何使用虚析构函数</strong>：</p><ul><li>如果析构函数不是虚方法，则将只调用对应于指针类型的析构函数。对于Brass * 指针将只调用Brass基类的析构函数，即使Brass * 指针指向的是BrassPlus对象。</li><li>如果析构函数是虚方法，将调用相应的指向对象类型的析构函数。即如果指针指向的是Brass对象，将调用Brass对象的析构函数，如果指针指向的是BrassPlus对象，将调用BrassPlus的析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以确保正确的析构函数序列被调用。</li><li>如果BrassPlus包含一个执行某些操作的析构函数，则Brass必须有一个虚析构函数，即使Brass的析构函数不执行任何操作。</li></ul></div><h2 id="静态联编和动态联编">静态联编和动态联编</h2><p><strong>静态联编</strong>：静态联编是指联编工作在<strong>编译阶段完成的</strong>，联编过程是在程序运行之前完成。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，静态联编对函数的选择是<strong>基于指向对象的指针或者引用的类型</strong>。其优点是<strong>效率高，但灵活性差</strong>，也因此作为C++默认联编选择。</p><p><strong>动态联编</strong>：动态联编是指联编在<strong>程序运行时动态地进行</strong>，根据当时的情况来确定调用哪个同名函数，实际上是在运行时是<strong>虚函数的实现</strong>。动态联编对成员函数的选择是基于<strong>对象的类型</strong>，针对不同的对象类型将做出不同的编译结果。C++中一般情况下的联编是静态联编，但是当涉及到<strong>多态性和虚函数时应该使用动态联编</strong>。动态联编的优点是<strong>灵活性强，但效率低</strong>。</p><p>动态联编规定：只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式为：指向基类的指针变量名-&gt;虚函数名（实参表）或基类对象的引用名.虚函数名（实参表）</p><ul><li>编译器对<strong>非虚方法</strong>使用<strong>静态联编</strong></li><li>编译器对<strong>虚方法</strong>使用<strong>动态联编</strong></li></ul><hr><p><strong>实现动态联编需要同时满足以下三个条件：</strong></p><p>①  必须把动态联编的行为定义为类的虚函数。</p><p>②  类之间应满足子类型关系，通常表现为一个类从另一个类公有派生而来。</p><p>③  必须先使用基类指针指向子类型的对象，然后直接或者间接使用基类指针调用虚函数</p><p><strong>总结</strong>：</p><p>大多数情况下，动态联编很好，因为他让程序能够选择特定类型设计的方法。<strong>虚函数是实现多态的基础，是实现动态联编的必要条件之一</strong>。动态联编要靠虚函数来实现，虚函数要靠动态联编的支持。两者相辅相成，缺一不可。</p><h2 id="初始化列表">初始化列表</h2><h3 id="概念">概念</h3><p>当在C++中定义类的构造函数时，可以使用初始化列表来初始化类的成员变量。初始化列表是在构造函数的参数列表后面使用冒号(:)分隔开来的一组初始化语句,多个参数初始化使用逗号隔开，用于初始化类的成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*初始化列表写法*/</span></span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> value,<span class="type">double</span> values):<span class="built_in">data</span>(value),<span class="built_in">datas</span>(values)<span class="comment">//这里的冒号及冒号右边的部分就是构造函数的初始化列表,逗号隔开</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*函数体内写法*/</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value,<span class="type">double</span> values)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;</span><br><span class="line">        <span class="type">double</span> = datas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">    <span class="type">double</span> datas;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意</strong>：</p><ul><li>对于<strong>继承的对象</strong>，构造函数在成员初始化列表中使用基类名来调用特定的基类构造函数。</li><li>对于<strong>成员对象</strong>，构造函数则使用成员名。</li></ul></div><h3 id="什么时候必须使用">什么时候必须使用</h3><ol><li><strong>在成员变量为引用类型时</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> &amp;data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value):<span class="built_in">data</span>(value)<span class="comment">//正确</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;<span class="comment">//会报错引用类型不允许这样做,只能使用初始化列表(上面的方式初始化)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>在成员变量为const时</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value):<span class="built_in">data</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="built_in">A</span>(<span class="type">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        data = value;<span class="comment">//会报错const类型不允许这样做,只能使用初始化列表(上面的方式初始化)</span></span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="建议使用的地方">建议使用的地方</h3><ul><li>初始化基类部分</li></ul><p>在派生类构造函数中使用初始化列表法初始基类的变量，可以避免在函数体中进行额外的赋值操作提高效率，同时提高可读性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*对于成员对象使用成员名初始化列表*/</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> value)</span>:data(value)//这里的冒号及冒号右边的部分就是构造函数的初始化列表,逗号隔开</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> datas;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*对于继承的对象，使用基类名初始化列表，调用基类构造函数初始化基类部分*/</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> value,<span class="type">double</span> values):<span class="built_in">A</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        datas = values; <span class="comment">//正常的在函数体内初始化派生类部分,更清晰表明继承关系，这个地方也可以在上面使用初始化列表方式为datas赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><p>建议尽可能使用初始化列表法来初始化构造函数中的成员变量，但并非所有情况都必须使用初始化列表。</p><p>一般来说，以下情况建议使用初始化列表法：</p><ol><li><strong>初始化成员变量</strong>：如果构造函数需要初始化类的成员变量,但此时类的结构和逻辑不是很复杂时，使用初始化列表是最清晰和高效的方式。</li><li><strong>初始化基类部分</strong>：在派生类的构造函数中调用基类的构造函数时，应该使用初始化列表来确保基类部分被正确地初始化。</li><li><strong>初始化const和引用类型成员变量</strong>：const和引用类型的成员变量只能在初始化列表中进行初始化，无法在构造函数体内进行赋值。</li><li><strong>初始化具有复杂初始化逻辑的成员变量</strong>：如果某个成员变量的初始化逻辑比较复杂，使用初始化列表可以将初始化逻辑集中在一起，提高代码的可读性。</li></ol><p>但也有一些情况可以在构造函数体内进行初始化，例如：</p><ol><li><strong>运行时条件决定的初始化</strong>：如果某些成员变量的初始化取决于运行时条件，可能需要在构造函数体内进行初始化。</li><li><strong>需要在构造函数体内执行额外逻辑</strong>：如果构造函数需要执行一些额外的逻辑操作，可以在构造函数体内进行初始化。</li></ol><h3 id="优点和缺点">优点和缺点</h3><p><strong>优点</strong>:</p><ol><li>(涉及含有类成员时)<strong>效率高</strong>: 使用初始化列表可以直接对成员变量进行初始化，而不需要先调用默认构造函数再进行赋值操作，从而提高了代码的执行效率。基本类型时效率与在函数体中差不多</li><li><strong>确保成员变量的初始化</strong>: 使用初始化列表可以确保所有成员变量在对象构造时立即得到正确的初始化，避免了可能出现的未初始化的情况。</li><li><strong>处理const和引用类型成员变量</strong>: 对于const成员变量和引用类型成员变量，只能在初始化列表中进行初始化，因为它们不能在构造函数体内被赋值。</li><li><strong>清晰明了</strong>: 初始化列表将所有初始化操作集中在一起，使代码更加清晰易读，便于理解和维护</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>可读性差</strong>: 对于复杂的类结构和初始化逻辑，初始化列表可能会使代码变得复杂和难以理解，降低了可读性。</li><li><strong>限制较多</strong>: 有些情况下，无法在初始化列表中初始化所有的成员变量，例如需要在构造函数体内进行逻辑判断后再进行初始化的情况。</li><li><strong>容易遗忘</strong>: 在添加新成员变量时，容易忘记在初始化列表中添加相应的初始化操作，导致未初始化的错误。</li></ol><h2 id="使用using-重新定义访问权限">使用using 重新定义访问权限</h2><p>使用<strong>保护派生或私有派生</strong>时，基类的公有成员将成为保护成员或私有成员。假设要让基类的方法在派生类外面可用，可以在派生类的public成员中使用using声明指出派生类可以使用特定的基类成员，就像using指定的成员或函数是派生类的公有方法一样，即使采用的是私有派生。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一个简单的例子*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">people</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">people</span>(string name,<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>: <span class="keyword">private</span> people<span class="comment">//私有派生</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> schoolnum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> people::showName;<span class="comment">//使用using定义重新定义访问权限</span></span><br><span class="line">    <span class="keyword">using</span> people::name;<span class="comment">//使用using定义重新定义访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">student</span>(string name,<span class="type">int</span> age,<span class="type">int</span> schoolNum):<span class="built_in">people</span>(name,age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;schoolnum = schoolNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">student <span class="title">s</span><span class="params">(<span class="string">&quot;keqiudi&quot;</span>,<span class="number">18</span>,<span class="number">2022124018</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">showName</span>();<span class="comment">//正确，使用了using可以在派生类外调用</span></span><br><span class="line">    cout &lt;&lt; s.name &lt;&lt; endl;<span class="comment">//正确，使用了using可以在派生类外调用</span></span><br><span class="line">    cout &lt;&lt; s.age &lt;&lt; endl;<span class="comment">//报错，未使用using，继承后为派生类private成员不可以直接访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多重继承">多重继承</h2><h3 id="定义">定义</h3><p>派生类都只有一个基类，称为单继承。除此之外，C++也支持多继承，即一个派生类可以有两个或多个基类。<br>多继承的语法也很简单，将多个基类用逗号隔开。</p><p>如已声明了类A、类B和类C，那么可以这样来声明派生类D：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A, <span class="keyword">private</span> B, <span class="keyword">protected</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//类D新增加的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数-2">构造函数</h3><p>与单继承形式基本相同，只是在派生类的构造函数中调用多个基类的构造函数。<br>以上面的 A、B、C、D 类为例，D 类构造函数的写法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">D</span>(形参列表): <span class="built_in">A</span>(实参列表), <span class="built_in">B</span>(实参列表), <span class="built_in">C</span>(实参列表)<span class="comment">//使用初始化列表写法调用基类构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二义性">二义性</h3><p>当两个或多个基类有同名成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员。这个时候需要在<strong>名字前面加上类名和域解析符::</strong>，以显示地指明到底使用哪个类的成员，消除二义性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseA</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">BaseA</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BaseA</span>(<span class="type">int</span> value):_value(value)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseA::_value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BaseB</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">BaseB</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BaseB</span>(<span class="type">int</span> value):_value(value)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseB::_value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> BaseA, <span class="keyword">public</span> BaseB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()=<span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Derived</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> valueA, <span class="type">int</span> valueB):<span class="built_in">BaseA</span>(valueA), <span class="built_in">BaseB</span>(valueB)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseA::_value: &quot;</span> &lt;&lt; BaseA::_value &lt;&lt; endl;<span class="comment">//使用::指明基类BaseA的value</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseB::_value: &quot;</span> &lt;&lt; BaseB::_value &lt;&lt; endl;<span class="comment">//使用::指明基类BaseB的value</span></span><br><span class="line">        BaseA::<span class="built_in">showValue</span>();<span class="comment">//使用::指明调用基类BaseA的方法</span></span><br><span class="line">        BaseB::<span class="built_in">showValue</span>();<span class="comment">//使用::指明调用基类BaseB的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    d.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>模板</h1><h2 id="类模板">类模板</h2><p>在C++中，<strong>模板类</strong>是一种用于创建通用数据结构或算法的强大工具。模板类允许您编写一次代码，然后在不同数据类型上重复使用它，例如有两个或多个类，其功能是相同的，仅仅是数据类型不同时使用，<strong>以提高代码的可重用性和灵活性</strong>。</p><p>模板类允许您定义一种通用的类模板，其中某些成员或函数可以根据不同进行参数化。它们使用template关键字定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,....&gt;</span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;</span><br><span class="line">类的定义;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>typename</code>表明其后面的符号是一种数据类型，可以用<code>class</code>代替</li><li><code>T</code>是通用的数据类型，名称可以替换，通常为大写字母</li><li>函数模板建议用 <code>typename</code> 描述通用数据类型，类模板建议用 <code>class</code></li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">nameType</span>,<span class="keyword">class</span> <span class="title class_">ageType</span>&gt;<span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    nameType name;</span><br><span class="line">    ageType age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(nameType name,ageType age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string,<span class="type">int</span>&gt; <span class="title">student</span><span class="params">(<span class="string">&quot;Tom&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    student.<span class="built_in">showPerson</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数模板">函数模板</h2><p>函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能，提高了程序的可重用性。</p><p>C++ 语言支持模板。有了模板，例如可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。</p><p><strong>写法</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span>,<span class="keyword">typename</span> 类型参数<span class="number">2</span>, ...&gt;</span><br><span class="line">返回值类型  模板名(形参表)</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*typename可以使用class替换*/</span></span><br></pre></td></tr></table></figure><p><strong>一个简单的示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp; x, T &amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>, m = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(n, m);  <span class="comment">//编译器自动生成 void Swap (int &amp;, int &amp;)函数</span></span><br><span class="line">    <span class="type">double</span> f = <span class="number">1.2</span>, g = <span class="number">2.3</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(f, g);  <span class="comment">//编译器自动生成 void Swap (double &amp;, double &amp;)函数</span></span><br><span class="line">    string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(s1, s2);  <span class="comment">//编译器自动生成 void Swap (string &amp;, string &amp;)函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类模板与函数模板区别">类模板与函数模板区别</h2><ol><li><strong>应用对象</strong>：<ul><li><strong>函数模板</strong>主要用于生成通用函数，可以用于不同类型的参数。它通过在函数定义中使用模板来实现，允许编写一次通用的函数代码，用于多种数据类型。</li><li><strong>类模板</strong>主要用于生成通用类，可以包含不同类型的成员变量或成员函数。它通过在类定义中使用模板来实现，允许创建一种通用的类形式，适用于多种数据类型。</li></ul></li><li><strong>自动类型推导的使用方式</strong>：<ul><li><strong>函数模板</strong>在调用时支持自动类型推导，允许省略模板参数，由编译器根据实参类型自动推导出模板参数的类型。</li><li><strong>类模板</strong>在实例化时需要显式指定模板参数，没有像函数模板那样的自动类型推导。每次实例化都需要<strong>明确指定模板参数</strong>。</li></ul></li><li><strong>默认参数</strong>：<ul><li><strong>函数模板</strong>和<strong>类模板</strong>都支持默认参数。在模板参数列表中可以为某些模板参数设置默认值，使得在使用时可以不必每次都指定这些参数。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板与函数模板的区别</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; <span class="comment">//指定默认参数</span></span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NameType m_Name;</span><br><span class="line">AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Person p(&quot;孙悟空&quot;, 1000);错误的，类模板无法用自动类型推导</span></span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;keqiudi&quot;</span>, <span class="number">19</span>);<span class="comment">//正确，只能用显式指定类型推导</span></span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string&gt;<span class="built_in">p</span>(<span class="string">&quot;keqiudi&quot;</span>, <span class="number">19</span>); <span class="comment">//类模板在参数列表中有默认参数</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类模板成员函数实现">类模板成员函数实现</h2><p>在类<strong>内部定义成员函数</strong>可以更简洁，因为不需<strong>要再次指定模板参数</strong>。类内部的成员函数定义可以直接使用类模板的模板参数，而在<strong>外部定义时需要重新指定一次</strong>。</p><p>总体来说，选择在类内部还是类外部定义成员函数取决于项目的需求和组织代码的风格。一般而言，对于简单、短小的成员函数，可以选择在类内部定义；而对于复杂或长的成员函数，以及避免头文件的多次包含导致的重定义错误，通常建议在类外部定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板成员类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"><span class="comment">/*内部定义&#123;</span></span><br><span class="line"><span class="comment">this-&gt;m_Name = name;</span></span><br><span class="line"><span class="comment">this-&gt;m_Age = age;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*内部定义&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造函数的类外实现，每个函数都要重新指定模板参数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="comment">//要点1：每个函数前加上template&lt;&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)<span class="comment">//要点2:类名指出模板参数再进行解析(::)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*成员函数的类外实现，每个函数都要重新指定模板参数*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">30</span>);</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="成员模板">成员模板</h2><p>模板可用作结构、类或模板类的成员。要完全实现STL(标准模板库)，必须使用这个特性</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">beta</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">V</span>&gt;<span class="comment">//模板成员</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">hold</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">         V val;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">hold</span>(V v=<span class="number">0</span>):<span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>&#123;cout &lt;&lt; val &lt;&lt; endl;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">V <span class="title">Value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    hold&lt;T&gt; q; <span class="comment">//模板类中的模板对象,传入的模板参数为T，即外部模板类想通过的模板参数</span></span><br><span class="line">    hold&lt;<span class="type">int</span>&gt; n;<span class="comment">//模板对象</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">beta</span>(T t,<span class="type">int</span> i):<span class="built_in">q</span>(t),<span class="built_in">n</span>(i)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;<span class="comment">//模板函数做成员</span></span><br><span class="line">    <span class="function">U <span class="title">blab</span><span class="params">(U u,T t)</span></span>&#123;<span class="keyword">return</span> (n.<span class="built_in">Value</span>()+q.<span class="built_in">Value</span>()*u/t);&#125; </span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span>&#123; q.<span class="built_in">show</span>(); n.<span class="built_in">show</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">beta&lt;<span class="type">double</span>&gt; <span class="title">guy</span><span class="params">(<span class="number">3.5</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T被设置为double\n&quot;</span>;</span><br><span class="line">    guy.<span class="built_in">Show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;V被设置为T,即double，第二个V被设置为int\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; guy.<span class="built_in">blab</span>(<span class="number">10</span>,<span class="number">2.3</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;U被设置为int\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; guy.<span class="built_in">blab</span>(<span class="number">10.0</span>,<span class="number">2.3</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;U被设置为double\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类模板对象做函数参数">类模板对象做函数参数</h2><p>一共有三种传入方式：</p><ol><li>指定传入的类型：直接显示对象的数据类型，此时模板对象必须含有模板类的参数</li><li>参数模板化：将对象中的参数变为模板进行传递</li><li>整个类模板化：将这个对象类型模板化进行传递</li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板对象做函数参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(T1 name,T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">199</span>);</span><br><span class="line"><span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 2、参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1,T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T1的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T2的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line"><span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">60</span>);</span><br><span class="line"><span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="将模板做模板类参数">将模板做模板类参数</h2><p>模板可以包含类型参数(如typename T)和非类型参数(如 int n)。模板还可以本身就是模板的参数，这种参数是模板类新增的特性，用于实现STL。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Thing</span>&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *模板参数是template &lt;typename T&gt; class Thing，其中template &lt;typename T&gt; class 是类型，Thing是参数。</span></span><br><span class="line"><span class="comment"> 假设有Crab&lt;King&gt; legs;</span></span><br><span class="line"><span class="comment"> 那么King必须是一个模板类，其声明与模板参数Thing的声明匹配；</span></span><br><span class="line"><span class="comment"> 即：</span></span><br><span class="line"><span class="comment"> template&lt;class T&gt;</span></span><br><span class="line"><span class="comment"> class King&#123;...&#125;</span></span><br><span class="line"><span class="comment"> */</span>    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Crab</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Thing&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    Thing&lt;<span class="type">double</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设有如下声明</span></span><br><span class="line">Crab&lt;Stack&gt;stack;</span><br><span class="line"><span class="comment">//成员函数Thing&lt;int&gt;就被替换为Stack&lt;int&gt;,Thing&lt;double&gt;替换为Stack&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *总之模板参数Thing将被替换为声明Crab对象时被用作模板参数的模板类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="类模板与继承">类模板与继承</h2><p>当类模板碰到继承时，需要注意以下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中<code>T</code>的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中<code>T</code>的类型，子类也需为类模板</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板与继承</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son: public Base //错误，必须要知道父类中的T类型，才能继承给子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想灵活指定父类中T的类型，子类也需要变成类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son2</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T1的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T2的类型为:&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">T1 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2&lt;<span class="type">int</span>,<span class="type">char</span>&gt; s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模板类和友元">模板类和友元</h2><p>模板类声明也可以有友元。模板的友元分为3类：</p><ol><li><p>非模板友元</p></li><li><p>约束(bound)模板友元，即友元的类型取决于类被实例化时的类型；</p></li><li><p>非约束(unbound)模板友元，即友元的所有具体化都是类的每一个具体化的友元</p></li></ol><ul><li><p>非模板友元</p><p>在模板类中将一个常规函数声明为友元</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasFriend</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">int</span>&gt;&amp; hf)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">double</span>&gt;&amp; hf)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *上述声明使counts()函数成为模板所有实例化的友元,例如是HasFriend&lt;int&gt;和HasFriend&lt;string&gt;的友元</span></span><br><span class="line"><span class="comment"> *report()函数也是，只不过接受一个模板类参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">int</span>&gt;&amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(HasFriend&lt;<span class="type">double</span>&gt;&amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>约束模板友元</li></ul><p>​修改前一个示例，使友元函数本身成为模板，即使类的每一个具体化都获得与友元匹配的具体化，一共包含3步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一步，在类定义前面声明每个模板函数*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(T&amp; t)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*第二步，在类中将模板声明为友元，这些语句根据类模板参数的类型声明具体化*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">class</span> TT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> HasFriendT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">counts</span>&lt;TT&gt;();</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> report&lt;&gt;(HasFriendT&lt;TT&gt; &amp; tt);</span><br><span class="line">        <span class="comment">//或使用friend void report&lt;HasFriendT&lt;TT&gt;&gt;(HasFriendT&lt;TT&gt; &amp; tt);</span></span><br><span class="line">    <span class="comment">//声明中的&lt;&gt;指出这是模板具体化，&lt;&gt;可以为空，因为可以从函数参数推断出模板类型参数</span></span><br><span class="line">    <span class="comment">//但counts()没有参数，因此必须使用模板参数语法(&lt;TT&gt;)来指明其具体化,TT为HasFriendT类的类模板参数类型</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三步，为友元函数提供定义*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counts</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">report</span><span class="params">(T &amp; hf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非约束模板友元</li></ul><p>每个函数<strong>具体化</strong>都是每个类<strong>具体化</strong>的友元，<strong>友元模板类型参数与模板类类型参数不同</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ManyFriend</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T item</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">ManyFriend</span>(<span class="type">const</span> T&amp; i):<span class="built_in">item</span>(i)&#123;&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C,<span class="keyword">typename</span> D&gt;</span><br><span class="line">      <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show2</span><span class="params">(C&amp; c,D&amp; d)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C,<span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show2</span><span class="params">(C&amp; c,D&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; c.item &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; d.item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类模板成员函数创建时机">类模板成员函数创建时机</h2><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>对于类模板的成员函数在使用时进行实例化。当你使用特定类型实例化类模板对象时，编译器会生成该类型的成员函数实现。</li><li>对于普通类，所有的成员函数都在编译时就被实例化了。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*故可以做到以下的操作*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数的创建时机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中的成员函数在调用的时候才创建，所以不会报错</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">obj.<span class="built_in">showPerson1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">obj.<span class="built_in">showPerson2</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Myclass&lt;Person1&gt;m;</span><br><span class="line">m.<span class="built_in">func1</span>();</span><br><span class="line"><span class="comment">//m.func2(); 此时模板参数传递为Person1故无法调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类模板分文件编写-重要">类模板分文件编写(重要)</h2><p>如果工程中需要利用多个类模板，那么将这些类模板都写在同一个文件中将会导致代码可读性变差，所以有必要对类模板进行分文件编写，但是类模板的分文件编写面临着一些问题，以下是类模板分文件编写面临的问题及解决方法。</p><p><strong>问题</strong>：模板的特性导致了编译器对模板的实例化是在链接阶段进行的，而编译器需要在链接时找到模板的定义，当模板类的定义放在.h文件模板类实现放在.cpp文件，会出现链接失败情况，找不到定义。</p><p><strong>解决方法</strong>：</p><ul><li>直接包含<code>.cpp</code>源文件（不常用因为.cpp风格不好一般用.hpp文件）</li><li>将声明和实现写到同一个文件中，并更改后缀名为<code>.hpp</code></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>.hpp</code> 文件通常用来包含 C++ 的头文件，其中包含类声明、函数原型、模板定义等。这种文件扩展名的选择<strong>是一种约定</strong>，用于表示这个头文件中包含一些声明与实现在一起，比如模板类</p><p>一般来说，<code>.hpp</code> 文件和 <code>.h</code> 文件在功能上是相似的，都用于包含头文件，但 <code>.hpp</code> 文件更常见于 C++ 项目中，尤其是涉及到类和模板的情况。</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编写的templatePerson.hpp文件，模板类的定义和实现放在一个文件中*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.cpp文件内容*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;templatePerson.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模板别名-C-11">模板别名(C++11)</h2><p>如果能为类型指定别名，将很方便，在模板设计中尤其如此，可以使用typedef为模板具体化指定别名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">double</span>,12&gt;arrd;</span><br><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="type">int</span>,12&gt;arri;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>C++11新增了一项功能——使用(using)为模板提供一系列别名，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> arrtype = std::array&lt;T,<span class="number">12</span>&gt;;</span><br><span class="line"><span class="comment">//使用using将arrtype定义为一个模板别名，arrtype&lt;T&gt;表示类型std::array&lt;T,12&gt;。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arrtype&lt;<span class="type">double</span>&gt; gallons;<span class="comment">//等价于 std::array&lt;double,12&gt;</span></span><br><span class="line">arrtype&lt;<span class="type">int</span>&gt; days;<span class="comment">//与上面相同</span></span><br><span class="line">arrtype&lt;std::string&gt; months</span><br></pre></td></tr></table></figure><p>C++11 允许将语法using = 用于非模板。用于非模板时语法与常规typedef等价：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span>* pc1;</span><br><span class="line"><span class="keyword">using</span> pc2 = <span class="type">const</span> <span class="type">char</span>*;<span class="comment">//与上方等价</span></span><br></pre></td></tr></table></figure><p><strong>好处</strong>：</p><ul><li>使用模板别名可以提高代码的可读性，特别是在涉及复杂模板或需要引入特定模板类型时。</li><li>模板别名还可以使代码更易于维护，因为你只需要在一个地方修改模板类型或表达式，而无需修改多处使用的地方。</li></ul><h1>友元</h1><p>在C++中，友元类和友元函数是用来在类之间建立友好关系的机制，允许一个类的成员访问另一个类的私有成员。这样可以增加程序的灵活性和封装性。</p><p>虽然友元提供了灵活性，但过度使用友元可能会破坏封装性，因此应该谨慎使用。友元应该只在确实需要访问私有成员的情况下使用，以保持代码的清晰性和可维护性。</p><h2 id="友元函数">友元函数</h2><ul><li><strong>作用</strong>： <strong>允许一个非成员函数访问类的私有成员。</strong></li><li><strong>用法</strong>： 可以在类的声明中使用<code>friend</code>关键字声明友元函数，然后在类外定义这个函数。</li><li><strong>示例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span>:myData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">showMyData</span><span class="params">(<span class="type">const</span> Myclass&amp; myclass)</span></span>;<span class="comment">//友元函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元函数类外定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMyData</span><span class="params">(<span class="type">const</span> Myclass&amp; myclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myData = &quot;</span> &lt;&lt; myclass.myData &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//友元函数可以访问私有数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showMyData</span>(myclass);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元类">友元类</h2><ul><li><strong>作用</strong>： <strong>允许一个类的所有成员函数访问另一个类的私有成员</strong>。</li><li><strong>用法</strong>：在类的声明中使用<code>friend</code>关键字声明<strong>友元类</strong>。</li><li><strong>示例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> friendData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FriendClass</span><span class="params">(<span class="type">int</span> data)</span>:friendData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">FriendClass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Myclass</span>;<span class="comment">//指定Myclass为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span>:myData(data)&#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>()=<span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;FriendClass data is: &quot;</span> &lt;&lt; friendclass.friendData &lt;&lt; endl;<span class="comment">//友元类的成员函数直接访问另一个类的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">FriendClass <span class="title">friendclass</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">   <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   myclass.<span class="built_in">showFriendData</span>(friendclass);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元成员函数">友元成员函数</h2><ul><li><strong>作用</strong>： <strong>允许一个类的某一个成员函数访问另一个类的私有成员</strong>。</li><li><strong>用法</strong>：在类的声明中使用<code>friend</code>关键字声明<strong>友元</strong>。</li><li><strong>示例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前向声明FriendClass，以便在Myclass中声明友元关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Myclass</span><span class="params">(<span class="type">int</span> data)</span> : myData(data) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明Myclass的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> friendData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FriendClass</span><span class="params">(<span class="type">int</span> data)</span> : friendData(data) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">FriendClass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数的声明，在FriendClass中声明，使Myclass的showFriendData作为FriendClass类的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Myclass::showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Myclass的成员函数因为是FriendClass的友元，所以定义必须在类外，用于访问FriendClass的私有成员，</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myclass::showFriendData</span><span class="params">(<span class="type">const</span> FriendClass&amp; friendclass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FriendClass data is: &quot;</span> &lt;&lt; friendclass.friendData &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Myclass data is: &quot;</span> &lt;&lt; myData &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FriendClass <span class="title">friendclass</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Myclass <span class="title">myclass</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    myclass.<span class="built_in">showFriendData</span>(friendclass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="友元的优缺点">友元的优缺点</h2><p><strong>优点：</strong></p><ol><li><strong>灵活性：</strong> 友元机制允许在类之间建立友好关系，使得某个函数或类可以访问其他类的私有成员，提高了灵活性。</li><li><strong>特定需求的访问权限：</strong> 有时候，为了实现特定的功能，需要某些函数或类能够直接访问其他类的私有成员，友元机制提供了一种选择。</li><li><strong>效率：</strong> 有时候使用友元可以避免通过公有接口的方式(比如get方法等等)进行多次函数调用，提高代码执行效率。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>破坏封装性：</strong> 友元可以直接访问类的私有成员，这可能破坏类的封装性，增加了代码的耦合性，增加了维护的难度。</li><li><strong>复杂性增加：</strong> 过度使用友元可能导致代码更加复杂，使得程序难以理解和维护。</li><li><strong>设计问题：</strong> 有时候需要重新考虑设计，以避免对友元的过度依赖。可能存在更好的设计模式或方法，不需要使用友元。</li></ol><h1>嵌套类</h1><h2 id="概念-2">概念</h2><p>在C++中，嵌套类是一个类被定义在另一个类的内部的情况。被嵌套的类称为内部类或嵌套类，而包含这个内部类的类称为外部类。嵌套类可以具有私有、受保护或公有的访问权限，这取决于它在外部类中的声明方式。包含类的成员函数可以创建和使用被嵌套类的对象；而仅当声明位于公有部分时，才能在包含类的外面使用嵌套类，而且必须使用作用域解析运算符(旧版本的C++不允许嵌套类或无法完全实现这种概念)</p><p><strong>一个示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内部类 Point 表示二维平面上的点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Point</span>(<span class="type">int</span> xCoord, <span class="type">int</span> yCoord) : <span class="built_in">x</span>(xCoord), <span class="built_in">y</span>(yCoord) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部类的成员函数</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Point: (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Point center; <span class="comment">// Shape 类包含 Point 类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Shape 类的构造函数</span></span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">int</span> centerX, <span class="type">int</span> centerY) : <span class="built_in">center</span>(centerX, centerY) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shape 类的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayShape</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shape with center at &quot;</span>;</span><br><span class="line">        center.<span class="built_in">display</span>(); <span class="comment">// 调用内部类的成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Shape 类对象</span></span><br><span class="line">    <span class="function">Shape <span class="title">myShape</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Shape 类的成员函数</span></span><br><span class="line">    myShape.<span class="built_in">displayShape</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="作用">作用</h2><p>嵌套类的主要作用之一是组织和封装代码，使代码更为模块化、清晰和可读。以下是嵌套类的一些主要作用：</p><ol><li><strong>封装实现细节：</strong> 嵌套类允许将一个类的一部分实现细节封装在另一个类中，从而隐藏一些具体的实现细节，提高封装性。外部类可以更专注于公共接口，而具体的实现则留给内部类。</li><li><strong>组织相关的类：</strong> 当两个类有密切关联时，将它们组织在一起可以形成更清晰的结构。嵌套类可以在逻辑上将这些关联的类放在同一个地方，方便代码的组织和维护。</li><li><strong>限制访问权限：</strong> 内部类可以访问外部类的私有成员，但外部类不能直接访问内部类的私有成员。这种特性可以用于在设计中划分不同层次的访问权限，使得代码更安全。</li><li><strong>实现接口与实现分离：</strong> 将接口和实现分离，可以通过内部类隐藏一些实现细节。外部类可以专注于公共接口，而具体的实现细节则留给内部类。</li><li><strong>增加代码的模块化：</strong> 将相关的类组织在一起可以使代码更模块化。每个嵌套类可以有自己的职责，这样代码更易于理解和维护。</li></ol><h2 id="访问控制">访问控制</h2><ol><li><p><strong>公有嵌套类</strong>： 如果内部类声明为<code>public</code>，则外部类的任何成员函数、友元或其他类都可以访问内部类。这使得内部类对外可见，允许外部代码直接访问它。</p></li><li><p><strong>私有嵌套类</strong>：如果内部类声明为<code>private</code>，则只有外部类的成员函数和友元可以访问内部类。外部类的客户端无法直接访问或创建内部类的对象。</p></li><li><p><strong>保护嵌套类</strong>： 如果内部类声明为<code>protected</code>，则外部类的成员函数、友元以及继承了外部类的派生类都可以访问内部类</p></li></ol><h1>异常</h1><h2 id="异常概念">异常概念</h2><p>C语言异常处理机制是：</p><ol><li>终止程序。缺陷：用户难以接受。如发生内存错误，除0错误时就会终止</li><li>返回错误码。缺陷：需要程序员自己去查对应的错误</li></ol><p>在C++中，异常是一种在程序执行过程中发生的错误或者意外状况。异常提供了一种机制，允许程序员在代码中识别和处理错误，以及在出现错误时进行适当的响应。异常处理是C++中一个重要的编程概念，它使得程序更健壮，更容易维护。</p><p>C++中异常处理有三个关键字：<strong>throw、catch、try</strong></p><ul><li>throw：当问题出现，程序抛出一个异常。抛异常使用throw关键字完成。</li><li>catch：用于捕捉异常。**catch(…)**可以捕获任意类型的异常，主要时用来捕获没有显示捕获类型的异常。相当于条件判断中的else。</li><li>try：try中包含会出现异常的代码或者函数。后面通常会跟一个或者多个catch块。</li></ul><p><strong>注意：可以抛出任意类型的对象。抛出的异常必须捕获。try要和catch匹配使用，catch里的内容抛出异常时才执行，没有异常，不执行。</strong></p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入被除数和除数:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;除0错误&quot;</span>;<span class="comment">//抛出异常,这里抛出的是字符串类型异常，也可以是对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">test</span>() &lt;&lt; endl;<span class="comment">//会出现异常的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//捕获字符串类型的异常，a即 &quot;除0错误&quot;。</span></span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* a)&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//捕获任意类型的异常，通常未知异常</span></span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unknow exception&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常的抛出和匹配规则">异常的抛出和匹配规则</h2><h3 id="异常的抛出">异常的抛出</h3><ol><li><p>异常时通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码。</p></li><li><p>被选中的处理代码的调用链是，找到于该类型匹配且离抛出异常位置最近的那一个catch。</p></li><li><p>抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象。</p></li><li><p>catch(…)可以捕获任意类型的对象，主要是用来捕获没有显示捕获类型的异常，因为如果没有匹配的catch会终止程序。相当于条件判断中的else。问题是不知道异常错误是什么。</p></li><li><p>实际中抛出和捕获的类型不一定类型完全匹配，可以抛出派生类对象，使用基类来捕获，这个在实际生活中很实用。主要原因是：派生类可以赋值给基类。</p></li></ol><h3 id="匹配规则">匹配规则</h3><ul><li>首先检查throw本身是否在try块内部，如果是，再在当前函数栈中查找匹配的catch语句。如果有匹配的直接跳到catch的地方执行。</li><li>如果没有匹配的catch块，则退出当前函数栈，在调用函数的栈中查找匹配的catch。</li><li>如果到达main函数的栈，都没有匹配的catch，就会终止程序。</li><li>上述沿着调用链查找匹配的catch块的过程叫栈展开。所以实际要最后要加一个catch(…)来捕获任意类型的异常，防止程序终止。</li><li>找到匹配的catch会直接跳到catch语句执行，执行完后，会继续沿着catch语句后面执行。</li></ul><h2 id="异常的重新抛出">异常的重新抛出</h2><p>有可能单个的catch不能完全处理一个异常，**在进行一些矫正处理后，需要交给更外层的调用链函数来处理。**catch可以做完矫正操作，再将异常重新抛出，交给更上层的函数进行处理。</p><h2 id="异常安全问题">异常安全问题</h2><p>由于抛异常只要找到匹配的catch就直接跳到catch块执行，没有找到对应catch的函数就不会继续执行。这样导致函数的执行流回很乱。可能会导致一些问题。</p><ul><li><p>构造函数完成对象的构造和初始化，最好不要再构造函数中抛出异常，否则可能导致对象不完整或者没有完全初始化</p></li><li><p>析构函数主要完成资源的清理，最好不要在析构函数中抛异常，否则可能导致内存泄漏。</p></li><li><p>C++异常经常会导致资源泄漏问题。比如：在new和delete中抛出异常，导致new出来的资源没有释放，导致内存泄漏。在lock和unlock中抛出异常，导致锁没有释放，导致死锁。</p></li></ul><p>有两种解决办法：</p><ul><li>将异常捕获，释放资源后，将锁重新抛出。</li><li>使用RAII的思想解决。定义一个类封装，管理资源。当要使用时实例化一个类对象，将资源传入，当退出函数，调用对象析构函数，释放资源。</li></ul><h2 id="异常规范说明">异常规范说明</h2><ul><li><strong>noexcept</strong>：表示函数不抛出异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>noexcept(expression)</strong>： 表示如果 <code>expression</code> 求值结果为 <code>true</code>，则函数不抛出异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(someExpression())</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>早期的异常规范：</strong> 在早期的C++标准中，可以使用 <code>throw()</code> 表示函数不抛出异常，或者使用 <code>throw(type1, type2, ...)</code> 来指定函数可能抛出的异常类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// 函数不抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">anotherFunction</span><span class="params">()</span> <span class="title">throw</span><span class="params">(std::exception, MyException)</span></span>; <span class="comment">// 函数可能抛出 std::exception 或 MyException</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>现代C++中的 noexcept</strong>： 推荐使用 <code>noexcept</code> 关键字来表示函数是否抛出异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 函数不抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">anotherFunction</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(someExpression())</span></span>; <span class="comment">// 函数在 someExpression() 为 true 时不抛出异常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>异常规范的问题：</strong> 早期的异常规范在实践中并没有提供太多的好处，而且容易导致问题。因此，自C++11开始，异常规范已经被弃用，而 <code>noexcept</code> 关键字更灵活且更安全。</p><h2 id="自定义异常体系">自定义异常体系</h2><p>在实际中，并不是我们想抛什么异常就抛什么异常，这样会导致捕捉的时候不好捕捉。而是，会建立一个继承体系，<strong>建立一个异常类，派生类继承这个类，来定义出不同的异常。</strong></p><ul><li>到时候抛出异常**，只需要用基类进行捕捉即可**</li><li>基类可以相当于是一个框架，派生类是具体的异常。然后去具体实现异常的内容，然后<strong>抛异常只需要抛派生类，捕捉异常只需要捕捉基类即可。</strong> ‘</li></ul><p>下列使用一个简单实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="comment">//异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Exception</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">0</span>):_errmsg(str), _id(id)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>;<span class="comment">//派生类中输出的指定异常信息</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _errmsg;<span class="comment">//错误信息</span></span><br><span class="line">    <span class="type">int</span> _id;<span class="comment">//错误码</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="comment">//数据库异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SqlException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">1</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//网络异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">2</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//缓存异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheException</span> :<span class="keyword">public</span> Exception&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CacheException</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">nullptr</span>, <span class="type">int</span> id = <span class="number">3</span>)</span><br><span class="line">            :<span class="built_in">Exception</span>(str, id)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">what</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error msg:&quot;</span> &lt;&lt; _errmsg &lt;&lt; endl;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;error id:&quot;</span> &lt;&lt; _id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//当网络连接失败，抛出这个异常即可</span></span><br><span class="line">    <span class="comment">//throw HttpException(&quot;Http fail&quot;, 2);</span></span><br><span class="line">    <span class="comment">//当缓存错误,抛出这个异常</span></span><br><span class="line">    <span class="comment">//throw CacheException(&quot;Cache error&quot;, 3);</span></span><br><span class="line">    <span class="comment">//当数据库错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">SqlException</span>(<span class="string">&quot;Sql error&quot;</span>, <span class="number">4</span>);<span class="comment">//抛出派生类异常对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//捕获基类异常，</span></span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> Exception&amp; a)&#123;</span><br><span class="line">        a.<span class="built_in">what</span>();<span class="comment">//输出错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unknow exception&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-标准库的异常体系">C++标准库的异常体系</h2><p>在C++库中也建立了一个异常体系。也给我们提供了一些异常类。我们可以在程序中使用这些标准异常，它们也是以父子类层次结构组织起来的。</p><ul><li>基类：std::exception</li><li>派生类：std::runtime_error等</li></ul><h2 id="异常优缺点">异常优缺点</h2><p><strong>优点</strong>：</p><ul><li>异常对象定义好了，相比较于错误码，可以清晰准确的展示出错误的各种信息，甚至包含堆栈调用信息，可以帮我们很好的定位程序的bug。</li><li>在函数调用链中，深层函数返回错误，我们得层层返回，需要不断的判断是什么错误，再返回给最外层。异常直接会找到对应的catch执行，不需要判断是什么错误。</li><li>部分函数更好处理，比如没有返回值的函数或者返回值为自身的T&amp; operator，不好返回错误码。并且pos越界了，内存错误等不需要终止程序。</li><li>更好的进行测试代码</li></ul><p><strong>缺点</strong>：</p><ul><li>异常导致执行流乱跳，运行混乱。导致我们调试和分析程序时，比较困难。</li><li>C++没有垃圾回收机制，可能会导致异常安全问题。开辟的资源和打开的流，由于执行流乱跳，导致没有释放和关闭等。导致内存泄漏。打开的锁为关闭，导致死锁。</li><li>C++标准库的异常体系定义不好，导致我们需要各自定义各自的体系，非常混乱。</li><li>随意抛异常，外层不好捕获，所以尽量按找异常规范使用。</li></ul><h2 id="RTTI">RTTI</h2><p>在C++中，RTTI是<strong>运行阶段类型识别</strong>的简称（Runtime Type Identification）。它允许在程序运行时获取对象的类型信息。是新添加到C++中的特性之一，很多老式实现不支持。主要用途包括：</p><ol><li><strong>识别对象类型：</strong> RTTI允许在程序运行时确定对象的类型。这对于处理多态性和动态多态性（dynamic polymorphism）非常有用。例如，在一个基类的指针或引用指向派生类对象时，你可以使用RTTI来确定实际派生类的类型。</li><li><strong>安全的类型转换：</strong> 在某些情况下，你可能需要将基类指针或引用安全地转换为派生类指针或引用。RTTI的<code>dynamic_cast</code>运算符可用于执行这种安全的转换，它会在转换之前检查类型信息，如果转换不安全，<strong>它会返回空指针或引发异常</strong>，而不是导致未定义行为。</li><li><strong>类型检查：</strong> RTTI允许你在运行时检查对象的类型信息，从而采取相应的措施。这对于实现一些通用的算法或框架，需要根据对象的类型来执行不同的操作，非常有用。</li><li><strong>异常处理：</strong> 在一些情况下，RTTI可用于处理异常。当在基类指针或引用上使用<code>dynamic_cast</code>时，如果转换失败，会返回空指针或引发<code>std::bad_cast</code>异常，可以在异常处理中捕获。</li></ol><p>C++中有三个支持RTTI的元素</p><ul><li>dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针，否则，该运算符返回空指针-0</li><li>typeid运算符返回一个指出对象的类型的值</li><li>type_info结构储存了有关特定类型的信息</li></ul><h3 id="dynamic-cast">dynamic_cast</h3><p><strong>dynamic_cast 操作符</strong>：<code>dynamic_cast</code> 用于在运行时执行安全的类型转换，主要用于处理继承关系。它可以将指向基类的指针或引用转换为派生类的指针或引用，同时执行类型检查。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line">   Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (derivedPtr != <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Successfully casted to Derived.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Failed to cast to Derived.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> basePtr;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Derived&amp; derivedRef = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(*basePtr);</span><br><span class="line">    <span class="comment">// 成功转换</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_cast&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 转换失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在一些情况下，RTTI可用于处理异常。当在基类指针或引用上使用dynamic_cast时，如果转换失败，会返回空指针或引发std::bad_cast异常，可以在异常处理中捕获。*/</span></span><br></pre></td></tr></table></figure><h3 id="typeid和type-info">typeid和type_info</h3><p><strong>typeid运算符</strong>：</p><ul><li><strong>用途：</strong> <code>typeid</code>运算符用于在运行时获取对象的类型信息。它返回一个<code>const std::type_info&amp;</code> 对象，该对象包含有关实际类型的信息，其中type_info是在头文件typeinfo(以前是typeInfo.h)中定义的一个类。。</li><li><strong>语法：</strong> <code>typeid(expression)</code>，其中<code>expression</code>是一个表达式，通常是<strong>一个对象或一个类型</strong>。</li></ul><p><strong>type_info类</strong>：</p><ul><li><strong>用途：</strong> <code>type_info</code>是一个类，表示类型信息。它包含有关类型的信息，例如类型的名称。</li><li><strong>成员函数：</strong><ul><li><strong><code>name()</code>：</strong> 返回一个指向包含类型名称的C字符串的指针。请注意，这个名称的格式是实现定义的，可能在不同编译器和平台上有所不同。</li><li><strong>其他成员函数：</strong> 可能会有其他一些实现特定的成员函数，但标准并没有规定。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="type">const</span> std::type_info&amp; typeInfo = <span class="built_in">typeid</span>(*basePtr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object type: &quot;</span> &lt;&lt; typeInfo.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>typeid运算符使得能够确定两个对象是否为同种类型。type_info类重载了==和!运算符，可以使用这些运算符来对类型比较。</strong></p><p><strong>例如</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> Base;</span><br><span class="line">    Derived* derivedPtr = <span class="keyword">new</span> Derived;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Base) == <span class="built_in">typeid</span>(*basePtr)) &lt;&lt; std::endl;<span class="comment">//(*basePtr表示指向的对象)相同,返回值1</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Base) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//返回值0</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Derived) == <span class="built_in">typeid</span>(*basePtr)) &lt;&lt; std::endl;<span class="comment">//返回值0</span></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(Derived) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//返回值1</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">typeid</span>(*basePtr) == <span class="built_in">typeid</span>(*derivedPtr)) &lt;&lt; std::endl;<span class="comment">//,对象不同返回值0</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">delete</span> derivedPtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>智能指针模板类</h1><p>当谈到C++中的智能指针时，通常会涉及到 <code>std::shared_ptr</code> 和 <code>std::unique_ptr</code> 这两个模板类。还有一个<code>std::auto_ptr</code>已经被摒弃，但在C++11以前使用了多年，如果编译器不支持其他两种，则auto_ptr是唯一选择。<strong>这些智能指针类旨在管理动态分配的内存，并在对象不再需要时自动释放该内存，从而避免内存泄漏和悬挂指针的问题。</strong></p><p>要创建智能指针对象，必须包含头文件<strong>memory</strong>，该文件模板定义。然后使用通常的模板语法来实例化所需类型的指针。</p><h2 id="auto-ptr模板类">auto_ptr模板类</h2><p><code>std::auto_ptr</code> 是 C++98 标准中引入的智能指针，用于管理动态分配的内存。然而，它在 C++11 标准中已被弃用，并且在 C++17 标准中已经被移除。主要原因是 <code>std::auto_ptr</code> 存在一些问题，特别是在资源所有权转移方面存在潜在的危险。</p><p>一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">autoPtr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    *autoPtr1 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// autoPtr2 现在拥有 autoPtr1 的内存所有权</span></span><br><span class="line">    std::auto_ptr&lt;<span class="type">int</span>&gt; autoPtr2 = autoPtr1;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; *autoPtr1 &lt;&lt; std::endl;<span class="comment">//输出1</span></span><br><span class="line">    <span class="comment">// 这里autoPtr1不再拥有资源，会导致运行时错误</span></span><br><span class="line">    <span class="comment">// 使用 autoPtr1 时可能会出现未定义的行为</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">double</span>&gt; <span class="title">autoPtr3</span><span class="params">(<span class="keyword">new</span> <span class="type">double</span>)</span></span>;</span><br><span class="line">    *autoPtr3 = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; *autoPtr3 &lt;&lt; std::endl;<span class="comment">//输出3.14</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::auto_ptr&lt;string&gt; <span class="title">autoPtr4</span><span class="params">(<span class="keyword">new</span> string)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>std::auto_ptr</strong>具有独占所有权的特性，但其所有权转移的方式可能导致一些问题，因为它采用了移动语义而非拷贝语义。这意味着当一个 <strong>std::auto_ptr</strong>所有权转移给另一个时，原始的 <strong>std::auto_ptr</strong> 将不再拥有对资源的所有权。</p></div><h2 id="shared-ptr模板类">shared_ptr模板类</h2><p><code>std::shared_ptr</code> 是一种共享所有权的智能指针，多个 <code>shared_ptr</code> 实例可以共享对同一块内存的所有权。它使用引用计数来追踪有多少个 <code>shared_ptr</code> 共享相同的资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 创建一个shared_ptr并分配内存</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  等价于std::shared_ptr&lt;int&gt; sharedPtr(new int(42));</span></span><br><span class="line"><span class="comment">         *  但是std::make_shared&lt;int&gt;(42)更加安全，因为它有性能优势和异常安全性</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 共享所有权</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; anotherSharedPtr = sharedPtr;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;sharedPtr: &quot;</span> &lt;&lt; *sharedPtr &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;anotherSharedPtr: &quot;</span> &lt;&lt; *anotherSharedPtr &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 使用sharedPtr和anotherSharedPtr</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当最后一个shared_ptr离开作用域时，内存会被自动释放</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="unique-ptr模板类">unique_ptr模板类</h2><p><code>std::unique_ptr</code> 是一种独占所有权的智能指针，一个 <code>unique_ptr</code> 实例独立拥有对其指向的资源的所有权，不能共享。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建一个unique_ptr并分配内存</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; uniquePtr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::cout &lt;&lt; *uniquePtr &lt;&lt; std::endl;<span class="comment">//输出42</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  等价于std::unique_ptr&lt;int&gt; sharedPtr(new int(42));</span></span><br><span class="line"><span class="comment">         *  但是std::make_unique&lt;int&gt;(42)更加安全，因为它有性能优势和异常安全性</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// unique_ptr不能直接赋值给另一个unique_ptr（会发生所有权转移）</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; anotherUniquePtr = uniquePtr;  // 错误，编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过std::move进行所有权转移</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; anotherUniquePtr = std::<span class="built_in">move</span>(uniquePtr);</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt; *anotherUniquePtr &lt;&lt; std::endl;<span class="comment">//输出42</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用anotherUniquePtr</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当anotherUniquePtr离开作用域时，内存会被自动释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="unique-ptr为何优于auto-ptr">unique_ptr为何优于auto_ptr</h2><ol><li><p><strong>更安全的所有权转移：</strong> <code>std::unique_ptr</code> 使用移动语义进行所有权转移，而 <code>std::auto_ptr</code> 使用复制语义。由于 <code>std::auto_ptr</code> 的复制语义可能导致不明确的行为，因此在 C++11 引入 <code>std::unique_ptr</code> 时，<code>std::auto_ptr</code> 被标记为已弃用。使用 <code>std::unique_ptr</code> 更容易理解和更安全。</p></li><li><p><strong>支持数组和自定义删除器：</strong> <code>std::unique_ptr</code> 可以用于管理数组（<code>std::unique_ptr&lt;T[]&gt;</code>），而 <code>std::auto_ptr</code> 不支持这种用法。此外，<code>std::unique_ptr</code> 还支持通过自定义删除器来管理非默认方式分配的资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">arrayPtr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">arrayPtr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arrayPtr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">arrayPtr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p><strong>更灵活的模板参数：</strong> <code>std::unique_ptr</code> 具有更灵活的模板参数，可以轻松地与自定义删除器和分配器一起使用。这提供了更多的灵活性，以适应各种资源管理需求。</p></li><li><p><strong>更严格的所有权管理：</strong> <code>std::unique_ptr</code> 严格实现了独占所有权的概念，一个 <code>std::unique_ptr</code> 实例独立拥有对其指向的资源的所有权。这使得代码更加明确，减少了潜在的错误。</p></li></ol><p><strong>警告</strong>：</p><p><strong>只有使用new分配内存时</strong>，才能使用auto_ptr和shared_ptr，<strong>使用new[] 分配内存时</strong>，不能使用它们，只能使用unique_ptr。<strong>不使用new或new[]分配内存时</strong>，也不能使用unique_ptr。</p><h1>标准模板库STL</h1><h2 id="模板类vector-2">模板类vector</h2><p><strong>vector又名动态数组</strong></p><p><a href="https://blog.csdn.net/qq_52324409/article/details/121000029?ops_request_misc=%7B%22request%5Fid%22%3A%22170903352516800180642186%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170903352516800180642186&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121000029-null-null.142%5Ev99%5Epc_search_result_base1&amp;utm_term=vector%E5%AE%B9%E5%99%A8&amp;spm=1018.2226.3001.4187">C++ vector容器详解_c++容器vector-CSDN博客</a></p><h2 id="基于范围的for循环">基于范围的for循环</h2><p>基于范围的for循环是为用于STL而设计的。在这种for循环中，括号中的代码<strong>声明一个类型(通常用auto)与容器储存的内容相同的变量</strong>，然后指出了容器的名称。接下来，循环体使用指定的变量依次访问容器的每个元素。若<strong>使用引用参数，则可修改容器内容</strong>。</p><p>一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> price[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; price2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*未使用引用参数，不能修改容器内容*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: price) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*使用引用可以修改容器内容*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x: price2) &#123;</span><br><span class="line">        x=<span class="number">10</span>;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="泛型编程">泛型编程</h2><p>STL是一种泛型编程。面向对象编程关注的是编程的数据方面，而泛型编程关注的则是算法。他们之间的共同点是抽象和创建可重用代码，但他们的理念绝然不同。</p><p>泛型编程旨在编写独立于数据类型的代码。在C++中，完成通用程序的工具是模板。模板使得能够按泛型定义函数或类，而STL通过通用算法更近了一步。为了解模板和设计是如何协同工作的，我们需要先了解一下迭代器。</p><h3 id="迭代器">迭代器</h3><p>在C++中，模板使得<strong>算法独立于储存的数据类型</strong>，而迭代器使<strong>算法独立于使用的容器类型</strong>，迭代器（Iterator）是一种用于遍历容器（如数组、向量、链表等）中元素的对象。迭代器提供了一种统一的方式来访问容器中的元素，而不必关心容器的具体类型或实现细节。C++标准库提供了多种类型的迭代器，<strong>主要分为五种</strong>：</p><ol><li><strong>Input Iterator（输入迭代器）</strong>：<ul><li>只允许从容器中读取元素，但不能修改元素。</li><li>支持逐个递增，只能用于单向遍历。</li></ul></li><li><strong>Output Iterator（输出迭代器）</strong>：<ul><li>只允许往容器中写入元素，但不能读取元素。</li><li>支持逐个递增，也只能用于单向遍历。</li></ul></li><li><strong>Forward Iterator（前向迭代器）</strong>：<ul><li>具有Input Iterator和Output Iterator的功能，支持读写操作。</li><li>支持逐个递增，可用于单向遍历。</li></ul></li><li><strong>Bidirectional Iterator（双向迭代器）</strong>：<ul><li>具有Forward Iterator的功能，同时支持逐个递减。</li><li>支持双向遍历，即可以前进也可以后退。</li></ul></li><li><strong>Random Access Iterator（随机访问迭代器）</strong>：<ul><li>具有Bidirectional Iterator的功能，同时支持随机访问元素。</li><li>支持通过指针算术运算（如 +、-）直接跳跃访问容器中的元素。</li></ul></li></ol><p>在C++标准库中，不同的容器提供不同类型的迭代器，例如，<code>std::vector</code>和<code>std::list</code>提供了双向迭代器，而<code>std::array</code>和<code>std::deque</code>提供了随机访问迭代器。在使用迭代器时，要注意选择适当的类型以满足操作的需求。。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义一个迭代器...*/</span></span><br><span class="line">vector&lt;type&gt;::iterator it;</span><br><span class="line">list&lt;type&gt;::iterator it2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*一个简单的示例*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; price= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">list&lt;<span class="type">double</span>&gt;::iterator it2;<span class="comment">//定义的一个遍历list容器的迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = price2.<span class="built_in">begin</span>();<span class="comment">//定义的一个遍历vector容器的迭代器</span></span><br><span class="line"><span class="keyword">for</span>(; it != price2.<span class="built_in">end</span>(); it++)<span class="comment">//迭代器支持前缀++和后缀++，遍历容器</span></span><br><span class="line">&#123;</span><br><span class="line">   std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上作为一种编程风格，最好避免直接使用迭代器，而应尽可能使用STL函数(for_each())来处理细节。也可以使用C++11新增的基于范围的for循环。</p><h3 id="容器">容器</h3><p>STL具有容器概念和容器类型。概念是具有名称(容器、序列容器、关联容器)的通用类别，容器类型是可用于创建具体容器对象的模板。</p><p>主要的容器分类包括：</p><ol><li><strong>序列容器（Sequence Containers）</strong>：<ul><li>顺序存储元素，元素的顺序与它们被插入的顺序相同。</li><li>包括：<ul><li><strong>std::vector：</strong> 动态数组，支持快速随机访问。</li><li><strong>std::list：</strong> 双向链表，支持在任意位置快速插入和删除元素。</li><li><strong>std::deque：</strong> 双端队列，支持在两端快速插入和删除元素。</li><li><strong>std::array：</strong> 固定大小的数组，支持快速随机访问。</li></ul></li></ul></li><li><strong>关联容器（Associative Containers）</strong>：<ul><li>基于键值对（Key-Value）的存储方式，通过键值来快速查找元素。</li><li>包括：<ul><li><strong>std::set：</strong> 有序集合，不允许重复元素。</li><li><strong>std::map：</strong> 有序映射，存储键值对，不允许重复的键。</li><li><strong>std::multiset：</strong> 有序集合，允许重复元素。</li><li><strong>std::multimap：</strong> 有序映射，允许重复的键。</li></ul></li></ul></li><li><strong>无序容器（Unordered Containers）</strong>：<ul><li>使用哈希表实现，元素的存储顺序不固定。</li><li>包括：<ul><li><strong>std::unordered_set：</strong> 无序集合，不允许重复元素。</li><li><strong>std::unordered_map：</strong> 无序映射，存储键值对，不允许重复的键。</li><li><strong>std::unordered_multiset：</strong> 无序集合，允许重复元素。</li><li><strong>std::unordered_multimap：</strong> 无序映射，允许重复的键。</li></ul></li></ul></li><li><strong>容器适配器（Container Adapters）</strong>：<ul><li>提供特定接口的封装，简化了底层容器的使用。</li><li>包括：<ul><li><strong>std::stack：</strong> 栈，后进先出（LIFO）。</li><li><strong>std::queue：</strong> 队列，先进先出（FIFO）。</li><li><strong>std::priority_queue：</strong> 优先队列，按照优先级排序。</li></ul></li></ul></li></ol><p><strong>用法见</strong>：<a href="https://blog.csdn.net/qq_45524532/article/details/115386824?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=C++%E5%AE%B9%E5%99%A8&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-115386824.142%5Ev99%5Epc_search_result_base9&amp;spm=1018.2226.3001.4187">C++常用容器-CSDN博客</a></p><h2 id="函数对象">函数对象</h2><p>在C++中，函数对象（Function Objects），也称为函数符或仿函数（Functor），函数符是可以以函数方式与()结合使用的任意对象。这包括函数名的指针和重载了()运算符对象的类(即定义了函数operator()()的类)。是一种可调用对象，可以像函数一样被调用。函数对象通常是类对象，但不像普通函数，它们可以携带状态信息，并可以通过成员函数实现自定义行为。函数对象可用于算法、STL容器等各种场景中。</p><p><strong>函数对象类</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数符类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddFunctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用方式</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddFunctor addFunctor;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">addFunctor</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 结果为7</span></span><br></pre></td></tr></table></figure><h3 id="应用">应用</h3><ol><li><strong>函数对象作为算法的参数</strong>：</li></ol><p>函数对象可以作为算法的参数，提供一种灵活的方式来定制算法的行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SquareFunctor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    SquareFunctor squareFunctor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象对容器中的每个元素进行平方操作</span></span><br><span class="line">    std::<span class="built_in">transform</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), numbers.<span class="built_in">begin</span>(), squareFunctor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在numbers为 &#123;1, 4, 9, 16, 25&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>函数对象与STL</strong>：</li></ol><p>函数对象在STL（标准模板库）中广泛应用，例如在排序、查找等算法中可以通过函数对象来指定比较的规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DescendingOrder</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    DescendingOrder descendingOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象进行降序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), descendingOrder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在numbers为 &#123;8, 5, 3, 2, 1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法">算法</h2><p><strong>STL的算法</strong>：</p><ul><li><strong>作用范围</strong>：STL的算法是独立于容器的通用算法。它们被设计为能够在不同类型的容器上进行操作，而不依赖于具体容器的实现。这种独立性使得同一个算法可以用于不同的数据结构，例如，可以使用<code>std::sort</code>在不同类型的容器上进行排序。</li><li><strong>参数类型</strong>：STL的算法通常接受迭代器（iterator）作为参数，因此可以用于各种容器，如数组、向量、链表等。它们不直接与容器关联，而是通过迭代器与容器交互。</li><li><strong>功能丰富</strong>：STL的算法涵盖了广泛的应用场景，包括排序、查找、数学运算、变换等。这些算法是为了提供通用且高效的数据处理工具。</li></ul><p>以下是一些常用的STL算法及其简要介绍：</p><ol><li><strong>排序算法</strong>：<ul><li><code>std::sort</code>：对容器进行排序，默认是升序排序。可以传递自定义的比较函数或Lambda表达式来实现不同的排序规则。</li><li><code>std::stable_sort</code>：稳定排序，保持相等元素的相对顺序。</li><li><code>std::partial_sort</code>：部分排序，将容器中的一部分元素排序，其余元素不变。</li></ul></li><li><strong>查找算法</strong>：<ul><li><code>std::find</code>：在容器中查找指定值的第一个出现位置。</li><li><code>std::binary_search</code>：在已排序的容器中进行二分查找。</li><li><code>std::count</code>：统计容器中指定值的出现次数。</li></ul></li><li><strong>变换算法</strong>：<ul><li><code>std::transform</code>：将一个范围的元素转换为另一个范围，可以结合函数对象或Lambda表达式进行元素的变换操作。</li><li><code>std::copy</code>：将一个范围的元素复制到另一个范围。</li><li><code>std::replace</code>：替换容器中指定值的所有出现。</li></ul></li><li><strong>删除和修改算法</strong>：<ul><li><code>std::remove</code>：在容器中移除指定值的所有元素，不改变容器大小，返回一个新的结束迭代器。</li><li><code>std::remove_if</code>：根据谓词条件移除满足条件的元素。</li><li><code>std::unique</code>：移除容器中相邻的重复元素，仅保留一个。</li></ul></li><li><strong>数值算法</strong>：<ul><li><code>std::accumulate</code>：对范围内的元素进行累积操作，可以用于计算总和、平均值等。</li><li><code>std::inner_product</code>：计算两个范围的内积。</li><li><code>std::iota</code>：用给定的值填充一个范围。</li></ul></li><li><strong>其他算法</strong>：<ul><li><code>std::min</code>、<code>std::max</code>：找到范围内的最小值和最大值。</li><li><code>std::reverse</code>：将容器中的元素进行反转。</li><li><code>std::rotate</code>：将容器中的元素进行旋转。</li></ul></li></ol><p>C++标准库中还有很多其他有用的算法。使用STL算法，可以编写更简洁、可读性更好的代码，并且由于这些算法经过优化，通常具有较好的性能</p><h2 id="STL总结">STL总结</h2><p>STL（Standard Template Library）是C++标准库的一部分，提供了一套通用的模板类和函数，用于处理常见的数据结构和算法。STL的设计目标是提供高效、灵活、可复用的代码，以便开发者能够更加专注于解决问题而不必重复实现基础数据结构和算法。<strong>STL主要包括以下三个组件</strong>：</p><ol><li>容器：序列容器、关联容器等等</li><li>算法：提供了一系列通用的算法，如排序、查找、变换、合并等。这些算法可以用于不同类型的容器，通过迭代器进行操作，实现了数据结构和算法的分离，增强了代码的可复用性和通用性。算法通过函数对象或函数指针支持用户自定义的操作和比较规则。</li><li>迭代器：迭代器是STL中用于遍历容器元素的通用接口，为算法和容器提供了统一的访问机制。不同类型的容器支持不同类型的迭代器，包括输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器，提供了不同程度的功能和效率。</li></ol><h2 id="其他库">其他库</h2><h3 id="vector、valarray、array">vector、valarray、array</h3><p>C++标准库提供了多个数组模板（<code>std::vector</code>、<code>std::valarray</code>、<code>std::array</code>），每个模板都有其特定的用途和优势。这样设计的目的是为了满足不同的编程需求，提供更丰富、更灵活的选择。以下是这三个数组模板的主要区别和适用场景：</p><ol><li><strong><code>std::vector</code></strong>：</li></ol><ul><li><strong>动态大小</strong>：<code>std::vector</code>是一个动态数组，其大小可以在运行时动态调整。这使得它非常适用于需要动态增减大小的场景，例如在运行时读取不确定数量的数据。</li><li><strong>内存管理</strong>：<code>std::vector</code>会自动处理内存的分配和释放，使得在动态数组的使用上更加方便。</li></ul><ol start="2"><li><strong><code>std::valarray</code></strong>：</li></ol><ul><li><strong>数值运算</strong>：<code>std::valarray</code>设计用于面向数值计算，提供了一些成员函数和操作符用于逐元素进行数学运算。它的目标是提高数值计算的效率。</li><li><strong>元素级别的操作</strong>：<code>std::valarray</code>更适用于执行逐元素的数学运算，如数组的逐元素加法、乘法等。</li></ul><ol start="3"><li><strong><code>std::array</code></strong>：</li></ol><ul><li><strong>固定大小</strong>：<code>std::array</code>是一个静态数组，其大小在编译时就确定了，不能动态改变。这使得它适用于固定大小的场景，例如需要在编译时确定数组大小的情况。</li><li><strong>栈上分配</strong>：<code>std::array</code>通常在栈上分配内存，因此相较于动态数组，它的内存访问更加高效。</li></ul><h3 id="模板initializer-list">模板initializer_list</h3><p>在C++中，<code>initializer_list</code> 是一个标准库中的类模板，用于方便地<strong>初始化容器或其他类的对象</strong>。它允许在对象的构造函数中传递一个初始化列表，类似于数组的初始化方式。<code>initializer_list</code> 的定义位于头文件 <code>&lt;initializer_list&gt;</code> 中。</p><ul><li><strong>用于容器的构造函数</strong>：使得容器类如 <code>std::vector</code>、<code>std::initializer_list</code> 等能够通过初始化列表进行构造。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vector类构造函数中参数使用了initializer_list</span></span><br></pre></td></tr></table></figure><ul><li><strong>容器和类的构造函数重载</strong>：类可以同时提供接受 <code>initializer_list</code> 和其他参数的构造函数，以便支持不同的初始化方式。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">double</span> b) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(std::initializer_list&lt;<span class="type">int</span>&gt; values) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;<span class="comment">//使传递一个初始化列表</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>输入、输出和文件</h1><h2 id="流和缓冲区">流和缓冲区</h2><p>在C++中，流（stream）和缓冲区（buffer）是与输入和输出相关的概念，用于处理数据的流动和存储。流提供了一个抽象层，使得输入和输出可以以统一的方式进行处理，而缓冲区则用于临时存储数据，以提高性能和效率。</p><h3 id="流（Stream）">流（Stream）</h3><p>流是一个抽象的概念，表示数据在程序和外部设备（如文件、屏幕、键盘等）之间的传输。在C++中，标准库提供了一些流类（如iostream、fstream、stringstream等），用于实现输入和输出的操作。流可以分为输入流和输出流，分别用于读取和写入数据。</p><p>常见的流类包括：</p><ol><li><p><strong><code>iostream</code>：</strong> 提供了<code>cin</code>（标准输入流）和<code>cout</code>（标准输出流），用于从键盘读取输入和向屏幕输出数据。</p></li><li><p><strong><code>fstream</code>：</strong> 用于文件输入和输出，包括<code>ifstream</code>（文件输入流）和<code>ofstream</code>（文件输出流）。</p></li><li><p><strong><code>stringstream</code>：</strong> 用于在内存中操作字符串，可以将字符串作为输入或输出流处理。</p></li></ol><h3 id="缓冲区（Buffer）">缓冲区（Buffer）</h3><p>缓冲区是用于暂时存储数据的区域，它可以提高输入输出的效率。标准库中的流都具有与之关联的缓冲区，用于暂时存储数据，然后一次性地进行读取或写入，而不是每次都直接与外部设备进行通信。</p><p>流的缓冲区可以分为两种：</p><ol><li><strong>输入缓冲区：</strong> 存储从外部设备（如键盘或文件）读取的数据，以便程序可以逐一处理。</li><li><strong>输出缓冲区：</strong> 存储要写入外部设备的数据，以提高写入效率。</li></ol><p>在一些情况下，你可能需要手动刷新缓冲区，以确保数据被及时处理。使用<code>flush()</code>函数可以强制将输出缓冲区的内容写入外部设备。</p><h2 id="iostream文件">iostream文件</h2><p><code>iostream</code>是C++标准库中的头文件之一，它包含了对输入和输出流的支持。具体而言，<code>iostream</code>是由两个基本的头文件合并而成，分别是：</p><ul><li><strong><code>istream</code>（Input Stream）：</strong> 用于输入流，提供了从输入设备（如键盘）读取数据的功能。主要的类包括<code>istream</code>和<code>ifstream</code>。</li><li><strong><code>ostream</code>（Output Stream）：</strong> 用于输出流，提供了向输出设备（如屏幕或文件）写入数据的功能。主要的类包括<code>ostream</code>和<code>ofstream</code>。</li></ul><p>通过合并这两个头文件，得到了<code>iostream</code>，其中包括了<code>cin</code>、<code>cout</code>、<code>cerr</code>、<code>clog</code>等标准流对象，以及相关的功能和操作符重载，使得输入输出操作变得简便和灵活。</p><p>C++的iostream库管理了很多细节。例如在程序中包换iostream文件将自动创建8个流对象(4个用于窄字符流，4个用于宽字符流)</p><p>常见的8个流对象及其用途包括：</p><ul><li><strong><code>cin</code>：</strong> 标准输入流，用于从用户输入中读取数据，wcin对象于此类似但处理的是wchar_t(宽字符类型)类型。</li><li><strong><code>cout</code>：</strong> 标准输出流，用于将数据输出到控制台。wcout对象于此类似但处理的是wchar_t(宽字符类型)类型。</li><li><strong><code>cerr</code>：</strong> 标准错误流，没有被缓冲，用于输出错误信息到控制台。wcerr对象于此类似但处理的是wchar_t(宽字符类型)类型。</li><li><strong><code>clog</code>：</strong> 标准日志流，用于输出程序运行时的一般信息。wclog对象于此类似但处理的是wchar_t(宽字符类型)类型。</li></ul><h3 id="cerr和clog">cerr和clog</h3><p>在C++中，<code>cerr</code>和<code>clog</code>都是标准错误流，用于输出错误信息到控制台。它们是<code>ostream</code>类的实例，提供了与<code>cout</code>相似的输出功能，但通常用于不同的目的。</p><ol><li><p><strong><code>cerr</code>（标准错误流）：</strong></p><ul><li><code>cerr</code>是一个标准错误流对象，用于输出程序的错误信息。</li><li>与<code>cout</code>不同，<code>cerr</code>的<strong>输出默认不被缓冲</strong>，意味着错误消息会立即显示在控制台上，而<strong>不受缓冲机制的影响</strong>。</li><li>通常用于输出紧急的错误信息，以便及时发现问题。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;This is an error message.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>clog</code>（标准日志流）：</strong></p><ul><li><code>clog</code>也是一个标准错误流对象，用于输出程序运行时的一般信息，类似于日志。</li><li>与<code>cerr</code>不同，<code>clog</code>的输出默认是被缓冲的，可以通过<code>std::flush</code>强制刷新输出，或者等到缓冲区满时才刷新。</li><li><strong>通常用于输出程序的运行时信息，方便调试和了解程序执行的进展</strong>。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::clog &lt;&lt; <span class="string">&quot;This is a log message.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总体而言，<code>cerr</code>和<code>clog</code>都是用于输出程序的诊断信息的标准错误流，它们与<code>cout</code>一起构成了C++中的标准流。选择使用哪一个取决于你的需求，如果你需要及时看到错误信息，可以使用<code>cerr</code>，如果你希望输出日志信息，并允许一定程度的缓冲，可以使用<code>clog</code>。</p><h2 id="使用cout进行输出">使用cout进行输出</h2><h3 id="重载的-运算符">重载的&lt;&lt;运算符</h3><p>在C++中，&lt;&lt;运算符的默认含义是按位左移运算符，但ostream类重新定义了&lt;&lt;运算符，将其重载为输出。在这种情况下&lt;&lt;能识别C++中的所有的基本类型(int、double、string…)</p><p>对于上述每种类型，ostream类提供了operator&lt;&lt;()函数的定义。</p><p>&lt;&lt;运算符的所有化身返回类型都是ostream&amp;，格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(type);</span><br></pre></td></tr></table></figure><p>意味着该运算符将返回一个指向ostream对象的引用，该引用指向用于调用该运算符的对象。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">// &lt;&lt;运算符返回的是cout对象</span></span><br></pre></td></tr></table></figure><p>这种特性使得cout能串联输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;oh&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="其他osteam方法">其他osteam方法</h3><p>ostream还提供了put()方法和write()方法</p><p>put：用于显示字符</p><p>write：用于显示字符串</p><ul><li>put原型：将一个字符插入到输出流中。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">put</span><span class="params">(<span class="type">char</span>)</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;W&#x27;</span>);</span><br><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;I&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;t&#x27;</span>);<span class="comment">//可进行拼接输出</span></span><br><span class="line">cout.<span class="built_in">put</span>(<span class="number">65</span>) <span class="comment">//输出A</span></span><br><span class="line">cout.<span class="built_in">put</span>(<span class="number">66.3</span>) <span class="comment">//自动将double值66.3转换为char值66，输出B</span></span><br></pre></td></tr></table></figure><ul><li><p>write模板原型： 将指定数量的字符从指定位置的字符串插入到输出流中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">basic_ostream&lt;<span class="type">char</span>, Traits&gt;&amp; <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, streamsize n)</span></span>;</span><br><span class="line"></span><br><span class="line">-第一个参数为指定字符串</span><br><span class="line">-第二个参数为指定长度</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello, C++!&quot;</span>;</span><br><span class="line">    cout.<span class="built_in">write</span>(message, <span class="number">6</span>); <span class="comment">// 将 &quot;Hello&quot; 写入输出流</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="刷新输出缓冲区">刷新输出缓冲区</h3><ul><li><p>在C++中，刷新输出缓冲区是指将缓冲区中的数据强制写入输出设备。默认情况下，输出流（如<code>cout</code>、<code>cerr</code>等）会将数据存储在内部缓冲区中，而不是每次写入一个字符就立即刷新到输出设备。刷新输出缓冲区的操作可以通过 <code>flush</code> 方法或 <code>flush</code> 操纵符来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一种*/</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is some text.&quot;</span> &lt;&lt; flush; <span class="comment">// 刷新输出缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第二种*/</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is some text.&quot;</span> &lt;&lt; endl;   <span class="comment">// endl 操纵符会输出一个换行符并刷新输出缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*第三种*/</span></span><br><span class="line"><span class="built_in">flush</span>(cout);</span><br></pre></td></tr></table></figure></li></ul><h3 id="用cout进行格式化">用cout进行格式化</h3><ol><li><strong>控制输出的进制</strong>：在下一次将格式状态修改为其他进制时才会输出其他进制，否则一直按照设置进制之后进行输出</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 十六进制输出</span></span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; <span class="string">&quot;Hexadecimal: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*或者使用hex(cout)、oct(cout)*/</span></span><br><span class="line">    <span class="comment">// 八进制输出</span></span><br><span class="line">    cout &lt;&lt; oct &lt;&lt; <span class="string">&quot;Octal: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hex,oct都是控制符</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>调整字段宽度和对齐方式</strong>：width()方法只影响接下来显示的一个项目，然后字段宽度将恢复为默认值</li></ol><p>使用width()进行设置字段宽度，left左对齐，right右对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> num2 = <span class="number">45.6789</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制输出宽度和对齐方式</span></span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; left &lt;&lt; num1;</span><br><span class="line">    </span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; right &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>填充字符</strong>：</li></ol><p>在默认情况下，cout用空格填充字段中未被使用的部分，可以使用fill()成员函数来改变填充字符。<strong>在下次修改之前将一直使用之前修改的字符填充</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> num2 = <span class="number">45.6789</span>;</span><br><span class="line">    cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">// 控制输出宽度和对齐方式</span></span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);<span class="comment">//宽度为10，前7位用*填充</span></span><br><span class="line">    cout &lt;&lt; right &lt;&lt; num1;</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; right &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>设置浮点数的显示精度</strong>：</li></ol><p>浮点数精度的含义取决于输出模式。在<strong>默认情况</strong>下，指的是显示的总位数，在<strong>定点模式和科学模式</strong>下，精度指的是小数点后面的位数。c++默认精度位6位(末尾的0不显示)。precision()成员函数使得能选择其他值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cout精度设置为2</span></span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>打印末尾的0和小数点</strong>：</li></ol><p>对于有些输出(比如价格栏中的数字)，保留末尾的0将更为美观。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.setf(ios_base::showpoint);</span><br></pre></td></tr></table></figure><p><strong>上面的dec、hex、oct、left、right等都是标准控制符能够调用setf()，并且自动提供正确的参数，工作方式都相似。</strong></p><h3 id="头文件iomanip">头文件iomanip</h3><p>使用iostream工具来设置一些格式值有时不太方便。为简化工作，C++在头文件iomanip中提供了一些控制符，作用类似，表示更方便。常用的有三个：setprecision()、setfill()和setw()，表示设置精度、填充字符、字段宽度。</p><p>setprecision()：接受一个指定精度的整数参数</p><p>setfill()：接受一个指定字段宽度的整数参数</p><p>setw()：接受一个指定填充字符的char参数</p><p>因为他们都是控制符，故可以使用cout将语句连接起来。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> root = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">10</span>;n&lt;=<span class="number">100</span>; n+=<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;.&#x27;</span>) &lt;&lt; n &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">12</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; root &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用cin进行输入">使用cin进行输入</h2><h3 id="cin如何检查输入">cin如何检查输入</h3><p>不同版本的抽取运算符查看输入流的方法是相同的。<strong>他们跳过空白（空格、换行符、制表符），直到遇到非空白字符</strong>。即使对于单字符模式（char、unsigned char）也是如此。在其他模式下，&gt;&gt;运算符将读取一个指定类型的数据。<strong>将从非空白字符开始，到与目标类型不匹配的第一个字符的全部内容</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"><span class="comment">//假设输入12348z</span></span><br><span class="line">cout &lt;&lt; num;<span class="comment">//输出12348，剩下的留在输入缓冲区</span></span><br></pre></td></tr></table></figure><h3 id="流状态">流状态</h3><p>在C++中，<code>cin</code> 对象的流状态会受到输入的影响。<code>cin</code> 是C++标准库中的标准输入流对象，用于从标准输入设备（通常是键盘）获取用户输入。流状态的不同值反映了输入的有效性和状态。以下是一些关于 <code>cin</code> 流状态的详细介绍：</p><ol><li><strong>流状态位</strong>：</li></ol><p><code>cin</code> 有一系列的流状态位，主要的有：</p><ul><li><strong><code>failbit</code>：</strong> 当输入的数据类型不匹配或输入格式错误时，<code>failbit</code> 会被设置。例如，用户输入了非整数字符而 <code>cin</code> 期望输入整数。</li><li><strong><code>badbit</code>：</strong> 当输入流发生严重错误时，如IO错误或设备故障，<code>badbit</code> 会被设置。</li><li><strong><code>eofbit</code>：</strong> 当遇到文件末尾时，<code>eofbit</code> 会被设置。</li><li><strong><code>goodbit</code>：</strong> 表示没有错误发生。</li></ul><ol start="2"><li><strong>流状态查询</strong>：</li></ol><p>可以通过 <code>cin</code> 对象的成员函数 <code>fail()</code>、<code>bad()</code>、<code>eof()</code> 和 <code>good()</code> 来查询流的状态。</p><ul><li><strong><code>fail()</code>：</strong> 返回 <code>true</code> 表示 <code>failbit</code> 或 <code>badbit</code> 被设置。</li><li><strong><code>bad()</code>：</strong> 返回 <code>true</code> 表示 <code>badbit</code> 被设置。</li><li><strong><code>eof()</code>：</strong> 返回 <code>true</code> 表示 <code>eofbit</code> 被设置。</li><li><strong><code>good()</code>：</strong> 返回 <code>true</code> 表示没有任何错误位被设置，即 <code>goodbit</code> 被设置。</li></ul><ol start="3"><li><strong>流状态的影响</strong>：</li></ol><p>在使用 <code>cin</code> 进行输入时，输入的有效性和格式与流状态密切相关。如果输入不符合预期，流状态位将被设置，进而影响程序的行为。例如：</p><h3 id="使用cin错误处理">使用cin错误处理</h3><p>在使用 <code>cin</code> 进行输入时，最好进行错误处理，以确保用户输入的数据是有效的。例如，如果用户输入了非整数的字符，<code>cin</code> 将进入错误状态。可以通过检查 <code>cin.fail()</code> 来检测错误，并通过 <code>cin.clear()</code> 来清除错误状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter an integer: &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!(cin &gt;&gt; num)) &#123;</span><br><span class="line">        <span class="comment">/*输入有效返回true，无效返回false*/</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Invalid input. Please enter an integer: &quot;</span>;</span><br><span class="line">        cin.<span class="built_in">clear</span>(); <span class="comment">// 清除错误状态</span></span><br><span class="line">      cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 忽略缓冲区中的无效字符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- cin.clear() 的作用是清除 cin 对象的错误状态，以便能够继续尝试接收输入。如果不清除错误状态，cin 会一直保持在错误状态，导致后续的输入操作无法正常进行。</span><br><span class="line"></span><br><span class="line">- cin.ignore(numeric_limits&lt;streamsize&gt;<span class="punctuation">:</span><span class="punctuation">:</span>max()<span class="punctuation">,</span> &#x27;\n&#x27;) 的作用是清除输入缓冲区中的无效字符，直到遇到换行符为止。这通常用于处理用户输入错误时，清除缓冲区中的残留字符，以便下一次输入操作不受之前错误的影响。</span><br><span class="line"></span><br><span class="line">- cin.fail() 是 cin 流的一个成员函数，用于检查最近一次的输入操作是否成功。它返回一个布尔值，如果最近的输入操作失败，则返回 <span class="literal"><span class="keyword">true</span></span>，否则返回 <span class="literal"><span class="keyword">false</span></span>。</span><br></pre></td></tr></table></figure><h3 id="其他istream类方法">其他istream类方法</h3><ol><li><strong>单字符输入</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(<span class="type">char</span>&amp; )</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在使用char参数或没有参数的情况下，get()方法读取下一个字符，即使该字符是空格、制表符或换行符。get(char&amp; ch)版本将输入字符赋给其参数，而get(void)版本将输入字符转换为整型并将其返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">cin.<span class="built_in">get</span>(c1);</span><br><span class="line"></span><br><span class="line">c1 = cin.<span class="built_in">get</span>();<span class="comment">//返回值为整型</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">cin.<span class="built_in">get</span>(c1).<span class="built_in">get</span>(c2) &gt;&gt; c3;</span><br><span class="line"><span class="comment">//可以进行拼接get，代表先赋值给c1返回调用对象cin，再赋值给c2，返回cin，最后把下一个非空白字符赋值给c3</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ct=<span class="number">0</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line">cin.<span class="built_in">get</span>(ch);<span class="comment">//如果这里替换位&gt;&gt;下面将不会退出循环</span></span><br><span class="line"><span class="keyword">while</span>(ch!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; ch;</span><br><span class="line">    ct++;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设输入 I C++ clearly.&lt;Enter&gt;</span></span><br><span class="line"><span class="comment">//最终输出会跳过空格，输出IC++clearly.</span></span><br></pre></td></tr></table></figure><p>2.<strong>字符串输入</strong>：get()、getline()和ignore()</p><ul><li><strong>cin.get()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">get</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>,<span class="type">char</span>)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">get</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">- <span class="type">char</span>*:放置输入字符串的内存单元的地址</span><br><span class="line">- <span class="type">int</span>:比读取的最大字符大<span class="number">1</span>，额外的一个字符用于存储结果为空字符</span><br><span class="line">- <span class="type">char</span>:指定用作分界符的字符，只有两个参数时将使用换行符用作分界符</span><br><span class="line">    </span><br><span class="line">cin.<span class="built_in">get</span>(array,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>无参数时，读入一个字符，包括换行符，常用来处理输入缓冲区中的换行符。</p><p>有参数时，从缓冲区读取数据，到达行尾或size-1个字符**(剩下的空间储存在结尾添加的空字符)<strong>后结束读取(超过规定字符数不会出现错误,会直接截断)，不会对换行符进行处理，将</strong>其留在输入流**。</p><ul><li><strong>cin.getline()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>,<span class="type">char</span>)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="type">char</span>*,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">- <span class="type">char</span>*:放置输入字符串的内存单元的地址</span><br><span class="line">- <span class="type">int</span>:比读取的最大字符大<span class="number">1</span>，额外的一个字符用于存储结果为空字符</span><br><span class="line">- <span class="type">char</span>:指定用作分界符的字符，只有两个参数时将使用换行符用作分界符</span><br><span class="line">    </span><br><span class="line">cin.<span class="built_in">getline</span>(array,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>从缓冲区读取数据,到达行尾或size-1**(剩下的空间储存在结尾添加的空字符)**个字符结束读取(超过规定的字符数会出现错误,中断)，会读取并丢弃输入流中的换行符。</p><ul><li><strong>ignore()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">ignore</span><span class="params">(<span class="type">int</span> =<span class="number">1</span>,<span class="type">int</span>= EOF)</span></span>;</span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">255</span>,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">255</span>,<span class="string">&#x27;\n&#x27;</span>).<span class="built_in">ignore</span>(<span class="number">255</span>,<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//可拼接</span></span><br></pre></td></tr></table></figure><p>原型为两个参数提供的默认值为1和EOF，EOF导致读取指定数目的字符或读取到文件结尾</p><p><code>cin.ignore</code> 是 C++ 中用于忽略输入流中一定数量字符或特定字符的函数。这个函数通常用于清除输入缓冲区中的不需要的字符，以便在后续的输入操作中不受其影响。</p><h2 id="文件输入输出">文件输入输出</h2><h3 id="文件输入输出-2">文件输入输出</h3><p><strong>iostream: 头文件中定义了一个处理输出的ostream类</strong></p><p><strong>fstream：头文件定义了一个用于处理输出的ofstream类</strong></p><p><strong>文件的输出主要步骤如下</strong>:</p><ol><li><p>包含头文件fstream，iostream</p></li><li><p>创建一个ofstream（output fstream）对象（<strong>通常取名为outFile</strong>）</p></li><li><p>将该ofstream 对象同一个文件关联起来(使用open方法)。</p></li><li><p>向cout那样使用ofstream对象（通常outFile）</p><p><strong>重点</strong>：cout在屏幕上输出，而outFile是在文件中输出（写入）</p></li><li><p>outFile.close()关闭文件流</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span><span class="comment">//步骤1</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">ofstream outFile;<span class="comment">//步骤2</span></span><br><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>,std::ios::out);<span class="comment">//步骤3以写入的方式打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!outFile.<span class="built_in">is_open</span>()) </span><br><span class="line">&#123;<span class="comment">//判断文件是否打开成功，打开成功返回true</span></span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>()</span><br><span class="line">&#123;</span><br><span class="line">    outFile &lt;&lt; data &lt;&lt; endl;<span class="comment">//步骤4，输入文件中</span></span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">    outFile.<span class="built_in">close</span>();<span class="comment">//步骤5，关闭文件流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>文件的输入包括以下步骤</strong>：</p><ol><li><p>包含头文件iostream，包含头文件fstream</p></li><li><p>声明一个或多个<strong>ifstream</strong>（<strong>input fstream</strong>）的变量（对象），并且命名，遵守常用的命名的规则，<strong>通常取名为inFile</strong></p></li><li><p>将ifstream对象与文件关联起来。为此，方法之一是使用open()方法</p></li><li><p>可结合ifstream对象 和运算符&gt;&gt;来输入各种类型的数据。</p></li><li><p>使用inFile.close()关闭文件流</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">255</span>];</span><br><span class="line">    ifstream inFile;<span class="comment">//步骤2</span></span><br><span class="line">    inFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,std::ios::in);<span class="comment">//步骤3</span></span><br><span class="line">    <span class="keyword">if</span> (!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!inFile.<span class="built_in">eof</span>())<span class="comment">//判断是否读取到文件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        inFile &gt;&gt; data;<span class="comment">//步骤4</span></span><br><span class="line">        inFile.<span class="built_in">getline</span>(str,<span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">close</span>();<span class="comment">//步骤5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查文件-2">检查文件</h3><p>格式为: 对象名.isopen()  例：   <strong>inFile.is_open()</strong></p><p>如果文件成功被打开，返回<strong>true</strong>；如果文件没有被打开，<strong>因此表达式   !inFile.is_open()  将为true</strong></p><p><strong>通常使用下方代码判断是否打开成功</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!inFile.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;文件打开失败&quot;</span>;</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//exit(0)程序正常结束</span></span><br><span class="line"><span class="comment">//exit(1)程序异常结束</span></span><br><span class="line"><span class="comment">//exit()使用需要用到头文件cstdlib</span></span><br></pre></td></tr></table></figure><h3 id="判断文件结尾">判断文件结尾</h3><p>格式为：对象名.eof()  例:   <strong>inFile.eof()</strong></p><p><strong>eof在遇到EOF（文件结束标志）时返回ture ，否则返回false</strong></p><p>通常和while循环一起用作文件读取结束，<strong>!inFile.eof</strong>在文件结束前为真，结束为假（退出循环）</p><p>具体格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!inFile.<span class="built_in">eof</span>())<span class="comment">//判断是否读取到文件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        inFile &gt;&gt; data;<span class="comment">//步骤4</span></span><br><span class="line">        inFile.<span class="built_in">getline</span>(str,<span class="number">255</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="文件打开关闭">文件打开关闭</h3><ul><li><strong>文件打开</strong>：</li></ul><p>**1.对象名.open(“文件名”) **（一个参数）例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果文件不存在，将会自动创建一个相同名字的文件,如果文件存在，将会打开该文件，首先截断该文件，将其长度截短到0，丢弃原有的内容，然后将新的输入加入到该文件中</p><p><strong>2.对象名.open(“文件名”，打开方式)</strong> （两个参数）例如 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;student.txt&quot;</span>,std::ios::in)</span><br></pre></td></tr></table></figure><p>只读模式以只读模式打开</p><ul><li><strong>文件关闭</strong>：</li></ul><p>格式：对象名.close()  例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outFile.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>注意方法close()，不需要使用文件名作为参数，因为outFile已经同特定的文件关联起来，如果忘记关闭文件，程序正常终止的时候将自动关闭它。</p><h3 id="打开多个文件">打开多个文件</h3><p>打开多个文件时可以同时打开多个文件流：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">std::ifstream userInFile,managerInFile;</span><br><span class="line">    userInFile.<span class="built_in">open</span>(<span class="string">&quot;user_data.txt&quot;</span>, std::ios::in);</span><br><span class="line">    managerInFile.<span class="built_in">open</span>(<span class="string">&quot;manager_data.txt&quot;</span>, std::ios::in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!userInFile.<span class="built_in">is_open</span>()||!managerInFile.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(!userInFile.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">while</span>(!managerInFile.<span class="built_in">eof</span>())</span><br><span class="line"> &#123;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">    userInFile.<span class="built_in">close</span>();</span><br><span class="line">    managerInFile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件打开模式">文件打开模式</h3><p><a href="https://blog.csdn.net/digitalkee/article/details/105799054?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=c++%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%A8%A1%E5%BC%8F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105799054.142%5Ev99%5Epc_search_result_base1&amp;spm=1018.2226.3001.4187">C++ open 打开文件（含打开模式一览表）_c++ open函数-CSDN博客</a></p><h1>c++新标准</h1><p><strong>更多内容见C++ primer plus 18章</strong></p><h2 id="统一的初始化">统一的初始化</h2><p>C++11扩大了大括号扩起的列表，即初始化列表的使用范围，使其可用于所有内置类型和用户定义的类对象。使用初始化列表时，可添加等号，也可不添加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">double</span> y&#123;<span class="number">2.75</span>&#125;;</span><br><span class="line"><span class="type">short</span> quar[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">76</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>另外初始化列表可用于new表达式中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ar = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>] &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;<span class="comment">//c++11</span></span><br></pre></td></tr></table></figure><h2 id="右值引用">右值引用</h2><h3 id="左值和右值：">左值和右值：</h3><ul><li><p><strong>左值（lvalue）：</strong> <strong>左值是可以标识内存位置的表达式</strong>。通常，左值是具有名称的变量、对象或表达式的结果，它们可以出现在等号的左边，可以被取地址。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;  <span class="comment">// x 是左值</span></span><br><span class="line"><span class="type">int</span>* ptr = &amp;x;  <span class="comment">// &amp;x 是左值，因为它是地址</span></span><br></pre></td></tr></table></figure></li><li><p><strong>右值（rvalue）：</strong> <strong>右值是不能标识内存位置的表达式</strong>。右值通常是临时的、<strong>无法取地址的值</strong>，出现在等号的右边。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">10</span> + <span class="number">5</span>;  <span class="comment">// 10 + 5 是右值</span></span><br><span class="line"><span class="type">int</span> z = x + y;   <span class="comment">// x + y 是右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> z = x;<span class="comment">//x不是右值，可以取地址</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="左值引用和右值引用：">左值引用和右值引用：</h3><ul><li><p><strong>左值引用（lvalue reference）：</strong> 左值引用是用于引用左值的引用类型。它使用 <code>&amp;</code> 符号声明。<strong>左值引用主要用于在函数中传递参数或作为函数的返回类型，以及在赋值操作中</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = x;  <span class="comment">// ref 是对 x 的左值引用</span></span><br></pre></td></tr></table></figure></li><li><p><strong>右值引用（rvalue reference）：</strong> <strong>右值引用是用于引用右值的引用类型</strong>。它使用 <code>&amp;&amp;</code> 符号声明。<strong>右值引用通常与移动语义一起使用，允许有效地将资源从一个对象移动到另一个对象，而不进行深层复制</strong>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">10</span> + <span class="number">5</span>;  <span class="comment">// rref 是对右值的引用</span></span><br><span class="line"><span class="comment">//无法对rref取地址</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>右值引用通常与移动语义结合，例如在移动构造函数和移动赋值运算符中使用，提高了对动态分配资源的效率。左值引用用于传递可修改的参数，而右值引用用于支持移动操作。</strong></p><h2 id="Lambda函数">Lambda函数</h2><p>在C++中，lambda 表达式是一种方便的方式，允许你在函数内部定义匿名函数。它的语法形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// lambda body</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>capture</code> 是捕获列表，用于指定在 lambda 表达式中可以访问的外部变量。</li><li><code>parameters</code> 是 lambda 函数的参数列表。</li><li><code>return_type</code> 是返回类型。</li><li><code>lambda body</code> 包含实际的函数体。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operateWithLambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 表达式，接受两个参数，返回它们的和</span></span><br><span class="line">    <span class="keyword">auto</span> add1 = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式计算并输出结果</span></span><br><span class="line">    <span class="type">int</span> result1 = <span class="built_in">add1</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum1 is: &quot;</span> &lt;&lt; result1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda 表达式也可以访问外部变量</span></span><br><span class="line">    <span class="keyword">auto</span> add2 = [x,y]() -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> result2 = <span class="built_in">add2</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum2 is: &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> addWithExternal = [x](<span class="type">int</span> b) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式计算并输出结果</span></span><br><span class="line">    <span class="type">int</span> resultWithExternal = <span class="built_in">addWithExternal</span>(y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum with external variable is: &quot;</span> &lt;&lt; resultWithExternal &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">operateWithLambda</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">学习C++时的一点笔记</summary>
    
    
    
    <category term="C++" scheme="https://www.thekqd.top/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.thekqd.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++的关键字用法</title>
    <link href="https://www.thekqd.top/posts/d29d5856.html"/>
    <id>https://www.thekqd.top/posts/d29d5856.html</id>
    <published>2024-02-08T08:52:14.000Z</published>
    <updated>2024-02-21T10:15:40.943Z</updated>
    
    <content type="html"><![CDATA[<h1>类型转换运算符</h1><p>C++中，类型转换运算符允许你在不同类型之间执行转换。这些运算符允许你显式地将一个类型转换为另一个类型。C++中有四种类型转换运算符：</p><h2 id="static-cast">static_cast</h2><p><strong>用途</strong>： 主要用于进行静态类型转换，例如将指针或引用从一种类型转换为另一种类型，但在转换时<strong>没有运行时检查</strong>。</p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> doubleValue = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> intValue = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(doubleValue);</span><br></pre></td></tr></table></figure><h2 id="dynamic-cast">dynamic_cast</h2><ul><li><strong>用途</strong>： 主要用于进行安全的动态类型转换，只能在<strong>指针或引用</strong>之间转换，<strong>通常在基类指针或引用和派生类之间进行类型转换</strong>。在运行时，<code>dynamic_cast</code>会检查转换的合法性，成功转换返回新指针，否则返回空指针。</li><li><strong>示例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Base* basePtr = <span class="keyword">new</span> Derived  <span class="comment">/* 指向派生类对象的基类指针 */</span>;</span><br><span class="line">Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (derivedPtr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 转换成功,非空指针</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 转换失败，空指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*有效性检验*/</span></span><br></pre></td></tr></table></figure><h2 id="const-cast">const_cast</h2><ul><li><strong>用途</strong>：主要用于添加或移除<code>const</code>性质。它可以用于去除<strong>指针或引用</strong>的<code>const</code>限定，也可以用于在必要时添加<code>const</code>限定。</li><li><strong>示例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> constValue = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* nonConstPtr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;constValue);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="reinterpret-cast">reinterpret_cast</h2><ul><li><strong>用途</strong>： 执行低级别的类型转换，例如将<strong>指针转换为整数或整数转换为指针</strong>。它是一种较为危险的转换，因为它不进行类型检查。</li><li><strong>示例</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intValue = <span class="number">42</span>;</span><br><span class="line"><span class="type">double</span>* doublePtr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">double</span>*&gt;(&amp;intValue);</span><br></pre></td></tr></table></figure><h2 id="注意事项和使用推荐">注意事项和使用推荐</h2><p><strong>static_cast</strong>：</p><ul><li><p>注意事项：</p><ul><li><code>static_cast</code> 在大多数情况下是相对安全的，但它不能执行运行时检查。</li><li>避免进行不安全或不明确的类型转换，以免引起问题。</li></ul></li><li><p>推荐用途：</p><ul><li>用于执行基本的类型转换，如数值之间的转换，非多态类之间的指针或引用转换。</li><li>在继承层次结构中进行上行转换（基类指针或引用到派生类）。</li></ul></li></ul><p><strong>dynamic_cast</strong>：</p><ul><li>注意事项：<ul><li>仅在存在虚函数的类层次结构中使用 <code>dynamic_cast</code>。</li><li>它会进行运行时类型检查，但只适用于多态类型。</li><li>在使用时要注意返回的指针可能为空，因此需要进行有效性检查。</li></ul></li><li>推荐用途：<ul><li>用于在运行时执行安全的下行转换（派生类指针或引用到基类）。</li><li>用于判断对象的实际类型。</li></ul></li></ul><p><strong>const_cast</strong>：</p><ul><li>注意事项：<ul><li>避免使用 <code>const_cast</code> 去除真正的 <code>const</code> 修饰符，因为这可能导致未定义行为。</li><li>可以用于去除指针或引用上的 <code>const</code> 修饰，但确保不修改原始对象。</li></ul></li><li>推荐用途：<ul><li>用于在函数调用或某些特殊情况下去除指针或引用的 <code>const</code> 限定。</li></ul></li></ul><p><strong>reinterpret_cast</strong>：</p><ul><li>注意事项：<ul><li>非常危险，可能导致未定义行为。</li><li>通常用于底层的硬件交互或者特殊的内存布局情况。</li></ul></li><li>推荐用途：<ul><li>尽量避免使用 <code>reinterpret_cast</code>，除非你确切地了解底层的内存表示和硬件特性。</li></ul></li></ul><h1>explicit</h1><p>C++中的explicit关键字<strong>通常</strong>用于修饰<strong>只有一个参数</strong>的类构造函数, 以指定该构造函数不会被用于隐式类型转换。当构造函数被标记为<strong>explicit</strong>时，它只能被显式调用，而不能隐式地将其参数转换为相应的类类型。跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).</p><p><strong>explicit关键字的作用</strong>：避免类构造函数的隐式自动转换.</p><h2 id="使用说明">使用说明</h2><ul><li><strong>使用了explicit关键字后</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span> : data(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1 = <span class="number">10</span>;  <span class="comment">// 会报错！不能进行隐式类型转换，10不允许被转换为MyClass类型</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;   <span class="comment">// 正确！显式调用构造函数</span></span><br><span class="line">    std::cout &lt;&lt; obj2.<span class="built_in">getData</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>未使用explicit</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">data</span>(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1 = <span class="number">10</span>;  <span class="comment">// 正确！隐式类型转换</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;   <span class="comment">// 正确！显式调用构造函数</span></span><br><span class="line">    std::cout &lt;&lt; obj2.<span class="built_in">getData</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类型转换">类型转换</h2><ol><li><strong>隐式类型转换</strong>：</li></ol><p>在第一个例子中，当我们尝试将一个整数直接赋值给<code>MyClass</code>对象时，发生了隐式类型转换。具体来说，整数<code>10</code>被隐式地转换为<code>MyClass</code>类型的对象。这是因为构造函数没有被声明为<code>explicit</code>，因此编译器可以自动执行类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj1 = <span class="number">10</span>;  <span class="comment">// 隐式类型转换</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>显式类型转换</strong>：</li></ol><p>在两个示例中，都使用了显式类型转换，即通过构造函数来显式创建对象。在第一个例子中，由于构造函数被声明为<code>explicit</code>，因此必须显式调用构造函数来创建对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;  <span class="comment">// 显式类型转换，调用构造函数</span></span><br><span class="line">MyClass obj2 = <span class="built_in">MyClass</span>(<span class="number">20</span>);<span class="comment">//上面等价于这个,但某种情况下可能会增加开销，建议使用上面的更简洁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*在这个语句中，整数 20 被显式地转换为 MyClass 类型的对象，而转换的具体过程是通过调用构造函数来实现的。*/</span></span><br></pre></td></tr></table></figure><p>总之，隐式类型转换是指在不显式指定类型转换的情况下，由编译器自动执行的类型转换。而显式类型转换则是通过显式调用构造函数或其他类型转换操作符来指定类型转换的过程。在使用<code>explicit</code>关键字时，它会禁止隐式类型转换，要求显式地调用构造函数来执行类型转换。</p><h2 id="优点和缺点">优点和缺点</h2><p><strong>优点</strong>：</p><ol><li><strong>明确转换意图：</strong> 明确指定了构造函数的调用方式，防止了隐式类型转换，使代码更加清晰易懂，降低了代码的误解和错误发生的概率。</li><li><strong>增强类型安全性：</strong> 显式指定构造函数调用可以减少类型转换的不确定性，使代码更加健壮，减少了潜在的类型错误。</li><li><strong>减少不必要的转换：</strong> 防止了不必要的自动类型转换，避免了一些不必要的中间步骤和临时对象的创建，提高了程序的性能和效率。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>冗长繁琐：</strong> 使用<code>explicit</code>关键字会使代码变得更加冗长和繁琐，因为在每次创建对象时都需要显式地调用构造函数，增加了代码的复杂度和书写量。</li><li><strong>限制灵活性：</strong> 在某些情况下，隐式类型转换可能会使代码更加简洁和灵活，而使用<code>explicit</code>关键字会限制这种灵活性，使代码的编写和使用更加受限。</li><li><strong>破坏现有代码：</strong> 在现有的代码库中添加<code>explicit</code>关键字可能会破坏原有的隐式类型转换逻辑，导致代码无法编译或者行为发生改变，增加了代码修改和维护的成本。</li></ol><p>综上所述，虽然<code>explicit</code>关键字可以提高代码的安全性和清晰度，但在使用时需要权衡其带来的好处和坏处，根据具体情况来决定是否使用。</p>]]></content>
    
    
    <summary type="html">C++中的一些关键字用法介绍</summary>
    
    
    
    <category term="C++" scheme="https://www.thekqd.top/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.thekqd.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>在Clion上愉快的写Qt</title>
    <link href="https://www.thekqd.top/posts/36b81ed7.html"/>
    <id>https://www.thekqd.top/posts/36b81ed7.html</id>
    <published>2023-12-27T14:45:40.000Z</published>
    <updated>2024-01-20T13:51:00.183Z</updated>
    
    <content type="html"><![CDATA[<h1>Clion配置Qt工具链</h1><p><a href="https://blog.csdn.net/Dusk_Clouds/article/details/120791223?spm=1001.2014.3001.5506">CLion配置qt环境-CSDN</a></p><h1>Clion配置外部工具</h1><h2 id="配置外部工具Qt-Creator和UIC等">配置外部工具Qt Creator和UIC等</h2><ul><li><strong>在Clion的设置中打开外部工具</strong></li><li><strong>名称填QT Creator</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">工具设置<span class="punctuation">:</span></span><br><span class="line"> 程序<span class="punctuation">:</span> qtcreator.exe的根路径</span><br><span class="line"> 实参： $FileName$</span><br><span class="line"> 工作目录<span class="punctuation">:</span> $FileDir$</span><br><span class="line"></span><br><span class="line">其他外部工具同理</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>可通过Qt creator外部工具打开.ui文件实现拖动部件设计UI，在Clion直接编译会自动将.ui文件转化为C++对应的头文件，不需要UIC转换</strong></p></div><h2 id="分块查找">分块查找</h2><h1>配置 Qt creator</h1><p><strong>写Qt有两种方法</strong>：</p><ul><li>直接在Qt creator 中创建项目，Build system选择qmake，Kits选择Qt minGW 64-bit/32-bit即可开始</li><li>将Clion与Qt creator联合使用来写Qt，下面介绍如何配置</li></ul><p>为了使Clion和Qt creator 同时使用来完成UI的设计</p><ul><li><p>首先需要在Qt中先创建项目选择Qt Widgets Application,取名并选择路径</p></li><li><p>在Build System 中选择Cmake</p></li><li><p>在Class information 中选择基类一共有三种(QMainWindow,QWidget,QDialog),任意选择一种即可，一般选择前面的，类名可随便定义你自己喜欢的(下面默认为widget)</p></li><li><p>Kits 中选择Kits选择Qt minGW 64-bit/32-bit即可</p></li><li><p>创建项目成功</p></li><li><p>用Clion打开对应项目文件夹</p></li><li><p>在Clion中用外部工具打开widget.ui，在其中拖动部件即可</p></li><li><p>可在widget的构造函数中添加代码实现与拖动部件相同功能</p></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>在创建项目时，若提示no suitable kits，即没有kits可以使用时，可能是没有下载cmake或cmake没有添加到环境变量，此时去官网下载cmake或创建环境变量即可</p></div><h1>配置Qt Resource File</h1><p>当要使用图片，动态图片等资源设置背景时，需要在项目根目录下创建Qt Resource File 文件</p><h2 id="只使用Qt-Creator">只使用Qt Creator</h2><ul><li><p>当使用的时qmake时，直接在项目根目录右键Add New然后创建Qt Resource File</p></li><li><p>随便取名称(以下用resource),路径为默认路径(项目根目录)</p></li><li><p>此时Qt creator会在项目根目录下创建一个Resources文件夹，里面有个文件resource.qrc</p></li><li><p>先点击Add Prefix，然后在下面将前缀改为单独一个&quot;/“即可，此时创建出一个”/&quot;的根目录</p></li><li><p>接下来再点击Add Files，选择你要添加的图片或动态图(注意要把图片放在项目根目录下)，Ctrl+S保存</p></li><li><p>然后在改变样式表中添加资源即可看见添加的资源</p></li></ul><h2 id="使用Clion">使用Clion</h2><ul><li><p>在Qt Creator中打开用cmake配置的项目，在根目录直接在项目根目录右键Add New然后创建Qt Resource File</p></li><li><p>随便取名称(以下用resource),路径为默认路径(项目根目录)</p></li><li><p>接下来在Clion中打开该项目，即可看到一个resource.qrc文件</p></li><li><p>然后用外部工具Qt creator打开resource.qrc文件，在里面进行Add Prefix,和Add Files(见上方)，Ctrl+S保存(一定要保存否则不会生效)</p></li><li><p>创建完之后在CMakeLists.txt中将resource.qrc添加进add_executable中</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ANDROID)</span><br><span class="line">  <span class="built_in">add_library</span>(qt_pj_stylesheet SHARED</span><br><span class="line">    main.cpp</span><br><span class="line">    widget.cpp</span><br><span class="line">    widget.h</span><br><span class="line">    widget.ui</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="built_in">add_executable</span>(qt_pj_stylesheet</span><br><span class="line">    main.cpp</span><br><span class="line">    widget.cpp</span><br><span class="line">    widget.h</span><br><span class="line">    widget.ui</span><br><span class="line">    resource.qrc<span class="comment">//只需要添加这一个地方即可</span></span><br><span class="line">  )</span><br><span class="line"><span class="built_in">endif</span>()</span><br></pre></td></tr></table></figure><p>然后直接编译即可</p>]]></content>
    
    
    <summary type="html">使用Clion和Qt Creator联合写Qt</summary>
    
    
    
    <category term="Qt" scheme="https://www.thekqd.top/categories/Qt/"/>
    
    
    <category term="Clion" scheme="https://www.thekqd.top/tags/Clion/"/>
    
  </entry>
  
  <entry>
    <title>Qt</title>
    <link href="https://www.thekqd.top/posts/b511cbcf.html"/>
    <id>https://www.thekqd.top/posts/b511cbcf.html</id>
    <published>2023-12-27T14:45:20.000Z</published>
    <updated>2024-03-18T14:11:22.917Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://note.youdao.com/web/#/file/recent/note/09695FF39793403CAF4C924E2E5E55B4/">笔记 (youdao.com)</a></p><p>视频等详细资料在U盘中</p><img src="/assets/2.webp" alt="示例图片" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">Qt的知识</summary>
    
    
    
    <category term="Qt" scheme="https://www.thekqd.top/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://www.thekqd.top/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://www.thekqd.top/posts/735e5788.html"/>
    <id>https://www.thekqd.top/posts/735e5788.html</id>
    <published>2023-11-06T14:36:06.000Z</published>
    <updated>2023-11-06T14:37:21.167Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>算法概述</title>
    <link href="https://www.thekqd.top/posts/1ce63292.html"/>
    <id>https://www.thekqd.top/posts/1ce63292.html</id>
    <published>2023-11-05T13:41:33.000Z</published>
    <updated>2023-11-07T14:34:49.161Z</updated>
    
    <content type="html"><![CDATA[<h1>算法的概念</h1><p>算法（algorithm）是解决一系列问题的<strong>清晰指令</strong>，也就是，能对一定规范的输入，在有限的时间内获得所要求的输出。</p><p>​    简单来说，算法就是解决一个问题的具体方法和步骤。算法是<strong>程序的灵魂</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序 = 算法+数据结构</span><br></pre></td></tr></table></figure><h1>算法的特征</h1><h2 id="可行性">可行性</h2><p>​        算法中执行的任何计算步骤都可以分解为基本可执行的操作步，即每个计算步都可以在有限时间里完成（也称之为有效性）</p><h2 id="确定性">确定性</h2><p>​        算法的每一步都要有确切的意义，不能有二义性。例如“增加x的值”，并没有说增加多少，计算机就无法执行明确的运算。</p><h2 id="有穷性">有穷性</h2><p>​        算法的有穷性是指算法必须在执行有限个步骤后终止。操作次数不宜过大，不能超过人们事先设定的时间限制。</p><h2 id="输入">输入</h2><p>算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法已经给出了初始条件。</p><h2 id="输出">输出</h2><p>一个算法可能有1个或多个输出，以反映输入数据加工后的代码，没有输出的算法是没有意义的！</p><h1>算法的评价</h1><p>通常一个好算法应该达到如下目标：</p><h2 id="正确性">正确性</h2><p>算法应该正确的解决问题。</p><h2 id="可读性">可读性</h2><p>算法应该具有较好的可读性，让人们理解算法的作用。</p><h2 id="健壮性">健壮性</h2><p>输入非法数据时，算法也可以做出适当的反应，而不会产生奇奇怪怪的输出。</p><h1>算法的复杂度</h1><p><strong>算法复杂度</strong>是指算法在变为可执行程序后所耗费的时间资源和内存,一般分为两种。</p><ul><li><p><strong>时间复杂度</strong>：评估程序所需要的时间。</p></li><li><p><strong>空间复杂度</strong>：评估程序所需要的储存空间。</p></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>空间复杂度一般不作考虑，一般都优先考虑时间复杂度。</p></div><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">常见时间复杂度</span><br><span class="line"></span><br><span class="line">复杂度标记符号          说明</span><br><span class="line">常量 O(<span class="number">1</span>)   操作数量为常数，与输入数据的规模无关</span><br><span class="line">对数 O(log2n)    与输入数据的比例是 log2（n）</span><br><span class="line">线性 O(n)        与输入数据成正比</span><br><span class="line">平方 O(n²)        与输入数据规模的比例为平方</span><br><span class="line">立方 O(n³)        与输入数据规模的比例为立方</span><br><span class="line"></span><br><span class="line">      O(<span class="number">2</span>ⁿ)</span><br><span class="line">指数   O(kⁿ)           快速增长，应该尽量减少这种代码</span><br><span class="line">      O(n!)</span><br><span class="line">   </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">算法概述</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.thekqd.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法概述" scheme="https://www.thekqd.top/tags/%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="https://www.thekqd.top/posts/e2adee35.html"/>
    <id>https://www.thekqd.top/posts/e2adee35.html</id>
    <published>2023-11-01T13:59:50.000Z</published>
    <updated>2023-11-19T10:38:26.224Z</updated>
    
    <content type="html"><![CDATA[<h1>线性表查找</h1><h2 id="顺序查找">顺序查找</h2><h3 id="算法介绍">算法介绍</h3><p>顺序查找算法又称<strong>顺序搜索算法</strong>或者<strong>线性搜索算法</strong>，是所有查找算法中最基本、最简单的，对应的时间复杂度为<strong>O(n)</strong>。</p><p>顺序查找算法适用于绝大多数场景，既可以在有序序列中查找目标元素，也可以在无序序列中查找目标元素。</p><p>顺序查找的特点：</p><ul><li>方法简单</li><li>对表的结构无要求</li><li>查找效率低，当n较大时不宜采用</li></ul><h3 id="算法实现">算法实现</h3><p>实现思路：所谓顺序查找，指的是从待查找序列中的第一个元素开始，查看各个元素是否为要找的目标元素。若相同则查找成功返回对应数组下标；若遍历完整个数组也没有找到待查找元素，则说明查找失败，返回-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一个简单的顺序查找，其实就是一个<span class="keyword">for</span>循环</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> arr[N],<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==value)</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//匹配失败，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="效率分析">效率分析</h3><p><strong>时间复杂度：</strong></p><ul><li>最坏情况：若相同则查找成功返回对应数组下标；若遍历完整个数组也没有找到待查找元素，则说明查找失败，返回-1。</li><li>最好情况：最理想的情况就是待查找元素位于集合的第一个位置，程序只需执行一次循环和比较就成功找到待查找元素并返回退出，所以时间复杂度为O(1)。</li><li>平均情况：综合两种，顺序查找的时间复杂度为O(n)。</li></ul><p><strong>空间复杂度：</strong></p><ul><li>算法中只需设置一个临时变量用于控制循环次数和数组下标变化，没有借助额外的辅助空间，所以空间复杂度为O(1)。</li></ul><h2 id="二分查找">二分查找</h2><h3 id="算法介绍-2">算法介绍</h3><p>二分查找，又叫<strong>折半查找</strong>，通过找到数据二段性每次都能将原来的数据筛选掉一半，通过这个算法我们能够将一个一个查找的 O(n) 的时间复杂度优化到 O(log2n) ，极大地提升了查找的效率。</p><p>但使用二分进行查找必须要有一个前提，那就是查找的区间必须是<strong>有序的</strong>。如数组并非有序，则找不到该数组的的二段性。</p><p>二分查找的特点：</p><ul><li>效率较高</li><li>要求查找表有序</li><li>只适合顺序查找和建立后很少改动而只需要查找的表</li></ul><h3 id="算法实现-2">算法实现</h3><p>实现思路：</p><p>二分法的思想很简单，因为整个数组是有序的，数组默认是递增的。</p><ul><li>首先选择数组中间的数字mid和需要查找的目标值比较</li><li>如果相等最好，就可以直接返回答案了</li><li>如果不相等<ul><li>如果中间的数字大于目标值，则中间数字向右的所有数字都大于目标值，全部排除，再移动right到mid-1的位置</li><li>如果中间的数字小于目标值，则中间数字向左的所有数字都小于目标值，全部排除，再移动left到mid+1的位置</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">searchKey</span><span class="params">(KeyType key,SSTable ST)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right = ST.length;</span><br><span class="line">    <span class="comment">/*区间初值*/</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)<span class="comment">//一定要取等，最后left和right相等时为最后一种情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left+right)/<span class="number">2</span> <span class="comment">//找到中间元素</span></span><br><span class="line">        <span class="keyword">if</span>(key == ST.elem[mid].key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; ST.elem[mid].key)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid<span class="number">-1</span>;<span class="comment">//key在middle左边，将right移过来</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;<span class="comment">//key在middle右边，将left移动过来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效率分析-2">效率分析</h3><ul><li><p>时间复杂度：O(log2n)</p></li><li><p>空间复杂度：O(1) 或 O(log2n)，取决于二分查找的实现方式。如果使用迭代的方式，只需要一个变量来存储中间元素的下标，所以空间复杂度为 O(1)。如果使用递归的方式，每次递归调用都需要额外的栈空间，所以空间复杂度为 O(log2n)。</p></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>二分查找的优点和缺点分别是：</p><ul><li>优点：比较次数少，查找速度快，平均性能好。</li><li>缺点：要求待查表为有序表，且插入删除困难。</li></ul></div><h2 id="分块查找">分块查找</h2><h3 id="算法介绍-3">算法介绍</h3><p>分块查找也称为索引查找，分块查找是一种结合了二分查找和顺序查找的查找方法，它将数据分为若干个块，在索引查找法中，除表本身之外还需要建立一个索引表。由分块查找可知，它要分开进行，块内元素之间无大小关系，块与块之间有大小关系（比如说：第二块中的元素肯定要比第一块中大，第三块中元素肯定要比前两块中的元素大）所以索引表是有序的，但每一块中的元素无序，可以进行二分查找进行查找由于要有索引所以要用到结构体。</p><h3 id="算法实现-3">算法实现</h3><p>索引查找是在一定条件下使用（给索引表开值为3，代表查找表中元素个数要是3的倍数），则每个块中的元素个数为n/3,则在每个块中找出块中最大值，赋值给索引表，在对索引表的关键字进行比较排序</p><p>索引查找是先找到确定的块（这个过程可以进行二分也可以进行顺序查找（下边代码实现的是顺序查找））</p><p>确定块之后在块中进行顺序查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">分块查找代码示例:</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义块的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">index</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key; <span class="comment">// 块的最大值</span></span><br><span class="line">    <span class="type">int</span> start; <span class="comment">// 块的起始位置</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*索引表中的每个元素包括该块中的最大值和块的起始位置*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量，存储索引表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">index</span> <span class="title">newIndex</span>[3];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义分块查找函数，参数为待查元素和数据数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">blockSearch</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义变量，存储左右边界和中间位置</span></span><br><span class="line">    <span class="type">int</span> left, right, mid;</span><br><span class="line">    <span class="comment">// 初始化左右边界(索引表的)</span></span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    right = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 1.二分查找：在索引表中用二分查找确定待查元素所在的块</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 计算中间位置</span></span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 如果找到了所在的块，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt;= newIndex[mid].key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果待查元素大于中间位置的最大值，由于是有序的，索引说明只能在在右半部分，更新左边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有找到所在的块，返回-1表示查找失败</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在确定的块中用顺序查找找到待查元素</span></span><br><span class="line">    <span class="comment">// 获取块的起始位置和结束位置</span></span><br><span class="line">    <span class="type">int</span> start = newIndex[mid].start;</span><br><span class="line">    <span class="type">int</span> end = start + <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 2.顺序查找：遍历块中的元素，如果找到了待查元素，返回其位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有找到待查元素，返回-1表示查找失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义数据数组</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">33</span>, <span class="number">42</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">24</span>, <span class="number">48</span>, <span class="number">22</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">58</span>, <span class="number">74</span>, <span class="number">49</span>, <span class="number">86</span>, <span class="number">53</span>&#125;;</span><br><span class="line">    <span class="comment">// 定义变量，存储块的数量和数据的总个数</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">18</span>;</span><br><span class="line">    <span class="comment">// 定义变量，为每个块内的元素个数</span></span><br><span class="line">    <span class="type">int</span> size = n / m;</span><br><span class="line">    <span class="comment">// 定义变量，存储待查元素</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="comment">// 确定每个块的最大值和起始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化每个块的起始位置</span></span><br><span class="line">        newIndex[i].start = i * size;</span><br><span class="line">        <span class="comment">// 初始化每个块的最大值为第一个元素的值</span></span><br><span class="line">        newIndex[i].key = arr[i * size];</span><br><span class="line">        <span class="comment">// 遍历每个块中的元素，更新每个块的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * size; j &lt; (i + <span class="number">1</span>) * size; j++)</span><br><span class="line">        &#123;        <span class="comment">/*条件为下个块之前*/</span></span><br><span class="line">            <span class="keyword">if</span> (newIndex[i].key &lt; arr[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                newIndex[i].key = arr[j];<span class="comment">//更新每个块的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输入待查元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要查找的元素：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line">    <span class="comment">// 调用分块查找函数，获取结果</span></span><br><span class="line">    <span class="type">int</span> result = blockSearch(key, arr);</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败，没有找到该元素。\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找成功，该元素在数组中的位置是：%d\n&quot;</span>, result + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效率分析-3">效率分析</h3><ul><li>时间复杂度：O(log2m + n/m)，其中 m 是块的数量，n 是数据的总个数，n/m为每个块元素个数。这是因为在分块查找过程中，需要先在索引表中用二分查找或顺序查找确定待查元素所在的块，这一步的时间复杂度为 O(log2m) 或 O(m)；然后在已确定的块中用顺序查找找到待查元素，这一步的时间复杂度为 O(n/m)。因此，分块查找的总时间复杂度为 O(log2m + n/m) 或 O(m + n/m)。</li><li>空间复杂度：O(m)，这是因为分块查找需要额外的空间来存储索引表，索引表的大小为 m。</li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li>优点：插入删除比较容易，无需进行大量移动。如果线性表既要快速查找又经常动态变化，则可采用分块查找。</li><li>缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算。如果分块过于稀疏或过于密集，都会影响查找效率。</li></ul></div><h1>树表的查找</h1><h2 id="二叉排序树">二叉排序树</h2><h3 id="二叉排序树-介绍">二叉排序树-介绍</h3><p><strong>二叉排序树</strong>又称为二叉搜索树、二叉查找树。二叉排序树或是空树，或是满足如下性质的二叉树：</p><ul><li>若它的<strong>左子树</strong>非空，则左子树上所有结点的值均<strong>小于它根结点的值</strong>。</li><li>若它的<strong>右子树</strong>非空，则右子树上所有结点的值均<strong>大于它根结点的值</strong>。</li><li>它的左、右树又本身是一颗⼆叉排序树</li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>二叉排序树性质</strong>：</p><p><strong>中序遍历</strong>非空的二叉排序树所得到的数据元素序列是一个按关键字排列的<strong>递增有序</strong>序列，即结点的从小到大顺序。</p></div><h3 id="二叉排序树-查找">二叉排序树-查找</h3><p><strong>查找思路：</strong></p><ul><li>若查找的关键字等于根节点，查找成功</li><li>若查找的关键字不等于根节点<ul><li>小于根节点，查找其左子树</li><li>若大于根节点，查找其右子树</li></ul></li><li>再左右子树上的查找与其类似</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    KeyType key; <span class="comment">//关键字项</span></span><br><span class="line">    infoType otherinfo;<span class="comment">//其他数据域</span></span><br><span class="line">&#125;ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>* <span class="title">lchild</span>;</span><span class="comment">//左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>* <span class="title">rchild</span>;</span><span class="comment">//右孩子</span></span><br><span class="line">&#125;BSTNode,*BSTree;</span><br><span class="line"></span><br><span class="line">BSTree T;<span class="comment">//定义二叉排序树T</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>二叉排序树的递归查找算法思想：</strong></p><ol><li>若二叉排序树为空，则查找失败，直接返回空指针。</li><li>若二叉排序树非空，将给定值key与根结点的关键字进行比较如果成功返回根结点地址，若小于data.key则查找左子树，若data.key则查找右子树。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉排序树递归查找函数*/</span></span><br><span class="line"></span><br><span class="line">BSTree <span class="title function_">searchBST</span><span class="params">(BSTree T,KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(key==T-&gt;data.key||T==<span class="literal">NULL</span>)<span class="comment">//树为空或找到了直接返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data.key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> searchBST(T-&gt;lchild,key);<span class="comment">//在左子树中继续寻找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span> searchBST(T-&gt;rchild,key); <span class="comment">//在右子树中继续寻找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉排序树的平均查找长度(ASL)和树的形态有关，一般来说树的高度越高，平均查找长度越大</strong></p><p>时间复杂度最好情况为O(log2n)，树的深度为：[log2n]+1，此时与折半查找中的判定树相同.</p><p>时间复杂度最坏为O(n)，树的深度为n，插入的元素变成了单支树的形态</p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>问题: 如何提高形态不均衡的二叉排序树的查找效率？</strong></p><p><strong>解决方法</strong>：做“平衡化”处理，尽量让二叉树的形状均衡。即实现平衡二叉树</p></div><h3 id="二叉排序树-插入">二叉排序树-插入</h3><p><strong>生成二叉排序树的过程就是插入的过程</strong></p><p><strong>插入思路：</strong></p><ul><li><p>若二叉排序树为空，则插入结点作为根节点插入到空树中</p></li><li><p>若二叉排序树为非空，则在其左右子树上查找</p><ul><li>树中已有，不再插入，直接返回</li><li>树中没有，查找直到某个叶子结点的左子树或右子树为空位置，再将该节点插入为该叶子结点的左孩子或右孩子</li></ul><p><strong>插入的结点一定是叶子结点上</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//定义一个临时指针 用于移动</span></span><br><span class="line">tNode* temp = root;<span class="comment">//temp为插入位置的结点</span></span><br><span class="line">tNode* prev = <span class="literal">NULL</span>;<span class="comment">//定位到待插入位置的前一个结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = (tNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tNode));</span><br><span class="line">root-&gt;data = key; </span><br><span class="line">root-&gt;left = <span class="literal">NULL</span>; </span><br><span class="line">root-&gt;right = <span class="literal">NULL</span>; </span><br><span class="line">    &#125;<span class="comment">//若根节点为NULL，直接插入</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/*第一部分：找到要插入的位置*/</span></span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prev = temp; <span class="comment">//保存插入结点的双亲的位置</span></span><br><span class="line"><span class="keyword">if</span> (key &lt; temp-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;left;<span class="comment">//找左边子树，若移动后为空则代表找到了插入的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(key &gt; temp-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;right;<span class="comment">//找右边子树，移动后为空则代表找到了插入位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;已存在该结点&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//存在该结点直接返回插入失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*第二部分：插入结点*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*当结点左子树为空时*/</span></span><br><span class="line"><span class="keyword">if</span> (key &lt; prev-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">prev-&gt;left = (tNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tNode));</span><br><span class="line">prev-&gt;left-&gt;data = key; <span class="comment">//插入结点数据域</span></span><br><span class="line">prev-&gt;left-&gt;left = <span class="literal">NULL</span>; <span class="comment">//设置左孩子为空</span></span><br><span class="line">prev-&gt;left-&gt;right = <span class="literal">NULL</span>; <span class="comment">//设置右孩子为空</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*当结点右子树为空时*/</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">prev-&gt;right = (tNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tNode));</span><br><span class="line">prev-&gt;right-&gt;data = key;</span><br><span class="line">prev-&gt;right-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">prev-&gt;right-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意：</strong></p><p>不同插入次序的序列生成不同形态的二叉排序树。</p></div><h3 id="二叉排序树-删除">二叉排序树-删除</h3><p>在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下来，将因删除结点而断开的二叉链表重新链接起来，同时**确保二叉排序树的性质（左子树结点值＜根结点值＜右子树结点值）**不会丢失。</p><p><strong>删除操作一般会出现三种情况</strong>：</p><ol><li>若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。</li><li>若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。</li><li>若结点z有左、右两棵子树，有两种方法：</li></ol><ul><li>令z的直接前驱（或直接后继）替代z，然后从二叉排序树中删除这个直接后继或直接前驱，这样就转换成了第一或第二种情况，按照第一种或第二种情况再删除直接前驱或后继(常使用这种方法)。</li><li>先用z结点的左子树替代该结点，再将z结点的右子树作为z节点直接前驱的右子树（这种方法会可能会增加树的深度，常使用第一种方法处理）</li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注</strong>：</p><p>已知二叉排序树经过中序遍历可以得到一个递增的有序序列，这里的<strong>直接后继（或直接前驱）<strong>应该是指被删除结点在这个</strong>中序遍历序列中的直接后继（或直接前驱）。</strong><br> <br>体现在二叉排序树的图中:<br> 某个结点的直接后继为以该结点为根的<strong>右子树中最左下位置的结点</strong>，即右子树的<strong>最小值</strong>；<br> 某个结点的直接前驱为以该结点为根的<strong>左子树中最右下位置的结点</strong>，即左子树的<strong>最大值</strong>。</p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从二叉树中删除值为key的结点*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">deleteNode</span><span class="params">(BSTree &amp;T,KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTree p = T，temp = <span class="literal">NULL</span>, prior = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*先查找值为key的结点*/</span></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data.key == key)</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//查找成功</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;data.key &lt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;rchild;<span class="comment">//在右子树中寻找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;lchild;<span class="comment">//在左子树中寻找</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//找不到结点p为NULL，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; p-&gt;rchild==<span class="literal">NULL</span>)<span class="comment">//p为叶子结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>) <span class="comment">//p左子树为空，删p后重接右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;rchild==<span class="literal">NULL</span>)<span class="comment">//p右子树为空，删p后重接左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span><span class="comment">//左右子树均不为空,先找前驱结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = p;</span><br><span class="line">        temp = temp-&gt;lchild;<span class="comment">//在左子树中寻找最大值，即删除结点的直接前驱</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;rchild)<span class="comment">//右子树为空时，找到结点退出循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            prior = temp;</span><br><span class="line">            temp = temp-&gt;rchild;<span class="comment">//继续寻找</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//while循环结果后：temp为直接前驱，prior为temp的双亲</span></span><br><span class="line">        p-&gt;data.key = temp-&gt;data.key;</span><br><span class="line">        <span class="comment">//将删除的结点替换为直接前驱</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prior!=p)<span class="comment">//直接前驱的双亲不为删除的结点时,前驱右孩子为NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*将直接前驱的左孩子重挂到双亲的右孩子上去，替代直接前驱的位置*/</span></span><br><span class="line">            prior-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span><span class="comment">//直接前驱的双亲为删除结点时,前驱右孩子为NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*直接将前驱的左子树(右子树为空)重挂到双亲的左子树上去替代直接前驱的位置*/</span></span><br><span class="line">            prior-&gt;lchild = temp-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">free</span>(temp);<span class="comment">//删除直接前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡二叉树">平衡二叉树</h2>]]></content>
    
    
    <summary type="html">七大查找算法介绍和具体实现</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://www.thekqd.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="查找算法" scheme="https://www.thekqd.top/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL通用语法及操作</title>
    <link href="https://www.thekqd.top/posts/f2e69609.html"/>
    <id>https://www.thekqd.top/posts/f2e69609.html</id>
    <published>2023-09-16T09:09:12.000Z</published>
    <updated>2023-11-07T13:39:05.565Z</updated>
    
    <content type="html"><![CDATA[<h1>基础篇</h1><h2 id="SQL通用语法">SQL通用语法</h2><ul><li>SQL语句可以单行或多行书写，使用回车可换行继续书写<strong>最后以分号结尾</strong>。</li><li>SQL语句可以使用空格/缩进来增加语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>注释：</li><li>单行注释：-- 注释内容 或 # 注释内容（MySQL特有）</li><li>多行注释：/*注释内容*/</li></ul><h2 id="SQL分类">SQL分类</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DDL<span class="punctuation">:</span> 数据定义语言，用来定义数据库对象（数据库，表，字段）</span><br><span class="line">DML<span class="punctuation">:</span> 数据操作语言，用来对数据库表中的数据进行增删改</span><br><span class="line">DQL<span class="punctuation">:</span> 数据查询语言，用来查询数据库中表的记录</span><br><span class="line">DCL<span class="punctuation">:</span> 数据控制语言，用来创建数据库的用户、控制数据库的访问权限</span><br></pre></td></tr></table></figure><h2 id="SQL数据类型">SQL数据类型</h2><p>见这篇blog-&gt;<a href="https://blog.csdn.net/wangkun_j/article/details/113500282?ops_request_misc=%7B%22request%5Fid%22%3A%22169493216516800197069763%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169493216516800197069763&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-113500282-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=mysql%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B&amp;spm=1018.2226.3001.4187">MySQL字段类型最全解析_kun_行者的博客-CSDN博客</a></p><h2 id="SQL运算符">SQL运算符</h2><p><a href="https://blog.csdn.net/heart2070292037/article/details/122562132?ops_request_misc=%7B%22request%5Fid%22%3A%22169522393616800180688568%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169522393616800180688568&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-122562132-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=sql%E8%BF%90%E7%AE%97%E7%AC%A6&amp;spm=1018.2226.3001.4187">SQL学习之运算符_sql运算符有哪些_heart-szu的博客-CSDN博客</a></p><h2 id="SQL七大约束">SQL七大约束</h2><p><strong>约束条件用法参考这篇blog</strong><a href="https://blog.csdn.net/m0_64338546/article/details/128547998?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mysql%E7%BA%A6%E6%9D%9F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-128547998.nonecase&amp;spm=1018.2226.3001.4187">【MySQL基础】MySQL表的七大约束_mysql 表级约束_小杨MiManchi的博客-CSDN博客</a></p><h2 id="DDL-数据库操作和表操作">DDL(数据库操作和表操作)</h2><h3 id="数据库操作">数据库操作</h3><h4 id="查询">查询</h4><p><strong>查看所有数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure><p><strong>查询当前数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure><h4 id="创建">创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE<span class="operator">|</span>SCHEMA [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [<span class="keyword">DEFAULT</span> (CHARSET)<span class="operator">|</span>(<span class="type">CHARACTER</span> <span class="keyword">SET</span>) 字符集] [<span class="keyword">COLLATE</span> 排序规则];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">DEFAULT</span>这个单词在写代码的时候可以加也可以不加,最好加上</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> ETISTS teaching</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="删除">删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] 数据库名;</span><br></pre></td></tr></table></figure><h4 id="使用">使用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure><h4 id="查看">查看</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>结果会显示出创建命令和各参数设置(字符集，校对规则)</span><br></pre></td></tr></table></figure><h4 id="修改">修改</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE<span class="operator">|</span>SCHEMA [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [<span class="keyword">DEFAULT</span> (CHARSET)<span class="operator">|</span>(<span class="type">CHARACTER</span> <span class="keyword">SET</span>) 字符集] [<span class="keyword">COLLATE</span> 排序规则];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>注意：用户必须有数据库的修改权限才能使用该命令修改数据库</span><br></pre></td></tr></table></figure><h3 id="表操作">表操作</h3><h4 id="查询-2">查询</h4><p>查询当前数据库所有表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><p>查询表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 表明;</span><br></pre></td></tr></table></figure><p>查询指定表的建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>会显示出详细注释，引擎，字符集，校对规则</span><br></pre></td></tr></table></figure><h4 id="创建-2">创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型 [约束条件] [COMMENT <span class="string">&#x27;字段1注释&#x27;</span>],</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型 [约束条件] [COMMENT <span class="string">&#x27;字段2注释&#x27;</span>],</span><br><span class="line">    字段<span class="number">3</span> 字段<span class="number">3</span>类型 [约束条件] [COMMENT <span class="string">&#x27;字段3注释&#x27;</span>],</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[COMMENT 表注释];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例子:</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">    id <span class="type">int</span> comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;姓名&#x27;</span></span><br><span class="line">    ) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li>表名和字段只能用反引号或不用符号，<strong>不能用单引号</strong></li><li>最后一个字段结尾不要有逗号</li><li>comment后的字段注释或表注释必须使用引号，而且<strong>是单引号</strong>而不是反引号</li></ul></div><h4 id="修改-2">修改</h4><p><strong>添加字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型(长度) [COMMENT 注释] [约束];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">alter</span>: 修改</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">add</span>: 添加</span><br></pre></td></tr></table></figure><p><strong>修改指定字段数据类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型(长度);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>modify: 修改</span><br></pre></td></tr></table></figure><p><strong>修改字段数据名和字段类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>change: 修改</span><br></pre></td></tr></table></figure><p><strong>删除字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br></pre></td></tr></table></figure><p><strong>修改表名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新表名;</span><br></pre></td></tr></table></figure><h4 id="删除-2">删除</h4><p><strong>删除表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 表名;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>数据全部删除</span><br></pre></td></tr></table></figure><p><strong>删除指定表，并重新创建该表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>数据全部删除，结构不变</span><br></pre></td></tr></table></figure><h2 id="DML-数据操作">DML(数据操作)</h2><h3 id="添加">添加</h3><ul><li><strong>给指定字段添加一条数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span><span class="operator">|</span>REPLACE <span class="keyword">INTO</span> 表名(字段名<span class="number">1</span>，字段名<span class="number">2</span>，字段名<span class="number">3</span>,..) <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..);</span><br></pre></td></tr></table></figure><ul><li><strong>给全部字段添加一条数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span><span class="operator">|</span>REPLACE <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，...);</span><br></pre></td></tr></table></figure><ul><li><strong>批量添加多条数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span><span class="operator">|</span>REPLACE <span class="keyword">INTO</span> 表名(字段名<span class="number">1</span>，字段名<span class="number">2</span>，字段名<span class="number">3</span>,..) <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>指定字段添加多份数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>所有字段添加多份数据</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意：</p><ul><li><strong>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</strong></li><li><strong>字符串和日期型(date型)数据应该包含在引号中</strong></li><li><strong>插入的数据大小应该在字段的规定范围内</strong></li></ul></div><h3 id="修改数据">修改数据</h3><p><strong>修改</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>, 字段名<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,...[<span class="keyword">WHERE</span> 条件]；</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;kqd&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>将id为<span class="number">1</span>的字段name数据修改为kqd</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意：</p><ul><li>修改语句的条件可以有，也可以没有，<strong>如果没有条件，则会修改整张表的所有数据。</strong></li></ul></div><p><strong>删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件]</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除gender为女的员工</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employee <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除所有员工</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意：</p><ul><li><strong>DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。</strong></li><li><strong>DELETE语句不能删除某一个字段的值(但可以使用UPDATE)。</strong></li></ul></div><h2 id="DQL-查询">DQL(查询)</h2><h3 id="基础查询">基础查询</h3><p>1.查询多个字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>，字段<span class="number">2.</span>.. <span class="keyword">FROM</span> 表名；</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 ; </span><br><span class="line"></span><br><span class="line"><span class="operator">*</span>代表查询所有的字段</span><br></pre></td></tr></table></figure><p>2.设置别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span> [<span class="keyword">AS</span> 别名<span class="number">1</span>]，字段<span class="number">2</span> [<span class="keyword">AS</span> 别名<span class="number">2</span>]... <span class="keyword">FROM</span> 表名；</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">AS</span> 可省略</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对字段起别名 </span></span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> <span class="keyword">as</span> <span class="string">&#x27;别名&#x27;</span>,...</span><br><span class="line">为字段<span class="number">1</span>取别名</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对表取别名</span></span><br><span class="line"><span class="keyword">select</span> a.name</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> a</span><br><span class="line">为student表取别名a</span><br></pre></td></tr></table></figure><p>3.去除重复记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><h3 id="条件查询">条件查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件列表;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">条件:</span><br><span class="line">运算符</span><br><span class="line"><span class="number">1.</span>算数</span><br><span class="line"><span class="operator">+</span>, <span class="operator">-</span>, <span class="operator">*</span>, <span class="operator">/</span></span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"><span class="number">2.</span>判断</span><br><span class="line"><span class="operator">&gt;</span>, <span class="operator">&lt;</span>, <span class="operator">&gt;=</span>, <span class="operator">&lt;=</span>, <span class="operator">!=</span>, <span class="operator">&lt;&gt;</span>(不等于) </span><br><span class="line"><span class="keyword">IS</span> <span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>(判断是否为<span class="keyword">NULL</span>)</span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"><span class="number">3.</span>逻辑 </span><br><span class="line"><span class="keyword">AND</span>(<span class="operator">&amp;&amp;</span>), <span class="keyword">OR</span>(<span class="operator">||</span>),<span class="keyword">NOT</span><span class="operator">||</span><span class="operator">!</span></span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"><span class="number">4.</span>范围 </span><br><span class="line"><span class="keyword">BETWEEN</span> 最小值 <span class="keyword">AND</span> 最大值,</span><br><span class="line"><span class="keyword">IN</span>(值<span class="number">1</span>，值<span class="number">2</span>，...)  <span class="operator">/</span><span class="operator">/</span><span class="keyword">IN</span>之后的列表的值为范围</span><br><span class="line"><span class="number">5.</span>模糊匹配 </span><br><span class="line"><span class="keyword">LIKE</span> <span class="string">&#x27;_||%||&#x27;</span></span><br><span class="line"><span class="string">&#x27;_&#x27;</span> 表示代表一个字符</span><br><span class="line"><span class="string">&#x27;%&#x27;</span> 表示<span class="number">0</span>各或多个字符</span><br><span class="line"><span class="string">&#x27;[]&#x27;</span> 表示某一范围的字符,例如[<span class="number">0</span><span class="number">-9</span>],<span class="number">0</span><span class="operator">~</span><span class="number">9</span>之间的字符</span><br><span class="line"><span class="string">&#x27;[^]&#x27;</span> 表示不再某一范围的字符</span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="聚合函数">聚合函数</h3><p><strong>介绍:</strong></p><p>将一列数据作为一个整体，进行纵向计算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">聚合函数：</span><br><span class="line"><span class="built_in">count</span>() 统计元组数量（行数）</span><br><span class="line"><span class="built_in">max</span>() 最大值</span><br><span class="line"><span class="built_in">min</span>() 最小值</span><br><span class="line"><span class="built_in">avg</span>() 平均值</span><br><span class="line"><span class="built_in">sum</span>() 求和</span><br></pre></td></tr></table></figure><p><strong>语法:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数(字段列表),聚合函数,... <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li><strong>所有的NULL值不参与所有聚合函数运算，对某个字段中有NULL在使用count时将不会计算数据条数。</strong></li><li><strong>count(*)统计的是表中所有的行数,count(字段)是统计该字段非NULL的行数,一般使用前者较多</strong></li></ul></div><h3 id="分组查询">分组查询</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件] GEOUP <span class="keyword">BY</span> 分组字段名 [<span class="keyword">HAVING</span> 分组后过滤条件]</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>where和having的区别:</strong></p><p>执行时机不同: where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果的过滤。</p><p>判断条件不同：where不能对聚合函数进行判断，而having可以。</p></div><p>注意：</p><ul><li>执行顺序：where &gt; 聚合函数 &gt; having.</li><li>分组之后，<strong>查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</strong></li></ul><h3 id="排序查询">排序查询</h3><p><strong>语法:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>，字段二 排序方式</span><br><span class="line"></span><br><span class="line">排序方式:</span><br><span class="line"><span class="keyword">ASC</span>: 升序（默认值）</span><br><span class="line"><span class="keyword">DESC</span>: 降序</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</p><h3 id="分页查询">分页查询</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT 起始索引(偏移量)，查询记录数</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一般LIMIT加在所有代码的最后</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p><strong>起始索引从0开始，起始索引 = (查询页码-1) * 每页显示记录数，起始索引也叫偏移量，表示从起始索引所在行数的下一行开始查询</strong></p></li><li><p><strong>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT</strong></p></li><li><p><strong>如果查询的是第一页数据，起始索引可以省略，直接简写为LIMIT 10。</strong></p></li></ul><h3 id="DQL执行顺序">DQL执行顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">执行顺序:了解了执行顺序后我们就可以知道哪些部分可以使用别名来访问数据，哪些不能使用</span><br><span class="line"><span class="number">1.</span><span class="keyword">FROM</span></span><br><span class="line"><span class="number">2.</span><span class="keyword">WHERE</span></span><br><span class="line"><span class="number">3.</span><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="number">4.</span><span class="keyword">HAVING</span></span><br><span class="line"><span class="number">5.</span><span class="keyword">SELECT</span></span><br><span class="line"><span class="number">6.</span><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line"><span class="number">7.</span>LIMIT</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> emp <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">若取别名 <span class="keyword">select</span> e.name,e.age <span class="keyword">from</span> emp <span class="keyword">as</span> e age <span class="keyword">where</span> e.age<span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">ASC</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>执行成功，先执行<span class="keyword">from</span>为emp取别名e，再执行<span class="keyword">where</span>,<span class="keyword">select</span></span><br><span class="line"></span><br><span class="line">若取别名<span class="keyword">select</span> e.name <span class="keyword">AS</span> ename, e.age <span class="keyword">AS</span> eage <span class="keyword">from</span> emp <span class="keyword">AS</span> e age <span class="keyword">where</span> eage<span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">ASC</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>错误，<span class="keyword">select</span>语句在<span class="keyword">where</span>之后执行，在执行<span class="keyword">select</span>之前没有eage这个别名</span><br></pre></td></tr></table></figure><h2 id="DCL-管理">DCL(管理)</h2><h3 id="用户管理">用户管理</h3><h4 id="查询用户">查询用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h4 id="创建用户">创建用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>设置任意主机访问该数据库</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;#&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>设置只能在本机访问数据库</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="修改用户密码">修改用户密码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="删除用户">删除用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意：</strong></p><ul><li><strong>主机名可以使用%通配</strong></li><li><strong>这类SQL开发人员操作的比较少，主要是DBA （数据库管理员)使用</strong></li></ul></div><h3 id="权限控制">权限控制</h3><h4 id="查询权限">查询权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="授予权限">授予权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALL</span><span class="operator">/</span><span class="keyword">all</span> 代表所有的权限</span><br><span class="line">数据库.<span class="operator">*</span> 代表所有的表</span><br><span class="line"><span class="operator">*</span>.<span class="operator">*</span> 代表所有数据库的所有表</span><br></pre></td></tr></table></figure><h4 id="撤销权限">撤销权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALL</span><span class="operator">/</span><span class="keyword">all</span> 代表所有的权限</span><br><span class="line"><span class="operator">*</span> 代表所有的表</span><br><span class="line"><span class="operator">*</span>.<span class="operator">*</span> 代表所有数据库的所有表</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意：</strong></p><ul><li><strong>多个权限之间，使用逗号分隔</strong></li><li><strong>授权时，数据库名和表名可以使用*进行通配，代表所有</strong>,</li></ul></div><h2 id="函数">函数</h2><p><a href="https://blog.csdn.net/hzbooks/article/details/118561808?ops_request_misc=%7B%22request%5Fid%22%3A%22169564664916800227428260%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169564664916800227428260&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-118561808-null-null.142%5Ev94%5Einsert_down1&amp;utm_term=mysql%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">MySQL 十大常用字符串函数_hzbooks的博客-CSDN博客</a></p><h3 id="字符串函数">字符串函数</h3><p>常用的函数:</p><h4 id="CONCAT">CONCAT</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(s1,s2,..sn)</span><br><span class="line">将字符串拼接，S1,S2,...Sn拼接成一个字符串，返回该字符串</span><br></pre></td></tr></table></figure><h4 id="LOWER">LOWER</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LOWER</span>(str) </span><br><span class="line">将字符串str全部转换为小写,返回该函数</span><br></pre></td></tr></table></figure><h4 id="UPPER">UPPER</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPPER</span>(str)</span><br><span class="line">将字符串str全部转换为大写,返回该函数</span><br></pre></td></tr></table></figure><h4 id="LPAD">LPAD</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LPAD(str,n,pad)</span><br><span class="line">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</span><br><span class="line"></span><br><span class="line">lpad(<span class="string">&#x27;01&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">代表用<span class="string">&#x27;-&#x27;</span>填充左边的得到<span class="string">&#x27;---01&#x27;</span>,一共五个字符，下面的rpad同理</span><br></pre></td></tr></table></figure><h4 id="RPAD">RPAD</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RPAD(str,n,pad)</span><br><span class="line">右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</span><br></pre></td></tr></table></figure><h4 id="TRIM">TRIM</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TRIM</span>(str)</span><br><span class="line">去掉字符串头部和尾部的空格(不除去中间)</span><br></pre></td></tr></table></figure><h4 id="SUBSTRING">SUBSTRING</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUBSTRING</span>(str,<span class="keyword">start</span>,len)</span><br><span class="line">返回从字符串str从<span class="keyword">start</span>位置起的len个长度的字符串</span><br></pre></td></tr></table></figure><h3 id="数值函数">数值函数</h3><h4 id="CEIL">CEIL</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CEIL</span>()</span><br><span class="line">向上取整</span><br></pre></td></tr></table></figure><h4 id="FLOOR">FLOOR</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FLOOR</span>()</span><br><span class="line">向下取整</span><br></pre></td></tr></table></figure><h4 id="MOD">MOD</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MOD</span>(x,y)</span><br><span class="line">返回x<span class="operator">/</span>y的模</span><br></pre></td></tr></table></figure><h4 id="RAND">RAND</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAND()</span><br><span class="line">返回<span class="number">0</span><span class="operator">~</span><span class="number">1</span>内的随机数</span><br></pre></td></tr></table></figure><h4 id="ROUND">ROUND</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ROUND(x,y)</span><br><span class="line">求参数x的四舍五入的值，保留y位小数</span><br></pre></td></tr></table></figure><h3 id="日期函数">日期函数</h3><h4 id="CURDATE">CURDATE</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curdate()</span><br><span class="line">返回当前日期,年<span class="operator">-</span>月<span class="operator">-</span>日</span><br></pre></td></tr></table></figure><h3 id="CURTIME">CURTIME</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curtime()</span><br><span class="line">返回当前时间</span><br></pre></td></tr></table></figure><h4 id="NOW">NOW</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">now()</span><br><span class="line">返回当前日期和时间</span><br></pre></td></tr></table></figure><h4 id="YEAR">YEAR</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">year</span>(<span class="type">date</span>)</span><br><span class="line">获取指定<span class="type">date</span>的年份</span><br></pre></td></tr></table></figure><h4 id="MONTH">MONTH</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">month</span>(<span class="type">date</span>)</span><br><span class="line">获取指定<span class="type">date</span>的月份</span><br></pre></td></tr></table></figure><h4 id="DAY">DAY</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">day</span>(<span class="type">date</span>)</span><br><span class="line">获取指定<span class="type">date</span>的日期</span><br></pre></td></tr></table></figure><h4 id="DATE-ADD">DATE_ADD</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DATE_ADD(<span class="type">date</span>,<span class="type">INTERVAL</span> expr type)</span><br><span class="line">返回一个日期<span class="operator">/</span>时间值加上一个时间间隔expr后的时间值</span><br><span class="line"></span><br><span class="line">expr 指定数字</span><br><span class="line">type 指定类型:年<span class="operator">/</span>月<span class="operator">/</span>日(<span class="keyword">DAY</span><span class="operator">/</span><span class="keyword">MONTH</span><span class="operator">/</span><span class="keyword">YEAR</span>)</span><br><span class="line">例：</span><br><span class="line">DATE_ADD(now(),<span class="type">INTERVAL</span> <span class="number">70</span> <span class="keyword">day</span>)<span class="comment">-- 70天之后的时间</span></span><br><span class="line">DATE_ADD(now(),<span class="type">INTERVAL</span> <span class="number">70</span> <span class="keyword">month</span>)<span class="comment">-- 70个月之后的时间</span></span><br></pre></td></tr></table></figure><h4 id="DATEDIFF">DATEDIFF</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DATEDIFF(date1,date2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回起始时间date1和结束时间date2</span></span><br><span class="line">之间的天数</span><br><span class="line"><span class="comment">-- 一般用于求入职，入学时间等</span></span><br></pre></td></tr></table></figure><h3 id="流程函数">流程函数</h3><h4 id="IF">IF</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF(<span class="keyword">value</span>,t,f)</span><br><span class="line">如果<span class="keyword">value</span>为<span class="literal">true</span>，则返回t，否则返回f</span><br><span class="line"><span class="comment">-- 类似三目运算符</span></span><br></pre></td></tr></table></figure><h4 id="IFNULL">IFNULL</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(value1,value2)</span><br><span class="line">如果value1不为<span class="keyword">null</span>，返回value1，否则返回value2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用于聚合函数的筛选</span></span><br><span class="line"><span class="comment">-- 例： 求成绩大于60分才有学分，求同学的总学分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sno <span class="keyword">as</span> <span class="string">&#x27;学号&#x27;</span>,sn <span class="keyword">as</span> <span class="string">&#x27;姓名&#x27;</span>,<span class="built_in">sum</span>(IF(score<span class="operator">&gt;=</span><span class="number">60</span>,credit,<span class="keyword">NULL</span>)) <span class="keyword">from</span> s;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这里的if会判断，如果score&gt;=60分就会返回credit，即sum(credit)计算学分和,如果不满足则会返回NULL，就不会计算该值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CASE-WHEN">CASE WHEN</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> [expr] <span class="keyword">WHEN</span> [val1] <span class="keyword">THEN</span> [res1] ...<span class="keyword">ELSE</span>[<span class="keyword">default</span>] <span class="keyword">END</span></span><br><span class="line">如果expr(表达式<span class="operator">/</span>字段)的值等于val1，返回res1，...否则返回<span class="keyword">default</span>默认值</span><br><span class="line"><span class="comment">-- 一般用于给出具体的条件的值</span></span><br><span class="line"></span><br><span class="line">例：查询emp表的员工姓名和工作地址，如果工作地址在北京<span class="operator">/</span>上海，则标明一线城市，其他则为二线城市</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">name,</span><br><span class="line">(<span class="keyword">case</span> workaddress <span class="keyword">when</span> <span class="string">&#x27;北京&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">when</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;二线城市&#x27;</span> <span class="keyword">end</span> ) <span class="keyword">as</span> <span class="string">&#x27;工作地址&#x27;</span></span><br><span class="line"><span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> [val <span class="number">1</span>] <span class="keyword">THEN</span> [RES1] ... <span class="keyword">ELSE</span> [<span class="keyword">default</span>] <span class="keyword">END</span></span><br><span class="line">如果val1为<span class="literal">true</span>，返回res1，...否则返回<span class="keyword">default</span>默认值</span><br><span class="line"><span class="comment">-- 一般用于范围</span></span><br><span class="line"></span><br><span class="line">例如：统计成绩，<span class="number">85</span>分以上为优秀，<span class="number">60</span>分以上为及格，<span class="number">60</span>分以下为不及格</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">id,</span><br><span class="line">name,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> math<span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span> ) <span class="keyword">as</span> <span class="string">&#x27;数学&#x27;</span>,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> english<span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span> ) <span class="keyword">as</span> <span class="string">&#x27;英语&#x27;</span>,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> chinese<span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span> ) <span class="keyword">as</span> <span class="string">&#x27;语文&#x27;</span>,</span><br><span class="line"><span class="keyword">from</span> score;</span><br><span class="line"></span><br><span class="line">其中math，english，chinese 三个字段使用了流程函数,使<span class="keyword">select</span>出来的值进行了指定</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多表关系">多表关系</h2><p>项目开发中，在进行数据库表结构设计师，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所有各个表结构之间也存在着各种联系，基本分为三种:</p><ul><li><p>一对多(多对一)</p><p>案例：部门与 员工的关系</p><p>关系：一个部门对应多个员工，一个员工对应多个部门</p></li></ul><p>​     实现：<strong>在多的一方建立外键，指向一的一方主键</strong></p><ul><li>多对多</li></ul><p>​案例：学生与课程的关系</p><p>​关系：一个学生可以选修多么课程，一门课程也可以供多个学生选择</p><p>​实现：<strong>建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</strong></p><ul><li><p>一对一</p><p>案例：用户与用户详情的关系</p><p>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详细字段放在另一张表中,以提升操作效率</p><p>实现：<strong>在任意一方加入外键，关联另一方的主键，并设置外键为唯一的UNIQUE</strong></p></li></ul><p>多表查询</p><h3 id="概述">概述</h3><p>概述：指从多张表中查询数据</p><p>笛卡尔积：笛卡尔乘积是指在数学中，两个集合A集合和B集合的所有组合情况。(<strong>在多表查询时，需要消除无效的笛卡尔积</strong>)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 后面这个where就可以保证出来的两个id对应</span></span><br><span class="line">连接条件为: emp.dept_id <span class="operator">=</span> dept.id</span><br></pre></td></tr></table></figure><h3 id="内连接">内连接</h3><p><strong>内连接将两张表连接起来，内连接查询的是两张表的交集的部分</strong></p><p>隐式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>，表<span class="number">2</span> <span class="keyword">WHERE</span> 条件 ...;</span><br><span class="line"><span class="comment">-- 不使用内连接实现方式</span></span><br></pre></td></tr></table></figure><p>显示内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 写法一</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 连接条件...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 写法二</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 连接条件 <span class="keyword">and</span> 连接条件 ...;</span><br></pre></td></tr></table></figure><h3 id="外连接">外连接</h3><h4 id="左外连接">左外连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> (<span class="keyword">OUTER</span>) <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 <span class="keyword">LEFT</span> (<span class="keyword">OUTER</span>) <span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 连接条件...;</span><br></pre></td></tr></table></figure><p><strong>注：相当于查询左表(表1)的所有数据包含表1和表2交集部分的数据</strong></p><h4 id="右外连接">右外连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> (<span class="keyword">OUTER</span>) <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 <span class="keyword">RIGHT</span> (<span class="keyword">OUTER</span>) <span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 连接条件...;</span><br></pre></td></tr></table></figure><p><strong>注：相当于查询右表(表2)的所有数据包含表1和表2交集部分的数据</strong></p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意:</strong></p><ul><li><strong>左外连接可以和右外连接互相转换，只需要交换字段位置</strong></li><li>外连接和内连接的区别:<strong>内连接只会展示两张表的交集部分当连接的部分中没有原表中的某条数据，即为NULL时，就不会显示出来，而外连接可以将某一张表的所有数据和交集部分显示出来，即可以显示想要知道的NULL</strong></li></ul></div><h3 id="自连接">自连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A <span class="keyword">AS</span> 别名A <span class="keyword">JOIN</span> 表A <span class="keyword">AS</span> 别名B <span class="keyword">ON</span> 条件 ...;</span><br><span class="line"></span><br><span class="line">一定要将该表取两个别名，看成两张表</span><br></pre></td></tr></table></figure><p><strong>自连接查询，可以是内连接查询，也可以是外连接查询</strong></p><h3 id="联合查询">联合查询</h3><p>把多次查询的结果合并起来，形成一个新的查询结果集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A ...</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B ...;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">50</span> </span><br><span class="line"></span><br><span class="line">有<span class="keyword">ALL</span>可能会导致有重复，但去掉<span class="keyword">ALL</span>只用<span class="keyword">union</span>则会去除相同的</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意:</strong></p><ul><li><strong>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</strong></li><li><strong>union all 会将全部的数据直接合并在一起，union会对合并之后的数据去重</strong></li><li><strong>or只能单表查询，而union可以多表查询</strong></li></ul></div><h3 id="子查询">子查询</h3><ul><li>概念：SQL语句中嵌套SELECT语句，成为<strong>嵌套查询</strong>，又称<strong>子查询</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> column1 <span class="operator">=</span> (<span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> t2);</span><br><span class="line"></span><br><span class="line">子查询外部的语句可以是：<span class="keyword">INSERT</span><span class="operator">/</span><span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span><span class="operator">/</span><span class="keyword">SELECT</span>的任何一个。</span><br></pre></td></tr></table></figure><ul><li><p>根据子查询结果不同，分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询 （子查询结果为多行多列）</li></ul></li><li><p>根据子查询位置,分为：WHERE之后、FROM之后、SELECT之后。</p></li></ul><h4 id="标量子查询">标量子查询</h4><p>子查询返回的结果是单个值(数字、字符串、日期等), 是最简单的形式，这种子查询称为<strong>标量子查询</strong></p><p>常用的操作符：<strong>= ，&lt;&gt; ，&gt;， &gt;=， &lt;， &lt;=</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例如:</span></span><br><span class="line"><span class="comment">-- 查询&#x27;销售部&#x27;的所有员工信息(id和名称在两张表)</span></span><br><span class="line"><span class="comment">-- 我们分为两步</span></span><br><span class="line"><span class="comment">-- 1.查询&#x27;销售部&#x27;部门ID</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.根据销售部的部门ID，查询员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.使用标量子查询合并之后就是</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="列子查询">列子查询</h4><p>子查询返回的结果是一列(可以是多行), 这种子查询成为列子查询。</p><p>常用的操作符： <strong>IN 、NOT IN 、ANY 、SOME 、ALL、EXISTS</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IN</span> ：在指定的集合范围之内  ，多选一</span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">IN</span> ： 不在指定的集合范围之内</span><br><span class="line"><span class="keyword">ANY</span> ：子查询返回列表中，有任意一个满足即可</span><br><span class="line"><span class="keyword">SOME</span> ： 与<span class="keyword">ANY</span>等同，使用<span class="keyword">SOME</span>的地方都可以使用<span class="keyword">ANY</span></span><br><span class="line"><span class="keyword">ALL</span> : 子查询返回列表的所有值都必须满足</span><br><span class="line"><span class="keyword">EXISTS</span>: 也可进行相关子查询，但不返回任何实际数据，只得到真或假</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="comment">-- 列子查询</span></span><br><span class="line"><span class="comment">-- 1.查询&#x27;销售部&#x27;和&#x27;市场部&#x27;的所有员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询比财务部所有人工资都高的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询所有财务部人员工资</span></span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b. 比财务部所有人工资都高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">ALL</span>(<span class="keyword">select</span>  salary <span class="keyword">from</span> <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>)salary )</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.查询比研发部任意一人工资高的员工该信息</span></span><br><span class="line"><span class="comment">-- a. 查询研发部所有人工资</span></span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b. 比研发部其中任意一人工资高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">ANY</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- exist 表示存在的量词，带有exists的子查询不返回任何实际数据，它只得到逻辑值&quot;真&quot;或&quot;假&quot;。当子查询的查询结果集合为非空时，外层的WHERE子句返回真值，否则返回假值。NOT EXISTS与此相反。</span></span><br><span class="line"><span class="comment">-- 查询学生的学号和姓名，查询条件是学生没有选修课程号为&quot;c1&quot;的课程（使用exist）</span></span><br><span class="line"><span class="keyword">select</span> sno,sn <span class="keyword">from</span> s <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sc <span class="keyword">where</span> sno <span class="operator">=</span> s.sno <span class="keyword">AND</span> cno <span class="operator">=</span> <span class="string">&#x27;C1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上述语句的执行过程是，对于父查询中的每一位学生，在子查询中查询是否选修了课程号为C1的课程，如果没有选课记录，说明子查询的结果集合为空，则父查询中WHERE子句中的not exists的返回逻辑值&quot;真&quot;,从而该学生的信息会被被选取到父查询的结果集合中,集合不为空，则not exists的返回逻辑值为&quot;假&quot;，则该学生信息丢弃。对父查询表s中的每一位学生重复上述过程，即可完成查询任务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="行子查询">行子查询</h4><p>子查询返回的结果是一行（可以是多列），这种子查询成为<strong>行子查询</strong></p><p>常用的操作符：<strong>= ，&lt;&gt; ，IN、NOT IN</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 行子查询</span></span><br><span class="line"><span class="comment">-- 1.查询与&#x27;张无忌&#x27;的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询张无忌的薪资及直属领导</span></span><br><span class="line"><span class="keyword">select</span> salary,managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b. 查询与&#x27;张无忌&#x27;的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">=</span> <span class="number">12500</span> <span class="keyword">and</span> managerid <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 组合作为条件</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="number">12500</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 表示salary =12500，managerid = 1 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 行子查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="keyword">select</span> salary,managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>);</span><br><span class="line"><span class="comment">-- 刚好是两条数据两两对应，等号的组合写法</span></span><br></pre></td></tr></table></figure><h4 id="表子查询">表子查询</h4><p>子查询返回的结果是多行多列，这种子查询称为<strong>表子查询</strong></p><p>常用操作符: <strong>IN</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表子查询</span></span><br><span class="line"><span class="comment">-- 1. 查询与 &#x27;lzk&#x27; ,&#x27;syq&#x27; 的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询 lzk，syq的职位和薪资</span></span><br><span class="line"><span class="keyword">select</span> job,salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;lzk&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;lyq&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b.查询与lzk，syq的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="comment">-- 组合写法</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (job,salary) <span class="keyword">in</span> (<span class="keyword">select</span> job,salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;lzk&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;lyq&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="事务简介">事务简介</h2><p><strong>事务（transaction）<strong>是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作</strong>要么同时成功，要么同时失败</strong></p><h3 id="事务操作">事务操作</h3><h4 id="方式一">方式一</h4><ul><li>查看/设置事务提交方式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="comment">-- 查看事务的自动提交方式：1为自动，0为手动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 设置系统变量的提交方式：1为自动，0为手动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这种方法可作用于全局</span></span><br></pre></td></tr></table></figure><ul><li>提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 在设置了手动提交后，任意的sql语句，只有在sql语句之后使用了commit才会提交修改数据库，否则不会修改</span></span><br></pre></td></tr></table></figure><ul><li>回滚事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="comment">-- 遇到异常时可以回滚已经执行的sql语句</span></span><br><span class="line"><span class="comment">-- 提交之后不能回滚</span></span><br></pre></td></tr></table></figure><h4 id="方式二">方式二</h4><ul><li>开启事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION 或 <span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 这句话执行后代表开启事务，代表我们要手动控制事务，只要没有commit数据库就不会改变、</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这种方法可作用于某些语句,执行完成后事务自动关闭</span></span><br></pre></td></tr></table></figure><ul><li>提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- commit事务后代表事务完成了</span></span><br></pre></td></tr></table></figure><ul><li>回滚事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h3 id="事务的四大特性-ACID">事务的四大特性(ACID)</h3><ul><li>原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态(合理加减)。</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变使永久的。</li></ul><h3 id="并发事务问题">并发事务问题</h3><ul><li><p><strong>丢失更新</strong>：两个事务读入同一数据，并发执行修改操作时，一个事务将另一个事务的修改覆盖，导致这些修改好像丢失了一样</p></li><li><p><strong>读取脏数据(脏读)：<strong>一个事务读到另外一个事务</strong>还没有提交</strong>的数据(未commit)</p></li><li><p>**不可重复读：**在一个事务中先后读取同一条数据，但两次读取的数据不同，称为不可重复读。</p></li><li><p>**幻象读(幻读)：**一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在了，好像出现了&quot;幻影&quot;</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- (查询)不可重复读：现在分别开启A,B两个事务，A第一次读取数据，在A第二次读取前，B事务修改了该数据，导致该事务再次读取数据时数据与第一次读取不同(A事务始终没有结束)</span></span><br><span class="line"><span class="comment">-- 如果解决了不可重复读，在一个事务中，两次读取同一个数据，数据相同，但在该事务结束后，再读取，数据就会更新了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- (增删)幻读: 在解决了不可重复读之后才会出现，A事务查询数据时，没有对应的数据行，A准备插入，但是在A插入前，B插入了数据,A就会得到数据已经存在，但是之后第二次查询，又发现没有该数据行。</span></span><br><span class="line"><span class="comment">-- 因为设置了可重复读（解决不可重复读），所以才会满足在同一个事务中两次读取到的数据应该是相同的，但是实际数据确实存在</span></span><br></pre></td></tr></table></figure><h3 id="事务隔离级别">事务隔离级别</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 四种事务隔离级别，从上到下性能降低，安全升高</span></span><br><span class="line"><span class="comment">-- 通常要综合性能和安全选择隔离级别</span></span><br><span class="line"></span><br><span class="line">脏读      不可重复读     幻读</span><br><span class="line">Read uncommitted:  会出现       会出现      会出现</span><br><span class="line">Read committed:     不会会  会</span><br><span class="line">Repeatable Read:不会不会 会</span><br><span class="line">Serializable:不会不会不会</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Mysql默认：Repeatable Read 可重复读</span></span><br><span class="line"><span class="comment">-- Oracle默认: Read committed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Read uncommitted：未提交读</span></span><br><span class="line"><span class="comment">-- Read committed：提交读</span></span><br><span class="line"><span class="comment">-- Repeatable Read：可重复读</span></span><br><span class="line"><span class="comment">-- Serializable：序列化(串行化)，代表在进行并发事务操作时，同一时间只能执行一个事务，只有在该事务提交之后，才能执行其他事务，其他事务在这之前会被阻塞,避免所有的并发问题</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看事务隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@TRANSACTION_ISOLATION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED<span class="operator">|</span> READ COMMITTED<span class="operator">|</span> REPEATABLE READ<span class="operator">|</span> SERIALIZABLE]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SESSION：会话级别,代表针对当前客户端窗口有效,某一个console控制台</span></span><br><span class="line"><span class="comment">-- GLOBAL：代表所有客户端有效</span></span><br></pre></td></tr></table></figure><ul><li><strong>注意事务隔离级别越高，数据越安全，但是性能越低</strong></li></ul><h1>进阶篇</h1><h2 id="索引">索引</h2><p>索引(index) 是帮助MySQL<strong>高效获取数据</strong>的<strong>数据结构(有序)</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p><strong>优点：</strong></p><ul><li><strong>提高数据检索的效率，降低数据库的IO成本</strong></li><li><strong>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</strong></li></ul><p><strong>缺点：</strong></p><ul><li><strong>索引列需要占用空间</strong></li><li><strong>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低</strong></li></ul><h3 id="索引结构">索引结构</h3><p>MySQL的索引是在储存引擎层实现的，不同的储存引擎有不同的结构，主要包含以下几种：</p><ul><li><strong>B+Tree索引：最常见的索引类型，大部分引擎都支持B+树索引</strong></li><li><strong>Hash索引：底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</strong></li><li><strong>R-tree：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</strong></li><li><strong>Full-text：是一种通过建立倒排索引，快速匹配文档的方式，类似于Lucene，Solr，ES</strong></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</strong></p></div><ul><li>二叉树</li></ul><p><strong>二叉树缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量的情况下，层级较深，检索速度慢。</strong></p><p><strong>红黑树：大数据量的情况下，层级较深，检索速度慢。</strong></p><ul><li>B-Tree(<strong>多路</strong>平衡查找树)</li></ul><p>以一颗最大度数为5(5个子节点)的b-tree为例(每个节点最多储存四个key，5个指针)，指针数 = key + 1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插入 <span class="number">100</span> <span class="number">65</span> <span class="number">169</span> <span class="number">368</span> <span class="number">900</span> <span class="number">556</span> <span class="number">780</span> <span class="number">35</span> <span class="number">215</span> <span class="number">1200</span> <span class="number">234</span> <span class="number">888</span> <span class="number">158</span> <span class="number">90</span> <span class="number">1000</span> <span class="number">88</span> <span class="number">120</span> <span class="number">268</span> <span class="number">250</span>  为例</span><br></pre></td></tr></table></figure><p>B-Tree 动态变化的过程可以参考网站：</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-Tree Visualization (usfca.edu)</a></p><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization (usfca.edu)</a></p><h3 id="索引分类">索引分类</h3><ul><li><strong>主键索引</strong>：针对于表中主键创建的索引，建表时默认自动创建，只能有一个，关键字是PRIMARY。</li><li><strong>唯一索引</strong>：避免同一个表中某数据列中的值重复，可以有多个，关键字UNIQUE。</li><li><strong>常规索引</strong>：快速定位特定的数据，可以有多个。</li><li><strong>全文索引</strong>：全文索引查找的是文本中的关键词，而不是比较索引中的值，可以有多个，关键字FULLTEXT。</li><li><strong>空间索引：</strong> 使用了SPATIAL关键字的索引，适用于GEOMETRY ,POINT,POLYGON等空间类型数据的列</li></ul><p>在InnoDB储存引擎中，根据索引的存储形式，又可以分为以下两种：</p><ul><li>聚集索引(Clustered Index)：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据(记录)，<strong>必须有，而且只有一个</strong></li><li>二级索引(Secondary Index)：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键，<strong>可以存在多个</strong></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>聚集索引的选取规则：</strong></p><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表中没有主键，或没有适合的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ul></div><p>回表查询：先根据字段对应的二级索引去查对应的主键值，在根据主键对应的聚集索引去查行数据。</p><h3 id="索引语法">索引语法</h3><h4 id="创建索引">创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name <span class="keyword">ON</span> table_name(字段名[(索引字符长度) [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]],...);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一个索引可关联多个字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不加可选项UNIQUE或FULLTEXT代表默认创建常规索引</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">--  以name字段为姓名字段，该字段的值可能会重复，且索引针对name的前3个字符以降序排序,为该字段创建索引。</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name(<span class="number">3</span>) <span class="keyword">desc</span>);</span><br><span class="line"><span class="comment">-- phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">UNIQUE</span> index idx_user_phone <span class="keyword">on</span> tb_user(phone);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为profession、age、status创建联合索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_status <span class="keyword">on</span> tb_user(profession、age、status);</span><br><span class="line">联合索引中字段索引是有讲究的</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为email建立合适的索引来提升查询效率</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_email <span class="keyword">on</span> tb_user(email);</span><br></pre></td></tr></table></figure><ul><li><strong>可以在建表时创建索引</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 数据类型 列约束 comment <span class="string">&#x27;注释&#x27;</span>,</span><br><span class="line">    字段<span class="number">2</span> 数据类型 列约束 comment <span class="string">&#x27;注释&#x27;</span>，</span><br><span class="line">    ...</span><br><span class="line">    [表约束]，</span><br><span class="line">    [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name(字段名[(索引字符长度) [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]],...),</span><br><span class="line">    ...</span><br><span class="line">     [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name(字段名[(索引字符长度) [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]],...),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例:</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> classroom(</span><br><span class="line">cid <span class="type">int</span> auto_increment,</span><br><span class="line">    crno <span class="type">varchar</span>(<span class="number">13</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    cbn <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(cid),</span><br><span class="line">    <span class="keyword">unique</span> index cn_cb_index(crno,cbn)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在表约束后，可以使用index关键字为表创建索引，与<span class="keyword">create</span> index用法相同。</span><br><span class="line"><span class="number">2.</span><span class="keyword">create</span> <span class="keyword">table</span>语句可以一次附带多个索引，不同索引间使用逗号分隔</span><br><span class="line"><span class="number">3.</span><span class="keyword">create</span> <span class="keyword">table</span>创建索引时无需提供表名，而是使用<span class="keyword">create</span> index语句创建索引时要指明表名</span><br></pre></td></tr></table></figure><h4 id="查看索引">查看索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看tb_user表的索引</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure><h4 id="修改索引">修改索引</h4><p><a href="https://blog.csdn.net/challenglistic/article/details/129166717">Mysql 索引（三）—— 不同索引的创建方式（主键索引、普通索引、唯一键索引）-CSDN博客</a></p><h4 id="删除索引">删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例：删除email的索引</span></span><br><span class="line"><span class="keyword">drop</span> index idx_user_email <span class="keyword">on</span> tb_user;</span><br></pre></td></tr></table></figure><h2 id="视图">视图</h2><ul><li>介绍</li></ul><p>视图(view)是一种<strong>虚拟存在的表</strong>。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p><p>通俗的讲，<strong>视图只保存了查询的SQL逻辑，不保存查询结果</strong>。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><h3 id="视图语法">视图语法</h3><ul><li><strong>创建</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- OR REPLACE &#x27;或替代&#x27; , 可选项</span></span><br><span class="line"><span class="comment">-- </span></span><br></pre></td></tr></table></figure><ul><li><strong>查询</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看创建视图的语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称；</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看视图数据(把视图当作表来查，可以像操作表一样来操作视图)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 视图名称 WHERE...;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> stu_v_1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1 <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>修改视图</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式一：关键在or replace上，修改必须加</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span>[<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure><ul><li><strong>删除视图</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] 视图名称，... ;</span><br></pre></td></tr></table></figure><h3 id="视图的检查选项">视图的检查选项</h3><p>当使用with check option子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使符合视图的定义。<strong>MySQL允许基于另一个视图创建视图</strong>，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：cascaded 和 local，<strong>默认值为cascaded(级联)</strong>。</p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意：</strong></p><ul><li><p><strong>只有添加了with check option的视图才会在插入时进行where条件的检查，没有检查时直接会添加成功到表</strong></p></li><li><p><strong>插入的数据是存放到基表中的，视图中不存放数据</strong></p></li></ul></div><h4 id="CASCADED-级联">CASCADED(级联)</h4><p><strong>cascade 会去递归检查当前视图以及创建时依赖的视图，并且看是否加了检查选项，如果其依赖的视图中没有加入检查选项，则会将cascaded向下传递，使其向下的视图都加上检查选项使其都能检查</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_1 <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;TOM&#x27;</span>)</span><br><span class="line"><span class="comment">-- 成功添加到student中</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_1 <span class="keyword">values</span>(<span class="number">30</span>,<span class="string">&#x27;TOM&#x27;</span>)</span><br><span class="line"><span class="comment">-- 添加成功到student中，用select搜索该视图中找不到该数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加cascaded选项后</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_1 <span class="keyword">values</span>(<span class="number">30</span>,<span class="string">&#x27;TOM&#x27;</span>)</span><br><span class="line"><span class="comment">-- 添加失败，因为id&gt;20，故会阻止该数据的添加</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span>  </span><br><span class="line"><span class="comment">-- 由于stu_2使用cascaded检查选项，则stu_1也会继承到该检查选项</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_3 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_3 <span class="keyword">values</span>(<span class="number">11</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入成功</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_3 <span class="keyword">values</span>(<span class="number">17</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入成功，stu_3没有检查选项，不会检查</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_3 <span class="keyword">values</span>(<span class="number">28</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入失败，stu_3没有检查选项，直接到依赖视图stu_2中，stu_2中有检查选项并且是cascaded，满足id&gt;=10,递归进入stu_1中，由于stu_1继承到了cascaded, 会进行判断,不满足id&lt;=20，阻止该数据插入.</span></span><br></pre></td></tr></table></figure><h4 id="LOCAL">LOCAL</h4><p><strong>local 会去递归检查当前视图以及创建时依赖的视图，并且看是否加了检查选项，如果有，则进行条件的检查看是否满足条件，如果没有则不进行检查继续递归</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图1,没有依赖视图，没有检查选项</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span>  student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">15</span>;</span><br><span class="line"><span class="comment">-- 创建视图2，依赖于视图1,没有检查选项</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_1 <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">10</span> ;</span><br><span class="line"><span class="comment">-- 创建视图3，依赖于视图2,设置local检查选项</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_3 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_2 <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">with</span> <span class="keyword">local</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_3 <span class="keyword">values</span>(<span class="number">13</span>,<span class="string">&#x27;TOM&#x27;</span>);</span><br><span class="line"><span class="comment">-- 由于stu_3设置了检查选项,该语句会先判断id&lt;20(如果没设置就不会判断而是会直接进入stu_2中),然后递归到stu_2发现stu_2没有添加检查选项，则不进行判断id&gt;=10，如果添加了，则会判断id&gt;=10，再依次递归到stu_1，直到没有依赖其他视图建立的视图为止</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果任意一次条件判断不满足则会插入失败</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">MySQL的相关知识包括基础篇、进阶篇和运维篇,学习自黑马</summary>
    
    
    
    <category term="MySQL" scheme="https://www.thekqd.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.thekqd.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQl安装</title>
    <link href="https://www.thekqd.top/posts/4484a8c6.html"/>
    <id>https://www.thekqd.top/posts/4484a8c6.html</id>
    <published>2023-09-16T08:25:42.000Z</published>
    <updated>2025-01-22T06:59:22.003Z</updated>
    
    <content type="html"><![CDATA[<h1>MySQL安装</h1><p><a href="https://www.mysql.com/downloads/">MySQL :: MySQL Downloads</a></p><h1>MySQL启动与停止</h1><p><strong>启动</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql80</span><br></pre></td></tr></table></figure><p><strong>停止</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql80</span><br></pre></td></tr></table></figure><h1>MySQL的客户端连接</h1><p>**方法一：**通过直接提供的MySQL 8.0 Command Line Client输入密码连接</p><p>**方法二：**系统的cmd连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql [-h 127.0.0.1] [-p 3306] -u root -p</span><br><span class="line"></span><br><span class="line">可选项1：指定连接ip，不填默认本机</span><br><span class="line">可选项2：指定端口号，不填默认3306</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意：要想在任意目录使用这种方式执行mysql指令就必须配置系统环境变量</p><p>系统环境变量path中添加：C:\Program Files\MySQL\MySQL Server 8.0\bin(mysql的路径)</p></div>]]></content>
    
    
    <summary type="html">MySQL启动与安装与连接</summary>
    
    
    
    <category term="MySQL" scheme="https://www.thekqd.top/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://www.thekqd.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>实验室管理系统</title>
    <link href="https://www.thekqd.top/posts/b088c444.html"/>
    <id>https://www.thekqd.top/posts/b088c444.html</id>
    <published>2023-07-29T15:10:02.000Z</published>
    <updated>2023-07-31T14:15:03.891Z</updated>
    
    <content type="html"><![CDATA[<h1>题目及源码</h1><p>相关题目以及源码放在github仓库</p><p><a href="https://github.com/keqiudi/Cpp_internal_exam">keqiudi/Cpp_internal_exam (github.com)</a></p><h1>相关知识点</h1><h2 id="线程池的实现">线程池的实现</h2><p>见线程池篇</p><p><a href="https://keqiudi.github.io/posts/aa76cb12.html">线程池C++版 | Walnut🍭 (keqiudi.github.io)</a></p><h2 id="线程池下的socket">线程池下的socket</h2><p><code>分为两个部分</code>:</p><ul><li>主线程中添加一个任务，单独让一个线程，进行一个任务，该任务处于循环中，一直检测是否有客户端连接。(该线程始终存在)</li><li>如果连接成功，则每一次循环添加所需要工作的任务进线程池中，让其它线程进行处理。(可能管理者被销毁)</li></ul><h2 id="vector">vector</h2><p>此项目中，利用封装后的用户类放入vector容器中，用于保存数据。</p><ul><li>以下只有本项目中使用的函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>()<span class="comment">//尾部插入元素</span></span><br><span class="line"><span class="built_in">emplace_back</span>()<span class="comment">//尾部插入元素</span></span><br><span class="line">userList.<span class="built_in">emplace_back</span>(userName,password,userType,realName);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">pop_back</span>()<span class="comment">//删除最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>()<span class="comment">//删除元素，允许使用迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(userList.<span class="built_in">begin</span>()+i<span class="number">-1</span>)<span class="comment">//删除第i个元素    </span></span><br></pre></td></tr></table></figure>  <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li><p><code>emplace_back()</code> 可以允许直接传入构造函数参数，直接在容器内部创建一个对象，示例见上方。</p></li><li><p><code>push_back()</code>则是需要先用构造函数创建一个对象，再使用拷贝(复制)构造函数插入集合。</p></li></ul><p>即：使用<code>emplace_back()</code>比常规的<code>push_back()</code>少调用了一次复制构造函数，<strong>可提高代码的效率</strong>。</p></div><p><strong>以下为vector详细用法：</strong></p><ul><li><a href="https://blog.csdn.net/qq_52324409/article/details/121000029?spm=1001.2014.3001.5506">C++ vector容器详解_c++容器vector_＆不逝的博客-CSDN博客</a></li></ul><h2 id="运算符重载">运算符重载</h2><p>需要的到一个全新对象对=进行重载时，返回值最好为引用类型</p><p>返回值不是引用的话有以下几个坏处:</p><ul><li>不能实现链式赋值，例如m1 = m2 = m3 = u这样的语句就会报错，因为m2 = m3 = u返回的是一个临时对象，不能再赋值给m1。</li><li>会造成额外的拷贝开销，因为每次赋值都要创建一个新的对象，并调用拷贝构造函数和析构函数，这会降低程序的效率。</li><li>会导致对象的一致性问题，因为赋值后的对象和原对象不是同一个对象，它们的地址不同，如果对其中一个对象进行修改，另一个对象不会受到影响。</li></ul><p><code>例</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Manager&amp; <span class="keyword">operator</span>=(User&amp; user)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserName</span>(user.<span class="built_in">getUserName</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserPassword</span>(user.<span class="built_in">getUserPassword</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserRealName</span>(user.<span class="built_in">getUserRealName</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserType</span>(user.<span class="built_in">getUserType</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserSeatNumber</span>(user.<span class="built_in">getUserSeatNumber</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserSeatStatus</span>(user.<span class="built_in">getUserSeatStatus</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserGarbageTime</span>(user.<span class="built_in">getUserGarbageTime</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserActivityNumber</span>(user.<span class="built_in">getUserActivityNumber</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//User对象赋值给一个Manager对象。这个运算符的返回值是一个Manager的引用，也就是*this</span></span><br></pre></td></tr></table></figure><p><code>附上常用重载：</code></p><p><a href="https://blog.csdn.net/qq_27278957/article/details/85269245?ops_request_misc=%7B%22request%5Fid%22%3A%22169081199116800222867695%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169081199116800222867695&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-85269245-null-null.142%5Ev91%5Econtrol_2,239%5Ev12%5Einsert_chatgpt&amp;utm_term=%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD&amp;spm=1018.2226.3001.4187"> C++ 运算符重载_c++ 重载=_高祥xiang的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">一个简单的实验室管理系统后端</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
    <category term="多线程" scheme="https://www.thekqd.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="socket" scheme="https://www.thekqd.top/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="https://www.thekqd.top/posts/ad18462f.html"/>
    <id>https://www.thekqd.top/posts/ad18462f.html</id>
    <published>2023-07-29T04:16:49.000Z</published>
    <updated>2024-01-20T13:54:17.155Z</updated>
    
    <content type="html"><![CDATA[<h1>基础篇</h1><h2 id="github术语">github术语</h2><p><strong>Repository</strong>：简称Repo，可以理解为“仓库”，我们的项目就存放在仓库之中。也就是说，如果我们想要建立项目，就得先建立仓库；有多个项目，就建立多个仓库。</p><p><strong>Issues</strong>：可以理解为“问题”，举一个简单的例子，如果我们开源一个项目，如果别人看了我们的项目，并且发现了bug，或者感觉那个地方有待改进，他就可以给我们提出Issue，等我们把Issues解决之后，就可以把这些Issues关闭；反之，我们也可以给他人提出Issue。</p><p><strong>Star</strong>：可以理解为“点赞”，当我们感觉某一个项目做的比较好之后，就可以为这个项目点赞，而且我们点赞过的项目，都会保存到我们的Star之中，方便我们随时查看。在 GitHub 之中，如果一个项目的点星数能够超百，那么说明这个项目已经很不错了。</p><p><strong>Fork</strong>：可以理解为“拉分支”，如果我们对某一个项目比较感兴趣，并且想在此基础之上开发新的功能，这时我们就可以Fork这个项目，这表示复制一个完成相同的项目到我们的 GitHub 账号之中，而且独立于原项目。之后，我们就可以在自己复制的项目中进行开发了。</p><p><strong>Pull Request</strong>：可以理解为“提交请求”，此功能是建立在Fork之上的，如果我们Fork了一个项目，对其进行了修改，而且感觉修改的还不错，我们就可以对原项目的拥有者提出一个Pull请求，等其对我们的请求审核，并且通过审核之后，就可以把我们修改过的内容合并到原项目之中，这时我们就成了该项目的贡献者。</p><p><strong>Merge</strong>：可以理解为“合并”，如果别人Fork了我们的项目，对其进行了修改，并且提出了Pull请求，这时我们就可以对这个Pull请求进行审核。如果这个Pull请求的内容满足我们的要求，并且跟我们原有的项目没有冲突的话，就可以将其合并到我们的项目之中。当然，是否进行合并，由我们决定。</p><p><strong>Watch</strong>：可以理解为“观察”，如果我们Watch了一个项目，之后，如果这个项目有了任何更新，我们都会在第一时候收到该项目的更新通知。</p><p><strong>Gist</strong>：如果我们没有项目可以开源或者只是单纯的想分享一些代码片段的话，我们就可以选择Gist。不过说心里话，如果不翻墙的话，Gist并不好用。</p><h2 id="配置用户名和邮箱">配置用户名和邮箱</h2><p>使用git前配置<strong>用户名和邮箱</strong>，这样才能够识别出来是谁提交的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;keqiudi&quot; #配置用户名</span><br><span class="line">git config --global user.email &quot;1244381125@qq.com&quot; #配置邮箱</span><br><span class="line"></span><br><span class="line">git config --global --list #查看配置</span><br><span class="line">参数：</span><br><span class="line">--global：全局配置，对所有仓库生效，一般使用</span><br><span class="line">--system：系统配置，对所有用户生效，一般不适用</span><br></pre></td></tr></table></figure><h2 id="创建仓库">创建仓库</h2><h3 id="方式一：git-init">方式一：git init</h3><p>先找到找到合适位置的目录，进入该仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init #初始化该仓库</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">成功会提示初始化了一个空的仓库，并且出现分支</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在该文件夹内出现隐藏文件夹.git</span></span><br><span class="line"></span><br><span class="line">git init my-repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加了一个参数后，将指定my-repo为git仓库，而不是该目录</span></span><br></pre></td></tr></table></figure><h3 id="方式二：git-clone">方式二：git clone</h3><p>先在github上常见仓库，再使用git clone</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/keqiudi/keqiudi.github.io</span><br></pre></td></tr></table></figure><h2 id="工作区域和文件状态">工作区域和文件状态</h2><p>git本地数据管理分为三个区域：</p><ul><li><strong>工作区</strong>：英文名working directory，即资源管理器中看到的文件夹，实际操作的目录</li><li><strong>暂存区</strong>：英文名staging area/index，用于保存即将提交到git仓库的修改内容，git版本控制中重要区域</li><li><strong>本地仓库</strong>：英文local repository，通过git init创建的本地仓库，包含完整的项目历史和源数据</li></ul><p><strong>流程</strong>：</p><ul><li>修改工作区文件后，需要将他们添加到暂存区</li><li>再将暂存区中的修改提交到本地仓库中</li></ul><p>git文件状态分为四种：</p><ul><li><p><strong>未跟踪</strong>：新创建没有被git管理起来的文件</p></li><li><p><strong>未修改</strong>：已经被git管理的文件但文件内容没有被修改过</p></li><li><p><strong>已修改</strong>：已经被git管理的文件但文件内容被修改过，没有添加到暂存区的文件</p></li><li><p><strong>已暂存</strong>：已经被git管理的文件但文件内容被修改过，已经添加到暂存区的文件</p></li></ul><h2 id="添加提交文件">添加提交文件</h2><ul><li>查看当前仓库状态，查看分支、文件等等</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">红色文件代表未被跟踪状态，未进入暂存区</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绿色文件代表已经被添加到了暂存区</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意git不会将空文件夹纳入版本控制中，如果创建一个空文件夹再使用git status将不会有区别</span></span><br></pre></td></tr></table></figure><ul><li>添加文件到暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git add fileName</span><br><span class="line"></span><br><span class="line">git add *.txt # 所有以.txt结尾的文件</span><br><span class="line">git add . # 将所有未被跟踪的文件加入暂存区，根据.gitignore做过滤</span><br><span class="line">git add * # 将所有未被跟踪的文件加入暂存区，不根据.gitignore做过滤</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git ls-files # 查看暂存区中的文件内容</span><br><span class="line">git rm --cached &lt;file&gt;...# 将添加到暂存区的文件取消</span><br></pre></td></tr></table></figure><ul><li>提交文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交信息&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意git commit只会提交暂存区中的文件，不会提交工作区中的文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不加上-m参数将会进入交互式状态，默认使用vim编辑提交信息</span></span><br><span class="line"></span><br><span class="line">git commit -a -m &quot;提交信息&quot;</span><br><span class="line">git commit -am &quot;提交信息&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加上-a参数可以同时完成添加暂存和提交两个动作</span></span><br></pre></td></tr></table></figure><ul><li>查看提交记录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示ID,日期，提交者和邮箱</span></span><br><span class="line"></span><br><span class="line">git log --oneline # 查看简介的提交记录，只会显示版本ID和提交信息</span><br></pre></td></tr></table></figure><h2 id="回退版本">回退版本</h2><p>git reset命令用于回退版本,可以退回到之前某一个提交状态，有三种模式</p><ul><li>表示回退到某一个版本，并且保留工作区和暂存区的所有修改内容,即所有工作区和暂存区在回退版本之后的修改都会保留</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft 版本ID</span><br></pre></td></tr></table></figure><ul><li>表示回退到某一个版本，并且丢弃工作区和暂存区的所有修改内容，即所有在工作区和暂存区在回退版本之后的修改都不会保留，完全回到当时版本的工作区和暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">版本ID中 代表上一个版本</span></span><br><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><ul><li>表示回退到某一个版本，并且只保留工作区修改的内容，丢弃暂存区修改的内容，即暂存区在回退版本之后的修改都不会保留，而工作区会保留到最新版本的工作区内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed 版本ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不加参数时默认为mixed</span></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>一般只使用soft和mixed，谨慎使用hard，但若误操作也没关系，git中的命令是可以回溯的，当我们误操作的时候只需要使用git reflog命令查看操作历史记录，找到误操作之前的版本号，再使用git reset回退到这个版本就可以了</strong></p></div><h2 id="查看文件差异">查看文件差异</h2><p>git diff命令可以用于查看文件在工作区、暂存区、本地仓库之间的差异，也可以查看不同版本，不同分支中文件的差异。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">红色代表删除的内容，绿色是添加的内容</span></span><br><span class="line"></span><br><span class="line">git diff </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">无参数默认比较工作区和暂存区之间的差异内容</span></span><br><span class="line"></span><br><span class="line">git diff HEAD </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">HEAD参数表示工作区和版本库之间的差异</span></span><br><span class="line"></span><br><span class="line">git diff --cached</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cached比较暂存区和版本库的差异</span></span><br><span class="line"></span><br><span class="line">git diff ID1 ID2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较不同版本的差异时，只需要在后面加上比较的两次版本ID，就可以比较两次版本的差异内容</span></span><br><span class="line"></span><br><span class="line">git diff HEAD~ HEAD</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较当前版本和上一个版本的区别</span></span><br><span class="line"></span><br><span class="line">git diff HEAD~2 HEAD</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较当前版本和最新提交前2个版本的区别</span></span><br><span class="line"></span><br><span class="line">git diff HEAD~ HEAD file3.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只比较file3文件最新版本和上一个版本区别，没有则不显示</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>HEAD是Git中的一个非常重要的概念，指向分支最新提交结点，而HEAD~/HEAD^可以表示上一个版本，通常用于比较当前版本和上一个版本区别。我们还可以在HEAD波浪线后加上数字代表提交之前的几个版本</strong></p></div><h2 id="删除文件">删除文件</h2><p>从版本库中删除文件一共有两种方法:</p><ul><li>直接删除文件后提交</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm file1.txt # 只删除了工作区文件，未更新暂存区文件</span><br><span class="line"></span><br><span class="line">git add . #更新暂存区</span><br><span class="line">git ls-files #查看暂存区文件</span><br><span class="line"></span><br><span class="line">git commit -m &quot;commit&quot; #再次提交</span><br></pre></td></tr></table></figure><ul><li>使用git rm删除(更简单)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git rm file2.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将工作区和暂存区文件同时删除</span></span><br><span class="line"></span><br><span class="line">git rm --cached &lt;file&gt; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--cached参数，将文件从暂存区删除，但保留在当前工作区中</span></span><br><span class="line"></span><br><span class="line">git rm -r *</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">递归删除某个目录下的所有子目录和文件</span></span><br><span class="line"></span><br><span class="line">git commit -m &quot;commit&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意删除后不要忘记提交</span></span><br></pre></td></tr></table></figure><h2 id="gitignore文件">.gitignore文件</h2><p>在git中有个特殊文件，叫忽略文件，可以忽略掉一些不应该加入版本库中的文件，可以让我们的版本库体积更小，更干净</p><p>一般来说遵循下面的原则</p><ul><li>系统或者软件自动生成的文件</li><li>编译产生的中间文件和结果文件</li><li>运行时产生的日志文件、缓存文件、临时文件</li><li>涉及身份、密码、口令、密钥等敏感信息文件</li></ul><p>先创建.gitignore文件，在通过vim对.gitignore文件进行设置过滤文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore</span><br><span class="line"></span><br><span class="line">vim .gitignore</span><br></pre></td></tr></table></figure><p>假设下方为.gitignore文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">access.log #代表忽略access.log文件</span><br><span class="line"></span><br><span class="line">*.log # 代表忽略所有.log文件</span><br></pre></td></tr></table></figure><p>.gitignore文件还可以忽略文件夹内容，注意文件夹格式是以/结尾，才能正常忽略文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.log # 代表忽略所有.log文件</span><br><span class="line"></span><br><span class="line">temp/ # 代表忽略temp文件夹内容</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意.gitignore文件生效有一个前提，就是这个文件不能先添加到版本库中，若已经添加到版本库中.gitignore文件将不会生效</p></div><p><strong>.gitignore文件的匹配规则</strong>：</p><p><strong>从上到下逐行匹配，每行表示一个忽略模式</strong></p><p><a href="https://git-scm.com/docs/gitignore">Git - gitignore 文档 (git-scm.com)</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>空行或者以#开头的行会被git忽略。一般空行用于可读性分隔，#一般用于注释</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>使用标准的Blob模式匹配，例如：</span><br><span class="line">*通配任意个字符</span><br><span class="line">?匹配单个字符</span><br><span class="line"><span class="punctuation">[</span><span class="punctuation">]</span>表示匹配列表中的单个字符<span class="punctuation">,</span>例如<span class="punctuation">:</span><span class="punctuation">[</span>abc<span class="punctuation">]</span> 表示a/b/c</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>两个星号**表示匹配任意的中间目录</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>中括号可以使用短中线链接<span class="punctuation">,</span>比如<span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">0</span><span class="number">-9</span><span class="punctuation">]</span>表示任意一位数字<span class="punctuation">,</span><span class="punctuation">[</span>a-z<span class="punctuation">]</span>表示任意一位小写字母</span><br><span class="line"><span class="number">5.</span>!表示取反</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略所有的.a文件</span></span><br><span class="line">*.a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在第一条的基础上除去lib.a文件</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只忽略当前目录下的TODO文件，而不忽略且文件夹的TODO，因为有/表示当前目录</span></span><br><span class="line">/TODO</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略任意目录下名为TODO的文件夹</span></span><br><span class="line">TODO/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略 doc/hello.txt,但不忽略doc/temp/test.txt,因为指定的是doc/目录下的，而不是doc/temp/下的</span></span><br><span class="line">doc/*.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略所有doc/目录及其所有子目录下的/pdf文件</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><p>github上提供了各种常用语言的忽略文件的模板，在新建仓库时可以直接使用，也可以根据需要自己修改</p><p>以下为链接：</p><p><a href="https://github.com/github/gitignore">GitHub - github/gitignore: A collection of useful .gitignore templates</a></p><h2 id="SSH绑定git与github">SSH绑定git与github</h2><p>我们就一起完成 Git 和 GitHub 的绑定，体验通过 Git 向 GitHub 提交代码的能力。不过在这之前，我们需要先了解 SSh（安全外壳协议），因为在 GitHub 上，一般都是通过 SSH 来授权的，而且大多数 Git 服务器也会选择使用 SSH 公钥来进行授权，所以想要向 GitHub 提交代码，首先就得在 GitHub 上添加 SSH key配置。</p><h3 id="生成SSH-key">生成SSH key</h3><ol><li><p>输入ssh 查看本机是否安装ssh</p></li><li><p>输入ssh-keygen -t rsa -C “your_email”</p></li></ol><ul><li>表示我们指定 RSA 算法生成密钥，然后敲三次回车键，期间不需要输入密码，之后就就会生成两个文件，分别为id_rsa和id_rsa.pub，即密钥id_rsa和公钥id_rsa.pub. 对于这两个文件，其都为隐藏文件，默认生成在以下目录：<ul><li>Linux 系统：~/.ssh</li><li>Mac 系统：~/.ssh</li><li>Windows 系统：C:\Documents and Settings\username\.ssh</li><li>Windows 10 ThinkPad：C:\Users\think.ssh</li></ul></li></ul><p>密钥和公钥生成之后，我们要做的事情就是把公钥id_rsa.pub的内容添加到 GitHub，这样我们本地的密钥id_rsa和 GitHub 上的公钥id_rsa.pub才可以进行匹配，授权成功后，就可以向 GitHub 提交代码啦！</p><ol start="3"><li>添加 SSH key</li></ol><ul><li>进入github中的settings，再点击SSH and GPG Keys进入此子界面，然后点击New SSH key按钮：</li><li>将公钥id_rsa.pub的内容粘贴到Key处的位置（Titles的内容不填写也没事），然后点击Add SSH key 即可。</li></ul><ol start="4"><li>验证绑定是否成功</li></ol><p>在 Git Bash 中输入ssh -T git@github.com进行测试：</p><p><img src="https://pic4.zhimg.com/80/v2-aa1938b4970cd5ccddd82406f58aee83_720w.webp" alt="img"></p><p>结果即为Git 与 GitHub 绑定成功的标志。</p><h2 id="通过git将代码提交到github">通过git将代码提交到github</h2><h3 id="pull与push">pull与push</h3><p>push：该单词直译过来就是“推”的意思，如果我们本地的代码有了更新，为了保持本地与远程的代码同步，我们就需要把本地的代码推到远程的仓库，代码示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git push origin master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</span></span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此时指定默认主机后才能不加参数使用</span></span><br></pre></td></tr></table></figure><p>pull：该单词直译过来就是“拉”的意思，如果我们远程仓库的代码有了更新，同样为了保持本地与远程的代码同步，我们就需要把远程的代码拉到本地，代码示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里的仓库名称和分支名称可以省略，默认拉去别名为origin的main分支即</span></span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">git pull -u origin master</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>pull request它表示：如果我们fork了别人的项目（或者说代码），并对其进行了修改，想要把我们的代码合并到原始项目（或者说原始代码）中，我们就需要提交一个pull request，让原作者把我们的代码拉到 ta 的项目中，至少对于 ta 来说，我们都是属于远程端的。</p>   <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>一般情况下，我们在push操作之前都会先进行pull操作，这样不容易造成冲突。</p></div><h3 id="提交代码">提交代码</h3><p>对于向远处仓库（GitHub）提交代码分为两种情况：</p><p><code>第一种：</code></p><ol><li>本地没有 Git 仓库，这时我们就可以直接将远程仓库clone到本地。通过clone命令创建的本地仓库，其本身就是一个 Git 仓库了，不用我们再进行init初始化操作啦，而且自动关联远程仓库。我们只需要在这个仓库进行修改或者添加等操作，然后commit即可。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/guobinhit/mybatis-tutorial.git (仓库链接)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>将需要提交的文件复制到该仓库中</p></li><li><p>使用git status、git add、git commit -m &quot; &quot;、git log、git status</p></li><li><p>将本地仓库的内容push到远程仓库，输入git push origin master</p></li><li></li></ol> <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>在第一次向远程仓库提交代码的时候，需要输入账号及密码进行验证，验证成功后即可。</p></div><p><code>第二种</code></p><p>有本地Git 仓库，并且我们已经进行了多次commit操作。</p><ol><li>进入该仓库，git init初始化操作：</li><li>命令，关联远程仓库（在此，默认大家都知道如何获取远程仓库的地址），其中origin为远程仓库的名字：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/guobinhit/springmvc-tutorial.git</span><br><span class="line"></span><br><span class="line">git remote -v </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以查看关联分支和地址</span></span><br></pre></td></tr></table></figure><ol start="3"><li>输入git pull origin master命令，同步远程仓库和本地仓库：</li><li>再回到本地springmvc-tutorial仓库，看看我们是否已经把远程仓库的内容同步到了本地：</li><li>输入git add和git commit命令，将文件添加并提交到springmvc-tutorial仓库：</li><li>git push origin master命令，将本地仓库修改（或者添加）的内容提交到远程仓库：</li></ol><p>在这个例子中，我们将远程仓库命名为origin，本地仓库名为springmvc-tutorial，其实两者的名字咱们可以随意取，一般来说，我们习惯性将远程仓库命名为origin，不过在需要关联多个远程仓库的时候，就需要我们再取别的名字啦！</p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>在我们向远程仓库提交代码的时候，一定要先进行pull操作，再进行push操作，防止本地仓库与远程仓库不同步导致冲突的问题，尤其是第二种提交代码的情况，很容易就出现问题。</p></div><h2 id="GUI工具">GUI工具</h2><p>常用的</p><ul><li>github Desktop</li><li>GitKraken</li><li>Sourcetree</li></ul><h2 id="分支简介和基本操作">分支简介和基本操作</h2><p>我们可以将分支branch看做代码库中的不同版本，可以独立存在并且有自己的提交记录，分支非常适合团队协作和开发管理，比如多个程序员可以在自己的分支上进行开发工作，我们可以在分支上建立一个新问题的开发或者建立一个问题修复的分支来处理一些bug和缺陷，这样就可以让主线代码仓库处于稳定可用状态。而不会影响到其他功能的开发和测试，能够提高团队开发效率</p><ul><li>创建新分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;新分支名&gt;</span><br></pre></td></tr></table></figure><ul><li>删除分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;已经完成合并的分支&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">小d参数只能删除已经完成合并的分支</span></span><br><span class="line"></span><br><span class="line">git branch -D &lt;未合并的分支&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要删除未合并分支，需要用大D来强制删除分支</span></span><br></pre></td></tr></table></figure><ul><li>查看有哪些分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以查看到有哪些分支</span></span><br></pre></td></tr></table></figure><ul><li>切换到指定分支/恢复文件或目录状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;切换的分支名&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意git checkout可以在意外修改文件后，将文件恢复到修改之前的状态，这个时候分支名称和文件名称相同的就会出现歧义，git checkout命令会默认切换分支而不是恢复文件，下面是官网提供的命令用于专门切换分支</span></span><br><span class="line">git switch &lt;切换的分支名&gt;</span><br></pre></td></tr></table></figure><ul><li>合并分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;需要合并的分支名&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令将不同的分支合并到当前的分支中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">即合并到的目标分支为当前分支</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>查看分支图</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --oneline --decorate --all</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在命令行中可以用以上命令查看分支图，但是没有在git GUI中看着美观</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常使用<span class="built_in">alias</span>为该命令取别名来简化操作</span></span><br><span class="line">alias graph=&quot;git log --graph --oneline --decorate --all&quot;</span><br></pre></td></tr></table></figure><h2 id="解决分支合并冲突">解决分支合并冲突</h2><p>一般情况，**如果两个分支的修改内容没有冲突，git会自动完成合并。**但如果两个分支修改同一文件的同一行代码，那么git就不知道该保留哪个，所以需要我们手动来解决冲突。</p><p>当我们和并分支，输入git merge之后，提示存在合并冲突之后，会自动进入处理合并冲突状态，此时如果想<strong>取消该次合并</strong>只需要输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">即可打断本次合并</span></span><br></pre></td></tr></table></figure><p><strong>如果想继续合并，现在需要解决冲突</strong></p><ul><li><ol><li>我们先输入git status或git diff 来查看冲突位置</li></ol></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br><span class="line"></span><br><span class="line">--- a/main1.txt</span><br><span class="line">+++ b/main1.txt</span><br><span class="line">++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line"> +main</span><br><span class="line"> +这是在master中修改的内容</span><br><span class="line">++=======</span><br><span class="line">+ main1</span><br><span class="line">+ 这是在test中修改的内容</span><br><span class="line">++&gt;&gt;&gt;&gt;&gt;&gt;&gt; test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面中HEAD代表当前分支,<span class="built_in">test</span>代表想合并的分支，+代表添加的内容，main1.txt代表冲突的文件</span></span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>此时我们只需要再进入冲突的文件删除不想要的地方和保留想要的地方即可，同时把提示内容一并删除(+和&lt;和==等)</li></ol></li><li><ol start="3"><li>再git add . 和git commit 即可</li></ol></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>切记在每个分支修改内容后一定要记得add和commit，否则就会出现修改一同带入到切换到的分支的后果，导致两个分支中同一个文件内容出现同步修改</p></div><h2 id="回退和rebase">回退和rebase</h2><p>我们在删除了分支之后可以用命令将已经删除了的分支恢复到指定版本，命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;恢复的分支名称&gt; &lt;恢复版本的提交ID&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">该命令可以恢复已经合并后删除的分支，只需要-b参数，版本ID可以通过来查看</span></span><br><span class="line">git log --graph --oneline --decorate --all</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一般主分支用git reset恢复</span></span><br></pre></td></tr></table></figure><p>rebase叫做&quot;变基&quot;，会将当前所处分支变基到目标分支上，会将两分支<strong>共同祖先</strong>之后的内容变基到目标分支上，类似嫁接移植，故<strong>在不同分支用rebase会产生不同的变基结果</strong>，最终都会是一条分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;目标分支&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下是一个示例</span></span><br><span class="line">----------------</span><br><span class="line">rebase前</span><br><span class="line">----------------</span><br><span class="line">* 941b6c7 (HEAD -&gt; master) main:4</span><br><span class="line">| * bd5a88d (test) test:1</span><br><span class="line">|/</span><br><span class="line">* 51f1666 main:3</span><br><span class="line">* 0e7b89e main:2</span><br><span class="line">* 85c4410 main:1</span><br><span class="line">----------------</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">处于main分支下时执行</span></span><br><span class="line">git rebase test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这将会使main与<span class="built_in">test</span>分支共同祖先之后的内容全部移动到<span class="built_in">test</span>最新分支之后再合并成一条分支</span></span><br><span class="line">在rebase test之后变为</span><br><span class="line">----------------</span><br><span class="line">* 941b6c7 (HEAD -&gt; master) main:4</span><br><span class="line">* bd5a88d (test) test:1</span><br><span class="line">* 51f1666 main:3</span><br><span class="line">* 0e7b89e main:2</span><br><span class="line">* 85c4410 main:1</span><br><span class="line">----------------</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">处于<span class="built_in">test</span>分支下执行</span></span><br><span class="line">git rebase main</span><br><span class="line"></span><br><span class="line">在rebase test之后变为</span><br><span class="line">----------------</span><br><span class="line">* 1d1fee5 (HEAD -&gt; test) test:1</span><br><span class="line">* 941b6c7 (master) main:4</span><br><span class="line">* 51f1666 main:3</span><br><span class="line">* 0e7b89e main:2</span><br><span class="line">* 85c4410 main:1</span><br><span class="line">----------------</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>Merge</strong></p><p><strong>优点</strong>：不会破坏原来分支的提交历史，方便回溯和查看</p><p><strong>缺点</strong>：会产生额外提交结点，分支图较复杂</p><p><strong>Rebase</strong></p><p><strong>优点</strong>：不会新增额外提交记录(合并)，形成线性历史，比较直观和干净；</p><p><strong>缺点</strong>：会改变提交历史，改变了当前分支branch out的节点，<strong>应当避免在共享分支中使用，一般不会和共同开发的分支中使用</strong>，当确定只有自己在该分支开发时且希望提交历史更加清晰明了则推荐使用。</p></div><h2 id="标签">标签</h2><p>tag用于在开发阶段创建标签，某个阶段完成了创建一个版本，在开发中可以使用tag来指定软件的一个重要时期，比如版本号更新的时候可以创建一个v1.0，这样回顾的时候比较简单</p><ul><li>查看tag</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这样列出的tag是按照字母排序的，和创建时间没有关系，如果只是想查看某些tag的话可以加一些限定：</span></span><br><span class="line"></span><br><span class="line">git tag -l version1.*</span><br></pre></td></tr></table></figure><ul><li>创建tag</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git tag version 1.0  #也可以 git tag 1.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">带有信息的tag:</span></span><br><span class="line">git tag -a version1.0 -m &quot;first version&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用 -a （译注：取 annotated 的首字母）指定标签名字即可,而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明</span></span><br></pre></td></tr></table></figure><ul><li>删除tag</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;标签名字&gt;</span><br></pre></td></tr></table></figure><h2 id="分支命名和管理">分支命名和管理</h2><p><strong>分支命名</strong>：</p><ul><li>推荐使用带有意义的描述性名称来命名分支<ul><li>版本发布分支/tag示例：v1.0.0</li><li>功能分支示例：feature-login-page</li><li>修复分支示例：hotfix-#issueid-desc</li></ul></li></ul><p><strong>分支管理</strong>：</p><ul><li>定期合并已经成功验证的分支，及时删除已经合并的分支</li><li>保持合适的分支数量</li><li>为分支设置合适的管理权限</li></ul>]]></content>
    
    
    <summary type="html">git的使用</summary>
    
    
    
    <category term="github" scheme="https://www.thekqd.top/categories/github/"/>
    
    
    <category term="github" scheme="https://www.thekqd.top/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>服务器并发</title>
    <link href="https://www.thekqd.top/posts/11572ff3.html"/>
    <id>https://www.thekqd.top/posts/11572ff3.html</id>
    <published>2023-07-21T07:24:19.000Z</published>
    <updated>2023-07-21T07:42:28.695Z</updated>
    
    <content type="html"><![CDATA[<h1>1.单线程/进程</h1><p>在TCP通信过程中，服务器端启动之后可以同时和多个客户端建立连接，并进行网络通信，但是在介绍TCP通信流程的时候，提供的服务器代码却不能完成这样的需求，先简单的看一下之前的服务器代码的处理思路，再来分析代码中的弊端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            write(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中用到了三个会引起程序阻塞的函数，分别是：</p><ul><li><p>accept()：如果服务器端没有新客户端连接，阻塞当前进程/线程，如果检测到新连接解除阻塞，建立连接</p></li><li><p>read()：如果通信的套接字对应的读缓冲区没有数据，阻塞当前进程/线程，检测到数据解除阻塞，接收数据</p></li><li><p>write()：如果通信的套接字写缓冲区被写满了，阻塞当前进程/线程（这种情况比较少见）</p></li></ul><p>如果需要和发起新的连接请求的客户端建立连接，那么就必须在服务器端通过一个循环调用accept()函数，另外已经和服务器建立连接的客户端需要和服务器通信，发送数据时的阻塞可以忽略，当接收不到数据时程序也会被阻塞，这时候就会非常矛盾，被accept()阻塞就无法通信，被read()阻塞就无法和客户端建立新连接。因此得出一个结论，基于上述处理方式，在单线程/单进程场景下，服务器是无法处理多连接的，解决方案也有很多，常用的有三种：</p><ol><li>使用多线程实现</li><li>使用多进程实现</li><li>使用IO多路转接（复用）实现</li><li>使用IO多路转接 + 多线程实现</li></ol><h1>2.多线程并发</h1><p>多线程中的线程有两大类：主线程（父线程）和子线程，他们分别要在服务器端处理监听和通信流程。根据多进程的处理思路，就可以这样设计了：</p><ul><li>主线程<ul><li>负责监听，处理客户端的连接请求，也就是在父进程中循环调用accept()函数</li><li>创建子线程：建立一个新的连接，就创建一个新的子进程，让这个子进程和对应的客户端通信</li><li>回收子线程资源：由于回收需要调用阻塞函数，这样就会影响accept()，直接做<strong>线程分离</strong>即可。</li></ul></li><li>子线程：负责通信，基于主线程建立新连接之后得到的文件描述符，和对应的客户端完成数据的接收和发送。<ul><li>发送数据：send() / write()</li><li>发送数据：recv() / read()</li></ul></li></ul><p>在多线程版的服务器端程序中，多个线程共用同一个地址空间，有些数据是共享的，有些数据的独占的，下面来分析一些其中的一些细节：</p>   <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li><p>同一地址空间中的多个线程的栈空间是独占的</p></li><li><p>多个线程共享全局数据区，堆区，以及内核区的文件描述符等资源，因此需要注意数据覆盖问题，并且在多个线程访问共享资源的时候，还需要进行线程同步。</p></li></ul></div><p>多线程版TCP服务器示例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;                      <span class="comment">// 通信</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;               <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span>     <span class="comment">// 地址信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span> <span class="title">infos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">info</span> =</span> (<span class="keyword">struct</span> SockInfo*)arg;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> ret = read(info-&gt;fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端已经关闭连接...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;接收数据失败...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            write(info-&gt;fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于监听的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;          <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">8989</span>);        <span class="comment">// 字节序应该是网络字节序</span></span><br><span class="line">    addr.sin_addr.s_addr =  INADDR_ANY; <span class="comment">// == 0, 获取IP的操作交给了内核</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.设置监听</span></span><br><span class="line">    ret = listen(fd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 等待, 接受连接请求</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据初始化</span></span><br><span class="line">    <span class="type">int</span> max = <span class="keyword">sizeof</span>(infos) / <span class="keyword">sizeof</span>(infos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(&amp;infos[i], <span class="keyword">sizeof</span>(infos[i]));</span><br><span class="line">        infos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        infos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程监听, 子进程通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(infos[i].fd == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pinfo = &amp;infos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> connfd = accept(fd, (<span class="keyword">struct</span> sockaddr*)&amp;pinfo-&gt;addr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent thread, connfd: %d\n&quot;</span>, connfd);</span><br><span class="line">        <span class="keyword">if</span>(connfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pinfo-&gt;fd = connfd;</span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);  <span class="comment">// 监听</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ol><li><p>在编写多线程版并发服务器代码的时候，需要注意父子线程共用同一个地址空间中的文件描述符，因此每当在主线程中建立一个新的连接，都需要将得到文件描述符值保存起来，不能在同一变量上进行覆盖，这样做丢失了之前的文件描述符值也就不知道怎么和客户端通信了。</p></li><li><p>在上面示例代码中是将成功建立连接之后得到的用于通信的文件描述符值保存到了一个全局数组中，每个子线程需要和不同的客户端通信，需要的文件描述符值也就不一样，只要保证存储每个有效文件描述符值的变量对应不同的内存地址，在使用的时候就不会发生数据覆盖的现象，造成通信数据的混乱了。</p></li></ol></div><h1>3.多进程并发</h1>]]></content>
    
    
    <summary type="html">多线程/进程</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>线程池C++版</title>
    <link href="https://www.thekqd.top/posts/aa76cb12.html"/>
    <id>https://www.thekqd.top/posts/aa76cb12.html</id>
    <published>2023-07-18T14:50:42.000Z</published>
    <updated>2023-11-05T13:55:06.143Z</updated>
    
    <content type="html"><![CDATA[<h1>1.任务队列</h1><h2 id="类声明-Task-TaskQueue">类声明(Task,TaskQueue)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> C___PRACTICE_TASKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C___PRACTICE_TASKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> function = <span class="built_in">void</span>(*)(<span class="type">void</span>* arg);<span class="comment">//为一个函数指针类型取别名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>()&#123;</span><br><span class="line">        working = <span class="literal">nullptr</span>;</span><br><span class="line">        arg = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*无参构造*/</span></span><br><span class="line">    <span class="built_in">Task</span>(function working, <span class="type">void</span>* arg)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;working = working;</span><br><span class="line">        <span class="keyword">this</span>-&gt;arg = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*有参构造*/</span></span><br><span class="line">    function working;</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;Task&gt; taskQueue;<span class="comment">//任务队列,用容器实现</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span>  QueueLock;<span class="comment">//互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task&amp; task)</span></span>;</span><br><span class="line">    <span class="comment">/*添加任务*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(function working, <span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">/*addTask重载函数*/</span></span><br><span class="line">    <span class="function">Task <span class="title">takeTask</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*取出任务*/</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">getTaskSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> taskQueue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取任务队列大小*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//C___PRACTICE_TASKQUEUE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<span class='p red'>Task</span> 是任务类，里边有两个成员，分别是两个指针 <span class='p red'>void(*)(void*)</span>和 <span class='p red'>void*</span></p><p>另外一个类<span class='p red'>TaskQueue</span>是任务队列，提供了添加任务、取出任务、存储任务、获取任务个数、线程同步的功能。</p><h2 id="类定义">类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskQueue::<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;QueueLock, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">TaskQueue::~<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;QueueLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(Task&amp; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);<span class="comment">//此处如果资源已经被释放，就会发生段错误</span></span><br><span class="line">    taskQueue.<span class="built_in">push</span>(task);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(function working, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);</span><br><span class="line">    taskQueue.<span class="built_in">push</span>(<span class="built_in">Task</span>(working, arg));</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">TaskQueue::takeTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);</span><br><span class="line">    Task t;</span><br><span class="line">    <span class="keyword">if</span>(!taskQueue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        t = taskQueue.<span class="built_in">front</span>();<span class="comment">//取出队列头部元素</span></span><br><span class="line">        taskQueue.<span class="built_in">pop</span>();<span class="comment">//删除队列头部元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2.线程池</h1><h2 id="类声明-ThreadPool">类声明(ThreadPool)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> C___PRACTICE_THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C___PRACTICE_THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaskQueue* taskQueue = <span class="literal">nullptr</span>;<span class="comment">//任务队列</span></span><br><span class="line">    <span class="type">pthread_t</span> managerID;<span class="comment">//管理者线程id</span></span><br><span class="line">    <span class="type">pthread_t</span>* threadIDs;</span><br><span class="line">    <span class="type">int</span> minNum;<span class="comment">//最小线程数</span></span><br><span class="line">    <span class="type">int</span> maxNum;<span class="comment">//最大线程数</span></span><br><span class="line">    <span class="type">int</span> busyNum;<span class="comment">//忙线程数</span></span><br><span class="line">    <span class="type">int</span> liveNum;<span class="comment">//活着的线程数</span></span><br><span class="line">    <span class="type">int</span> exitNum;<span class="comment">//要销毁的线程数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> threadLock;<span class="comment">//锁住整个线程池</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> busyLock;<span class="comment">//单独锁住busyNum，提高效率</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;<span class="comment">//任务队列为空时阻塞，不为空时唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> shutdown;<span class="comment">//是否要销毁线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//工作线程函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//管理者线程函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadExit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> min,<span class="type">int</span> max);</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task task)</span></span>;</span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getBusyNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取忙线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getAliveNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取活着的线程数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//C___PRACTICE_THREADPOOL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类定义-2">类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_TIME 5<span class="comment">//默认管理者线程检测时间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_NUM 2<span class="comment">//一次添加3个线程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_NUM 2<span class="comment">//一次销毁3个线程</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">safe_delete_void_ptr</span><span class="params">(<span class="type">void</span>* &amp;target)</span></span>;</span><br><span class="line"></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> min, <span class="type">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">        taskQueue = <span class="built_in">new</span> (std::nothrow)TaskQueue;</span><br><span class="line">          <span class="comment">/*没有std::nothrow则if条件始终为false*/</span></span><br><span class="line">        <span class="keyword">if</span>(taskQueue == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;new taskQueue error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        threadIDs = <span class="built_in">new</span> (std::nothrow)<span class="type">pthread_t</span>[max];<span class="comment">//分配动态数组</span></span><br><span class="line"><span class="comment">/*没有std::nothrow则if条件始终为false*/</span></span><br><span class="line">        <span class="keyword">if</span>(threadIDs == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new threadIDs error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(threadIDs, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        minNum = min;</span><br><span class="line">        maxNum = max;</span><br><span class="line">        busyNum = <span class="number">0</span>;</span><br><span class="line">        liveNum = min;</span><br><span class="line">        exitNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;threadLock, <span class="literal">nullptr</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_mutex_init</span>(&amp;busyLock, <span class="literal">nullptr</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_cond_init</span>(&amp;notEmpty, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;init the lock or cond error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shutdown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 类的成员函数传递地址时失败报错:Reference to non-static member function must be called</span></span><br><span class="line"><span class="comment">         * 原因:类的成员函数不是静态时，函数没有地址，只有实例化之后才会有地址，所以不能传递地址</span></span><br><span class="line"><span class="comment">         * 两种解决方案:</span></span><br><span class="line"><span class="comment">         * 1.将成员函数改为静态函数</span></span><br><span class="line"><span class="comment">         * 2.将成员函数改为全局函数，独立于类之外（想要访问成员变量就必须加上友元函数）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;managerID, <span class="literal">nullptr</span>, manager, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;threadIDs[i], <span class="literal">nullptr</span>, worker, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//此处不返回将会导致之后的释放资源</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] threadIDs;</span><br><span class="line">        threadIDs = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="comment">//如果threadIDs不为空，释放内存</span></span><br><span class="line">    <span class="keyword">if</span>(taskQueue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> taskQueue;</span><br><span class="line">        taskQueue = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="comment">//如果taskQueue不为空，释放内存</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadPool::worker</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);<span class="comment">//传递的是(void*)this,所以要强制类型转换</span></span><br><span class="line">    <span class="comment">/*此处static_cast为C++的强制类型转换，也可用C中的(ThreadPool*)形式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 静态函数不能访问成员变量，所以必须传入该类的实例化对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        <span class="keyword">while</span>(pool-&gt;taskQueue-&gt;<span class="built_in">getTaskSize</span>()==<span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;thread &quot;</span>&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot; is waiting&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notEmpty, &amp;pool-&gt;threadLock);</span><br><span class="line">            <span class="comment">//如果任务队列为空，且线程池没有关闭，则等待</span></span><br><span class="line">            <span class="comment">//等待条件变量，会先解锁，等待被唤醒，再次拿到了这把锁</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*管理者销毁线程逻辑</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 唤醒后判断是否要销毁线程</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;exitNum &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pool-&gt;exitNum--;<span class="comment">//不能放在if里面，否则可能在产生新线程时，Num&gt;0,直接就被销毁了，不符合期望，故保证每次循环都减一</span></span><br><span class="line">                <span class="comment">/*限定当存活的线程个数大于最小个数时才销毁*/</span></span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum) &#123;</span><br><span class="line">                    pool-&gt;liveNum--;</span><br><span class="line">                    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//解锁</span></span><br><span class="line">                    pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;shutdown)<span class="comment">//如果线程池关闭，则线程全部退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//避免死锁</span></span><br><span class="line">            pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出任务工作</span></span><br><span class="line">        Task task = pool-&gt;taskQueue-&gt;<span class="built_in">takeTask</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处生产者不需要被唤醒了，任务队列可以无限大,即可以无限量的任务</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">        pool-&gt;busyNum++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; start working&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        task.<span class="built_in">working</span>(task.arg);<span class="comment">//执行任务</span></span><br><span class="line">        <span class="built_in">safe_delete_void_ptr</span>&lt;<span class="type">int</span>&gt;(task.arg);<span class="comment">//直接delete task.arg 有危险</span></span><br><span class="line">        task.arg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; end working&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">        pool-&gt;busyNum--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadPool::manager</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(CHECK_TIME);<span class="comment">//每隔3秒检测一次</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        <span class="type">size_t</span> queueSize = pool-&gt;taskQueue-&gt;<span class="built_in">getTaskSize</span>();<span class="comment">//取出任务个数</span></span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;<span class="comment">//取出存活线程个数</span></span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加线程规则</span></span><br><span class="line">        <span class="comment">//1.任务个数&gt;存活线程个数&amp;&amp;存活线程个数&lt;最大线程个数时，创建线程</span></span><br><span class="line">        <span class="keyword">if</span>(queueSize&gt;liveNum&amp;&amp;liveNum&lt;pool-&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*for循环三个条件</span></span><br><span class="line"><span class="comment">             * 1.遍历线程id</span></span><br><span class="line"><span class="comment">             * 2.counter&lt;ADD_NUM</span></span><br><span class="line"><span class="comment">             * 3.在存活线程个数小于最大线程个数时才添加*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pool-&gt;maxNum&amp;&amp;counter&lt;ADD_NUM&amp;&amp;pool-&gt;liveNum&lt;pool-&gt;maxNum;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到空闲的线程id，创建线程</span></span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threadIDs[i]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">pthread_create</span>(&amp;pool-&gt;threadIDs[i],<span class="literal">nullptr</span>,worker,pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//销毁线程规则</span></span><br><span class="line">        <span class="comment">//1.忙线程*2&lt;存活线程&amp;&amp;存活线程&gt;最小线程个数时，销毁线程</span></span><br><span class="line">        <span class="keyword">if</span>(busyNum*<span class="number">2</span>&lt;liveNum&amp;&amp;liveNum&gt;pool-&gt;minNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">            pool-&gt;exitNum = EXIT_NUM;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">            <span class="comment">//唤醒线程池中所有的线程，让他们自己执行，判断是否退出</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;EXIT_NUM;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadExit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*使线程退出时线程id归0*/</span></span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="built_in">pthread_self</span>();<span class="comment">//获取当前线程的id</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(threadIDs[i] == tid)</span><br><span class="line">        &#123;</span><br><span class="line">            threadIDs[i] = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;threadExit() called, threadID: &quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot; exiting...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);<span class="comment">//C的函数，此处不用nullptr，而是用NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::addTask</span><span class="params">(Task task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处不用判断任务队列是否满，因为任务队列可以无限大</span></span><br><span class="line">    <span class="keyword">if</span>(shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="comment">//如果线程池关闭，则不添加任务</span></span><br><span class="line"></span><br><span class="line">    taskQueue-&gt;<span class="built_in">addTask</span>(task);<span class="comment">//添加任务,此时不用上锁原因，因为addTask中已经上锁了</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);<span class="comment">//唤醒线程池中的消费者线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ThreadPool::getBusyNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用busyNum自己的锁，提高效率</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;busyLock);</span><br><span class="line">    <span class="type">int</span> busyNum = <span class="keyword">this</span>-&gt;busyNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;busyLock);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ThreadPool::getAliveNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用线程池的锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;threadLock);</span><br><span class="line">    <span class="type">int</span> liveNum = <span class="keyword">this</span>-&gt;liveNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;threadLock);</span><br><span class="line">    <span class="keyword">return</span> liveNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shutdown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(<span class="keyword">this</span>-&gt;managerID, <span class="literal">nullptr</span>);<span class="comment">//等待管理者线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;liveNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);<span class="comment">//唤醒所有线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;threadLock);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;busyLock);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;notEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(taskQueue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> taskQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] threadIDs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_delete_void_ptr</span><span class="params">(<span class="type">void</span>* &amp;target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target)</span><br><span class="line">    &#123;</span><br><span class="line">        T* temp = <span class="built_in">static_cast</span>&lt;T*&gt;(target);</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line">        target = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="遇到的问题">遇到的问题</h3><div class="tip warning faa-horizontal animated"><p>注意25行用new分配内存C++中，new操作符默认不会返回NULL，而是会在分配内存失败时抛出一个std::bad_alloc异常。这样做的好处是，你不需要在每次使用new操作符后检查返回值是否为NULL，而是可以用try/catch语句统一处理异常。如果你想让new操作符在分配内存失败时返回NULL，而不是抛出异常，你可以使用std::nothrow参数</p></div><p>解决方案:</p><ul><li>try/catch语句统一处理异常</li><li>std::nothrow参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.第一种</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            taskQueue = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (std::bad_alloc &amp;e) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new taskQueue error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadIDs = <span class="keyword">new</span> <span class="type">pthread_t</span>[max];<span class="comment">//分配动态数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (std::bad_alloc &amp;e) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new threadIDs error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种，见上方代码中使用方法,25行</span></span><br></pre></td></tr></table></figure><div class="tip warning faa-horizontal animated"><p>注意这里133行代码，C++中不能用delete直接删除一个void*指针，因为delete需要调用被删除对象的析构函数，而void指针没有类型信息，所以无法确定调用哪个析构函数。这样做会导致未定义行为，可能会出现崩溃或内存泄漏。你必须在delete之前把void指针转换回它原来的类型，才能正确地释放内存。</p></div><ul><li>解决方案一：使用模板定义内联函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">safe_delete_void_ptr</span><span class="params">(<span class="type">void</span>* &amp;target)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_delete_void_ptr</span><span class="params">(<span class="type">void</span>* &amp;target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target)</span><br><span class="line">    &#123;</span><br><span class="line">        T* temp = <span class="built_in">static_cast</span>&lt;T*&gt;(target);</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line">        target = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//</span></span><br></pre></td></tr></table></figure><p>[ C++指针编程你要小心的陷阱——如何优雅的释放指针void*_c++释放void<em>指针_二流小宝的博客-CSDN博客](<a href="https://blog.csdn.net/SweetTool/article/details/77688337?ops_request_misc=%7B%22request%5Fid%22%3A%22168977949416800222881353%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168977949416800222881353&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-77688337-null-null.142%5Ev90%5Einsert_down28v1,239%5Ev2%5Einsert_chatgpt&amp;utm_term=c%2B%2B">https://blog.csdn.net/SweetTool/article/details/77688337?ops_request_misc={&quot;request_id&quot;%3A&quot;168977949416800222881353&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334..&quot;}&amp;request_id=168977949416800222881353&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-77688337-null-null.142^v90^insert_down28v1,239^v2^insert_chatgpt&amp;utm_term=c%2B%2B</a> delete void</em> 指针&amp;spm=1018.2226.3001.4187)</p><ul><li>解决方案二：用模板类</li></ul><h1>3.修改为模板类处理指针释放问题</h1><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">TaskQueue.h</button></li><li class="tab"><button type="button" data-href="#分栏-2">TaskQueue.cpp</button></li><li class="tab"><button type="button" data-href="#分栏-3">ThreadPool.h</button></li><li class="tab"><button type="button" data-href="#分栏-4">ThreadPool.cpp</button></li><li class="tab"><button type="button" data-href="#分栏-5">test.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> C___PRACTICE_TASKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C___PRACTICE_TASKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> function = <span class="built_in">void</span>(*)(<span class="type">void</span>* arg);<span class="comment">//为一个函数指针类型取别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//含有模板类的函数或类都要加这个</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>&lt;T&gt;()&#123;</span><br><span class="line">        working = <span class="literal">nullptr</span>;</span><br><span class="line">        arg = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*无参构造*/</span></span><br><span class="line">    <span class="built_in">Task</span>&lt;T&gt;(function working, <span class="type">void</span>* arg)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;working = working;</span><br><span class="line">        <span class="keyword">this</span>-&gt;arg = (T*)arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*有参构造*/</span></span><br><span class="line">    function working;</span><br><span class="line">    T* arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;Task&lt;T&gt;&gt; taskQueue;<span class="comment">//任务队列,用容器实现</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span>  QueueLock;<span class="comment">//互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task&lt;T&gt; task)</span></span>;</span><br><span class="line">    <span class="comment">/*添加任务*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(function working, <span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">/*addtask重载函数*/</span></span><br><span class="line">    <span class="function">Task&lt;T&gt; <span class="title">takeTask</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*取出任务*/</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">getTaskSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> taskQueue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取任务队列大小*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//C___PRACTICE_TASKQUEUE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">TaskQueue&lt;T&gt;::<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;QueueLock, <span class="literal">nullptr</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//模板类前面都要加这个</span></span><br><span class="line">TaskQueue&lt;T&gt;::~<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;QueueLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> TaskQueue&lt;T&gt;::<span class="built_in">addTask</span>(Task&lt;T&gt; task)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);<span class="comment">//此处如果资源已经被释放，就会发生段错误</span></span><br><span class="line">    taskQueue.<span class="built_in">push</span>(task);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> TaskQueue&lt;T&gt;::<span class="built_in">addTask</span>(function working, <span class="type">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);</span><br><span class="line">    taskQueue.<span class="built_in">push</span>(<span class="built_in">Task</span>&lt;T&gt;(working, arg));</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Task&lt;T&gt; TaskQueue&lt;T&gt;::<span class="built_in">takeTask</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);</span><br><span class="line">    Task&lt;T&gt; t;</span><br><span class="line">    <span class="keyword">if</span>(!taskQueue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      t = taskQueue.<span class="built_in">front</span>();<span class="comment">//取出队列头部元素</span></span><br><span class="line">      taskQueue.<span class="built_in">pop</span>();<span class="comment">//删除队列头部元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> C___PRACTICE_THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C___PRACTICE_THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.cpp&quot;</span></span></span><br><span class="line"><span class="comment">/*特殊:</span></span><br><span class="line"><span class="comment"> * 当有类模板时,类模板的声明和定义分开写时，需要包含头文件和源文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    TaskQueue&lt;T&gt;* taskQueue;<span class="comment">//任务队列</span></span><br><span class="line">    <span class="type">pthread_t</span> managerID;<span class="comment">//管理者线程id</span></span><br><span class="line">    <span class="type">pthread_t</span>* threadIDs;</span><br><span class="line">    <span class="type">int</span> minNum;<span class="comment">//最小线程数</span></span><br><span class="line">    <span class="type">int</span> maxNum;<span class="comment">//最大线程数</span></span><br><span class="line">    <span class="type">int</span> busyNum;<span class="comment">//忙线程数</span></span><br><span class="line">    <span class="type">int</span> liveNum;<span class="comment">//活着的线程数</span></span><br><span class="line">    <span class="type">int</span> exitNum;<span class="comment">//要销毁的线程数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> threadLock;<span class="comment">//锁住整个线程池</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> busyLock;<span class="comment">//单独锁住busyNum，提高效率</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;<span class="comment">//任务队列为空时阻塞，不为空时唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> shutdown;<span class="comment">//是否要销毁线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//工作线程函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//管理者线程函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadExit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> min,<span class="type">int</span> max);</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task&lt;T&gt; task)</span></span>;</span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getBusyNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取忙线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getAliveNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取活着的线程数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//C___PRACTICE_THREADPOOL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_TIME 5<span class="comment">//默认管理者线程检测时间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_NUM 2<span class="comment">//一次添加3个线程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_NUM 2<span class="comment">//一次销毁3个线程</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ThreadPool&lt;T&gt;::<span class="built_in">ThreadPool</span>(<span class="type">int</span> min, <span class="type">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        taskQueue = <span class="keyword">new</span> TaskQueue&lt;T&gt;;</span><br><span class="line">        <span class="keyword">if</span>(taskQueue == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new taskQueue error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threadIDs = <span class="keyword">new</span> <span class="type">pthread_t</span>[max];<span class="comment">//分配动态数组</span></span><br><span class="line">        <span class="keyword">if</span>(threadIDs == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new threadIDs error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(threadIDs, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        minNum = min;</span><br><span class="line">        maxNum = max;</span><br><span class="line">        busyNum = <span class="number">0</span>;</span><br><span class="line">        liveNum = min;</span><br><span class="line">        exitNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;threadLock, <span class="literal">nullptr</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_mutex_init</span>(&amp;busyLock, <span class="literal">nullptr</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_cond_init</span>(&amp;notEmpty, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;init the lock or cond error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shutdown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 类的成员函数传递地址时失败报错:Reference to non-static member function must be called</span></span><br><span class="line"><span class="comment">         * 原因:类的成员函数不是静态时，函数没有地址，只有实例化之后才会有地址，所以不能传递地址</span></span><br><span class="line"><span class="comment">         * 两种解决方案:</span></span><br><span class="line"><span class="comment">         * 1.将成员函数改为静态函数</span></span><br><span class="line"><span class="comment">         * 2.将成员函数改为全局函数，独立于类之外（想要访问成员变量就必须加上友元函数）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">         <span class="built_in">pthread_create</span>(&amp;managerID, <span class="literal">nullptr</span>, manager, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;threadIDs[i], <span class="literal">nullptr</span>, worker, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//此处不返回将会导致之后的释放资源</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] threadIDs;</span><br><span class="line">        threadIDs = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="comment">//如果threadIDs不为空，释放内存</span></span><br><span class="line">    <span class="keyword">if</span>(taskQueue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> taskQueue;</span><br><span class="line">        taskQueue = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="comment">//如果taskQueue不为空，释放内存</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* ThreadPool&lt;T&gt;::<span class="built_in">worker</span>(<span class="type">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">auto</span> pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);<span class="comment">//传递的是(void*)this,所以要强制类型转换</span></span><br><span class="line">     <span class="comment">/*此处为C++的强制类型转换，也可用C中的(ThreadPool*)</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * 静态函数不能访问成员变量，所以必须传入该类的实例化对象</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">         <span class="keyword">while</span>(pool-&gt;taskQueue-&gt;<span class="built_in">getTaskSize</span>()==<span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">         &#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;thread &quot;</span>&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot; is waiting&quot;</span>&lt;&lt;endl;</span><br><span class="line">             <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notEmpty, &amp;pool-&gt;threadLock);</span><br><span class="line">             <span class="comment">//如果任务队列为空，且线程池没有关闭，则等待</span></span><br><span class="line">             <span class="comment">//等待条件变量，会先解锁，等待被唤醒，再次拿到了这把锁</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">/*管理者销毁线程逻辑</span></span><br><span class="line"><span class="comment">              *</span></span><br><span class="line"><span class="comment">              * 唤醒后判断是否要销毁线程</span></span><br><span class="line"><span class="comment">              * */</span></span><br><span class="line">             <span class="keyword">if</span> (pool-&gt;exitNum &gt; <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 pool-&gt;exitNum--;<span class="comment">//不能放在if里面，否则可能在产生新线程时，Num&gt;0,直接就被销毁了，不符合期望，故保证每次循环都减一</span></span><br><span class="line">                 <span class="comment">/*限定当存活的线程个数大于最小个数时才销毁*/</span></span><br><span class="line">                 <span class="keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum) &#123;</span><br><span class="line">                     pool-&gt;liveNum--;</span><br><span class="line">                     <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//解锁</span></span><br><span class="line">                     pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(pool-&gt;shutdown)<span class="comment">//如果线程池关闭，则线程全部退出</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//避免死锁</span></span><br><span class="line">                 pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//取出任务工作</span></span><br><span class="line">             Task task = pool-&gt;taskQueue-&gt;<span class="built_in">takeTask</span>();</span><br><span class="line"></span><br><span class="line">             <span class="comment">//此处生产者不需要被唤醒了，任务队列可以无限大,即可以无限量的任务</span></span><br><span class="line">             <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line">             <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">             pool-&gt;busyNum++;</span><br><span class="line">             <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; start working&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             task.<span class="built_in">working</span>(task.arg);<span class="comment">//执行任务</span></span><br><span class="line">             <span class="keyword">delete</span> task.arg;<span class="comment">//释放参数资源</span></span><br><span class="line">             task.arg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; end working&quot;</span> &lt;&lt; endl;</span><br><span class="line">             <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">             pool-&gt;busyNum--;</span><br><span class="line">             <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* ThreadPool&lt;T&gt;::<span class="built_in">manager</span>(<span class="type">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(CHECK_TIME);<span class="comment">//每隔3秒检测一次</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        <span class="type">size_t</span> queueSize = pool-&gt;taskQueue-&gt;<span class="built_in">getTaskSize</span>();<span class="comment">//取出任务个数</span></span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;<span class="comment">//取出存活线程个数</span></span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加线程规则</span></span><br><span class="line">        <span class="comment">//1.任务个数&gt;存活线程个数&amp;&amp;存活线程个数&lt;最大线程个数时，创建线程</span></span><br><span class="line">        <span class="keyword">if</span>(queueSize&gt;liveNum&amp;&amp;liveNum&lt;pool-&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*for循环三个条件</span></span><br><span class="line"><span class="comment">             * 1.遍历线程id</span></span><br><span class="line"><span class="comment">             * 2.counter&lt;ADD_NUM</span></span><br><span class="line"><span class="comment">             * 3.在存活线程个数小于最大线程个数时才添加*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pool-&gt;maxNum&amp;&amp;counter&lt;ADD_NUM&amp;&amp;pool-&gt;liveNum&lt;pool-&gt;maxNum;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到空闲的线程id，创建线程</span></span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threadIDs[i]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">pthread_create</span>(&amp;pool-&gt;threadIDs[i],<span class="literal">nullptr</span>,worker,pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//销毁线程规则</span></span><br><span class="line">        <span class="comment">//1.忙线程*2&lt;存活线程&amp;&amp;存活线程&gt;最小线程个数时，销毁线程</span></span><br><span class="line">        <span class="keyword">if</span>(busyNum*<span class="number">2</span>&lt;liveNum&amp;&amp;liveNum&gt;pool-&gt;minNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">            pool-&gt;exitNum = EXIT_NUM;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">            <span class="comment">//唤醒线程池中所有的线程，让他们自己执行，判断是否退出</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;EXIT_NUM;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ThreadPool&lt;T&gt;::<span class="built_in">threadExit</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*使线程退出时线程id归0*/</span></span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="built_in">pthread_self</span>();<span class="comment">//获取当前线程的id</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(threadIDs[i] == tid)</span><br><span class="line">        &#123;</span><br><span class="line">            threadIDs[i] = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;threadExit() called, threadID: &quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot; exiting...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);<span class="comment">//C的函数，此处不用nullptr，而是用NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ThreadPool&lt;T&gt;::<span class="built_in">addTask</span>(Task&lt;T&gt; task)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处不用判断任务队列是否满，因为任务队列可以无限大</span></span><br><span class="line">    <span class="keyword">if</span>(shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="comment">//如果线程池关闭，则不添加任务</span></span><br><span class="line"></span><br><span class="line">    taskQueue-&gt;<span class="built_in">addTask</span>(task);<span class="comment">//添加任务,此时不用上锁原因，因为addTask中已经上锁了</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);<span class="comment">//唤醒线程池中的消费者线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> ThreadPool&lt;T&gt;::<span class="built_in">getBusyNumber</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用busyNum自己的锁，提高效率</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;busyLock);</span><br><span class="line">    <span class="type">int</span> busyNum = <span class="keyword">this</span>-&gt;busyNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;busyLock);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> ThreadPool&lt;T&gt;::<span class="built_in">getAliveNumber</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用线程池的锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;threadLock);</span><br><span class="line">    <span class="type">int</span> liveNum = <span class="keyword">this</span>-&gt;liveNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;threadLock);</span><br><span class="line">    <span class="keyword">return</span> liveNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ThreadPool&lt;T&gt;::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shutdown = <span class="literal">true</span>;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(<span class="keyword">this</span>-&gt;managerID, <span class="literal">nullptr</span>);<span class="comment">//等待管理者线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;liveNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);<span class="comment">//唤醒所有线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;threadLock);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;busyLock);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;notEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(taskQueue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> taskQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] threadIDs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ThreadPool.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span>*)arg;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; is working, number = &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadPool&lt;<span class="type">int</span>&gt; <span class="title">pool</span><span class="params">(<span class="number">3</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>*num = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//分配空间</span></span><br><span class="line">        *num = i+<span class="number">100</span>;</span><br><span class="line">        pool.<span class="built_in">addTask</span>(<span class="built_in">Task</span>&lt;<span class="type">int</span>&gt;(working, num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tip warning faa-horizontal animated"><p>特殊:当有类模板时,类模板的声明和定义分开写时，需要包含头文件和源文件，否则会报找不到定义的错误</p></div><div class="tag link"><a class="link-card" title="线程池C++版" href="https://keqiudi.github.io/posts/de7c53fe.html"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">线程池C++版</p><p class="url">https://keqiudi.github.io/posts/de7c53fe.html</p></div></a></div>]]></content>
    
    
    <summary type="html">线程池C++版</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>线程池C语言版</title>
    <link href="https://www.thekqd.top/posts/de7c53fe.html"/>
    <id>https://www.thekqd.top/posts/de7c53fe.html</id>
    <published>2023-07-16T11:14:40.000Z</published>
    <updated>2023-07-18T15:37:45.046Z</updated>
    
    <content type="html"><![CDATA[<h1>1.线程池原理</h1><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p><p><strong>线程池</strong>是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）, 则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p><p>在各个编程语言的语种中都有<strong>线程池</strong>的概念，并且很多语言中直接提供了线程池，作为程序猿直接使用就可以了，下面给大家介绍一下<strong>线程池</strong>的实现原理：</p><p><strong>线程池的组成主要分为 3 个部分，这三部分配合工作就可以得到一个完整的线程池：</strong></p><ol><li><p><strong>任务队列，存储需要处理的任务，由工作的线程来处理这些任务</strong></p><ul><li>通过线程池提供的 API 函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除</li><li>已处理的任务会被从任务队列中删除</li><li>线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程</li></ul></li><li><p><strong>工作的线程（任务队列任务的消费者） ，N个</strong></p><ul><li>线程池中维护了一定数量的工作线程，他们的作用是是不停的读任务队列，从里边取出任务并处理</li><li>工作的线程相当于是任务队列的消费者角色，</li><li>如果任务队列为空，工作的线程将会被阻塞 (使用条件变量 / 信号量阻塞)</li><li>如果阻塞之后有了新的任务，由生产者将阻塞解除，工作线程开始工作</li></ul></li><li><p><strong>管理者线程（不处理任务队列中的任务），1个</strong></p></li></ol><ul><li><ul><li>它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测</li><li>当任务过多的时候，可以适当的创建一些新的工作线程</li><li>当任务过少的时候，可以适当的销毁一些工作的线程</li></ul></li></ul><h1>2.任务队列(Task)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">void</span>* arg);</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125;Task;</span><br></pre></td></tr></table></figure><h1>3.线程池定义(ThreadPool)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    Task* taskQ;</span><br><span class="line">    <span class="type">int</span> queueCapacity;  <span class="comment">// 容量</span></span><br><span class="line">    <span class="type">int</span> queueSize;      <span class="comment">// 当前任务个数</span></span><br><span class="line">    <span class="type">int</span> queueFront;     <span class="comment">// 队头 -&gt; 取数据</span></span><br><span class="line">    <span class="type">int</span> queueRear;      <span class="comment">// 队尾 -&gt; 放数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> managerID;    <span class="comment">// 管理者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span> *threadIDs;   <span class="comment">// 工作的线程ID</span></span><br><span class="line">    <span class="type">int</span> minNum;             <span class="comment">// 最小线程数量</span></span><br><span class="line">    <span class="type">int</span> maxNum;             <span class="comment">// 最大线程数量</span></span><br><span class="line">    <span class="type">int</span> busyNum;            <span class="comment">// 忙的线程的个数</span></span><br><span class="line">    <span class="type">int</span> liveNum;            <span class="comment">// 存活的线程的个数</span></span><br><span class="line">    <span class="type">int</span> exitNum;            <span class="comment">// 要销毁的线程个数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexPool;  <span class="comment">// 锁整个的线程池</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexBusy;  <span class="comment">// 锁busyNum变量</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notFull;     <span class="comment">// 任务队列是不是满了</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;    <span class="comment">// 任务队列是不是空了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> shutdown;           <span class="comment">// 是不是要销毁线程池, 销毁为1, 不销毁为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>4.头文件声明(ThreadPool.h)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span> <span class="title">ThreadPool</span>;</span></span><br><span class="line"><span class="comment">// 创建线程池并初始化</span></span><br><span class="line">ThreadPool *<span class="title function_">threadPoolCreate</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queueSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁线程池</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolDestroy</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池添加任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadPoolAdd</span><span class="params">(ThreadPool* pool, <span class="type">void</span>(*func)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程池中工作的线程的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolBusyNum</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程池中活着的线程的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolAliveNum</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////</span></span><br><span class="line"><span class="comment">// 工作的线程(消费者线程)任务函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span>;</span><br><span class="line"><span class="comment">// 管理者线程任务函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">manager</span><span class="params">(<span class="type">void</span>* arg)</span>;</span><br><span class="line"><span class="comment">// 单个线程退出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadExit</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// _THREADPOOL_H</span></span></span><br></pre></td></tr></table></figure><h1>5.源文件定义(ThreadPool.c)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool* <span class="title function_">threadPoolCreate</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queueSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadPool));</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadpool fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool-&gt;threadIDs = (<span class="type">pthread_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threadIDs == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadIDs fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;threadIDs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        pool-&gt;minNum = min;</span><br><span class="line">        pool-&gt;maxNum = max;</span><br><span class="line">        pool-&gt;busyNum = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;liveNum = min;    <span class="comment">// 和最小个数相等</span></span><br><span class="line">        pool-&gt;exitNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;pool-&gt;mutexPool, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_mutex_init(&amp;pool-&gt;mutexBusy, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_cond_init(&amp;pool-&gt;notEmpty, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_cond_init(&amp;pool-&gt;notFull, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mutex or condition init fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务队列</span></span><br><span class="line">        pool-&gt;taskQ = (Task*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Task) * queueSize);</span><br><span class="line">        pool-&gt;queueCapacity = queueSize;</span><br><span class="line">        pool-&gt;queueSize = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueFront = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueRear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pool-&gt;shutdown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        pthread_create(&amp;pool-&gt;managerID, <span class="literal">NULL</span>, manager, pool);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_create(&amp;pool-&gt;threadIDs[i], <span class="literal">NULL</span>, worker, pool);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (pool &amp;&amp; pool-&gt;threadIDs) <span class="built_in">free</span>(pool-&gt;threadIDs);</span><br><span class="line">    <span class="keyword">if</span> (pool &amp;&amp; pool-&gt;taskQ) <span class="built_in">free</span>(pool-&gt;taskQ);</span><br><span class="line">    <span class="keyword">if</span> (pool) <span class="built_in">free</span>(pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolDestroy</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    pool-&gt;shutdown = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 阻塞回收管理者线程</span></span><br><span class="line">    pthread_join(pool-&gt;managerID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 唤醒阻塞的消费者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;liveNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放堆内存</span></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;taskQ)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;taskQ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threadIDs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;mutexPool);</span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;notEmpty);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;notFull);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadPoolAdd</span><span class="params">(ThreadPool* pool, <span class="type">void</span>(*func)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">while</span> (pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞生产者线程</span></span><br><span class="line">        pthread_cond_wait(&amp;pool-&gt;notFull, &amp;pool-&gt;mutexPool);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    pool-&gt;taskQ[pool-&gt;queueRear].function = func;</span><br><span class="line">    pool-&gt;taskQ[pool-&gt;queueRear].arg = arg;</span><br><span class="line">    pool-&gt;queueRear = (pool-&gt;queueRear + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">    pool-&gt;queueSize++;</span><br><span class="line"></span><br><span class="line">    pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolBusyNum</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolAliveNum</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="type">int</span> aliveNum = pool-&gt;liveNum;</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> aliveNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">// 当前任务队列是否为空</span></span><br><span class="line">        <span class="keyword">while</span> (pool-&gt;queueSize == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 阻塞工作线程</span></span><br><span class="line">            pthread_cond_wait(&amp;pool-&gt;notEmpty, &amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是不是要销毁线程</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;exitNum &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pool-&gt;exitNum--;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    pool-&gt;liveNum--;</span><br><span class="line">                    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">                    threadExit(pool);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断线程池是否被关闭了</span></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            threadExit(pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从任务队列中取出一个任务</span></span><br><span class="line">        Task task;</span><br><span class="line">        task.function = pool-&gt;taskQ[pool-&gt;queueFront].function;</span><br><span class="line">        task.arg = pool-&gt;taskQ[pool-&gt;queueFront].arg;</span><br><span class="line">        <span class="comment">// 移动头结点</span></span><br><span class="line">        pool-&gt;queueFront = (pool-&gt;queueFront + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">        pool-&gt;queueSize--;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_cond_signal(&amp;pool-&gt;notFull);</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %ld start working...\n&quot;</span>, pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;busyNum++;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        task.function(task.arg);</span><br><span class="line">        <span class="built_in">free</span>(task.arg);</span><br><span class="line">        task.arg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %ld end working...\n&quot;</span>, pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;busyNum--;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)arg;</span><br><span class="line">    <span class="keyword">while</span> (!pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每隔3s检测一次</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出线程池中任务的数量和当前线程的数量</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="type">int</span> queueSize = pool-&gt;queueSize;</span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出忙的线程的数量</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加线程</span></span><br><span class="line">        <span class="comment">// 任务的个数&gt;存活的线程个数 &amp;&amp; 存活的线程数&lt;最大线程数</span></span><br><span class="line">        <span class="keyword">if</span> (queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;maxNum &amp;&amp; counter &lt; NUMBER</span><br><span class="line">                &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;threadIDs[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    pthread_create(&amp;pool-&gt;threadIDs[i], <span class="literal">NULL</span>, worker, pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 销毁线程</span></span><br><span class="line">        <span class="comment">// 忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程&gt;最小线程数</span></span><br><span class="line">        <span class="keyword">if</span> (busyNum * <span class="number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;exitNum = NUMBER;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="comment">// 让工作的线程自杀</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadExit</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;maxNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threadIDs[i] == tid)</span><br><span class="line">        &#123;</span><br><span class="line">            pool-&gt;threadIDs[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;threadExit() called, %ld exiting...\n&quot;</span>, tid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>6.测试代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">taskFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread %ld is working, number = %d\n&quot;</span>,</span><br><span class="line">        pthread_self(), num);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    ThreadPool* pool = threadPoolCreate(<span class="number">3</span>, <span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>* num = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *num = i + <span class="number">100</span>;</span><br><span class="line">        threadPoolAdd(pool, taskFunc, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    threadPoolDestroy(pool);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tag link"><a class="link-card" title="线程池C++版" href="https://keqiudi.github.io/posts/aa76cb12.html"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">线程池C++版</p><p class="url">https://keqiudi.github.io/posts/aa76cb12.html</p></div></a></div>]]></content>
    
    
    <summary type="html">线程池C语言版</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>线程同步</title>
    <link href="https://www.thekqd.top/posts/895e9db.html"/>
    <id>https://www.thekqd.top/posts/895e9db.html</id>
    <published>2023-07-15T09:04:29.000Z</published>
    <updated>2023-11-05T13:55:46.801Z</updated>
    
    <content type="html"><![CDATA[<h1>1.线程同步概念</h1><p>线程同步的真实意思，其实是“<strong>排队</strong>”：几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。 而最让人无语的是，线程同步的目的就是让各个线程去排队使用资源，而不是让线程同时去使用资源。</p><p>假设有 4 个线程 A、B、C、D，当前一个线程 A 对内存中的共享资源进行访问的时候，其他线程 B, C, D 都不可以对这块内存进行操作，直到线程 A 对这块内存访问完毕为止，B，C，D 中的一个才能访问这块内存，剩余的两个需要继续阻塞等待，以此类推，直至所有的线程都对这块内存操作完毕。 线程对内存的这种访问方式就称之为线程同步，通过对概念的介绍，我们可以了解到所谓的同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次进行的。</p><h2 id="为什么要线程同步">为什么要线程同步</h2><p><strong>在研究线程同步之前，先来看一个两个线程交替计数（每个线程数 50 个数，交替数到 100）的例子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 50</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcA_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcB_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个子线程</span></span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，资源回收</span></span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译并执行上面的测试程序，得到如下结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out </span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">1</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">2</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">2</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">3</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">4</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">5</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">6</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">7</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">8</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">7</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">8</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">9</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">8</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">9</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">9</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">10</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">11</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">10</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">11</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">11</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">12</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">13</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">14</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">15</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">16</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">17</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">18</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">19</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">17</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">18</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">19</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">19</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">20</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">20</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">21</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">21</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">22</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">22</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">23</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">23</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">24</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">24</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">25</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">25</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">26</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">26</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">27</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">27</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">28</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">28</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">29</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">29</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">30</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">30</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">31</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">31</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">32</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">32</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">33</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">33</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">34</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">34</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">35</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">35</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">36</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">36</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">37</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">37</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">38</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">38</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">39</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">39</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">40</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">41</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">42</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">42</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">43</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">44</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">45</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">45</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">46</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">46</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">47</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">47</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">48</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">48</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">49</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">50</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">51</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">51</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">52</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">53</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">54</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">55</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">56</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">57</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">58</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">59</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">60</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">61</span></span><br></pre></td></tr></table></figure><p>通过对上面例子的测试，可以看出虽然每个线程内部循环了 50 次每次数一个数，但是最终没有数到 100，通过输出的结果可以看到，有些数字被重复数了多次，其原因就是没有对线程进行同步处理，造成了<strong>数据的混乱。</strong></p><p>两个线程在数数的时候需要分时复用 CPU 时间片，并且测试程序中调用了 sleep() 导致线程的 CPU 时间片没用完就被迫挂起了，这样就能让 CPU 的上下文切换（保存当前状态，下一次继续运行的时候需要加载保存的状态）更加频繁，更容易再现数据混乱的这个现象。</p><p>在测试程序中两个线程共用全局变量 <strong>number</strong> 当线程变成运行态之后开始数数，从物理内存加载数据，让后将数据放到 CPU 进行运算，最后将结果更新到物理内存中。如果数数的两个线程都可以顺利完成这个流程，那么得到的结果肯定是正确的。</p><p>如果线程 A 执行这个过程期间就失去了 CPU 时间片，线程 A 被挂起了最新的数据没能更新到物理内存。线程 B 变成运行态之后从物理内存读数据，很显然它没有拿到最新数据，只能基于旧的数据往后数，然后失去 CPU 时间片挂起。线程 A 得到 CPU 时间片变成运行态，第一件事儿就是将上次没更新到内存的数据更新到内存，但是这样会导致线程 B 已经更新到内存的数据被覆盖，活儿白干了，最终导致有些数据会被重复数很多次。</p><h2 id="同步方式">同步方式</h2><p>对于多个线程访问共享资源出现数据混乱的问题，需要进行线程同步。常用的线程同步方式有四种：<strong>互斥锁、读写锁、条件变量、信号量</strong>。所谓的共享资源就是多个线程共同访问的变量，这些变量通常为全局数据区变量或者堆区变量，这些变量对应的共享资源也被称之为<strong>临界资源</strong>。</p><p><img src="https://subingwen.cn/linux/thread-sync/image-20200106092600543.png" alt="image-20200106092600543"></p><p>找到临界资源之后，再找和临界资源相关的上下文代码，这样就得到了一个代码块，这个代码块可以称之为临界区。确定好临界区（临界区越小越好）之后，就可以进行线程同步了，线程同步的大致处理思路是这样的：</p><ul><li>在临界区代码的上边，添加加锁函数，对临界区加锁。<ul><li>哪个线程调用这句代码，就会把这把锁锁上，其他线程就只能阻塞在锁上了。</li></ul></li><li>在临界区代码的下边，添加解锁函数，对临界区解锁。<ul><li>出临界区的线程会将锁定的那把锁打开，其他抢到锁的线程就可以进入到临界区了。</li></ul></li><li>通过锁机制能保证临界区代码最多只能同时有一个线程访问，这样并行访问就变为串行访问了。</li></ul><h1>2.互斥锁</h1><h2 id="互斥锁函数">互斥锁函数</h2><p>互斥锁是线程同步最常用的一种方式，通过互斥锁可以锁定一个代码块，被锁定的这个代码块，所有的线程只能顺序执行 (不能并行处理)，这样多线程访问共享资源数据混乱的问题就可以被解决了，需要付出的代价就是执行效率的降低，因为默认临界区多个线程是可以并行处理的，现在只能串行处理。</p><p>在 Linux 中互斥锁的类型为 <strong>pthread_mutex_t</strong>，创建一个这种类型的变量就得到了一把互斥锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span>  mutex;</span><br></pre></td></tr></table></figure><p>在创建的锁对象中保存了当前这把锁的状态信息：锁定还是打开，如果是锁定状态还记录了给这把锁加锁的线程信息（线程 ID）。一个互斥锁变量只能被一个线程锁定，被锁定之后其他线程再对互斥锁变量加锁就会被阻塞，直到这把互斥锁被解锁，被阻塞的线程才能被解除阻塞。<strong>一般情况下，每一个共享资源对应一个把互斥锁(全局共享的锁)，锁的个数和线程的个数无关。</strong></p><p><strong>Linux 提供的互斥锁操作函数如下，如果函数调用成功会返回 0，调用失败会返回相应的错误号：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放互斥锁资源            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><p>mutex: 互斥锁变量的地址</p></li><li><p>attr: 互斥锁的属性，一般使用默认属性即可，这个参数指定为 NULL</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改互斥锁的状态, 将其设定为锁定状态, 这个状态被写入到参数 mutex 中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>这个函数被调用，首先会判断参数 mutex 互斥锁中的状态是不是锁定状态:</p><ul><li><p>没有被锁定，是打开的，这个线程可以加锁成功，这个这个锁中会记录是哪个线程加锁成功了</p></li><li><p>如果被锁定了，其他线程加锁就失败了，这些线程都会阻塞在这把锁上</p></li><li><p>当这把锁被解开之后，这些阻塞在锁上的线程就解除阻塞了，并且这些线程是通过竞争的方式对这把锁加锁，没抢到锁的线程继续阻塞</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数对互斥锁变量加锁还是有两种情况:</p><ul><li>如果这把锁没有被锁定是打开的，线程加锁成功</li><li>如果锁变量被锁住了，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对互斥锁解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 不是所有的线程都可以对互斥锁解锁，哪个线程加的锁，哪个线程才能解锁成功。</p><h2 id="互斥锁的使用">互斥锁的使用</h2><p>我们可以将上面多线程交替数数的例子修改一下，使用互斥锁进行线程同步。两个线程一共操作了同一个全局变量，因此需要添加一互斥锁，来控制这两个线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一把互斥锁</span></span><br><span class="line"><span class="comment">// 全局变量, 多个线程共享</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcA_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果线程A加锁成功, 不阻塞</span></span><br><span class="line">        <span class="comment">// 如果B加锁成功, 线程A阻塞</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcB_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// a加锁成功, b线程访问这把锁的时候是锁定的</span></span><br><span class="line">        <span class="comment">// 线程B先阻塞, a线程解锁之后阻塞解除</span></span><br><span class="line">        <span class="comment">// 线程B加锁成功了</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个子线程</span></span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，资源回收</span></span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="comment">// 线程销毁之后, 再去释放互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>3.死锁</h1><p>当多个线程访问共享资源，需要加锁，如果锁使用不当，就会造成死锁这种现象。如果线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。</p><p>造成死锁的场景有如下几种：</p><ul><li><p>1.加锁后忘记解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功, 当前循环完毕没有解锁, 在下一轮循环的时候自己被阻塞了</span></span><br><span class="line">        <span class="comment">// 其余的线程也被阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        <span class="comment">// 忘记解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程被阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        <span class="keyword">if</span>(xxx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 函数退出, 没有解锁（解锁函数无法被执行了）</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2.重复加锁，形成死锁</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 锁被锁住了, A线程阻塞</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏的比较深的情况</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">funcA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">funcB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        funcA();<span class="comment">// 重复加锁</span></span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>3.在程序中有多个共享资源，因此有很多把锁，随意加锁，导致相互被阻塞</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">场景描述:</span><br><span class="line">  1. 有两个共享资源:X, Y，X对应锁A, Y对应锁B</span><br><span class="line">     - 线程A访问资源X, 加锁A</span><br><span class="line">     - 线程B访问资源Y, 加锁B</span><br><span class="line">  2. 线程A要访问资源Y, 线程B要访问资源X，因为资源X和Y已经被对应的锁锁住了，因此这个两个线程被阻塞</span><br><span class="line">     - 线程A被锁B阻塞了, 无法打开A锁</span><br><span class="line">     - 线程B被锁A阻塞了, 无法打开B锁</span><br></pre></td></tr></table></figure></li></ul><p><strong>在使用多线程编程的时候，如何避免死锁呢？</strong></p><ul><li><p>避免多次锁定，多检查</p></li><li><p>对共享资源访问完毕之后，一定要解锁，或者在加锁的使用 trylock</p></li><li><p>如果程序中有多把锁，可以控制对锁的访问顺序 (顺序访问共享资源，但在有些情况下是做不到的)，另外也可以在对其他互斥锁做加锁操作之前，先释放当前线程拥有的互斥锁。</p></li><li><p>项目程序中可以引入一些专门用于死锁检测的模块</p></li></ul><h1>4.读写锁</h1><p>读写锁是互斥锁的升级版，在做读操作的时候可以提高程序的执行效率，如果所有的线程都是做读操作, 那么读是并行的，但是使用互斥锁，读操作也是串行的。</p><p>读写锁是一把锁，锁的类型为 <strong>pthread_rwlock_t</strong>，有了类型之后就可以创建一把互斥锁了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br></pre></td></tr></table></figure><p>之所以称其为读写锁，是因为这把锁既可以锁定读操作，也可以锁定写操作。为了方便理解，可以大致认为在这把锁中记录了这些信息：</p><ul><li>锁的状态：锁定 / 打开</li><li>锁定的是什么操作：读操作 / 写操作，使用读写锁锁定了读操作，需要先解锁才能去锁定写操作，反之亦然。</li><li>哪个线程将这把锁锁上了</li></ul><p>读写锁的使用方式也互斥锁的使用方式是完全相同的：找共享资源，确定临界区，在临界区的开始位置加锁（读锁 / 写锁），临界区的结束位置解锁。</p><p>因为通过一把读写锁可以锁定读或者写操作，下面介绍一下关于读写锁的特点：</p><ol><li>使用读写锁的读锁锁定了临界区，线程对临界区的访问是并行的，读锁是共享的。</li><li>使用读写锁的写锁锁定了临界区，线程对临界区的访问是串行的，写锁是独占的。</li><li>使用读写锁分别对两个临界区加了读锁和写锁，两个线程要同时访问者两个临界区，访问写锁临界区的线程继续运行，访问读锁临界区的线程阻塞，因为<strong>写锁比读锁的优先级高。</strong></li></ol><p>如果说程序中所有的线程都对共享资源做写操作，使用读写锁没有优势，和互斥锁是一样的，如果说程序中所有的线程都对共享资源有写也有读操作，并且对共享资源读的操作越多，读写锁更有优势。</p><p><strong>Linux 提供的读写锁操作函数原型如下，如果函数调用成功返回 0，失败返回对应的错误号：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放读写锁占用的系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>rwlock: 读写锁的地址，传出参数</li><li>attr: 读写锁属性，一般使用默认属性，指定为 NULL</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加读锁, 锁定的是读操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数的线程会被阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加读锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数加锁失败，对应的线程不会被阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加写锁, 锁定的是写操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数的线程会被阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加写锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数加锁失败，但是线程不会阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解锁, 不管锁定了读还是写都可用解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><h2 id="读写锁的使用">读写锁的使用</h2><p>题目要求：8 个线程操作同一个全局变量，3 个线程不定时写同一全局资源，5 个线程不定时读同一全局资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义读写锁</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写的线程的处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writeNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur ++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++写操作完毕, number : %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">// 添加sleep目的是要看到多个线程交替工作</span></span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程的处理函数</span></span><br><span class="line"><span class="comment">// 多个线程可以如果处理动作相同, 可以使用相同的处理函数</span></span><br><span class="line"><span class="comment">// 每个线程中的栈资源是独享</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">readNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--全局变量number = %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化读写锁</span></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3个写线程, 5个读的线程</span></span><br><span class="line">    <span class="type">pthread_t</span> wtid[<span class="number">3</span>];</span><br><span class="line">    <span class="type">pthread_t</span> rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;wtid[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;rtid[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(wtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(rtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>5.条件变量</h1><h2 id="条件变量函数">条件变量函数</h2><p>严格意义上来说，条件变量的主要作用不是处理线程同步，<strong>而是进行线程的阻塞</strong>。如果在多线程程序中只使用条件变量无法实现线程的同步，必须要配合互斥锁来使用。虽然条件变量和互斥锁都能阻塞线程，但是二者的效果是不一样的，二者的区别如下：</p><ul><li>设有 A-Z 26 个线程，这 26 个线程共同访问同一把互斥锁，如果线程 A 加锁成功，那么其余 B-Z 线程访问互斥锁都阻塞，所有的线程只能顺序访问临界区</li><li>条件变量只有在满足指定条件下才会阻塞线程，如果条件不满足，多个线程可以同时进入临界区，同时读写临界资源，这种情况下还是会出现共享资源中数据的混乱。</li></ul><p>一般情况下条件变量用于处理生产者和消费者模型，并且和互斥锁配合使用。条件变量类型对应的类型为 <strong>pthread_cond_t</strong>，这样就可以定义一个条件变量类型的变量了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;<span class="comment">//cond(condition)</span></span><br></pre></td></tr></table></figure><ul><li>被条件变量阻塞的线程的线程信息会被记录到这个变量中，以便在解除阻塞的时候使用。</li></ul><p><strong>条件变量操作函数函数原型如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">      <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 销毁释放资源        </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数:</p><ul><li>cond: 条件变量的地址</li><li>attr: 条件变量属性，一般使用默认属性，指定为 NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure><p>通过函数原型可以看出，该函数在阻塞线程的时候，需要一个互斥锁参数，这个互斥锁主要功能是进行线程同步，让线程顺序进入临界区，避免出现数共享资源的数据混乱。该函数会对这个互斥锁做以下几件事情：</p><ol><li>在阻塞线程时候，如果线程已经对互斥锁 mutex 上锁，那么会将这把锁打开，这样做是为了避免死锁</li><li>当线程解除阻塞的时候，函数内部会帮助这个线程再次将这个 mutex 互斥锁锁上，继续向下访问临界区</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这个函数的前两个参数和 <strong>pthread_cond_wait</strong> 函数是一样的，第三个参数表示线程阻塞的时长，但是需要额外注意一点：<strong>struct timespec</strong> 这个结构体中记录的时间是从1971.1.1到某个时间点的时间，总长度使用秒/纳秒表示。因此赋值方式相对要麻烦一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> mytim = time(<span class="literal">NULL</span>);<span class="comment">// 1970.1.1 0:0:0 到当前的总秒数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tmsp</span>;</span></span><br><span class="line">tmsp.tv_nsec = <span class="number">0</span>;</span><br><span class="line">tmsp.tv_sec = time(<span class="literal">NULL</span>) + <span class="number">100</span>;<span class="comment">// 线程阻塞100s</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><p>调用上面两个函数中的任意一个，都可以唤醒被 pthread_cond_wait 或者 pthread_cond_timedwait 阻塞的线程，区别就在于 pthread_cond_signal 是唤醒至少一个被阻塞的线程（总个数不定），pthread_cond_broadcast 是唤醒所有被阻塞的线程。</p><h2 id="生产者和消费者">生产者和消费者</h2><p><strong>生产者和消费者模型组成：</strong></p><ol><li>生产者线程 -&gt; 若干个<ul><li>生产商品或者任务放入到任务队列中</li><li>任务队列满了就阻塞，不满的时候就工作</li><li>通过一个生产者的条件变量控制生产者线程阻塞和非阻塞</li></ul></li><li>消费者线程 -&gt; 若干个<ul><li>读任务队列，将任务或者数据取出</li><li>任务队列中有数据就消费，没有数据就阻塞</li><li>通过一个消费者的条件变量控制消费者线程阻塞和非阻塞</li></ul></li><li>队列 -&gt; 存储任务 / 数据，对应一块内存，为了读写访问可以通过一个数据结构维护这块内存<ul><li>可以是数组、链表，也可以使用 stl 容器：queue /stack/list/vector</li></ul></li></ol><p><strong>场景描述：使用条件变量实现生产者和消费者模型，生产者有 5 个，往链表头部添加节点，消费者也有 5 个，删除链表头部的节点。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义条件变量, 控制消费者线程</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产了任务, 通知消费者消费</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span><span class="comment">//rand()产生0-32767之间的随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* consumer(<span class="type">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 一直消费, 删除链表中的一个节点</span></span><br><span class="line"><span class="comment">//        if(head == NULL)   // 这样写有bug</span></span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 任务队列, 也就是链表中已经没有节点可以消费了</span></span><br><span class="line">            <span class="comment">// 消费者线程需要阻塞</span></span><br><span class="line">            <span class="comment">// 线程加互斥锁成功, 但是线程阻塞在这行代码上, 锁还没解开</span></span><br><span class="line">            <span class="comment">// 其他线程在访问这把锁的时候也会阻塞, 生产者也会阻塞 ==&gt; 死锁</span></span><br><span class="line">            <span class="comment">// 这函数会自动将线程拥有的锁解开</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">            <span class="comment">// 当消费者线程解除阻塞之后, 会自动将这把锁锁上</span></span><br><span class="line">            <span class="comment">// 这时候当前这个线程又重新拥有了这把互斥锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="keyword">struct</span> Node* pnode = head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);        </span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 一直消费, 删除链表中的一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)   <span class="comment">// 这样写有bug</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);        </span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么在第7行使用if 有bug:</span></span><br><span class="line"><span class="comment">    当任务队列为空, 所有的消费者线程都会被这个函数阻塞 pthread_cond_wait(&amp;cond, &amp;mutex);</span></span><br><span class="line"><span class="comment">    也就是阻塞在代码的第9行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当生产者生产了1个节点, 调用 pthread_cond_broadcast(&amp;cond); 唤醒了所有阻塞的线程</span></span><br><span class="line"><span class="comment">      - 有一个消费者线程通过 pthread_cond_wait()加锁成功, 其余没有加锁成功的线程继续阻塞</span></span><br><span class="line"><span class="comment">      - 加锁成功的线程向下运行, 并成功删除一个节点, 然后解锁</span></span><br><span class="line"><span class="comment">      - 没有加锁成功的线程解除阻塞继续抢这把锁, 另外一个子线程加锁成功</span></span><br><span class="line"><span class="comment">      - 但是这个线程删除链表节点的时候链表已经为空了, 后边访问这个空节点的时候就会出现段错误</span></span><br><span class="line"><span class="comment">    解决方案:</span></span><br><span class="line"><span class="comment">      - 需要循环的对链表是否为空进行判断, 需要将if 该成 while</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1>6.信号量</h1><h2 id="信号量函数">信号量函数</h2><p>信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。信号量不一定是锁定某一个资源，而是流程上的概念，比如：有 A，B 两个线程，B 线程要等 A 线程完成某一任务以后再进行自己下面的步骤，这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。</p><p>**信号量（信号灯）**与互斥锁和条件变量的主要不同在于” 灯” 的概念，灯亮则意味着资源可用，灯灭则意味着不可用。信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。</p><p>**信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。**信号的类型为 sem_t 对应的头文件为 <strong>&lt;semaphore.h&gt;：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br></pre></td></tr></table></figure><ul><li>Linux 提供的信号量操作函数原型如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化信号量/信号灯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">          </span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">// 资源释放, 线程销毁之后调用这个函数即可</span></span><br><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br></pre></td></tr></table></figure><ul><li><p>参数:</p><ul><li><p>sem: 信号量变量地址</p></li><li><p>pshared：</p><ul><li><p>0：线程同步</p></li><li><p>非 0：进程同步</p></li></ul></li><li><p>value：初始化当前信号量拥有的资源数（&gt;=0），如果资源数为 0，线程就会被阻塞了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，因此线程也就被阻塞了。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li>当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，但是线程不会被阻塞，直接返回错误号，因此可以在程序中添加判断分支，用于处理获取资源失败之后的情况。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用该函数线程获取sem中的一个资源，当资源数为0时，线程阻塞，在阻塞abs_timeout对应的时长之后，解除阻塞。</span></span><br><span class="line"><span class="comment">// abs_timeout: 阻塞的时间长度, 单位是s, 是从1970.1.1开始计算的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li>该函数的参数 abs_timeout 和 pthread_cond_timedwait 的最后一个参数是一样的，使用方法不再过多赘述。当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，线程被阻塞，当阻塞指定的时长之后，线程解除阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用该函数给sem中的资源数+1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li>调用该函数会将 sem 中的资源数 +1，如果有线程在调用 sem_wait、sem_trywait、sem_timedwait 时因为 sem 中的资源数为 0 被阻塞了，这时这些线程会解除阻塞，获取到资源之后继续向下运行。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看信号量 sem 中的整形数的当前值, 这个值会被写入到sval指针对应的内存中</span></span><br><span class="line"><span class="comment">// sval是一个传出参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br></pre></td></tr></table></figure><ul><li>通过这个函数可以查看 sem 中现在拥有的资源个数，通过第二个参数 sval 将数据传出，也就是说第二个参数的作用和返回值是一样的。</li></ul><h2 id="生产者和消费者-2">生产者和消费者</h2><p>由于生产者和消费者是两类线程，并且在还没有生成之前是不能进行消费的，在使用信号量处理这类问题的时候可以定义两个信号量，分别用于记录生产者和消费者线程拥有的总资源数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者线程 </span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量初始化</span></span><br><span class="line">sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);    <span class="comment">// 5个生产者可以同时生产</span></span><br><span class="line">sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// 消费者线程没有资源, 因此不能消费</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="comment">// 在生产之前, 从信号量中取出一个资源</span></span><br><span class="line">sem_wait(&amp;psem);</span><br><span class="line"><span class="comment">// 生产者商品代码, 有商品了, 放到任务队列</span></span><br><span class="line">...... </span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 通知消费者消费，给消费者信号量添加资源，让消费者解除阻塞</span></span><br><span class="line">sem_post(&amp;csem);<span class="comment">//消费者资源+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="comment">// 消费者需要等待生产, 默认启动之后应该阻塞</span></span><br><span class="line">sem_wait(&amp;csem);<span class="comment">//生产者资源-1</span></span><br><span class="line"><span class="comment">// 开始消费</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 消费完成, 通过生产者生产，给生产者信号量添加资源</span></span><br><span class="line">sem_post(&amp;psem);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面的代码可以知道，初始化信号量的时候没有消费者分配资源，消费者线程启动之后由于没有资源自然就被阻塞了，等生产者生产出产品之后，再给消费者分配资源，这样二者就可以配合着完成生产和消费流程了。</p><h2 id="信号量的使用">信号量的使用</h2><p><strong>场景描述：使用信号量实现生产者和消费者模型，生产者有 5 个，往链表头部添加节点，消费者也有 5 个，删除链表头部的节点。</strong></p><h3 id="总资源数为1">总资源数为1</h3><p>如果生产者和消费者线程使用的信号量对应的总资源数为 1，那么不管线程有多少个，可以工作的线程只有一个，其余线程由于拿不到资源，都被迫阻塞了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费, 给消费者加信号灯</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="comment">// 生产者和消费者拥有的信号灯的总和为1</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 生成者线程一共有1个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过测试代码可以得到如下结论：如果生产者和消费者使用的信号量总资源数为 1，那么不会出现生产者线程和消费者线程同时访问共享资源的情况，不管生产者和消费者线程有多少个，它们都是顺序执行的。</strong></p><h3 id="总资源数大于1">总资源数大于1</h3><p>如果生产者和消费者线程使用的信号量对应的总资源数为大于 1，这种场景下出现的情况就比较多了：</p><ul><li>多个生产者线程同时生产</li><li>多个消费者同时消费</li><li>生产者线程和消费者线程同时生产和消费</li></ul><p>以上不管哪一种情况都可能会出现多个线程访问共享资源的情况，如果想防止共享资源出现数据混乱，那么就需要使用互斥锁进行线程同步，处理代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 加锁, 这句代码放到 sem_wait()上边, 有可能会造成死锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 生成者线程一共有5个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写上述代码的时候还有一个需要注意是事项，不管是消费者线程的处理函数还是生产者线程的处理函数内部有这么两行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure><p><strong>这两行代码的调用顺序是不能颠倒的，如果颠倒过来就有可能会造成死锁，下面来分析一种死锁的场景：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">......</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">......</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 生成者线程一共有5个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，初始化状态下消费者线程没有任务信号量资源，假设某一个消费者线程先运行，调用 <strong>pthread_mutex_lock(&amp;mutex)</strong>; 对互斥锁加锁成功，然后调用 <strong>sem_wait(&amp;csem)</strong>; 由于没有资源，因此被阻塞了。其余的消费者线程由于没有抢到互斥锁，因此被阻塞在互斥锁上。对应生产者线程第一步操作也是调用 <strong>pthread_mutex_lock(&amp;mutex)</strong>;，但是这时候互斥锁已经被消费者线程锁上了，所有生产者都被阻塞，到此为止，多余的线程都被阻塞了，程序产生了死锁。</p><p><strong>请记住: 先拿信号灯，再加锁!!!</strong></p>]]></content>
    
    
    <summary type="html">线程同步</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>虚拟地址空间</title>
    <link href="https://www.thekqd.top/posts/fb84f8a3.html"/>
    <id>https://www.thekqd.top/posts/fb84f8a3.html</id>
    <published>2023-07-14T10:22:13.000Z</published>
    <updated>2023-09-17T06:48:52.061Z</updated>
    
    <content type="html"><![CDATA[<h1>1.虚拟地址空间</h1><p>虚拟地址空间是一个非常抽象的概念，先根据字面意思进行解释：</p><ul><li>它可以用来加载程序数据（数据可能被加载到物理内存上，空间不够就加载到虚拟内存中）</li><li>它对应着一段连续的内存地址，起始位置为 0。</li><li>之所以说虚拟是因为这个起始的 0 地址是被虚拟出来的， 不是物理内存的 0 地址</li></ul><p>虚拟地址空间的大小也由操作系统决定，32位的操作系统虚拟地址空间的大小为 232 字节，也就是 4G，64 位的操作系统虚拟地址空间大小为 264 字节，这是一个非常大的数，感兴趣可以自己计算一下。当我们运行磁盘上一个可执行程序, 就会得到一个进程，内核会给每一个运行的进程创建一块属于自己的虚拟地址空间，并将应用程序数据装载到虚拟地址空间对应的地址上。</p><p>进程在运行过程中，程序内部所有的指令都是通过 CPU 处理完成的，CPU 只进行数据运算并不具备数据存储的能力，其处理的数据都加载自物理内存，那么进程中的数据是如何进出入到物理内存中的呢？其实是通过 CPU 中的内存管理单元 MMU（Memory Management Unit）从进程的虚拟地址空间中映射过去的。</p><h2 id="意义">意义</h2><p>通过上边的介绍大家会感觉到一头雾水， 为什么操作系统不直接将数据加载到物理内存中而是将数据加载到虚拟地址空间中，在通过 CPU 的 MMU 映射到物理内存中呢？</p><p>先来看一下如果直接将数据加载到物理内存会发生什么事情：</p><p><strong>假设计算机的物理内存大小为 1G, 进程 A 需要 100M 内存因此直接在物理内存上从 0 地址开始分配 100M, 进程 B 启动需要 250M 内存，因此继续在物理内存上为其分配 250M 内存，并且进程 A 和进程 B 占用的内存是连续的。之后再启动其他进程继续按照这种方法进行物理内存的分配。</strong></p><p>使用这种方式分配内存会有如下几个问题：</p><p>1.每个进程的地址不隔离，有安全风险。</p><p>由于程序都是直接访问物理内存，所以恶意程序可以通过内存寻址随意修改别的进程对应的内存数据，以达到破坏的目的。虽然有些时候是非恶意的，但是有些存在 bug 的程序可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。</p><p>2.内存效率低。</p><p>如果直接使用物理内存的话，一个进程对应的内存块就是作为一个整体操作的，如果出现物理内存不够用的时候，我们一般的办法是将不常用的进程拷贝到磁盘的交换分区（虚拟内存）中，以便腾出内存，因此就需要将整个进程一起拷走，如果数据量大，在内存和磁盘之间拷贝时间就会很长，效率低下。</p><p>3.进程中数据的地址不确定，每次都会发生变化。</p><p>由于物理内存的使用情况一直在动态的变化，我们无法确定内存现在使用到哪里了，如果直接将程序数据加载到物理内存，内存中每次存储数据的起始地址都是不一样的，这样数据的加载都需要使用相对地址，加载效率低（静态库是使用绝对地址加载的）。</p><p>总结：有了虚拟地址空间之后就可以完美的解决上边提到的所有问题了，**虚拟地址空间就是一个中间层，相当于在程序和物理内存之间设置了一个屏障，将二者隔离开来。程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。**这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</p><h2 id="分区">分区</h2><p>从操作系统层级上看，虚拟地址空间主要分为两个部分<strong>内核区</strong>和<strong>用户区</strong>。</p><ul><li>内核区：<ul><li>内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</li><li>内核总是驻留在内存中，是操作系统的一部分。</li><li>系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（系统内核只有一个）。</li></ul></li></ul><p><img src="https://subingwen.cn/linux/file-descriptor/image-20210130093015907.png" alt="img"></p><p>每个进程的虚拟地址空间都是从 0 地址开始的，我们在程序中打印的变量地址也其在虚拟地址空间中的地址，程序是无法直接访问物理内存的。虚拟地址空间中用户区地址范围是 0~3G，里边分为多个区块：</p><ul><li><p>保留区: 位于虚拟地址空间的最底部，未赋予物理地址。任何对它的引用都是非法的，程序中的空指针（NULL）指向的就是这块内存地址。</p></li><li><p>.text段: 代码段也称正文段或文本段，通常用于存放程序的执行代码 (即 CPU 执行的机器指令)，代码段一般情况下是只读的，这是对执行代码的一种保护机制。</p></li><li><p>.data段: 数据段通常用于存放程序中已初始化且初值不为 0 的全局变量和静态变量。数据段属于静态内存分配 (静态存储区)，可读可写。</p></li><li><p>.bss段: 未初始化以及初始为 0 的全局变量和静态变量，操作系统会将这些未初始化变量初始化为 0</p></li><li><p>堆(heap)：用于存放进程运行时动态分配的内存。</p><ul><li><p>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。</p></li><li><p>堆向高地址扩展 (即 “向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。</p></li></ul></li><li><p>内存映射区(mmap)：作为内存映射区加载磁盘文件，或者加载程序运作过程中需要调用的动态库。</p></li><li><p>栈(stack): 存储函数内部声明的非静态局部变量，函数参数，函数返回地址等信息，栈内存由编译器自动分配释放。栈和堆相反地址 “向下生长”，分配的内存是连续的。</p></li><li><p>命令行参数：存储进程执行的时候传递给 main() 函数的参数，argc，argv []</p></li><li><p>环境变量: 存储和进程相关的环境变量，比如：工作路径，进程所有者等信息</p></li></ul>]]></content>
    
    
    <summary type="html">虚拟地址空间概述</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="https://www.thekqd.top/posts/15fc6e8c.html"/>
    <id>https://www.thekqd.top/posts/15fc6e8c.html</id>
    <published>2023-07-14T09:01:14.000Z</published>
    <updated>2023-07-18T15:20:54.802Z</updated>
    
    <content type="html"><![CDATA[<h1>1.线程概述</h1><ul><li><p><strong>多线程和多进程都能够提高程序的并发性，但多线程对系统资源消耗更少，且多线程和多进程效率都是差不多的</strong></p></li><li><p>cpu会将单位时间分为很多份，每一份叫时间片，由系统进行调度，每个线程执行时都需要抢时间片，抢到的线程就执行成为<strong>运行态</strong>，没抢到就处于<strong>就绪态</strong>，执行完之后又成为就绪态继续抢时间片（都是随机的，无序运行）。</p></li></ul><div class="tip "><p>线程是轻量级的进程（LWP：light weight process），在 Linux 环境下线程的本质仍是进程。在计算机上运行的程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行。操作系统会以进程为单位，分配系统资源，可以这样理解，<strong>进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。</strong></p></div><p>先从概念上了解一下线程和进程之间的区别：</p><ul><li><p>进程有自己<strong>独立</strong>的地址空间，多个线程<strong>共用</strong>同一个地址空间</p><ul><li><p>线程更加节省系统资源，效率不仅可以保持的，而且能够更高</p></li><li><p>在一个<strong>地址空间</strong>中多个线程<strong>独享</strong>：每个线程都有属于自己的栈区，寄存器 (内核中管理的)</p></li><li><p>在一个<strong>地址空间</strong>中多个线程<strong>共享</strong>：代码段，堆区，全局数据区，打开的文件 (文件描述符表) 都是线程共享的</p></li></ul><p>(详细见blog篇)虚拟地址空间：于每一个程序在执行时（如a.out），此时会产生一个相应的进程，系统都会自动为其分配一个0~4G的虚拟地址空间，其中1G的内核空间用于：进程管理、内存管理、设备管理和虚拟文件系统等。</p><p>下面详细介绍0~3G的用户空间：</p><pre><code>     强调一点：以下说明的各段都是与编程相关的，不包括虚拟地址空间的全部。    0~3G的用户空间。从小到大（从下往上）依次为：保留区（受保护的地址）、代码段、数据段（.data段）、.bss段、堆空间、内存映射段、栈空间、命令行参数和环境变量。下面依次对每一个段做简单的介绍：</code></pre></li><li><p>线程是程序的最小执行单位，进程是操作系统中最小的资源分配单位</p><ul><li><p>每个进程对应一个虚拟地址空间，一个进程只能抢一个 CPU 时间片</p></li><li><p>一个地址空间中可以划分出多个线程，在有效的资源基础上，能够抢更多的 CPU 时间片</p></li></ul></li><li><p>CPU 的调度和切换：线程的上下文切换比进程要快的多</p><p>上下文切换：进程 / 线程分时复用 CPU 时间片，在切换之前会将上一个任务的状态进行保存，下次切换回这个任务的时候，加载这个状态继续运行，任务从保存到再次加载这个过程就是一次上下文切换。</p></li><li><p>线程更加廉价，启动速度更快，退出也快，对系统资源的冲击小。</p><p><strong>一般考虑多线程，只执行任务的话，考虑多线程</strong></p><p><strong>当同时启动多个程序时，考虑多进程</strong></p><div class="tip "><p><strong>在处理多任务程序的时候使用多线程比使用多进程要更有优势，但是线程并不是越多越好，如何控制线程的个数呢？</strong></p></div><p>1.文件 IO 操作：文件 IO 对 CPU 是使用率不高，因此可以分时复用 CPU 时间片，线程的个数 = 2 * CPU 核心数 (效率最高)</p><p>2.处理复杂的算法 (主要是 CPU 进行运算，压力大)，线程的个数 = CPU 的核心数 (效率最高)</p></li></ul><h1>2.创建线程</h1><h2 id="线程函数">线程函数</h2><p>每一个线程都有一个唯一的线程 ID，ID 类型为 <strong>pthread_t</strong>，这个 ID 是一个<strong>无符号长整形数</strong>，如果想要得到当前线程的线程 ID，可以调用如下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>）<span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">// 返回当前线程的线程ID</span></span><br></pre></td></tr></table></figure><p>在一个进程中调用线程创建函数，就可得到一个子线程，和进程不同，需要给每一个创建出的线程指定一个处理函数，否则这个线程无法工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> <span class="comment">//线程库</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread, 线程库的名字叫pthread</span></span><br><span class="line"><span class="comment">//全名: libpthread.so libptread.a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>thread: 传出参数，是无符号长整形数，线程创建成功，会将线程 ID 写入到这个指针指向的内存中</li><li>attr: 线程的属性，一般情况下使用默认属性即可，写 NULL</li><li>start_routine: 函数指针，创建出的子线程的处理动作，也就是该（回调函数）工作函数在子线程中执行。</li><li>arg: 作为实参传递到 start_routine 指针指向的函数内部，工作函数的参数，会自动传入</li></ul></li></ul><p>返回值：线程创建成功返回 0，创建失败返回对应的错误号</p><div class="note warning flat"><p>注意：1.回调函数返回值为void *型，参数为void * arg。2.回调函数 的参数当有多个时，可以用结构体储存，再将该结构体传入</p></div><h2 id="创建线程">创建线程</h2><p>下面是创建线程的示例代码，在创建过程中一定要保证编写的线程函数与规定的函数指针类型一致：<strong>void *(*start_routine) (void *)</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_create.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//sleep函数所在头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 休息, 休息一会儿...</span></span><br><span class="line">    <span class="comment">// sleep(1);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>linux下编译测试程序，会看到如下错误信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc pthread_create.c</span> </span><br><span class="line">/tmp/cctkubA6.o: In function `main&#x27;:</span><br><span class="line">pthread_create.c:(.text+0x7f): undefined reference to `pthread_create&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>错误原因是因为编译器链接不到线程库文件（动态库），需要在编译的时候通过参数指定出来，动态库名为 <a href="http://libpthread.so">libpthread.so</a> 需要使用的参数为 -l，根据规则掐头去尾最终形态应该写成：-lpthread（参数和参数值中间可以有空格）。正确的编译命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pthread_create 函数的定义在某一个库中, 编译的时候需要加库名 pthread</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc pthread_create.c -lpthread</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span> </span><br><span class="line">子线程创建成功, 线程ID: 139712560109312</span><br><span class="line">我是主线程, 线程ID: 139712568477440</span><br><span class="line">i = 0</span><br><span class="line">i = 1</span><br><span class="line">i = 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意：在打印的日志输出中为什么子线程处理函数没有执行完毕呢（只看到了子线程的部分日志输出）？<br>主线程一直在运行，执行期间创建出了子线程，说明主线程有 CPU 时间片，在这个时间片内将代码执行完毕了，主线程就退出了。<strong>子线程被创建出来之后需要抢cpu时间片, 抢不到就不能运行，如果主线程退出了, 虚拟地址空间就被释放了, 子线程就一并被销毁了。但是如果某一个子线程退出了, 主线程仍在运行, 虚拟地址空间依旧存在。</strong></p></div><p>得到的结论：<strong>在没有人为干预的情况下，虚拟地址空间的生命周期和主线程是一样的，与子线程无关</strong>。</p><p>目前的解决方案：让子线程执行完毕，主线程再退出，可以在主线程中添加挂起函数 sleep()，避免主线程先执行完毕后虚拟地址空间被释放;</p><h1>3.线程退出</h1><div class="tip "><p>在编写多线程程序的时候，如果想要让线程退出，<strong>但是不会导致虚拟地址空间的释放（针对于主线程退出后，不想释放虚拟空间地址的情况）</strong>，我们就可以调用线程库中的线程退出函数，只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，<strong>不管是在子线程或者主线程中都可以使用。</strong></p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数(void *retval)：线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为 NULL</li></ul><p>线程退出示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);<span class="comment">// 直接退出子线程</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程调用退出函数退出, 地址空间不会被释放</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>4.线程回收</h1><h2 id="线程函数-2">线程函数</h2><div class="tip "><p>线程和进程一样，子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做  <strong>pthread_join()</strong>，这个函数是一个阻塞函数，<strong>如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</strong></p></div><p>另外通过线程回收函数还可以获取到子线程退出时传递出来的数据，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这是一个阻塞函数, 子线程在运行这个函数就阻塞</span></span><br><span class="line"><span class="comment">// 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>参数:</p><ul><li>thread: 要被回收的子线程的线程 ID</li><li>retval: 二级指针，指向一级指针的地址，是一个传出参数，这个地址中存储了 pthread_exit () 传递出的数据，如果不需要这个参数，可以指定为 NULL</li></ul></li><li><p>返回值：线程回收成功返回 0，回收失败返回错误号。</p></li></ul><h2 id="回收子线程数据">回收子线程数据</h2><p>在子线程退出的时候可以使用 pthread_exit() 的参数将数据传出，在回收这个子线程的时候可以通过 phread_join() 的第二个参数来接收子线程传递出的数据。接收数据有很多种处理方式，下面来列举几种：</p><h3 id="使用子线程栈">使用子线程栈</h3><p>通过函数 <em>pthread_exit(void *retval);</em> 可以得知，子线程退出的时候，需要将数据记录到一块内存中，通过参数传出的是存储数据的内存的地址，而不是具体数据，由因为参数是 <em>void*</em> 类型，所有这个万能指针可以指向任意类型的内存地址。先来看第一种方式，将子线程退出数据保存在子线程自己的栈区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_join.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span></span><br><span class="line">            p.age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p.id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(&amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">// 代码执行不到这个位置就退出了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">pp</span> =</span> (<span class="keyword">struct</span> Persion*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程返回数据: name: %s, age: %d, id: %d\n&quot;</span>, pp-&gt;name, pp-&gt;age, pp-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行测试程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 编译代码</span><br><span class="line">$ gcc pthread_join.c -lpthread</span><br><span class="line"># 执行程序</span><br><span class="line">$ ./a.out </span><br><span class="line">子线程创建成功, 线程ID: <span class="number">140652794640128</span></span><br><span class="line">我是主线程, 线程ID: <span class="number">140652803008256</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">我是子线程, 线程ID: <span class="number">140652794640128</span></span><br><span class="line">child == i: = <span class="number">0</span></span><br><span class="line">child == i: = <span class="number">1</span></span><br><span class="line">child == i: = <span class="number">2</span></span><br><span class="line">child == i: = <span class="number">3</span></span><br><span class="line">child == i: = <span class="number">4</span></span><br><span class="line">child == i: = <span class="number">5</span></span><br><span class="line">child == i: = <span class="number">6</span></span><br><span class="line">子线程返回数据: name: , age: <span class="number">0</span>, id: <span class="number">0</span></span><br><span class="line">子线程资源被成功回收...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过打印的日志可以发现，在主线程中没有没有得到子线程返回的数据信息，具体原因是这样的：</p><p><strong>如果多个线程共用同一个虚拟地址空间，每个线程在栈区都有一块属于自己的内存，相当于栈区被这几个线程平分了，当线程退出，线程在栈区的内存也就被回收了，因此随着子线程的退出，写入到栈区的数据也就被释放了。</strong></p><h3 id="使用全局变量">使用全局变量</h3><p>位于同一虚拟地址空间中的线程，虽然<strong>不能共享栈区数据，但是可以共享全局数据区和堆区数据</strong>，因此在子线程退出的时候可以将传出数据存储到全局变量、静态变量或者堆内存中。在下面的例子中将数据存储到了全局变量中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span><span class="comment">// 定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用全局变量</span></span><br><span class="line">            p.age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p.id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(&amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">pp</span> =</span> (<span class="keyword">struct</span> Persion*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s, age: %d, id: %d\n&quot;</span>, pp-&gt;name, pp-&gt;age, pp-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用主线程栈">使用主线程栈</h3><p>虽然每个线程都有属于自己的栈区空间，但是<strong>位于同一个地址空间的多个线程是可以相互访问对方的栈空间上的数据的</strong>。由于很多情况下还需要在主线程中回收子线程资源，所以主线程一般都是最后退出，基于这个原因在下面的程序中将子线程返回的数据保存到了主线程的栈区内存中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">p</span> =</span> (<span class="keyword">struct</span> Persion*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用主线程的栈内存</span></span><br><span class="line">            p-&gt;age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p-&gt;id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">// 主线程的栈内存传递给子线程</span></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s, age: %d, id: %d\n&quot;</span>, p.name, p.age, p.id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的程序中，调用 pthread_create() 创建子线程，并将主线程中栈空间变量 p 的地址传递到了子线程中，在子线程中将要传递出的数据写入到了这块内存中。也就是说在程序的 main() 函数中，通过指针变量 ptr 或者通过结构体变量 p 都可以读出子线程传出的数据。</p><h2 id="手动和自动回收资源">手动和自动回收资源</h2><div class="tip "><p><strong>线程退出有多种方式，如return，pthread_exit,pthread_cancel等；线程分为可结合的（joinable）和 分离的（detached）两种，如果没有在创建线程时将线程分离，则线程默认是可结合的。可结合的线程在线程退出后不会立即释放资源，必须要调用pthread_join来显式的结束线程。分离的线程在线程退出时系统会自动回收资源。</strong></p></div><p></p><ul><li><p>pthread_exit()：只退出当前子线程。<strong>注意</strong>：在主线程退出时，其它线程不会结束。同样可以执行。所以这个只字非常重要。并且，与return一样，pthread_exit退出的线程也需要调用pthread_join去回收子线程的资源(8k左右)，不会自行回收，否则服务器长时间运行会浪费资源导致无法再创建新线程。</p></li><li><p>pthread_detach()，自行回收资源</p></li></ul><h1>5.线程分离</h1><div class="tip "><p><strong>某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用 pthread_join() 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。</strong></p></div><p>在线程库函数中为我们提供了线程分离函数 <strong>pthread_detach()</strong>，调用这个函数之后指定的<strong>子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。<strong>线程分离之后在主线程中使用 <strong>pthread_join()</strong> 就回收不到子线程资源了。</strong>(detach后资源自动回收)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p>下面的代码中，在主线程中创建子线程，并调用线程分离函数，实现了主线程和子线程的分离：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子线程和主线程分离</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程自己退出即可，必须有这个，否则虚拟地址空间内存会被释放</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>6.其他线程函数</h1><h2 id="线程取消函数">线程取消函数</h2><p>线程取消的意思就是在某些特定情况下在一个线程中杀死另一个线程。使用这个函数杀死一个线程需要分两步：</p><ul><li>在线程 A 中调用线程取消函数 pthread_cancel，指定杀死线程 B，这时候线程 B 是死不了的</li><li>在线程 B 中进程一次系统调用（从用户区切换到内核区），否则线程 B 可以一直运行。<br>这其实和七步断肠散、含笑半步癫的功效是一样的，吃了毒药不动或者不笑也没啥事儿</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数是子线程的线程ID</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数：要杀死的线程的线程 ID</p></li><li><p>返回值：函数调用成功返回 0，调用失败返回非 0 错误号。</p></li></ul><p>在下面的示例代码中，主线程调用线程取消函数，只要在子线程中进行了系统调用，当子线程执行到这个位置就挂掉了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf这个函数会调用系统函数, 因此这是个间接的系统调用,运行到子线程就挂了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; child i: %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 杀死子线程, 如果子线程中做系统调用, 子线程就结束了</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程自己退出即可</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>关于系统调用有两种方式：</strong></p><ul><li>直接调用 Linux 系统函数</li><li>调用标准 C 库函数，为了实现某些功能，在 Linux 平台下标准 C 库函数会调用相关的系统函数</li></ul><h2 id="线程ID比较">线程ID比较</h2><p>在 Linux 中线程 ID 本质就是一个无符号长整形，因此可以直接使用比较操作符比较两个线程的 ID，但是线程库是可以跨平台使用的，在某些平台上 <strong>pthread_t</strong> 可能不是一个单纯的整形，这中情况下比较两个线程的 ID 必须要使用比较函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：t1 和 t2 是要比较的线程的线程 ID</li><li>返回值：如果两个线程 ID 相等返回非 0 值，如果不相等返回 0</li></ul><h1>7.C++线程类（std::thread）</h1><p><a href="https://blog.csdn.net/sjc_0910/article/details/118861539?spm=1001.2014.3001.5506"> C++11 多线程（std::thread）详解_c++多线程_jcShan709的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">线程相关知识（pthread）</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Clion快捷键</title>
    <link href="https://www.thekqd.top/posts/70b69f96.html"/>
    <id>https://www.thekqd.top/posts/70b69f96.html</id>
    <published>2023-04-11T01:18:44.000Z</published>
    <updated>2023-07-17T11:17:07.781Z</updated>
    
    <content type="html"><![CDATA[<h1>CLion编辑快捷键</h1><p><strong>Ctrl+Spacebar</strong> 基本代码完成(任何类、方法或变量的名称)</p><p><strong>Ctrl+Shift+Spacebar</strong> 智能代码完成(按预期类型筛选方法和变量列表)</p><p><strong>Ctrl+Shift+Enter</strong> 完整的语句</p><p><strong>Ctrl+P</strong> 参数信息(在方法调用参数内)</p><p><strong>Ctrl+Q</strong> 快速查找文档</p><p><strong>Ctrl+Mouse over code</strong> 简短的信息</p><p><strong>Ctrl+F1</strong> 在插入符号处显示错误或警告的说明</p><p><strong>Alt+Insert</strong> 生成代码…(Getters, Setters, Constructors, hashCode/equals, toString)</p><p><strong>Ctrl+O</strong> 覆盖方法</p><p><strong>Ctrl+I</strong> 实现方法</p><p><strong>Ctrl+Alt+T</strong> 围绕与…(如果. .其他,试试. .catch, for, synchronized等)</p><p><strong>Ctrl+/</strong> 注释/取消注释行注释</p><p><strong>Ctrl+Shift+/</strong> 注释/取消注释块注释</p><p><strong>Ctrl+W</strong> 选择连续递增代码块</p><p><strong>Ctrl+Shift+W</strong> 减少当前选择到以前的状态</p><p><strong>Alt+Q</strong> 显示强度动作和快速修复</p><p><strong>Ctrl+Alt+L</strong> 重新格式化代码</p><p><strong>Ctrl+Alt+O</strong> 优化进口</p><p><strong>Ctrl+Alt+I</strong> 自动缩进线(年代)</p><p><strong>Tab/Shift+Tab</strong> 缩进/ unindent选定的行</p><p><strong>Ctrl+X</strong> 剪切当前行或选定块到剪贴板</p><p><strong>Ctrl+C</strong> 复制当前行或选定块到剪贴板</p><p><strong>Ctrl+V</strong> 从剪贴板粘贴</p><p><strong>Ctrl+Shift+V</strong> 从最近的缓冲区粘贴…</p><p><strong>Ctrl+D</strong> 复制当前行或选定块</p><p><strong>Ctrl+Y</strong> 删除插入符号处的行</p><p><strong>Ctrl+Shift+J</strong> 智能线连接</p><p><strong>Ctrl+Enter</strong> 智能线分裂</p><p><strong>Shift+Enter</strong> 开始新的一行</p><p><strong>Ctrl+Shift+U</strong> 在插入符号或选定块上切换大小写</p><p><strong>Ctrl+Shift+]/[</strong> 选择直到代码块结束/开始</p><p><strong>Ctrl+Delete</strong> 删除到字尾</p><p><strong>Ctrl+Backspace</strong> 删除到单词开始</p><p><strong>Ctrl+ NumPad +/-</strong> 展开/折叠代码块</p><p><strong>Ctrl+Alt+ NumPad +/-</strong> 展开所有/折叠所有</p><p><strong>Ctrl+F4</strong> 关闭活动编辑器选项卡</p><p><strong>Alt+Shift+Click</strong> 将插入符号放置在多个位置</p><p><strong>Esc</strong> 恢复单插入字符模式</p><p><strong>Alt+G/Alt+Shift+G</strong> 添加/删除下次出现的当前单词选择</p><h1>CLion查找和替换</h1><p><strong>Double Shift</strong> 到处寻找</p><p><strong>Ctrl+F</strong> 找到</p><p><strong>F3 / Shift+F3</strong> 查找下一个/找到之前</p><p><strong>Ctrl+R</strong> 取代</p><p><strong>Ctrl+Shift+F</strong> 找到的路径</p><p><strong>Ctrl+Shift+R</strong> 在路径替换</p><h1>CLion编译、运行快捷键</h1><p><strong>Ctrl+F9</strong> 建设项目</p><p><strong>Alt+Shift+F10</strong> 选择配置并运行</p><p><strong>Alt+Shift+F9</strong> 选择配置和调试</p><p><strong>Shift+F10</strong> 运行</p><p><strong>Shift+F9</strong> 调试</p><h1>CLion Debug快捷键</h1><p><strong>F8</strong> 步进</p><p><strong>F7</strong> 进入</p><p><strong>Shift+F8</strong> 步出</p><p><strong>Alt+F9</strong> 运行到光标</p><p><strong>Alt+F8</strong> 计算表达式</p><p><strong>F9</strong> 恢复程序</p><p><strong>Ctrl+F8</strong> Toggle breakpoint</p><p><strong>Ctrl+Shift+F8</strong> 查看断点</p><h1>CLion Live模板快捷键</h1><p><strong>Ctrl+Alt+J</strong> 使用Live模板包围</p><p><strong>Ctrl+J</strong> 插入Live模板</p><p><strong>for</strong> (索引;,)循环</p><p><strong>iter</strong> 迭代范围(C + + 11)</p><p><strong>itit</strong> 使用Begin/End成员函数迭代</p><p><strong>incboost</strong> 在CMake中包含使用Boost的指示</p><p><strong>function</strong> 在CMake中创建新的函数定义器</p><h1>CLion搜索文件、导航快捷键</h1><p><strong>Ctrl+N</strong> 搜索类文件</p><p><strong>Ctrl+Shift+N</strong> 搜索文件</p><p><strong>Ctrl+Alt+Shift+N</strong> 定位到符号</p><p><strong>Alt+Right Arrow/Left Arrow</strong> 转到下一个/上一个编辑器选项卡</p><p><strong>F12</strong> 返回到前一个工具窗口</p><p><strong>Esc</strong> 转到编辑器(从工具窗口)</p><p><strong>Shift+Esc</strong> 隐藏活动的或最近活动的窗口</p><p><strong>Ctrl+Shift+F4</strong> 关闭活动运行/信息/发现/…选项卡</p><p><strong>Ctrl+G</strong> 去行</p><p><strong>Ctrl+E</strong> 最近文件弹出</p><p><strong>Ctrl+Alt+Left Arrow/Right Arrow</strong> 向后/向前导航</p><p><strong>Ctrl+Shift+Backspace</strong> 导航到最后一次编辑位置</p><p><strong>Alt+F1</strong> 在任意视图中选择当前文件或符号</p><p><strong>Ctrl+B</strong> 定位声明 或 <strong>Ctrl + 鼠标左键</strong></p><p><strong>Ctrl+Alt+B</strong> 搜索实现类(年代)</p><p><strong>Ctrl+Alt+Home</strong> 转到相关符号(头/源)</p><p><strong>Ctrl+Shift+I</strong> 文件)</p><p><strong>Ctrl+Shift+B</strong> 开放快速定义查找</p><p><strong>Ctrl+U</strong> 进入类型声明</p><p><strong>Alt+Up Arrow/Down Arrow</strong> 父类方法/超类</p><p><strong>Ctrl+]/[</strong> 转到前一个/下一个方法</p><p><strong>Ctrl+F12</strong> 移动到代码块结束/移动到代码开始</p><p><strong>Ctrl+H</strong> 弹出文件结构</p><p><strong>Ctrl+Alt+H</strong> 类型层次结构</p><p><strong>F2/Shift+F2</strong> 调用层次结构</p><p><strong>F11</strong> 下一个/以前的错误突出显示</p><p><strong>Ctrl+F11</strong> 切换书签</p><p><strong>Ctrl+0…9</strong> 用助记符切换书签</p><p><strong>Shift+F11</strong> 转到编号书签</p><h1>CLion常用快捷键</h1><p><strong>Alt+0…9</strong> 打开相应的工具窗口</p><p><strong>Alt+Shift+I</strong> 用当前配置文件检查当前文件</p><p><strong>Ctrl+`</strong> 快速开关电流方案</p><p><strong>Ctrl+Alt+S</strong> 编辑应用程序设置</p><p><strong>Ctrl+Shift+F12</strong> 隐藏所有工具窗口</p><p><strong>Alt+Shift+F</strong> 添加到收藏夹</p><h1>CLion 使用过的搜索</h1><p><strong>Alt+F7</strong> 发现使用</p><p><strong>Ctrl+F7</strong> 在文件中查找用法</p><p><strong>Ctrl+Shift+F7</strong> 突出显示文件中的用法</p><p><strong>Ctrl+Alt+F7</strong> 显示用法</p><h1>VCS/Git快捷键</h1><p><strong>Ctrl+K</strong> 向VCS/Git提交项目</p><p><strong>Ctrl+T</strong> 从VCS更新项目</p><p><strong>Alt+Shift+C</strong> 查看最近的变化</p><p><strong>Alt+`</strong> VCS/Git快速弹出</p><h1>CLion重构快捷键</h1><p><strong>Ctrl+Alt+Shift+T</strong> 重构</p><p><strong>F5</strong> 复制</p><p><strong>F6</strong> 移动</p><p><strong>Alt+Delete</strong> 安全的删除</p><p><strong>Shift+F6</strong> 重命名</p><p><strong>Ctrl+F6</strong> 更改签名</p><p><strong>Ctrl+Alt+M</strong> 提取功能</p><p><strong>Ctrl+Alt+N</strong> 内联</p><p><strong>Ctrl+Alt+P</strong> 引入参数</p><p><strong>Ctrl+Alt+V</strong> 引入变量</p><p><strong>Ctrl+Alt+C</strong> 介绍常数</p><p><strong>Ctrl+Alt+D</strong> 介绍定义</p>]]></content>
    
    
    <summary type="html">一些Clion常用的快捷键一共120个</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>STM32(HAL库)</title>
    <link href="https://www.thekqd.top/posts/b900f0d0.html"/>
    <id>https://www.thekqd.top/posts/b900f0d0.html</id>
    <published>2023-04-02T15:03:08.000Z</published>
    <updated>2025-01-22T07:22:09.650Z</updated>
    
    <content type="html"><![CDATA[<h1>实验和一些好用的工具</h1><p><a href="https://docs.keysking.com/docs/stm32/intro">欢迎来到 波特律动 | 波特律动 (keysking.com)</a></p><p><strong>串口调试助手、蓝牙调试助手</strong>：</p><p><a href="https://serial.keysking.com/">波特律动 串口助手 (keysking.com)</a></p><p><strong>OLED驱动库、图片字体取模</strong>：<a href="https://led.baud-dance.com/">波特律动LED字模生成器 (baud-dance.com)</a></p><h1>讲解视频</h1><p><a href="https://www.bilibili.com/video/BV1do4y1F7wt/?spm_id_from=333.788&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【工作STM32】第10集 STM32串口DMA模式与收发不定长数据 | keysking的stm32教程_哔哩哔哩_bilibili</a></p><h1>GPIO</h1><h2 id="GPIO介绍">GPIO介绍</h2><p>GPIO是<strong>通用输入输出端口</strong>（General-purpose input/output）的英文简写，是所有的微控制器必不可少的外设之一，可以由STM32直接驱动从而实现与外部设备通信、控制以及采集和捕获的功能。STM32单片机的GPIO被分为很多组，每组有16个引脚，不同型号的MCU的GPIO个数是不同的，比如STM32F103C8T6只有PA、PB以及个别PC引脚而STM32F103ZET6拥有PA~PG的全部112个引脚。<strong>所有的GPIO都有基本的输入输出功能，同时GPIO还可以作为其它的外设功能引脚</strong>。</p><p>作为STM32最基本的外设，GPIO最基本的输出功能是由STM32控制 引脚输出高低电平，比如可以把GPIO接LED灯来控制其亮灭，也可以接继电器或者三极管，通过继电器或三极管来控制外部大功率电路的通断。</p><h2 id="GPIO工作模式">GPIO工作模式</h2><ul><li>输入模式：<ul><li>浮空输入</li><li>上拉输入(内部上拉和外部上拉)</li><li>下拉输入</li><li>模拟输入</li></ul></li><li>输出模式：<ul><li>推挽输出(PP)：高低电平均有驱动能力(一般使用)</li><li>开漏输出(OD,open drain)：高电平相当于高阻态，没有驱动能力，低电平有驱动能力(特殊使用)</li><li>开漏复用输出</li><li>推挽复用输出</li></ul></li></ul><p><strong>VCC：C=circuit，表示电路的意思，即接入电路的电压。</strong></p><p><strong>VDD：D=device，表示器件的意思，即器件内部的工作电压。</strong></p><p><strong>VSS：S=series，表示公共连接的意思，通常指电路公共接地端电压。</strong></p><p><a href="https://blog.csdn.net/weixin_63094577/article/details/124489756?ops_request_misc=%7B%22request%5Fid%22%3A%22171126819716800211573854%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171126819716800211573854&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124489756-null-null.142%5Ev99%5Epc_search_result_base1&amp;utm_term=stm32GPIO&amp;spm=1018.2226.3001.4187">STM32基础入门——GPIO详解_stm32gpio采集0、1信号-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_44016222/article/details/123206403?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stm32GPIO&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-123206403.nonecase&amp;spm=1018.2226.3001.4187">STM32-GPIO介绍_stm32 gpio-CSDN博客</a></p><h2 id="点灯">点灯</h2><h1>STM32启动流程</h1><h2 id="启动文件">启动文件</h2><p>startup_stm32xxx.s(汇编文件)文件具体工作</p><h1>RCC</h1><p>stm32上的**RCC(Reset and Clock Control)**外设，是复位和时钟控制的英文缩写。简单理解为’‘心跳’’</p><h2 id="复位">复位</h2><p>可见<strong>参考手册</strong></p><ul><li>系统复位</li><li>电源复位</li><li>后备域复位</li></ul><p>原理图上有复位电路</p><h2 id="时钟">时钟</h2><p><a href="https://blog.csdn.net/as480133937/article/details/98845509?ops_request_misc=%7B%22request%5Fid%22%3A%22171266890916800182712783%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=171266890916800182712783&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-16-98845509-null-null.142%5Ev100%5Epc_search_result_base5&amp;utm_term=rcc&amp;spm=1018.2226.3001.4187">【STM32】系统时钟RCC详解(超详细，超全面)_rcc时钟-CSDN博客</a></p><h3 id="时钟源">时钟源</h3><p>STM32中能够主动发出时钟信号的元器件，可以用作<strong>时钟源</strong>。STM32中有四个时钟源，还有一个辅助时钟源生成倍频时钟信号的器件锁相环。</p><ul><li><strong>HSI(高速内部时钟)</strong></li></ul><p>时钟信号由内部RC震荡电路提供，时钟频率为<strong>8MHz</strong>，但是这个时钟频率会随着温度产生漂移，<strong>很不稳定</strong>，所以一般不使用此时钟信号</p><ul><li><strong>HSE(高速外部时钟)</strong></li></ul><p>时钟信号由外部晶振提供，时钟频率一般在<strong>4-16MHz</strong>，是经常会用到的时钟源</p><blockquote><p>这里的外部晶振可以是有源晶振，也可以是无源晶振，它们的区别在于与<strong>STM32的 连接方式，以及需不需要谐振电容</strong></p></blockquote><ul><li><strong>LSI(低速内部时钟)</strong></li></ul><p>时钟信号由内部RC振荡电路提供，时钟频率一般为40KHz，这个信号<strong>一般用于独立看门狗时钟</strong></p><ul><li><strong>LSE(低速外部时钟)</strong></li></ul><p>时钟信号由外部晶振提供，时钟频率一般为32.768KHz，这个信号一般用于<strong>RTC实时时钟</strong></p><ul><li><strong>PLLCLK(锁相环倍频时钟)</strong></li></ul><p>PLL锁相环是辅助产生时钟信号的器件。PLL并不是自己产生的时钟源，而是通过倍频得到的时钟。将时钟信号输入锁相环，锁相环可以将这个时钟信号的频率按照<strong>指定倍率提高</strong>（倍频）之后，再输出。</p><blockquote><p>与锁相环具有相反作用的是分频器，分频器可以将输入时钟信号分率按照指定倍率降低之后，再输出。简单理解<strong>分频就是做除法</strong></p></blockquote><h3 id="系统时钟SYSCLK">系统时钟SYSCLK</h3><p>系统时钟SYSCLK可<strong>来源于三个时钟源</strong>：</p><ul><li><strong>HSI振荡器时钟</strong></li><li><strong>HSE振荡器时钟</strong></li><li><strong>PLLCLK时钟</strong></li></ul><h2 id="配置时钟树">配置时钟树</h2><p>STM32CubeMX一般填入指定最大即可</p><p>但对STM32上的时钟，具体怎么配置，根据需求决定。时钟频率选取越高，功耗也会越高。</p><p>所以实际情况中考虑芯片的工作条件，根据芯片运行的工作条件选取时钟频率</p><p>相关AHB、APB1、APB2总线上的时钟工作条件可以在STM32数据手册的通用工作条件模块可以查看到满足的条件</p><h1>中断和异常</h1><p><strong>中断概念</strong>：中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续执行。</p><p><strong>STM32中断触发后流程</strong>：</p><p>触发中断-&gt;中断向量表(存放中断服务函数地址)-&gt;偏移：入口地址</p><p>中断可以分为<strong>内部中断</strong>和<strong>外部中断</strong>：</p><p><strong>外部中断</strong>：STM32说的中断一般指这个外部中断，发生在<strong>处理器外部</strong>连接的设备或外部信号，例如按键按下、外部传感器信号变化等。外部中断用于响应外部事件，并及时处理相关任务。</p><p><strong>异常(内部中断)</strong>：异常和中断概念相近，异常可以说是<strong>内核活动(处理器内部)产生</strong>，比如执行<strong>未定义指令、除零运算</strong>等发生在CPU内部的意外事件。这些异常的发生，会引起CPU运行相应的异常处理程序，因为发生在处理器内部，故叫做<strong>内部中断</strong>。</p><p><strong>注</strong>：中断一般指连接到内核的**外部器件(外设)**产生，。使用一般不严格区分中断和异常，但无论是异常还是中断，都会引起程序执行偏离正常的流程，转而去执行异常/中断的处理函数。</p><h2 id="中断优先级">中断优先级</h2><p><strong>中断优先级分为两种</strong>：</p><ol><li><p><strong>可编程</strong></p></li><li><p><strong>不可编程</strong></p></li></ol><p>STM32的中断优先级，决定着内核优先响应谁的中断请求:</p><ul><li><strong>中断优先级数值越小，优先级越大</strong>，中断会被优先响应</li><li>中断优先级按照<strong>优先级分组</strong>配置</li></ul><blockquote><p>在STM32的芯片参考手册中可以找到中断向量表，里面可找到优先级数值等信息</p></blockquote><h2 id="优先级分组">优先级分组</h2><p>在优先级分组中存在<strong>抢占优先级</strong>和<strong>子优先级</strong></p><p>分组个数和各优先级数值图片：</p><p><a href="https://blog.csdn.net/qq_41066277/article/details/88728661?ops_request_misc=%7B%22request%5Fid%22%3A%22171275025416800215044240%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171275025416800215044240&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-88728661-null-null.142%5Ev100%5Epc_search_result_base5&amp;utm_term=%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E7%BB%84&amp;spm=1018.2226.3001.4187">stm32入门篇–中断的初步认识及其优先级和分组_中断优先级和分组-CSDN博客</a></p><ol><li><p>通过优先级分组，我们可以管理中断的响应顺序</p></li><li><p>只有抢占优先级才具有抢占中断的权限，打断了就发生了<strong>中断嵌套</strong></p></li></ol><blockquote><p><strong>中断嵌套</strong>：中断嵌套是指中断系统正在执行一个中断服务时，有另一个抢占优先级更高的中断提出，这时会暂时终止当前正在执行的级别较低的的，去处理级别更高的中断源，待处理完毕，再返回到被中断了的的过程。</p><p>例如：B中断正在执行，突然发生了A中断，<strong>但是A中断的抢占优先级数值更小比B的更小(数值更小，A抢占优先级更高)</strong>，A中断则抢过B中断的使用权，响应A的中断服务函数，A中断执行完毕后再交回B继续执行。</p></blockquote><ol start="3"><li><p>如果中断抢占优先级相同，将不会发生抢占行为(只能乖乖的排队等待),这就叫做<strong>中断挂起</strong></p></li><li><p>如果多个在挂起状态的中断具有<strong>相同的抢占优先级</strong>，则<strong>子优先级高的先响应</strong>，如果<strong>子优先级也相同</strong>，则由<strong>IRQ编号(中断编号)小的响应</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一些中断编号的定义，一般在芯片头文件中找到，下列为stm32f103xe.h*/</span> </span><br><span class="line">NonMaskableInt_IRQn         = <span class="number">-14</span>,    </span><br><span class="line"> HardFault_IRQn              = <span class="number">-13</span>,   </span><br><span class="line"> MemoryManagement_IRQn       = <span class="number">-12</span>,    </span><br><span class="line"> BusFault_IRQn               = <span class="number">-11</span>,    </span><br><span class="line"> UsageFault_IRQn             = <span class="number">-10</span>,   </span><br><span class="line"> SVCall_IRQn                 = <span class="number">-5</span>,    </span><br><span class="line"> DebugMonitor_IRQn           = <span class="number">-4</span>,    </span><br><span class="line"> PendSV_IRQn                 = <span class="number">-2</span>,     </span><br><span class="line"> SysTick_IRQn                = <span class="number">-1</span>, </span><br></pre></td></tr></table></figure><p><strong>总结</strong>：抢占优先级&gt;子优先级&gt;IRQ编号。</p><ol start="5"><li><strong>可编程的优先级</strong>，可以通过**嵌套向量中断控制器(NVIC)**实现</li></ol><h2 id="NVIC">NVIC</h2><p>NVIC（Nested Vectored Interrupt Controller）-<strong>嵌套向量中断控制器</strong>，是STM32系列微控制器中的中断控制器模块，其主要功能如下：</p><ol><li>中断优先级管理</li><li>中断使能和禁止</li><li>中断嵌套</li><li>中断状态控制</li><li>中断向量表管理</li></ol><p><strong>通常在STM32CubeMX中开启各EXTI线的中断</strong></p><p>有关EXTI和NVIC的介绍：</p><p><a href="https://blog.csdn.net/m0_56694518/article/details/131260526?ops_request_misc=%7B%22request%5Fid%22%3A%22171275275416800186516157%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171275275416800186516157&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-131260526-null-null.142%5Ev100%5Epc_search_result_base5&amp;utm_term=stm32%E5%86%85%E9%83%A8%E4%B8%AD%E6%96%AD&amp;spm=1018.2226.3001.4187">STM32的中断系统详解（嵌入式学习）_stm32中断嵌套-CSDN博客</a></p><h2 id="EXTI">EXTI</h2><p>EXTI(External interrupt/event controller)，是STM32的<strong>外部中断/事件控制器</strong>，是STM32的外设，用于处理外部引脚的中断请求。EXTI模块与NVIC紧密合作，使得处理器能够响应外部事件并执行相应的中断处理程序。</p><p>通过EXTI线，捕获EXTI线事件，并且去生成中断，在中断回调函数中，翻转LED状态，并且<strong>清除EXTI中断标志</strong>(中断标志要清除不然就会一直产生中断)。</p><blockquote><p>使用外部中断模块特性：</p><p>对于STM32来说，想要获取的信号是外部的很快的突发信号。由外部驱动，STM32只能被动读取。</p></blockquote><h2 id="实验">实验</h2><h3 id="外部按键中断控制LED亮灭">外部按键中断控制LED亮灭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (GPIO_Pin == KEY0_Pin) </span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试时发现灯的行为有一些奇怪，比如闪烁，不完全亮等情况会发生，所以需要按键消抖。</p><h3 id="按键消抖">按键消抖:</h3><p>当用户按下一个物理按键时，由于<strong>按键使用的是机械式弹簧片的结构</strong>，通常会导致按键在接通和断开状态之间快速切换，造成一系列的开关状态变化。<strong>这种短暂的状态变化称为按键抖动</strong>。按键抖动可能会导致系统误以为用户进行了多次按键操作，从而引发意外行为或错误。</p><p>抖动时间的长短由按键的机械特性决定，<strong>一般为5ms～10ms</strong>。这是一个很重要的时间参数，在很多场合都要用到。按键稳定闭合时间的长短则是由操作人员的按键动作决定的，一般为零点几秒至数秒。为确保CPU对键的一次闭合仅作一次处理，必须去除键抖动。在键闭合稳定时读取键的状态，并且必须判别到键释放稳定后再作处理。</p><p><strong>按键消抖分为硬件消抖和软件消抖</strong>:</p><ul><li><p>硬件消抖：一般是添加RC滤波电容</p></li><li><p>软件消抖：延时函数按键消抖或者定时器按键消抖或状态机消抖，<strong>消抖时间设置为20ms-100ms即可</strong></p></li></ul><blockquote><p><strong>首先一定要在CubeMX中的按键引脚设置为上拉(pull up)状态，不要设置为浮空输入(no pull up and no pull down)。</strong></p><p><strong>做了按键消抖却失效的原因</strong>：</p><p>按键消抖的有效性通常取决于按键引脚的电气特性，尤其是在没有上拉或下拉电阻的情况下。<strong>没有上拉电阻时，处于浮空输入状态，按键引脚可能会更容易受到电气噪声和抖动等外部环境的影响，从而使消抖无法正常工作。</strong></p></blockquote><h4 id="轮询按键控制LED亮灭-延时消抖">轮询按键控制LED亮灭(延时消抖)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_RESET)<span class="comment">//按下检测!</span></span><br><span class="line">    &#123;</span><br><span class="line">        HAL_Delay(<span class="number">20</span>);<span class="comment">//延时消抖</span></span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_RESET)<span class="comment">//再次确认是否按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_TogglePin(LED_BLUE_GPIO_Port,LED_BLUE_Pin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_RESET)&#123;&#125;;<span class="comment">//松手检测!</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>()<span class="comment">//其他颜色的灯同理...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>优点：代码简单</strong></p><p><strong>缺点：delay会使cpu空等浪费时间</strong></p></blockquote><h4 id="外部中断-定时器消抖-推荐">外部中断+定时器消抖(推荐)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*消抖时间设置为20ms-100ms即可,一般设置为20ms,Pre=7199,arr=199~500*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(GPIO_Pin == KEY1_Pin)</span><br><span class="line">  &#123;</span><br><span class="line">       HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_TIM_Base_Stop_IT(&amp;htim2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_TogglePin(LED_BLUE_GPIO_Port,LED_BLUE_Pin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>优点</strong>：cpu并没有浪费时间</p><p><strong>缺点</strong>：会浪费一个定时器</p><p><strong>注意</strong>：在CubeMX配置时注意上升沿触发还是下降沿触发,可能效果会不同,一般都是<strong>设置下降沿触发</strong>，按下开关为低电平</p></blockquote><blockquote><p><strong>注意</strong>：</p><p><strong>别在中断回调函数中使用延时函数，可能会出现神奇的bug，严重会导致死机</strong></p></blockquote><h4 id="按键状态机消抖">按键状态机消抖</h4><h1>volatile关键字</h1><p><code>volatile关键字作用：</code>避免编译器优化。编译器优化会可以去除无用的繁杂代码，降低代码空间，提升运行效率，但优化后编译器在某些地方可能会弄巧成拙。</p><p><code>例1：</code>空循环延时，编译器就会觉得没什么用浪费时间，会直接给你优化掉</p><p><code>例2：</code></p><p><strong>中断方式下，如果需要访问全局变量，最好把全局变量使用 volatile 来进行修饰，避免编译器对该 变量进行优化。</strong></p><p>具体参考  <a href="https://blog.csdn.net/dengjin20104042056/article/details/107716564">https://blog.csdn.net/dengjin20104042056/article/details/107716564</a>  。</p><p>主函数和中断处理函数相当于两个线程，因为编译器的优化，在一个线程中改变一个全局变量的值，另外一个线程读取到的可能是没有改变前的值，因此需要用 volatile 来标识这个变量，让编译器不优化这个变量的存储（这个变量的值可能因为编译器的优化在寄存器中进行改变，而不是在真 正的内存区间）。这个问题书上在中断这部分也说明了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> A;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    A...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span><br><span class="line">&#123;</span><br><span class="line">    A....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>SysTick系统定时器</h1><h2 id="介绍">介绍</h2><p>SysTick系统定时器(又叫系统滴答定时器)是属于 Cortex-M3 <strong>内核中的一个外设，内嵌在 NVIC中</strong>。系统定时器是一个计数宽度24bit的向下递减的计数器，计数器每计数一次的时间为 1/SYSCLK，一般我们设置系统时钟 SYSCLK等于72M。<strong>当重装载数值寄存器的值递减到 0 的时候，系统定时器就产生一次中断，以此循环往复</strong>。</p><p>因为 SysTick 是属于 CM3 内核的外设，所以所有基于 Cortex-M 内核的单片机都具有这个系统定时器，使得软件在 CM3 单片机中可以很容易的移植。</p><ul><li>计数宽度：24bit来储存数据，2^24=16,777,216</li><li>向下递减：计数器的工作模式</li><li>计数器的工作周期：1/CLKSource，1/72Mhz(每-1的时间为1/72000000)</li></ul><p><strong>常用功能</strong>：</p><ul><li><p>系统定时器一般用于操作系统，用于产生时基，维持操作系统的心跳</p></li><li><p>最常用的功能是计数。比如用来进行微秒、毫秒的延时，以此产生特定时序</p></li></ul><h2 id="寄存器介绍">寄存器介绍</h2><p><a href="https://blog.csdn.net/PORKWOTONLEE/article/details/121154152?ops_request_misc=%7B%22request%5Fid%22%3A%22171309432516800184129019%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=171309432516800184129019&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-121154152-null-null.142%5Ev100%5Epc_search_result_base2&amp;utm_term=Systick%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%BB%8B%E7%BB%8D&amp;spm=1018.2226.3001.4187">第7课【SysTick定时器】中断 系统定时器 寄存器-CSDN博客</a></p><p><strong>HAL库中HAL_Delay是基于SysTick来实现，使用时基源SysTick</strong></p><h2 id="uwTick">uwTick</h2><p><code>uwTick</code> 是 STM32 中用于存储系统运行时间的变量，它在 <code>HAL</code> 库中与滴答定时器（SysTick）一起使用，通常用于实现毫秒级的计时。<code>uwTick</code> 是一个全局变量，保存了从系统启动开始经过的毫秒数，通常用于延时、超时管理或作为定时器的时间基准。</p><h3 id="uwTick的工作原理">uwTick的工作原理</h3><ul><li><code>uwTick</code> 由系统的滴答定时器（SysTick Timer）自动递增。每当 SysTick 定时器触发中断时，<code>uwTick</code> 的值增加 1，表示已经过去了 1 毫秒。</li><li><code>HAL_InitTick()</code> 函数会初始化 <code>uwTick</code>，并确保 SysTick 定时器按照指定的时钟频率（通常是 1ms）定期递增。</li></ul><h3 id="uwTick的使用场景">uwTick的使用场景</h3><ul><li><strong>延时函数</strong>：<code>uwTick</code> 可用于在没有 RTOS 的情况下实现毫秒级的延时函数。</li><li><strong>定时任务</strong>：可以使用 <code>uwTick</code> 来实现周期性定时任务。</li><li><strong>超时管理</strong>：可以通过 <code>uwTick</code> 计算超时，进行时间监控。</li></ul><h3 id="如何配置和使用-uwTick">如何配置和使用 uwTick</h3><p>在 STM32 系列中，<code>uwTick</code> 是由 <code>HAL</code> 库自动管理的，因此你不需要手动操作它，只需配置好 SysTick 定时器，并让它触发 <code>uwTick</code> 的更新。</p><h4 id="初始化">初始化</h4><p>在调用 <code>HAL_Init()</code> 时，<code>HAL_InitTick()</code> 会被自动调用，确保滴答定时器已启用并正确地递增 <code>uwTick</code>。</p><h4 id="读取-uwTick">读取 uwTick</h4><p>你可以直接读取 <code>uwTick</code> 来获取从系统启动以来的毫秒数。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">uint32_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> startTick = uwTick;</span><br><span class="line">    <span class="keyword">while</span> ((uwTick - startTick) &lt; ms)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 等待指定的毫秒数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数可以实现一个简单的延时功能，利用 <code>uwTick</code> 的递增特性来实现时间等待。</p><h4 id="获取系统启动后的时间">获取系统启动后的时间</h4><p><code>uwTick</code> 保存了系统从启动以来经过的毫秒数。如果你需要获取系统的运行时间，可以直接读取 <code>uwTick</code>。</p><p>例如，获取系统启动后的运行时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">getSystemUptime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> uwTick;  <span class="comment">// 返回从启动以来的毫秒数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理溢出问题">处理溢出问题</h4><p><code>uwTick</code> 是一个 32 位无符号整数，因此当它达到最大值（0xFFFFFFFF）时会溢出回 0。一般情况下，你不需要担心溢出问题，因为 <code>uwTick</code> 的更新是连续的，你可以通过以下方式避免溢出导致的问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">getTickDiff</span><span class="params">(<span class="type">uint32_t</span> startTick)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (uwTick - startTick);  <span class="comment">// 自动处理溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，你可以计算当前 <code>uwTick</code> 和之前记录的时间差，无论它是否经历了溢出。</p><h3 id="HAL-Delay">HAL_Delay</h3><p>HAL_Delay()函数就是使用系统滴答定时器Systick实现的。</p><h3 id="自定义延时函数">自定义延时函数</h3><p>除了使用 <code>HAL_Delay()</code>，你也可以编写自定义延时函数。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_ms_custom</span><span class="params">(<span class="type">uint32_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> start_tick = uwTick;</span><br><span class="line">    <span class="keyword">while</span> ((uwTick - start_tick) &lt; ms) &#123;</span><br><span class="line">        <span class="comment">// 可以放置其他任务或者空闲等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><ul><li><strong>定时精度</strong>：<code>uwTick</code> 的精度依赖于系统时钟频率，如果系统时钟较低，延时精度可能不如高精度时钟。</li><li><strong>溢出</strong>：<code>uwTick</code> 是一个 32 位计数器，每 49.7 天会溢出一次。大部分应用场景中不需要特别处理溢出问题，除非你需要精确计时更长时间段。</li><li><strong>RTOS 与 <code>uwTick</code></strong>：如果使用 RTOS（如 FreeRTOS），<code>uwTick</code> 可以作为 RTOS 内部定时器的基础，进行任务调度和延时处理。</li></ul><h2 id="uwTick与硬件定时器外设区别">uwTick与硬件定时器外设区别</h2><h3 id="uwTick-2">uwTick</h3><ul><li><strong>来源</strong>：<code>uwTick</code> 是由 <strong>SysTick 定时器</strong>（系统定时器）更新的全局变量，通常用于提供一个基于毫秒的系统时基。它是由 STM32 的 <strong>Cortex-M 内核</strong>提供，通常用于时间管理和简单的延时。</li><li><strong>精度</strong>：<code>uwTick</code> 的精度取决于系统时钟频率（通常是 1 毫秒）。对于很多应用场景，这种精度足够了。</li><li><strong>功能</strong>：<code>uwTick</code> 只是一个软件计数器，它每 1 毫秒递增，并通过 SysTick 中断（如果启用）更新。它通常用于：<ul><li>延时操作（比如定时任务、超时控制）。</li><li>简单的时间基准（比如计算系统运行时间）。</li></ul></li><li><strong>优点</strong>：<ul><li>简单易用，尤其是没有 RTOS 时，它可以作为一个基本的定时机制。</li><li>使用非常灵活，可以通过 <code>uwTick</code> 实现延时、超时、周期性任务等功能。</li></ul></li><li><strong>缺点</strong>：<ul><li>只能提供低精度的时间基准（通常为 1 毫秒）。</li><li>不能直接处理复杂的定时器任务，如生成特定频率的 PWM 信号，或者需要高精度计时的应用。</li></ul></li></ul><h3 id="硬件定时器外设">硬件定时器外设</h3><ul><li><strong>来源</strong>：硬件定时器是 STM32 提供的专用硬件模块，它们可以用来精确地生成定时中断、PWM 输出、计数器等。STM32 通常具有多个定时器外设（如 TIM1、TIM2 等）。</li><li><strong>精度</strong>：硬件定时器的精度非常高，通常由定时器的计数时钟频率（通常是系统时钟或 APB 时钟的一部分）决定，可以达到微秒级别的精度。硬件定时器可以配置为不同的分频因子，以适应不同的应用需求。</li><li><strong>功能</strong>：硬件定时器可以用于：<ul><li>生成高精度的定时中断。</li><li>生成 PWM 波形输出。</li><li>实现高精度延时、时间测量和计数。</li><li>用于编码器、频率测量、信号发生等。</li></ul></li><li><strong>优点</strong>：<ul><li>提供高精度定时。</li><li>不需要依赖系统时钟或软件轮询，硬件定时器直接生成中断，效率较高。</li><li>可以配置为多种不同模式，如 PWM、脉冲计数、输入捕获等。</li></ul></li><li><strong>缺点</strong>：<ul><li>配置较复杂，尤其是在需要多种不同定时器功能时，配置工作量较大。</li><li>受限于硬件资源，每个 STM32 芯片上有固定数量的定时器。</li></ul></li></ul><h3 id="使用场景分析">使用场景分析</h3><h4 id="使用-uwTick-的场景">使用 uwTick 的场景</h4><p><code>uwTick</code> 主要适用于以下场景：</p><ul><li><p><strong>简单的定时器应用</strong>：如延时、超时控制、周期性任务等。如果你的系统不需要极高的定时精度，并且不需要复杂的定时任务管理，<code>uwTick</code> 是一个非常便捷的选择。</p><p>例如：</p><ul><li><strong>延时功能</strong>：你可以用 <code>uwTick</code> 实现简单的延时操作（如延时 1 秒、5 秒等）。</li><li><strong>超时检测</strong>：在没有 RTOS 的情况下，可以用 <code>uwTick</code> 检测外部事件是否超时（如等待串口数据、等待传感器响应等）。</li><li><strong>周期性任务</strong>：比如每 100 毫秒执行一次某些任务，使用 <code>uwTick</code> 来检测时间是否满足周期要求。</li></ul></li><li><p><strong>低精度任务</strong>：当任务不依赖于极高的定时精度时，<code>uwTick</code> 足够满足需求。比如一些简单的 LED 闪烁、定时任务等。</p></li></ul><h4 id="使用硬件定时器外设的场景">使用硬件定时器外设的场景</h4><p>硬件定时器外设适用于以下场景：</p><ul><li><p><strong>高精度定时任务</strong>：如精确的时间测量、频率产生等。硬件定时器可以提供比 <code>uwTick</code> 更高精度的定时，通常是微秒级别。</p><p>例如：</p><ul><li><strong>PWM 生成</strong>：当你需要控制电机、灯光等硬件时，通常需要高精度的 PWM 信号，这时就需要硬件定时器。</li><li><strong>频率计数</strong>：通过硬件定时器的输入捕获功能，可以精确地测量信号的频率。</li><li><strong>精确延时</strong>：对于一些要求非常精确延时的场景，如通信协议中的时序控制，硬件定时器可以提供更高的精度。</li></ul></li><li><p><strong>复杂的定时功能</strong>：如果你需要多个定时器同步运行，或者需要定时器在某个特定事件（如输入信号）时产生中断，硬件定时器会是一个更合适的选择。</p></li><li><p><strong>RTOS 应用</strong>：在 RTOS 环境中，硬件定时器通常用于管理任务的时间片，或者作为周期性任务的时基。</p></li><li><p><strong>硬件事件捕捉</strong>：硬件定时器支持的输入捕获模式使得它可以捕捉外部信号的事件，如测量脉冲宽度、时间间隔等。</p></li></ul><h3 id="总结对比表">总结对比表</h3><p><img src="../assets/image-20250117235719124-17375302847761.png" alt="image-20250117235719124"></p><h1>通讯概念</h1><h2 id="通讯方式">通讯方式</h2><p>通讯方式分类：</p><ul><li><strong>串行通讯和并行通讯</strong></li></ul><p>按数据传送的方式，通讯可分为串行通讯与并行通讯，<strong>串行通讯是指设备之间通过少量数据信号线 (一般是 8 根以下)，地线以及控制信号线，按数据位形式一位一位地传输数据的通讯方式</strong>。<strong>并行通讯一般是指使用 8、16、32 及 64 根或更多的数据线进行传输的通讯方式，并行通讯就像多个车道的公路，可以同时传输多个数据位的数据</strong>。而串行通讯，而串行通讯就像单个车道的公路，同一时刻只能传输一个数据位的数据。</p><p><strong>一般情况下，串行通讯成本更低(节省数据线),且通讯距离、抗干扰能力较强，但传输速率较慢</strong></p><ul><li><p><strong>全双工通讯、半双工、单工通讯</strong></p><ul><li>全双工 ：在同一时刻，两个设备之间可以同时收发数据</li><li>半双工：在同一时刻，两个设备之间可以收发数据，但不能在同一时刻进行</li><li>单工 ：在任何时刻都只能进行一个方向的通讯，即一个固定为发送设备，另一个固定为接收设备</li></ul></li><li><p><strong>同步通讯和异步通讯</strong></p></li></ul><p>根据<strong>通讯的数据同步方式</strong>，又分为同步和异步两种，可以根据通讯过程中<strong>是否有使用到时钟信号</strong>进行简单的区分，<strong>使用时钟信号的叫同步通讯，未使用时钟信号则叫异步通讯</strong>。</p><p>在同步通讯中，收发设备双方会使用一根信号线表示时钟信号，在时钟信号的驱动下双方进行协调，同步数据，<strong>通讯中通常双方会统一规定在时钟信号的上升沿或下降沿对数据线进行采样</strong>。</p><h2 id="通讯速率">通讯速率</h2><p>衡量通讯性能的一个非常重要的参数就是通讯速率，通常以<strong>比特率</strong> (Bitrate) 来表示，即<strong>每秒钟传输的二进制位数，单位为比特每秒 (bit/s)</strong>。</p><p>容易与比特率混淆的概念是“<strong>波特率</strong>”(Baudrate)，它表示<strong>每秒钟传输了多少个码元</strong>。而码元是通讯信号调制的概念，通讯中常用时间间隔相同的符号来表示一个二进制数字，这样的信号称为<strong>码元</strong>。如常见的通讯传输中，用 0V 表示数字 0，5V 表示数字 1，那么一个码元可以表示两种状态 0 和 1，所以<strong>一个码元等于一个二进制比特位，此时波特率的大小与比特率一致</strong>；如果在通讯传输中，有 0V、2V、4V 以及 6V 分别表示二进制数 00、01、10、11，那么<strong>每个码元可以表示四种状态，即两个二进制比特位，所以码元数是二进制比特位数的一半，这个时候的波特率为比特率的一半。</strong></p><p>因为很多常见的通讯中一个码元都是表示两种状态，人们常常直接以波特率来表示比特率，虽然严格来说没什么错误，但不能混淆。</p><h1>USART</h1><p><a href="https://blog.csdn.net/qq_43743762/article/details/97811470?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stm32usart%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-97811470.142%5Ev100%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187">STM32—串口通讯详解_串口通讯的原理流程图-CSDN博客</a></p><p><a href="https://blog.csdn.net/as480133937/article/details/99073783">【STM32】HAL库 STM32CubeMX教程四—UART串口通信详解_hal_uart_transmit-CSDN博客</a></p><p><a href="https://blog.csdn.net/fuhanghang/article/details/123280368?ops_request_misc=%7B%22request%5Fid%22%3A%22171370716116800226596446%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171370716116800226596446&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-123280368-null-null.142%5Ev100%5Epc_search_result_base8&amp;utm_term=CH340%E8%8A%AF%E7%89%87&amp;spm=1018.2226.3001.4187">ch340是什么芯片_ch340是干嘛的-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_59161987/article/details/128480063">STM32 —— USB 转 TTL（CH340）-CSDN博客</a></p><h2 id="概念">概念</h2><p>USART-通用同步/异步收发器(Universal Synchronous/Asynchronous Receiver/Transmitter)，USART是一个全双工通用同步/异步串行收发模块，该接口是一个高度灵活的串行通信设备。</p><blockquote><ul><li>STM32中的USART外设可以实现<strong>同步传输</strong>功能，所以命名为USART，比UART多了一个S，即synchronous(同步)</li></ul></blockquote><p>UART器件<strong>主要用来产生相关接口的协议信号</strong>，如<code>TTL串口</code> /<code>RS232</code>/<code>RS485</code>等<strong>串行接口标准规范和总线的标准规范</strong>，要使用传输数据的这些接口，就要按照接口规定的协议信号发送数据。所以<strong>UART期间广泛应用于串口通信中，扮演者传输者的角色</strong>。</p><h2 id="功能">功能</h2><p>STM32的串口通常用于与其他设备进行通信。</p><p><strong>它可以用于与计算机、其他微控制器、传感器、显示屏或其他外围设备进行数据传输</strong>。串口通常用于发送和接收数据，可以是文本、二进制数据或其他格式。</p><p><strong>常见的应用</strong>：</p><p>通过<strong>串口进行调试、控制外部设备、传感器数据采集和与外部设备进行通信等</strong>。串口通常是嵌入式系统中基本且常用的通信接口之一。</p><h2 id="串口接受与发送">串口接受与发送</h2><p>在 <strong>stm32f4xx_hal.c</strong>中包含#include &lt;stdio.h&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> UART_HandleTypeDef huart1;   <span class="comment">//声明串口</span></span><br></pre></td></tr></table></figure><p><strong>重定向printf函数：</strong></p><p>在 <strong>stm32f4xx_hal.c</strong> 中重写fget和fput函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数功能: 重定向c库函数printf到DEBUG_USARTx</span></span><br><span class="line"><span class="comment">  * 输入参数: 无</span></span><br><span class="line"><span class="comment">  * 返 回 值: 无</span></span><br><span class="line"><span class="comment">  * 说    明：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, (<span class="type">uint8_t</span> *)&amp;ch, <span class="number">1</span>, HAL_MAX_DELAY);</span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数功能: 重定向c库函数getchar,scanf到DEBUG_USARTx</span></span><br><span class="line"><span class="comment">  * 输入参数: 无</span></span><br><span class="line"><span class="comment">  * 返 回 值: 无</span></span><br><span class="line"><span class="comment">  * 说    明：无</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint8_t</span> ch = <span class="number">0</span>;</span><br><span class="line">  HAL_UART_Receive(&amp;huart1, &amp;ch, <span class="number">1</span>, HAL_MAX_DELAY);<span class="comment">//该函数在轮询中会堵塞执行</span></span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * UART_HandleTypeDef *huart      UATR的别名    如 :   </span></span><br><span class="line"><span class="comment">  * UART_HandleTypeDef huart1;   别名就是huart1  </span></span><br><span class="line"><span class="comment">  **pData      需要发送的数据 </span></span><br><span class="line"><span class="comment">  *  Size    发送的字节数</span></span><br><span class="line"><span class="comment">  * Timeout   最大发送时间，发送数据超过该时间退出发送   </span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在main函数中使用printf、getchar、scanf等*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ch = getchar();<span class="comment">//从串口获取单个字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="USART中断">USART中断</h2><p>轮询状态下的串口接收数据会使cpu效率一直查看是否有数据，干不了其他事情，使程序堵塞，效率低下。但如果使用中断发送和接收比较高效,cpu需要处理时会被叫回处理，其他时间可以干其他事情,不会长期占用cpu时间。</p><blockquote><p><strong>轮询模式是阻塞模式，程序会等到所有数据发送/接收完成后才会着向下执行</strong></p><p><strong>而中断和DMA是非阻塞模式，他们将任务交给外设后就会接着向下执行，不会等待数据发送/接收完成</strong></p></blockquote><p><strong>主要有三个函数</strong>：</p><ul><li><strong>串口中断处理函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_IRQHandler(UART_HandleTypeDef *huart);  </span><br></pre></td></tr></table></figure><p><strong>功能</strong>：对接收到的数据进行判断和处理 <strong>判断是发送中断还是接收中断</strong>，然后进行数据的发送和接收，在中断服务函数中使用</p><ul><li><strong>中断接收数据</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span><br></pre></td></tr></table></figure><ul><li><strong>中断发送数据</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span><br></pre></td></tr></table></figure><ul><li><strong>串口接收中断回调函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span><br><span class="line">&#123;</span><br><span class="line">    .......</span><br><span class="line">        </span><br><span class="line">    HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);<span class="comment">//再次开启串口接收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cplt代表 complete完成，代表接收完成后触发中断回调</span></span><br></pre></td></tr></table></figure><p><strong>注意：别忘了在中断回调函数中重新启动接收</strong></p><ul><li><strong>空闲中断idle对应回调函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart2, rData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="keyword">sizeof</span>(rData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ex代表扩展</span></span><br><span class="line"><span class="comment"> * 参数2：size代表接收的数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="实验-2">实验</h2><h3 id="USART1普通中断回显实验">USART1普通中断回显实验</h3><p><strong>主要的函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;haurt1,(<span class="type">uint8_t</span>*)&amp;buffer,<span class="number">1</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数功能: 用于启用串口的接收中断，并指定接收数据存放位置。每当接收到数据时，将触发一个中断，然后调用相应的中断回调函数处理接收数据</span></span><br><span class="line"><span class="comment">  * 输入参数: 一共三个，串口别名，数据存放地址，字节数</span></span><br><span class="line"><span class="comment">  * 返 回 值: 无</span></span><br><span class="line"><span class="comment">  * 说    明：无</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>UART_HandleTypeDef *huart   <strong>UATR的别名</strong>  如 :  UART_HandleTypeDef huart1;  别名就是huart1</li><li>*pData   <strong>接收到的数据存放地址</strong></li><li>Size  <strong>一次接收的字节数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 函数功能: 串口接收中断回调函数，由用户自己编写,当接收到一个或多个字符后会被调用。在这个函数中处理接收到的数据，比如回显到终端或者储存到缓冲区中</span></span><br><span class="line"><span class="comment">  * 输入参数: 无</span></span><br><span class="line"><span class="comment">  * 返 回 值: 无</span></span><br><span class="line"><span class="comment">  * 说    明：无</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">255</span>];</span><br><span class="line"><span class="type">uint8_t</span> bufferCounter=<span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> charBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_RESET);</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_RESET);</span><br><span class="line">  </span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);<span class="comment">//开启串口接收中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_2);</span></span><br><span class="line"><span class="comment">//  HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_3);</span></span><br><span class="line"><span class="comment">//  HAL_Delay(1000);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if(bufferCounter&gt;=255)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//HAL_UART_Transmit(&amp;huart1,(uint8_t * )&quot;数据溢出&quot;,10,HAL_MAX_DELAY);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(huart == &amp;huart1)</span><br><span class="line">&#123;</span><br><span class="line">buffer[bufferCounter++] = charBuffer;</span><br><span class="line">HAL_UART_Transmit(&amp;huart1,&amp;charBuffer,<span class="number">1</span>,HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);<span class="comment">//开启串口中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>每次中断接收一个字节的数据，数据量大会频繁触发中断</p><p>可以改进为一次接收N个字节的数据。</p></blockquote><h3 id="USART2控制LED灯">USART2控制LED灯</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">255</span>];</span><br><span class="line"><span class="type">uint8_t</span> bufferCounter=<span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> charBuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_SET);</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_SET);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请操作小灯：\n1.只有小灯1亮\n2.只有小灯2亮\n3.两个小灯同时亮\n4.两个小灯同时熄灭\n&quot;</span>);</span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);<span class="comment">//开启串口接收中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_2);</span></span><br><span class="line"><span class="comment">//  HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_3);</span></span><br><span class="line"><span class="comment">//  HAL_Delay(1000);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(huart == &amp;huart1)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(charBuffer == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_RESET),</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(charBuffer == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_SET),</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(charBuffer == <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_RESET),</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_2,GPIO_PIN_SET),</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_3,GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1,&amp;charBuffer,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在串口调试助手时，发送1，2，3，4在单片机上可以看到明显的现象</p></blockquote><h1>HAL库函数的一些调用流程</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>HAL_外设名_Init()</span><br><span class="line">-- 该函数一般会调用<span class="number">2</span>函数，实际操作寄存器初始化外设功能，由HAL库实现</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>HAL_外设名_MspInit()</span><br><span class="line">-- 该函数是外设外围相关功能的初始化，比如：引脚、特殊功能比如时钟使能等等，由用户自己实现</span><br></pre></td></tr></table></figure><p><strong>以USART初始化来举例</strong>：</p><ol><li>定义一个UART_HandleTypeDef结构体句柄</li><li>通过HAL_UART_MspInit函数来实现串口外设的底层初始化</li></ol><ul><li><p>要做的功能：</p><ol><li><p>使能UART外设时钟</p></li><li><p>配置UART使用的引脚模式</p></li><li><p>如果要使用中断，就配置中断</p></li><li><p>如果要用DMA，就配置DMA</p></li></ol></li></ul><ol start="3"><li>通过前面定义的结构体具备，来配置串口的波特率、数据字长、停止位、奇偶校验位。</li><li>如果要使用异步模式，则通过调用HAL_UART_Init()函数来将串口配置为异步模式。</li></ol><h1>TIM(定时器)</h1><h2 id="概念-2">概念</h2><p>STM32中的定时器是一种内置的硬件模块，用于<strong>生成精确的时间延迟、执行周期性任务、捕获外部事件</strong>等。<strong>定时器通常用于需要精确时间控制的应用，比如实时操作系统、通信协议、PWM（脉冲宽度调制）生成等</strong>。</p><p><strong>以下常见的几种定时器</strong>:</p><ul><li><strong>高级定时器</strong></li><li><strong>通用定时器</strong></li><li><strong>基本定时器</strong></li></ul><p><strong>定时器的常见作用</strong>：</p><ol><li><strong>计时器模式（Timer Mode）</strong>：定时器可以作为简单的计时器，用于生成一段时间延迟。你可以设置定时器的计数值和时钟频率来控制延迟的精度。</li><li><strong>定时器中断（Timer Interrupts）</strong>：定时器可以配置为在计数器达到特定值时生成中断请求。这对于周期性任务执行或时间精确控制非常有用。</li><li><strong>PWM输出（Pulse Width Modulation）</strong>：定时器可以用来生成PWM信号，用于控制电机速度、LED亮度、音频输出等。</li><li><strong>捕获模式（Capture Mode）</strong>：定时器可以捕获外部事件的时间戳，比如测量输入脉冲的周期或脉宽。</li><li><strong>计数器级联（Timer Cascade）</strong>：一些STM32系列的芯片支持多个定时器级联，可以扩展定时器的计数范围或增加功能。</li></ol><p>还有一些相关知识例如:定时器的主从模式</p><p><strong>定时器相关寄存器可以查看参考手册、数据手册等</strong></p><p><strong>还有一些相关知识(定时器的主从模式等)，以下为定时器详细介绍</strong>：</p><p><a href="https://blog.csdn.net/qq_44016222/article/details/123507270?ops_request_misc=%7B%22request%5Fid%22%3A%22171386792116800185878220%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171386792116800185878220&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123507270-null-null.142%5Ev100%5Econtrol&amp;utm_term=stm32%E5%AE%9A%E6%97%B6%E5%99%A8&amp;spm=1018.2226.3001.4187">STM32-定时器详解_stm32定时器-CSDN博客</a></p><h2 id="基于定时器的LED闪烁">基于定时器的LED闪烁</h2><h3 id="CubeMX配置">CubeMX配置</h3><ol><li><p><strong>确定时钟输入</strong>: 这里我们需要一个稳定的时钟输入，以精确的进行定时，因此可以选择内部时钟源。这里以<code>TIM2</code>为例，在CubeMX中将<code>Clock Source</code>选择为<code>Internal Clock</code>, 使用内部时钟源。那么这个内部时钟源是哪来的呢？参考芯片手册。找到时钟源输入频率。<strong>即在CubeMX中配置Clock Source为Internal Clock(内部时钟源)</strong></p></li><li><p><strong>确定预分频值</strong>：预分频值就是指时钟信号输入之后会在这里被分频，也就是降低了输入频率。 假设这里的值设定为2，则最终信号会变成36MHz，也就是计数器每秒会加36M次，很显然这个速度对我们来说还是太大了。 为了便于计算，我这里更倾向于让输出的时钟频率变成10k，这样每0.1ms定时器就加1。</p></li><li><p><strong>确定重装载值</strong>：</p></li></ol><p>当我们在上面分完频后，就很容易计算这里的值应该为多少了。显然，要使定时器100ms触发一次，这里的这个值应该为1000，最后别忘了-1，才是准确的值(从0开始)。<strong>别忘了使能自动重装载enable</strong>。</p><ol start="4"><li><strong>使能定时器中断</strong>：在NVIC中开启TIM中断。</li></ol><blockquote><p><strong>主要涉及三个概念</strong>：</p><ol><li><p><strong>Prescaler(psc)-预分频值</strong>：内部有一个预分频器PSC，简单来说就是分频值</p><p>时钟信号被分频后的频率 F= TCLK/(PSC+1)</p></li><li><p><strong>auto-reload preload(arr)-自动重装载值</strong>：内部有一个自动重装载寄存器，简单来说就是设置计数值上限，最大为65535</p></li><li><p><strong>CNT-计数器</strong>：内部有一个计数器自增，会与自动重装在寄存器比较，当计数值等于自动重装载值arr时，将会触发<strong>更新中断或更新事件</strong>，同时清零计数器</p></li></ol><p><strong>定时器溢出时间 Tout =  (arr+1)/F   =   (arr+1)*(PSC+1) /TCLK</strong></p><p><strong>注意：psc和arr的值配置时都要-1，因为从0开始数</strong></p></blockquote><p><strong>举个例子</strong>：</p><p>​假设时钟源频率为72MHZ，我们设置psc为7200-1=7199，那么得到分频后的时钟频率为10000HZ, 每秒计数10000次，要使定时器0.1s溢出一次，那么1000-1=999次，1000/10000 = 0.1s</p><p><a href="https://blog.csdn.net/as480133937/article/details/99201209">【STM32】HAL库 STM32CubeMX教程六----定时器中断_hal_tim_irqhandler-CSDN博客</a></p><h3 id="函数和业务代码">函数和业务代码</h3><p><strong>主要函数</strong>：</p><p><strong>定时器中断处理函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_IRQHandler(&amp;htim2);</span><br></pre></td></tr></table></figure><p><strong>定时器溢出中断回调函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>;   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在stm32f1xx_it.c中可以找到HAL_TIM_IRQHandler(&amp;htim2);里面调用了这个溢出中断回调函数</span></span><br><span class="line"><span class="comment">  */</span> </span><br></pre></td></tr></table></figure><p><strong>使能定时器中断</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line"><span class="comment">/*使用之前别忘了在setup中使能定时器中断*/</span></span><br></pre></td></tr></table></figure><p><strong>业务代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*定时器中断使能*/</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(htim == &amp;htim2)</span><br><span class="line"> &#123;</span><br><span class="line"> HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_2);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RTC">RTC</h2><p>STM32 微控制器中的 RTC（Real Time Clock，实时时钟）模块是一个低功耗的独立计时器，用于提供精确的时间和日期信息。<strong>RTC 模块设计为即使在主电源关闭的情况下也能继续运行，从而确保时间信息不会丢失。这通常是通过一个备用电池或超级电容来实现的，它能够为 RTC 供电，即便主电源断开</strong>。</p><p>以下是关于 STM32 中 RTC 的一些关键点：</p><ol><li><strong>功能</strong>:<ul><li><strong>提供实时时间</strong>：RTC 可以作为系统时钟，提供准确的小时、分钟、秒等。</li><li><strong>日历功能</strong>：除了时间，RTC 还可以提供年、月、日等日期信息。</li><li><strong>闹钟功能</strong>：可以设置特定时间触发中断，用于定时唤醒或其他用途。</li><li><strong>定时任务</strong>：可用于执行定期的任务或事件。</li></ul></li><li><strong>硬件特性</strong>:<ul><li>低功耗设计：RTC 在低功耗模式下也能工作，适合于电池供电的应用。</li><li>备用电源：通过 VBAT 引脚连接备用电源，保证在主电源断开后仍能维持时间信息。</li><li>时钟源：可以选择多种时钟源，如 LSE (低速外部晶振, 通常为 32.768kHz)、LSI (低速内部 RC 振荡器) 或 HSE (高速外部晶振) 经过分频后的信号。</li></ul></li></ol><h3 id="RTC时钟选择">RTC时钟选择</h3><blockquote><p><strong>RTC设备因为其独特的运行方式（即掉电依旧运行）使用HSE分频时钟或者LSI的时候,在主电源VDD掉电的情况下,这两个时钟来源都会受到影响，资源消耗太大，小小的纽扣电池根本吃不消。</strong></p></blockquote><p>​所以<strong>RTC一般都时钟低速外部时钟LSE</strong>,频率为实时时钟模块中常用的32.768KHz,因为32768 = 2^15,分频容易实现,所以被广泛应用到RTC模块.(在主电源VDD有效的情况下(待机),RTC还可以配置闹钟事件使STM32退出待机模式).</p><blockquote><p><strong>故使用RTC时记得使能LSE的外部晶振，配置时钟树时RTC选择LSE</strong></p></blockquote><h3 id="RTC中断">RTC中断</h3><blockquote><p><strong>秒中断</strong>：<br>这里时钟自带一个秒中断，每当计数加一的时候就会触发一次秒中断，。注意，这里所说的秒中断并非一定是一秒的时间，它是由RTC时钟源和分频值决定的“秒”的时间，当然也是可以做到1秒钟中断一次。我们通过往秒中断里写更新时间的函数来达到时间同步的效果</p><p><strong>闹钟中断</strong>：<br>闹钟中断就是设置一个预设定的值，计数每自加多少次触发一次闹钟中断</p></blockquote><h3 id="CubeMX配置-2">CubeMX配置</h3><blockquote><p>Activate Clock Source 激活时钟源<br>Activate calendar激活日历<br>这两个都要使能，作用也很明显，先是使能时钟源，再使能RTC日历</p><p>RTC_OUT： Not RTC_OUT<br>Tamper： ×</p><p>第一个参数：是否使能tamper引脚作为校正的秒脉冲输出</p><p>第二个参数：是否使能tamper引脚作为RTC入侵检测校验功能</p><p><strong>剩下的就是时间配置</strong></p></blockquote><h3 id="库函数">库函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设置系统时间*/</span></span><br><span class="line">HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, <span class="type">uint32_t</span> Format) </span><br><span class="line"><span class="comment">/*读取系统时间*/</span></span><br><span class="line">HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*设置系统日期*/</span></span><br><span class="line">HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*读取系统日期*/</span></span><br><span class="line"> HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*启动报警功能*/</span></span><br><span class="line">HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*设置报警中断*/</span></span><br><span class="line">HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, <span class="type">uint32_t</span> Format)</span><br><span class="line"><span class="comment">/*报警时间回调函数*/</span></span><br><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_RTC_AlarmAEventCallback</span><span class="params">(RTC_HandleTypeDef *hrtc)</span></span><br><span class="line"><span class="comment">/*写入备份储存器*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_RTCEx_BKUPWrite</span><span class="params">(RTC_HandleTypeDef *hrtc, <span class="type">uint32_t</span> BackupRegister, <span class="type">uint32_t</span> Data)</span></span><br><span class="line"><span class="comment">/*读取备份储存器*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">HAL_RTCEx_BKUPRead</span><span class="params">(RTC_HandleTypeDef *hrtc, <span class="type">uint32_t</span> BackupRegister  </span></span><br><span class="line"><span class="params"></span></span><br></pre></td></tr></table></figure><blockquote><p><strong>参数1</strong>：RTC句柄结构体参数</p><p><strong>参数2</strong>：<strong>RTC_TimeTypeDef</strong> *sTime： 获取RTC时间的结构体</p><p><strong>参数3</strong>： <strong>获取时间的格式</strong><br><strong>RTC_FORMAT_BIN 使用2进制<br>RTC_FORMAT_BCD 使用BCD进制</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Time structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> Hours;            <span class="comment">/*!&lt; Specifies the RTC Time Hour.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Minutes;          <span class="comment">/*!&lt; Specifies the RTC Time Minutes.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Seconds;          <span class="comment">/*!&lt; Specifies the RTC Time Seconds.</span></span><br><span class="line"><span class="comment">                                 This parameter must be a number between Min_Data = 0 and Max_Data = 59 */</span></span><br><span class="line"></span><br><span class="line">&#125; RTC_TimeTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  RTC Date structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span> WeekDay;  <span class="comment">/*!&lt; Specifies the RTC Date WeekDay (not necessary for HAL_RTC_SetDate).</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_WeekDay_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Month;    <span class="comment">/*!&lt; Specifies the RTC Date Month (in BCD format).</span></span><br><span class="line"><span class="comment">                         This parameter can be a value of @ref RTC_Month_Date_Definitions */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Date;     <span class="comment">/*!&lt; Specifies the RTC Date.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 1 and Max_Data = 31 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> Year;     <span class="comment">/*!&lt; Specifies the RTC Date Year.</span></span><br><span class="line"><span class="comment">                         This parameter must be a number between Min_Data = 0 and Max_Data = 99 */</span></span><br><span class="line"></span><br><span class="line">&#125; RTC_DateTypeDef;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实验-实时时间OLED显示">实验-实时时间OLED显示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> realTime[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> realDate[<span class="number">10</span>];</span><br><span class="line">RTC_DateTypeDef GetDate;<span class="comment">//获取日期结构体</span></span><br><span class="line">RTC_TimeTypeDef GetTime;<span class="comment">//获取时间结构体</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    HAL_RTC_GetTime(&amp;hrtc, &amp;GetTime, RTC_FORMAT_BIN);</span><br><span class="line">   <span class="comment">/*分别从RTC获取时间结构体和日期结构体*/</span> HAL_RTC_GetDate(&amp;hrtc,&amp;GetDate,RTC_FORMAT_BIN);</span><br><span class="line">   </span><br><span class="line">    OLED_NewFrame();</span><br><span class="line"><span class="built_in">sprintf</span>(realDate,<span class="string">&quot;%02d/%02d/%02d&quot;</span>,<span class="number">2000</span>+GetData.Year, GetData.Month, GetData.Date);</span><br><span class="line">    <span class="built_in">sprintf</span>(realTime,<span class="string">&quot;%02d:%02d:%02d&quot;</span>,GetTime.Hours, GetTime.Minutes, GetTime.Seconds);</span><br><span class="line"></span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>,realDate ,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">16</span>,realTime ,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RTC掉电重置">RTC掉电重置</h3><h4 id="BKP寄存器">BKP寄存器</h4><p>是在嵌入式系统（如STM32微控制器）中用于在系统掉电或复位时保存数据的特殊寄存器。它们通常用于需要在掉电或复位后保留的重要数据，这些数据在重新上电或复位时能够被恢复。<strong>即使系统复位或电源复位，备份寄存器的内容会保留不变，直到手动修改或在特定条件下被重置</strong>。</p><blockquote><p>BKP寄存器可以在芯片手册中找到</p></blockquote><p><img src="../assets/image-20241008202341686-17375302847772.png" alt="image-20241008202341686"></p><h4 id="解决掉电重置代码">解决掉电重置代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MX_RTC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTC_Init 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END RTC_Init 0 */</span></span><br><span class="line"></span><br><span class="line">  RTC_TimeTypeDef sTime = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  RTC_DateTypeDef DateToUpdate = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN RTC_Init 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END RTC_Init 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initialize RTC Only</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  hrtc.Instance = RTC;</span><br><span class="line">  hrtc.Init.AsynchPrediv = RTC_AUTO_1_SECOND;</span><br><span class="line">  hrtc.Init.OutPut = RTC_OUTPUTSOURCE_NONE;</span><br><span class="line">  <span class="keyword">if</span> (HAL_RTC_Init(&amp;hrtc) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Check_RTC_BKUP */</span></span><br><span class="line">   <span class="comment">/*新增代码处1：*/</span></span><br><span class="line">  <span class="keyword">if</span>(HAL_RTCEx_BKUPRead(&amp;hrtc,RTC_BKP_DR1)!= <span class="number">0x1234</span>)</span><br><span class="line">    <span class="comment">// 读取备份寄存器，检查是否已经初始化过</span></span><br><span class="line">      </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END Check_RTC_BKUP */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize RTC and set the Time and Date</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sTime.Hours = <span class="number">0x19</span>;</span><br><span class="line">    sTime.Minutes = <span class="number">0x0</span>;</span><br><span class="line">    sTime.Seconds = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAL_RTC_SetTime(&amp;hrtc, &amp;sTime, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    DateToUpdate.WeekDay = RTC_WEEKDAY_TUESDAY;</span><br><span class="line">    DateToUpdate.Month = RTC_MONTH_OCTOBER;</span><br><span class="line">    DateToUpdate.Date = <span class="number">0x8</span>;</span><br><span class="line">    DateToUpdate.Year = <span class="number">0x24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HAL_RTC_SetDate(&amp;hrtc, &amp;DateToUpdate, RTC_FORMAT_BCD) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN RTC_Init 2 */</span></span><br><span class="line">    <span class="comment">/*新增代码处2：*/</span></span><br><span class="line">    <span class="comment">// 设置完成后，将标志位写入备份寄存器，标记RTC已初始化,下次开机后将不再初始化</span></span><br><span class="line">    HAL_RTCEx_BKUPWrite(&amp;hrtc,RTC_BKP_DR1,<span class="number">0x1234</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END RTC_Init 2 */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p><strong>检查BKP寄存器值</strong>： 在 <code>USER CODE BEGIN Check_RTC_BKUP</code> 部分，通过 <code>HAL_RTCEx_BKUPRead()</code> 函数读取备份寄存器 <code>RTC_BKP_DR1</code> 的值。我们约定用值 <code>0x1234</code> 来表示RTC已经被初始化。<strong>该值自己约定即可！！！！</strong></p></li><li><p><strong>RTC初始化和时间设置</strong>： 如果读取到的值不是 <code>0x1234</code>，说明RTC未初始化，接着会进行RTC的时间和日期设置。否则，跳过初始化，保留当前时间。</p></li><li><p><strong>保存初始化标志</strong>： 设置完时间后，通过 <code>HAL_RTCEx_BKUPWrite()</code> 将 <code>0x1234</code> 写入 <code>RTC_BKP_DR1</code>，标记RTC已经完成初始化，以便下次重启时检测。</p></li></ol></blockquote><blockquote><p>在 STM32 中，备份寄存器可以使用 <code>RTC_BKP_DR1</code> 到<code>RTC_BKP_DRx</code>（多个寄存器）。上面的例子使用的是 <code>RTC_BKP_DR1</code>，你可以根据需要选择其他备份寄存器。</p></blockquote><h2 id="定时器外部时钟与循迹模块">定时器外部时钟与循迹模块</h2><h3 id="循迹模块">循迹模块</h3><p><strong>作用</strong>：为传送带测速/测距，计算流水线上的货物数量等</p><p><a href="https://www.bilibili.com/video/BV1N94y1u7Uz?spm_id_from=333.788.videopod.sections&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32】动画讲解定时器外部时钟 &amp; 实战传送带测速装置_哔哩哔哩_bilibili</a></p><h3 id="抖动脉冲">抖动脉冲</h3><h3 id="输入滤波器">输入滤波器</h3><h2 id="PWM">PWM</h2><h3 id="概念-3">概念</h3><p><strong>脉冲宽度调制-PWM</strong>，是英文“Pulse Width Modulation”的缩写，简称<strong>脉宽调制</strong>，其实是在利用微控制器的<strong>定时器模块</strong>来生成一种特定频率和占空比的<strong>脉冲信号</strong>，调整脉冲的宽度从而影响功率等。PWM信号是一种周期性的脉冲信号，通过调整脉冲的宽度（高电平时间）可以<strong>模拟模拟信号，控制电机速度、LED亮度、蜂鸣器响度</strong>等。</p><blockquote><p><strong>PWM无非就是一定的频率(周期)，输出不断交替的高低电平信号。</strong></p><p>占空比：高电平在一个周期中占用时间的比重叫做占空比，占空比越大其在宏观上表现的电压也就越大，成线性关系。</p><p>通用或者高级定时器具有输出比较模式，可以通过不断比较<strong>计数器</strong>与<strong>比较寄存器的值</strong>。</p></blockquote><h3 id="相关函数">相关函数</h3><ul><li><strong>启动定时器PWM输出</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_TIM_PWM_Start</span><span class="params">(TIM_HandleTypeDef *htim, <span class="type">uint32_t</span> Channel)</span>;</span><br><span class="line"><span class="comment">/*第一个参数为指向定时器句柄的指针，第二个参数为启动的通道，一个有1，2，3，4共四个,例：TIM_CHANNEL_1*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数返回一个 HAL_StatusTypeDef 类型的值，表示操作的状态。常见的返回值包括：HAL_OK(操作成功)、HAL_ERROR(操作失败)*/</span></span><br></pre></td></tr></table></figure><ul><li><strong>启动PWM输出，并启动比较中断</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_PWM_Start_IT(&amp;htim2);</span><br></pre></td></tr></table></figure><ul><li><strong>修改占空比</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_SetCompare(&amp;htim2, TIM_CHANNEL_1, pwmVal);</span><br><span class="line"><span class="comment">/*或*/</span></span><br><span class="line">__HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, pwmVal);</span><br><span class="line"><span class="comment">/*前两个参数不变，第三个参数为用户占空比，占空比=pwmVal/arr*/</span></span><br><span class="line"></span><br><span class="line">-------------------上下两种都可以----------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">/*它是HAL库中的一个宏，用于快速设置定时器的比较寄存器的值。*/</span></span><br><span class="line">TIM2-&gt;CCR1 = pwmVal </span><br><span class="line">htim2.Instance-&gt;CCR1 = pwmVal</span><br><span class="line"><span class="comment">/*直接修改比较寄存器CCRx的值也可以访问定时器相关寄存器*/</span></span><br></pre></td></tr></table></figure><ul><li><strong>修改PSC或ARR的值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*修改预分频值,PSC寄存器*/</span></span><br><span class="line">htim2.Instance-&gt;PSC = <span class="number">72</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改自动重装载值，ARR寄存器*/</span></span><br><span class="line">htim2.Instance-&gt;ARR = <span class="number">1000</span><span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h3 id="实验-PWM控制LED亮度实现呼吸灯">实验-PWM控制LED亮度实现呼吸灯</h3><p><a href="https://blog.csdn.net/as480133937/article/details/99231677">【STM32】HAL库 STM32CubeMX教程七—PWM输出(呼吸灯)_stm32 hal pwm-CSDN博客</a></p><h4 id="CubeMX配置-3">CubeMX配置</h4><p><strong>第一步</strong>：配置时钟树</p><p><strong>第二步</strong>：选用定时器，这里用TIM2，Clock Source选择内部时钟源，四个独立通道channel任选一个，选择PWM模式(PWM Generation CH1),CH1代表通道1，对应引脚将自动配置为复用模式。</p><blockquote><p>Channel1~4 就是设置定时器通道的功能   (<strong>输入捕获、输出比较、PWM输出、单脉冲模式</strong>)</p></blockquote><p><strong>第三步</strong>：Mode选择PWM mode 1，Pulse(宽度/占空比)先选择0，Fast Mode不使能，通道极性(CH Polarity)配置为Low(<strong>选择Low可以使占空比变为低电平占整个周期的比例</strong>)</p><blockquote><p>PWM mode 1 和 2 区别在于一个是向上计数一个是向下计数，以及频率和占空比是否固定上等</p><p>**CHPolarity的选择上：**当占空比为30%时，如果选择High那么高电平占30%，选择Low那么低电平占30%。</p><p>但一般情况下占空比都是指高电平所占周期的比例</p></blockquote><p><strong>第四步</strong>：设置预分频值和重装载值以及占空比，我设置arr = 100-1，psc = 71，得到的Fpwm = 72000000/7200 = 10000HZ</p><blockquote><p><strong>定时溢出频率即pwm的频率，故Fpwm =  TCLK/(arr+1)*(PSC+1)</strong></p><p><strong>占空比为高电平所占时间与整个周期比例：TIM2-&gt;CCR1/arr</strong></p><p><strong>TIM2-&gt;CCR1是定时器2的比较(捕获)寄存器1可以修改其值来调整占空比</strong></p></blockquote><p><strong>第五步</strong>：生成项目</p><h4 id="业务代码-轮询修改占空比">业务代码(轮询修改占空比)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按键控制LED呼吸灯开关*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="type">uint16_t</span> pwmVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> mode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(pwmVal&lt;<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pwmVal+=<span class="number">1</span>;</span><br><span class="line">            __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_2, pwmVal);</span><br><span class="line">            HAL_Delay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!mode)</span><br><span class="line">            &#123;</span><br><span class="line">                __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_2, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pwmVal)</span><br><span class="line">        &#123;</span><br><span class="line">            pwmVal-=<span class="number">1</span>;;</span><br><span class="line">            __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_2, pwmVal);</span><br><span class="line">            HAL_Delay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!mode)</span><br><span class="line">            &#123;</span><br><span class="line">                __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_2, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_Delay(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">/*此时占空比为0，代表全为低电平，这里的延迟可以使到达最暗或者最亮之后可以持续一会，以便于灯的变化更加顺畅*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(GPIO_Pin == KEY1_Pin)</span><br><span class="line">  &#123;</span><br><span class="line">      HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_TIM_Base_Stop_IT(&amp;htim2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            mode = !mode; <span class="comment">// 注意切换模式要卸载消抖里面，否则可能会出现关不上灯的情况</span></span><br><span class="line">            <span class="comment">// HAL_GPIO_TogglePin(LED_BLUE_GPIO_Port,LED_BLUE_Pin);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>tips</strong>：</p><ul><li>如果感觉灯到达最亮或者最暗的时间比较慢，可以调整一次循环中pwmVal加或减的值，使亮度变化更平滑。</li><li>如果感觉灯到达最亮或者最暗之后的维持的一段时间比较慢(快)，可以修改每一次大循环的延迟，HAL_Delay(200)比较合适</li><li>每一次pwmVal加或减之后有一个HAL_Delay(1),在每次循环迭代中产生一个较小的延迟，因为每一次while循环都是很快的pwmVal+=1的速度远远小于一个pwm输出周期的时间，如果删除它那么占空比将会很快到达0，我们肉眼观察就是瞬间亮了又瞬间灭了，而不会产生亮度慢慢变化的结果，一般设置为1ms即可</li></ul><p><strong>提问：每一个周期不应是有高电平和低电平吗，为什么观察到的不是LED灯一闪一闪的到达最亮或最暗呢？</strong></p><p>那么我们平时见到的LED灯，当它的频率大于50Hz的时候，人眼就会产生视觉暂留效果，基本就看不到闪烁了，而是一个常亮的LED灯，</p><p>你在1秒内，高电平0.5秒，低电平0.5秒，(频率1Hz)如此反复，那么你看到的电灯就会闪烁，</p><p>但是如果是10毫秒内，5毫秒打开，5毫秒关闭，(频率100Hz) 这时候灯光的亮灭速度赶不上开关速度(LED灯还没完全亮就又熄灭了)，由于视觉暂留作用 人眼不感觉电灯在闪烁，而是感觉灯的亮度少了 ，然后占空比在不断变化，所以才会感觉在慢慢变亮和慢慢变暗。</p><h4 id="业务代码-定时器修改占空比">业务代码(定时器修改占空比)</h4><blockquote><p>另外启用了一个定时器修改占空比，数秒内让占空比从0~100。假定5s内，那么0.05s(50ms)增加一占空比，所以PSC = 72-1，ARR = 20000-1。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-10-14.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> pwmVal1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> pwmVal2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> pwmVal3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_1);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3);</span><br><span class="line">    HAL_TIM_Base_Start_IT(&amp;htim4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim-&gt;Instance == TIM4)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通道1的呼吸效果</span></span><br><span class="line">        <span class="keyword">if</span>(!flag1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal1 &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal1 += <span class="number">1</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, pwmVal1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag1 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal1 &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal1 -= <span class="number">1</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, pwmVal1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag1 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通道2的呼吸效果</span></span><br><span class="line">        <span class="keyword">if</span>(!flag2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal2 &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal2 += <span class="number">2</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_2, pwmVal2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag2 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal2 &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal2 -= <span class="number">2</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_2, pwmVal2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag2 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通道3的呼吸效果</span></span><br><span class="line">        <span class="keyword">if</span>(!flag3)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal3 &lt; <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal3 += <span class="number">3</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_3, pwmVal3);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag3 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwmVal3 &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pwmVal3 -= <span class="number">3</span>;</span><br><span class="line">                __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_3, pwmVal3);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag3 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实验-PWM控制无源蜂鸣器">实验-PWM控制无源蜂鸣器</h3><p>通过改变<strong>PWM频率</strong>，可以输出不同频率的方波信号。用这个信号驱动<strong>无源蜂鸣器</strong>，便能播放不同频率的声音。</p><h4 id="原理">原理</h4><ul><li>学习板上的蜂鸣器型号为：<strong>QMB-09B-03电磁式无源蜂鸣器</strong>。</li><li>蜂鸣器内部有一个<strong>电磁线圈</strong>，能够驱动<strong>振动膜片</strong>发出声音。通过PWM给蜂鸣器提供不同频率的信号，即可发出不同频率的声音</li><li>实际操作中，除了控制<strong>PWM频率</strong>，还需要控制<strong>PWM占空比</strong>，以使膜片振动趋近于正弦波，从而发出清脆明亮的声音。在学习板上，使用<strong>20%占空比</strong>可以有较好的响度和音质</li></ul><h4 id="CubeMX配置-4">CubeMX配置</h4><blockquote><ol><li><strong>配置Debug，打开外部晶振，配置时钟树</strong></li><li><strong>配置对应按键输入模式，上拉等</strong></li><li><strong>找到蜂鸣器对应的TIM引脚和通道，勾选对应TIM内部时钟，对应通道选择PWM生成模式</strong></li><li><strong>TIM参数：PSC = 72-1 ARR = 按照要求或随意</strong></li></ol></blockquote><h4 id="业务代码">业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim4,TIM_CHANNEL_4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// KEY1按下: 输出2kHz声波</span></span><br><span class="line">    <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_Delay(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            htim4.Instance-&gt;ARR = <span class="number">500</span>;<span class="comment">// 2kHz = 72MHz / 72 / 500</span></span><br><span class="line">            __HAL_TIM_SET_COMPARE(&amp;htim4, TIM_CHANNEL_4, <span class="number">500</span>/<span class="number">5</span>);<span class="comment">// 设置占空比为20%</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2按下: 输出3kHz声波</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY2_GPIO_Port,KEY2_Pin) == GPIO_PIN_RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_Delay(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span> (HAL_GPIO_ReadPin(KEY2_GPIO_Port,KEY2_Pin) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            htim4.Instance-&gt;ARR = <span class="number">334</span>; <span class="comment">// 3kHz = 72MHz / 72 / 334</span></span><br><span class="line">            __HAL_TIM_SET_COMPARE(&amp;htim4, TIM_CHANNEL_4, <span class="number">1000</span>/<span class="number">5</span>);<span class="comment">// 设置占空比为20%</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port,KEY1_Pin) == GPIO_PIN_RESET);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 否则: 关闭声波输出</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim4, TIM_CHANNEL_4, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验-PWM控制直流电机">实验-PWM控制直流电机</h3><p><strong>直流电机一端通正极，一端通负极就可以旋转,电压越大，旋转也就越快，正负极反过来还可以实现反转</strong></p><h4 id="DRV8833电机驱动模块">DRV8833电机驱动模块</h4><p>通常驱动一个小电机需要几百毫安的电流，但单片机上的I/O口只能支持几毫安的电流，直接接上可能会损坏STM32单片机。所有我们需要一个电机驱动芯片</p><p>，常见的有DRV8833等。</p><p><img src="../assets/image-20240929204303792-17375302847783.png" alt="image-20240929204303792"></p><blockquote><p>一共4个IN口，4个OUT口。其中<strong>N1 IN2与OUT1 OUT2一组，N3 N4与OUT3 OUT4一组</strong>。</p><p>我们可以通过单片机输出PWM到IN1 IN2，来控制OUT1 OUT2的输出来控制电机。IN3 IN4同理，也就是说DRV8833电机芯片可以驱动两个电机。</p><p><strong>SLEPP引脚可以让芯片暂停工作，实现低功耗。</strong></p><p><strong>FAULT的脚可以在出现控制错误时提醒单片机</strong></p><p><strong>VCC和GND脚用于给芯片和电机供电</strong></p></blockquote><blockquote><p><strong>原理</strong></p><p><strong>停止旋转时：</strong></p><p><strong>STM32向IN1输入高电平，向IN2输入低电平时。OUT1输出高电平，OUT2输出低电平，使电机正转。</strong></p><p><strong>STM32向IN1输入低电平，向IN2输入高电平时，OUT1输出低电平，OUT2输出高电平，电机反转</strong>。</p><p><strong>旋转时</strong>：</p><p><strong>IN1、IN2都输入高电平</strong>，OUT1与OUT2都输出低电平，相当于将电机的两根线短路，由于电机内的转子由很多线圈组成，相当于电感，产生反电动势阻碍电流变化，因此电流在整个回路中是缓慢变小消失，这种情况称为<strong>电流慢衰减</strong>。反电动势产生的磁场与定子产生的磁场相互作用，会使电机转子很快的刹停，叫<strong>刹车</strong>。</p><p><strong>IN1、IN2都输入低电平</strong>，DRV8833会将OUT1与OUT2都输出高电平，使得转子电流瞬间释放，这种情况称为<strong>电流快衰减</strong>，相当于将电机的两根线断路，无回路不能形成磁场，此时会随着摩擦力慢慢停下来，叫<strong>滑行</strong>。</p></blockquote><h4 id="原理-2">原理</h4><blockquote><p><strong>正转</strong>：</p><p><strong>IN1             IN2               OUT1          OUT2</strong></p><p><strong>PWM输入     低电平            正转&amp;滑行(快衰减)</strong></p><p>​</p><p>电机一会处于正转一会处于滑行，<strong>PWM占空比越高，正转时间越长</strong>，宏观上来看也就是<strong>电机转速也就越快</strong>。</p><p><strong>IN1             IN2               OUT1          OUT2</strong></p><p><strong>高电平    PWM输入              正转&amp;刹车(慢衰减)</strong></p><p>电机一会处于正转一会处于刹车，<strong>PWM占空比越低，正转时间越长</strong>，宏观上来看也就是<strong>电机转速也就越快</strong>。</p><blockquote><p><strong>滑行和刹车区别</strong>： 都可以实现控制电机转速，区别就在于占空比一个高越快，一个低越快</p><p><strong>应用场景</strong>：</p><ul><li><p>快衰减能够迅速降低电流，故常用于需要快速变化的高动态响应场景。</p></li><li><p>慢衰减电流变化比较平稳，因而比较适合用于平稳运行，降低噪音的场景中</p></li></ul><p><strong>对于小电机来说其实感受不到什么区别</strong></p></blockquote></blockquote><blockquote><p><strong>反转</strong>：</p><p><strong>IN1             IN2               OUT1          OUT2</strong></p><p><strong>低电平     PWM输入           反转&amp;滑行</strong></p><p><strong>IN1             IN2               OUT1          OUT2</strong></p><p><strong>PWM输入     高电平             反转&amp;刹车</strong></p></blockquote><p><strong>注意：占空比过低时，电机可能无法启动</strong></p><h4 id="CubeMX配置-5">CubeMX配置</h4><blockquote><ol><li><strong>配置Debug，打开外部晶振，配置时钟树</strong></li><li><strong>查看对应引脚对应的TIM通道，切换到TIM配置，选择内部时钟源，将对应通道设置为PWM生成模式(一个通道正转，一个通道反转)</strong></li><li><strong>TIM参数配置：PSC = 72-1 ，ARR = 100-1 ，PWM频率变为10000HZ</strong></li><li>其他配置</li><li>生成代码</li></ol></blockquote><h4 id="业务代码-2">业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT_MID 20 <span class="comment">//停止转动</span></span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> speed = <span class="number">0</span>;<span class="comment">//电机转速由counter计算而来</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_TIM_Encoder_Start(&amp;htim1, TIM_CHANNEL_ALL);</span><br><span class="line">    <span class="comment">/*使用旋转编码器控制电机转速*/</span></span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim2, TIM_CHANNEL_1);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim2, TIM_CHANNEL_2);</span><br><span class="line">    <span class="comment">/*启动两个通道*/</span></span><br><span class="line">    </span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1,COUNT_MID);</span><br><span class="line">    <span class="comment">/*设置编码器初始值为20，停止转动*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    counter = __HAL_TIM_GET_COUNTER(&amp;htim1);</span><br><span class="line">    <span class="comment">/*控制编码器count在0~40之间，0~19代表反转,21~40代表正转，离中点越远转速越快,0最快反转,40最快正转*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(counter&gt;<span class="number">60000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        counter = <span class="number">0</span>;</span><br><span class="line">        __HAL_TIM_SET_COUNTER(&amp;htim2,<span class="number">0</span>);<span class="comment">//保持反转最快</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(counter&gt;COUNT_MID*<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        counter = COUNT_MID*<span class="number">2</span>;</span><br><span class="line">        __HAL_TIM_SET_COUNTER(&amp;htim2, COUNT_MID*<span class="number">2</span>);<span class="comment">//保持正转最快</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*控制counter的值在0~40之间*/</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(counter &lt; COUNT_MID)</span><br><span class="line">    &#123;</span><br><span class="line">        speed = (COUNT_MID - counter) * <span class="number">100</span> /  COUNT_MID; <span class="comment">//通过控制counter0~19,使speed映射在0~100之间</span></span><br><span class="line">        </span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_2, speed);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/*反转&amp;滑行*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        speed = (counter - COUNT_MID) * <span class="number">100</span> / COUNT_MID;<span class="comment">//通过控制counter21~40,使speed映射在0~100之间</span></span><br><span class="line">        </span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, speed);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_2, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/*正转&amp;滑行*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;counter:%d&quot;</span>, counter);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line"></span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>最好将该DRV8833模块拆分为单独的.c/.h 实现驱动的编写!!!</strong></p></blockquote><h4 id="驱动库">驱动库</h4><p>DRV8833电机驱动：</p><p><a href="https://led.baud-dance.com/">波特律动LED字模生成器 (baud-dance.com)</a></p><p><strong>可以参照别人写的驱动，自己编写代码!!!</strong></p><h2 id="输入捕获">输入捕获</h2><p><a href="https://www.bilibili.com/video/BV1HM4m1R75B/?spm_id_from=333.788&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32】动画讲解输入捕获 并实现超声波测距_哔哩哔哩_bilibili</a></p><h3 id="概念-4">概念</h3><p><strong>输入捕获</strong>：当定时器输入通道上检测到<strong>上升沿(或者下降沿)时</strong>，立刻将此时计数器的值记录到捕获寄存器中，等待程序稍后读取，并且可以借用另一个输入通道的捕获寄存器进行输入捕获。此种方法不会受到软件运行时间的干扰，更加准确。</p><h3 id="捕获寄存器">捕获寄存器</h3><p>对于通用定时器和高级定时器来说，<strong>每个输入通道</strong>都有它自己的捕获寄存器，。</p><blockquote><p>假设我们启动了输入通道1(TI1FP1)的输入捕获模式，并且设定为上升沿捕获，定时器启动计数后，<strong>若输入到输入通道TI1的信号出现了一个上升沿，边沿检测器立即检测到就会通过TI1FP1传递到捕获寄存器1，捕获寄存器1便立刻将此时计数器的值复制到自身</strong>，如果对此输入捕获开启了中断，就还会触发输入捕获中断，通知程序尽快读取捕获寄存器中的数值，这样就获取到了<strong>上升沿出现时定时器的时刻，当我们再获取下降沿出现时定时器的时刻，就可以获得到高电平持续时间</strong></p><p>但一个输入通道的输入捕获只能进行上升沿捕获或者下降沿捕获，不能设置为双边沿捕获。所以STM32又从TI1上引出了一条线 连接到了<strong>捕获寄存器2</strong>上，这条线就是<strong>TI1FP2</strong>。</p><p><strong>输入捕获的直接模式和间接模式</strong>：<strong>信号从TI1引入</strong>，在自己的捕获寄存器1上进行输入捕获，就叫做<strong>输入捕获的直接模式</strong>。而借用捕获寄存器2进行输入捕获，则叫做<strong>输入捕获的间接模式</strong>。</p><p><strong>TI1和TI2是一对可以相互借用，TI3和TI4是一对可以相互借用</strong></p></blockquote><h3 id="超声波测距介绍">超声波测距介绍</h3><p><strong>超声波测距模块是各种需要测距的产品中常用的一类传感器</strong>：</p><blockquote><p><strong>测距原理</strong>：首先发送一定频率的超声波，超声波遇见被测物体后就会被反射回来，当模块接收到反射回来的超声波后，只要将超声波从发送到接收的时间差乘以声速，再除以2 , 就可以得到超声波测距模块和被测物体的距离了。</p><p>(发送时刻-接受时刻)×声速 ÷ 2 = 距离</p><p>注意：若被测物体和超声波测距模块之间有障碍物，则测得的是障碍物的距离，因而某些场景不适合，但<strong>倒车雷达</strong>等需要对一个范围内进行测距的便非常合适。</p></blockquote><p><strong>超声波测距模块以HC-SR04为例：共有四个引脚</strong></p><blockquote><ul><li><p>VCC</p></li><li><p>GND</p></li><li><p><strong>控制端Trig</strong>：用于触发模块进行测距</p></li><li><p><strong>输出端Echo</strong>：用于测量模块输出的高电平持续时间</p></li></ul><p><strong>原理</strong>：当需要超声波测距时，只需要通过<strong>GPIO口向Trig引脚</strong>发送一个脉冲信号，超声波模块接收到脉冲信号就会向外发送一段超声波，然后模块会将Echo拉高，当模块接收到反射回来的超声波后，Echo会被拉低，<strong>那么Echo高电平持续时间也就是超声波在往返路途中消耗的时间</strong>。</p><p><strong>向Trig引脚发送脉冲信号(启动超声波测距)</strong>：先将GPIO口拉高，等待一会后，再将GPIO口拉低即可，<strong>等待的时间可以查看超声波模块手册(us级别）</strong></p><p><strong>测量Echo上高电平持续时间(得到超声波往返时间)</strong>：使用STM32定时器上的<strong>输入捕获,通过两个输入捕获寄存器的差可以得到高电平持续时间</strong></p></blockquote><h3 id="实验-使用超声波测距">实验-使用超声波测距</h3><h4 id="CubeMX配置：">CubeMX配置：</h4><blockquote><p><strong>CubeMX配置</strong>：</p><p>先启动Debug，开启外部晶振，配置时钟树72MHZ，使用OLED屏幕显示测距，所以打开I2C1。</p><p>查看手册找到控制端Trig和输出端Echo对应引脚，Trig配置为GPIO_Output，Echo配置为TIM1_CH3，并打好对应Label</p><p>然后转到TIM1，选择内部时钟源，配置TIM1的Channel3为输入捕获直接模式(Input Caputure direct mode)，配置Channel4为输入捕获间接模式(indirect)</p><p>转到参数设置：PSC设置为72-1，计数器频率变为1MHZ，每1us计数值+1</p><p>Arr = 65535</p><p><strong>Input Capture Channel 3</strong> ：设置<strong>上升沿检测</strong>，<strong>输入捕获直接模式(direct)</strong>，<strong>捕获寄存器前的分频设置为不分频</strong>，<strong>Input Filter(滤波)为0</strong>，因为没什么抖动所以不用滤波。</p><p><strong>Input Capture Channel 4</strong>：置<strong>下降沿检测</strong>，<strong>输入捕获间接模式(indirect)</strong>，<strong>捕获寄存器前的分频设置为不分频</strong>，<strong>Input Filter(滤波)为0</strong>，</p><p>因为需要使用中断模式，<strong>最后使能TIM1捕获比较中断(TIM1 capture compare interrupt)</strong></p></blockquote><h4 id="函数">函数</h4><p><strong>输入捕获函数启动</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_IC_Start(&amp;htim1, TIM_CHANNEL_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*IC就是input Capture输入捕获的意思*/</span></span><br></pre></td></tr></table></figure><p><strong>输入捕获中断</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_IC_Start_IT(&amp;htim1, TIM_CHANNEL_4);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当下降沿来临时，说明高电平结束，我们需要获取两个输入捕获寄存器的值进行计算，因此需要在通道4捕获完成后,中断通知我们*/</span></span><br></pre></td></tr></table></figure><p><strong>读取捕获寄存器数值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读取对应通道的捕获寄存器值*/</span></span><br></pre></td></tr></table></figure><p><strong>输入捕获中断回调</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在输入捕获完成后将会进入该函数*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>定时器计数值设置</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_SET_COUNTER(&amp;htim1,<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*参数1为对应定时器句柄，参数2为设置的值*/</span></span><br></pre></td></tr></table></figure><h4 id="业务代码-3">业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> upEdge = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> downEdge = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> distance = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_TIM_Base_Start(&amp;htim1);<span class="comment">//启动定时器</span></span><br><span class="line">    HAL_TIM_IC_Start(&amp;htim1, TIM_CHANNEL_3);<span class="comment">//启动上升沿输入捕获</span></span><br><span class="line">    HAL_TIM_IC_Start_IT(&amp;htim1, TIM_CHANNEL_4);<span class="comment">//启动下降沿输入捕获,此处中断启动，因为得到捕获值后要计算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">/*Tig引脚发送脉冲信号：先拉高Trig引脚，等待一段时间后，再拉低     用于启动超声波测距*/</span></span><br><span class="line">    HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_SET);</span><br><span class="line">    HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_RESET);</span><br><span class="line">    <span class="comment">/*重置计数器的值，避免下降沿捕获数值小于上升沿捕获数值*/</span></span><br><span class="line">    __HAL_TIM_SET_COUNTER(&amp;htim1,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*使用显示器*/</span></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line">    <span class="built_in">sprintf</span>(message,<span class="string">&quot;距离：%.2fcm&quot;</span>,distance);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>,<span class="number">0</span>,message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    </span><br><span class="line">    HAL_Delay(<span class="number">500</span>);<span class="comment">//缓慢发送</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在HAL_TIM_IRQHandler中可以发现每次进入中断回调函数前，htim-&gt;Channel都会被重新赋值*/</span></span><br><span class="line">    <span class="comment">/*以表示当前处理的是哪个通道, 注意和之前的HAL_CHANNEL_4是不同的*/</span></span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim1 &amp;&amp; htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_4)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        upEdge = HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_3);</span><br><span class="line">        <span class="comment">/*分别通过两个捕获寄存器得到上升沿对应计数和下降沿对应计数*/</span></span><br><span class="line">        downEdge = HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_4);</span><br><span class="line">        distance = (upEdge - downEdge) * <span class="number">0.034</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/*TIM分频后为1Mhz即1μs一次,声速影响条件较多，这里取340m/s，即0.034cm/us,最后单位为cm*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>启动超声波测距</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">startMeasureDistance</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*Trig引脚发送脉冲信号：先拉高Trig引脚，等待一段时间后，再拉低     用于启动超声波测距*/</span></span><br><span class="line">    HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_SET);</span><br><span class="line">    HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    HAL_GPIO_WritePin(Trig_GPIO_Port,Trig_Pin,GPIO_PIN_RESET);</span><br><span class="line">    <span class="comment">/*重置计数器的值，避免下降沿捕获数值小于上升沿捕获数值*/</span></span><br><span class="line">    __HAL_TIM_SET_COUNTER(&amp;htim1,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计算高电平持续时间和被测物体距离</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在HAL_TIM_IRQHandler中可以发现每次进入中断回调函数前，htim-&gt;Channel都会被重新赋值*/</span></span><br><span class="line">    <span class="comment">/*以表示当前处理的是哪个通道, 注意和之前的HAL_CHANNEL_4是不同的*/</span></span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim1 &amp;&amp; htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_4)</span><br><span class="line">    &#123;</span><br><span class="line">        upEdge = HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_3);</span><br><span class="line">        downEdge = HAL_TIM_ReadCapturedValue(&amp;htim1,TIM_CHANNEL_4);</span><br><span class="line">        distance = (downEdge - upEdge) * <span class="number">0.034</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/*TIM分频后为1Mhz即1μs一次,声速影响条件较多，这里取340m/s，即0.034cm/us,最后单位为cm*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="旋转编码器">旋转编码器</h2><p><strong>概念</strong>：用来测量位置、速度或旋转方向的传感器，当期旋转轴旋转时，其输出端可以输出与<strong>旋转速度和方向对应的方波信号</strong>，读取方波信号的频率和相位信息可以得知<strong>旋转轴的速度和方向</strong>。</p><p><strong>常见的有</strong>：<strong>增量型旋转编码器、绝对型编码器</strong>等</p><p><a href="https://www.bilibili.com/video/BV1f4421U7Uj/?spm_id_from=333.337.search-card.all.click&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32教程】扭扭扭，转转转，轻松掌握编码器！_哔哩哔哩_bilibili</a></p><h3 id="增量型旋转编码器">增量型旋转编码器</h3><h4 id="原理-3">原理</h4><p><strong>增量型旋转编码器一般有A、B两相输出信号</strong>，当旋转编码器没有旋转时，A、B两相均没有电平变化，稳定输出高电平或者低电平。</p><p>当旋转编码器被<strong>顺时针旋转</strong>时，A相会输出一个方波，B相此时也会输出一个方波，但是<strong>B相方波领先A相90度</strong>，也就是B相先产生上升沿/下降沿，稍后A相再产生上升沿/下降沿。也可以说A相上升沿时，B相为高电平，A相为下降沿时，B相为低电平。</p><p>当<strong>逆时针旋转时</strong>，情况相反，<strong>B相方波落后A相90度</strong>，A相上升沿时，B相为低电平，A相为上升沿时，B相为高电平。</p><blockquote><p><strong>这样我们可以</strong>：</p><ol><li>通过计算A相或者B相上升沿或者下降沿的数量来获取旋转编码器的角度。</li><li>可以通过A相边沿时，B相电平的情况得知当前的旋转方向</li></ol><p><strong>注意</strong>：不同旋转方向下A、B相到底谁在前谁在后，也可能根据具体元器件的不同而反过来！！！！</p></blockquote><blockquote><p>查阅旋转编码器的手册中可以看到，20 pulses/360°，即每360读输出20个脉冲，也就是每个脉冲为18°，所以用<strong>脉冲数量乘以18°</strong>就能得到真实的旋转角度</p><p><strong>旋转角度° = 脉冲数量 * 每个脉冲对应的角度</strong></p><p>当然对于旋钮这种用户输入，我们一般只需要知道用户向哪个方向旋转了多大程度就好，不必计算真实角度</p></blockquote><h4 id="实现思路">实现思路</h4><blockquote><p><strong>思路1(中断)</strong>：</p><ol><li><p>将A、B相信号接入到GPIO口后，将A相的GPIO口设置为上升沿(或者下降沿触发中断)，然后再<strong>中断回调</strong>中读取B相GPIO口的电平状态，即可判断旋转方向。</p></li><li><p>同时，根据旋转方向对计数值加1或减1，来记录脉冲数量。</p></li></ol><p><strong>缺点</strong>：</p><p>处理单片机上转的慢的旋钮效果不错，但是处理转的非常快的电机的旋转编码器时，<strong>容易频繁触发中断，导致CPU工作效率低</strong>，还有可能出现软件处理跟不上导致<strong>丢步问题</strong>。</p></blockquote><blockquote><p><strong>思路2(定时器)</strong>:</p><p>通用/高级定时器为增量型编码器准备了<strong>专门的编码器接口</strong>，只要将A、B两相信号同时输入进去就可以实现<strong>正传时计数器自增，反转时计数器自减</strong>。</p><p><strong>那么我们将如何将A、B相信号输入编码器呢？</strong></p><p>编码器两个输入接口其实是早已了解过的TI1FP1和TI2FP2，也就是说我们**直接将A、B相信号接入到定时器的通道1(TI1)和通道2(TI2)，就可以接入到编码器接口，让编码器可以根据A、B相的信号 控制计数器进行增加和减少,**而且还可以利用这两个通道的滤波器与边沿检测器对A、B相信号初步处理</p></blockquote><blockquote><p><strong>编码器接口对上下边沿都很敏感</strong>，对于A、B相上的一组脉冲会计数两次。例如：A相下降沿时，B相为低电平，计数器+1，A相上升沿时，B相为高电平，计数器又+1。反向时同理。</p><p><strong>一句话来说就是：一个脉冲上下降沿都会被计数，一共两次</strong></p></blockquote><h3 id="实验-使用增量型旋转编码器控制小灯亮度">实验-使用增量型旋转编码器控制小灯亮度</h3><h4 id="CubeMX配置-6">CubeMX配置</h4><ol><li><p><strong>配置Debug，打开外部晶振，配置时钟树</strong></p></li><li><p><strong>查阅原理图找到A相、B相、按键找到对应引脚和TIM(该板为TIM1)，配置引脚和TIM</strong></p></li><li><p><strong>由于旋转编码器能自主产生两路信号，故不用配置内部时钟源。直接找到Combined Channels(组合通道)设置，选择为Encoder Mode(编码器模式)，引脚自动被设置。</strong></p></li><li><p><strong>旋转编码器对应定时器参数配置</strong>：</p></li></ol><blockquote><blockquote><p><strong>Counter Settings</strong>:</p><p>PSC：默认为0不分频，由于编码器对上下沿都敏感，此时编码器旋转一次计数为2，如果想要旋转一次计数器计数为1的话，设置PSC = 2-1 (二分频)即可，或者可以在代码中手动对counter值进行修改</p><p>ARR：编码器对应定时器的计数器，保持默认的65535，或设置为想要的值即可</p></blockquote><blockquote><p><strong>Encoder</strong>：</p><p>Encoder Mode：是选择在哪个通道进行计数，如果选择两个通道都计数的话，一个脉冲将会被计数4次，通常配置为TI1即可</p><p>Polarity(极性设置)：类似于有效电平机制，设置下降沿有效，会将此通道波形翻转，如果与平时顺时针增加，逆时针减少不符，可<strong>以修改一个通道的极性即可</strong></p><p>IC Selection(输入捕获)：只能进行直接捕获 走TI1FP1和TI2FP2</p><p>Prescaler Division Ratio(预分频器分频比)：不进行预分频</p><p>Input Filter(输入滤波)：可以设置为最大值15，不滤波其实也没为问题</p></blockquote></blockquote><ol start="5"><li>编码器可以按下当按键使用，配置为输入模式或中断模式都可，注意是否需要开启内部上拉。</li><li>为了实现亮度调节，找到小灯对应的定时器设置(这里为TIM3)，勾选内部时钟源，将通道设置为PWM生成模式(PWM Generation)，PSC = 72-1  ARR = 100-1</li><li>为了使用OLED，打开I2C1</li></ol><h4 id="函数-2">函数</h4><ul><li><strong>编码器启动</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Encoder_Start(&amp;htim1,TIM_CHANNEL_ALL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*参数1：定时器对应结构体句柄*/</span></span><br><span class="line"><span class="comment">/*参数2：对应通道，对于只有一相信号的单相编码器来说，填通道1或2。若有A、B两项以上的，一般填TIM_CHANNEL_ALL，所有通道,其实也就是通道1和2。*/</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取定时器计数值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_GET_COUNTER(&amp;htim1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*内部库使用，能够获取当前的计数器值，编码器旋转时计数值会自增或自减*/</span></span><br></pre></td></tr></table></figure><h4 id="业务代码-4">业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Channel[<span class="number">3</span>] = &#123;TIM_CHANNEL_1, TIM_CHANNEL_2, TIM_CHANNEL_3&#125;;</span><br><span class="line"><span class="type">int</span> ChannelIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*启动编码器，启动小灯的PWM输出*/</span></span><br><span class="line">    HAL_TIM_Encoder_Start(&amp;htim1, TIM_CHANNEL_ALL);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3,TIM_CHANNEL_1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     counter = __HAL_TIM_GET_COUNTER(&amp;htim1);</span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim3, Channel[ChannelIndex], counter);</span><br><span class="line">    <span class="comment">/*每次循环更新encoder定时器的计数值*/</span></span><br><span class="line">    </span><br><span class="line">    OLED_NewFrame();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;counter:%d&quot;</span>, counter);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message, &amp;font16x16, OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_DrawRectangle(<span class="number">0</span>,<span class="number">20</span>,<span class="number">100</span>,<span class="number">12</span>,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_DrawFilledRectangle(<span class="number">1</span>,<span class="number">20</span>,counter,<span class="number">12</span>,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    HAL_Delay(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">/*OLED上显示counter，和进度条*/</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (GPIO_Pin == KEY_ENCODER_Pin)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_TIM_PWM_Stop(&amp;htim3,Channel[ChannelIndex]);</span><br><span class="line">        ChannelIndex = (ChannelIndex+<span class="number">1</span>)%<span class="number">3</span>;</span><br><span class="line">        HAL_TIM_PWM_Start(&amp;htim3,Channel[ChannelIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*实现按下编码器切换小灯，未作消抖处理*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="舵机-SERVO">舵机(SERVO)</h2><p>概念：舵机由于经常用于控制航模船模的舵面而得名，是一种比较简易的伺服电机系统。</p><h3 id="原理-PWM">原理(PWM)</h3><blockquote><p>以SG90为例，可以控制舵机从0°旋转到180°**，查看舵机手册**可以得到0~180°分别对应着500~2500us的高电平时长。</p><p>我们见到的多数舵机通常使用<strong>50HZ</strong>，也就是<strong>周期为20ms的PWM信号</strong>进行控制，因而500us~2500us对应的占空比为：</p><p>500us~2500us/20ms = 2.5%~12.5% -&gt; 0°~180°</p><p>即输出占空比为2.5%时，舵机旋转到0°，输出占空比为7.5%，舵机旋转到90°，输出占空比为12.5%时，舵机旋转到180°</p><p><strong>绝大多数舵机控制的占空比范围都是2.5%~12.5%，因为绝大多数的航模遥控器也是输出这个范围的信号</strong></p></blockquote><p><img src="../assets/99-17375302847784.png" alt="image-20241123213856589"></p><h3 id="实验-使用旋转编码器控制舵机-SG90-旋转">实验-使用旋转编码器控制舵机(SG90)旋转</h3><h4 id="CubeMX配置-7">CubeMX配置</h4><ol><li><strong>配置Debug，打开外部晶振，配置时钟树</strong></li><li><strong>配置好旋转编码器</strong>，PSC默认，ARR设置为20，其余默认即可</li><li>查看手册找到舵机对应TIM，打开内部时钟，配置对应通道的PWM生成模式。</li><li>使用<strong>50HZ</strong>的PWM信号，假设TIM的内部时钟为72MHZ，配置PSC为720-1 ，ARR = 2000-1。</li><li>生成代码</li></ol><blockquote><p>注意：因为旋转编码器20个脉冲对应的是360°，也就是计数40次。而舵机只能旋转180°，所以最大计数值应该设为20</p></blockquote><h4 id="业务代码-5">业务代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COUNT 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[<span class="number">50</span>]</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> duty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// AHT20_Init();</span></span><br><span class="line"></span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_TIM_Encoder_Start(&amp;htim1, TIM_CHANNEL_ALL);</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim4,TIM_CHANNEL_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    counter = __HAL_TIM_GET_COUNTER(&amp;htim1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*占空比(duty cycle)*/</span></span><br><span class="line">    duty = ((((<span class="type">float</span>)counter / MAX_COUNT)*<span class="number">10</span> + <span class="number">2.5</span>)/<span class="number">100.0</span>)*<span class="number">2000</span>;</span><br><span class="line">    <span class="comment">/*定时器最大值为2000,计算占空比为2.5%~12.5%对应的比较寄存器的值*/</span></span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim4, TIM_CHANNEL_3, duty);</span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;counter:%d&quot;</span>, counter);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    HAL_Delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看门狗</h1><h2 id="介绍-2">介绍</h2><p>STM32微控制器中的看门狗外设是一种用于<strong>监视系统运行的外设，它是一种硬件计时器，用于检测系统是否正常运行</strong>。其基本原理是周期性地重置系统，以确保系统在正常情况下能够响应。当系统出现异常情况（如死循环、软件错误等）导致停止响应时，看门狗定时器将超时并执行其预设的动作，例如重置系统或触发中断，从而使系统得以恢复或采取适当的措施。</p><p>在STM32微控制器中，看门狗外设主要分为两种类型：<strong>独立看门狗和窗口看门狗。</strong></p><h2 id="独立看门狗">独立看门狗</h2><p><strong>独立看门狗-IWDG</strong>(Independent Watchdog)：</p><ul><li><strong>特点</strong>： 独立看门狗是一种基本的看门狗类型，本质是一个单独的定时器，独立于主处理器，即使主时钟发生故障仍然有效。</li><li><strong>驱动时钟</strong>：由专用的低速时钟（LSI）驱动（40kHz），由于LSI的时钟频率不精确，故<strong>独立看门狗只适用于对时间精度要求比较低的场合</strong>。</li><li><strong>用途</strong>： <strong>独立看门狗主要用于监视整个系统的运行状态</strong>。当系统出现故障、死锁或其他异常情况时，独立看门狗会在预设的超时时间内未收到系统的喂狗信号时，触发重启操作，以恢复系统的正常运行。</li></ul><blockquote><p>独立看门狗可以简单理解为<strong>一个12位的递减计数器</strong>，看门狗激活后，如果计数器的重装载值递减到0，系统就会产生复位。如果在计数器递减到0之前刷新了计数器值，那么系统就不会产生复位。<strong>这个刷新计数器的过程我们称为&quot;喂狗&quot;</strong></p></blockquote><h3 id="CubeMX配置-8">CubeMX配置</h3><p>LSI时钟并不直接提供给计数器时钟，而是通过一个8位的预分频器寄存器IWDG_PR分频后输入给计数器时钟(具体见STM32xxxx的参考手册IWDG寄存器章节)。</p><blockquote><p>CubeMX配置:</p><p>预分频系数prescaler取值：4、8、16、32、64、128、256。</p><p>溢出时间：Tout = (4*2^pre^ )  / 40 * rl r =  (prescaler/40) *rlr    单位：ms</p><ul><li><p>pre是预分频系数(0-6)，而(4*2^pre^)是prescaler的取值代表4分频、8分频等。</p></li><li><p>rlr是重装载寄存器的值   (12位,rlr&lt;4096,即0xFFF)</p></li><li><p>40KHz为LSI输入时钟频率</p></li><li><p>prescaler/40是分频后的频率的倒数即周期，再乘rlr代表定时器溢出时间</p></li></ul></blockquote><h3 id="相关函数-2">相关函数</h3><p><strong>看门狗初始化函数</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)</span><br></pre></td></tr></table></figure><p><strong>喂狗函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg)</span><br><span class="line">    </span><br><span class="line">举例：  HAL_IWDG_Refresh(&amp;hiwdg);   <span class="comment">//看门狗喂狗</span></span><br></pre></td></tr></table></figure><h2 id="窗口看门狗">窗口看门狗</h2><p><strong>窗口看门狗-WWDG</strong>(Window Watchdog)：</p><ul><li><strong>特点：</strong> 窗口看门狗是一种高级的看门狗类型，它具有两个阈值，即看门狗窗口。只有在这个窗口内喂狗信号才被视为有效，超出窗口范围的喂狗信号会被视为异常。</li><li><strong>驱动时钟</strong>：由APB1时钟(如：36MHZ)分频后得到时钟驱动，通过可配置的时间窗口来检测应用程序非正常的过迟或过早操作。 窗口看门狗最适合那些要求看门狗在精确计时窗口起作用的程序。</li><li><strong>用途：</strong> 窗口看门狗不仅可以监视系统的整体运行状态，还可以检测特定时间段内的系统运行状态。<strong>它可以帮助系统在特定的时间窗口内完成任务，以确保系统的实时性和稳定性</strong>。比如一个程序段正常运行的时间是50ms， 在运行完这个段程序之后紧接着进行喂狗，如果在规定的时间窗口内还没有喂狗，那就说明我们监控的程序出故障了，跑飞了，那么就会产生系统复位，让程序重新运行。</li></ul><blockquote><p>窗口看门狗跟独立看门狗一样，也是一个递减计数器不断的往下递减计数，当减到一个固定值 <strong>0x3F</strong> 时还不喂狗的话，产生复位，这个值叫窗口的下限，是固定的值，不能改变。</p><p>窗口看门狗之所以称为窗口，就是因为<strong>其喂狗时间限制在一个有上下限(上下窗口)的范围内（计数器减到某个值~计数器减到0x3F），在这个范围内才可以喂狗，可以通过设定相关寄存器，设定其上限时间（但是下限是固定的0x3F）</strong></p></blockquote><h3 id="中断">中断</h3><p>相比于独立看门狗，窗口看门狗可以使能中断，如果使能了提前唤醒中断，系统出现问题，喂狗函数没有生效，那么在计数器由减到<strong>0x40 (0x3F+1)</strong>  的时候，<strong>便会先进入中断，之后再递减一次才会复位</strong>。当然你也可以在中断里面喂狗</p><blockquote><p><strong>喂狗的操作，必须要在主循环里，而不能放在定时器中断里</strong>！这是很多初学者容易犯的错误！因为，如果出现了主循环跑飞或者陷入某个死循环，定时器中断可能还在正常运行，定期进入中断喂狗，则看门狗不能复位系统，起不到监测系统正常运行的作用；</p></blockquote><h3 id="配置">配置</h3><blockquote><ol><li><p>预分频系数选择(prescaler)：1、2、4、8</p></li><li><p>window value：上窗口值（要求在0x3F和计数器值之间）</p></li><li><p>free-running downcounter value：向下递减的计数器值，如果不喂狗到0x3F会复位MCU(有7位，取值为0~127)</p></li><li><p>Early wakeup interrupt：Enable使能提前唤醒中断，并开启中断</p></li></ol></blockquote><blockquote><p>若APB1时钟为36MHZ，选择8分频，计数器取最大值127,上窗口设置为126</p><p>分频后 CLK = (APB1CLK/4096)/8 = 1098.63281HZ</p><p>(127-126)/1098.63281 = 0.910ms (递减到上窗口的最短时间)</p><p>(127-0x3F)/1098.63281 =  58.25ms(递减到下窗口的最长时间)</p><p>喂狗窗口期为：0.910ms~58.25ms，超出这个时间没有喂狗那么MCU就会复位</p></blockquote><h3 id="相关函数-3">相关函数</h3><p><strong>看门狗初始化</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_WWDG_Init(WWDG_HandleTypeDef *hwwdg)</span><br></pre></td></tr></table></figure><p><strong>喂狗</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_WWDG_Refresh(WWDG_HandleTypeDef *hwwdg)</span><br></pre></td></tr></table></figure><p><strong>看门狗中断处理函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_WWDG_IRQHandler(WWDG_HandleTypeDef *hwwdg)</span><br></pre></td></tr></table></figure><p><strong>看门狗中断回调函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak <span class="title function_">HAL_WWDG_EarlyWakeupCallback</span><span class="params">(WWDG_HandleTypeDef *hwwdg)</span>;</span><br></pre></td></tr></table></figure><h3 id="实验-3">实验</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建的user.c中*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wwdg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> early_wwdg_flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*中断发生标志位*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setUp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED0_GPIO_Port,LED0_Pin,GPIO_PIN_RESET);</span><br><span class="line">HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(early_wwdg_flag==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,GPIO_PIN_SET);</span><br><span class="line">HAL_WWDG_Refresh(&amp;hwwdg);</span><br><span class="line">        </span><br><span class="line">early_wwdg_flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*清除该标志位，等待下一次中断喂狗,避免一直重复喂狗*/</span></span><br><span class="line">&#125;s</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_WWDG_EarlyWakeupCallback</span><span class="params">(WWDG_HandleTypeDef *hwwdg)</span></span><br><span class="line">&#123;</span><br><span class="line">early_wwdg_flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>设置了一个中断进入标志位，当主循环中检测到进入中断后，则喂狗，避免复位</p><p>烧录到开发板后可以看到，LED1亮起之后熄灭，没有再亮起，代表没有复位，实验成功。</p><p><strong>注意：最好不要在中断回调函数中喂狗</strong></p></blockquote><p><a href="https://blog.csdn.net/as480133937/article/details/99121645">【STM32】HAL库 STM32CubeMX教程五----看门狗(独立看门狗,窗口看门狗)_使用hall库程序跑飞-CSDN博客</a></p><h1>传感器模块</h1><p>传感器元件(光敏电阻/热敏电阻/红外接收管等)的电阻会随外界的模拟量的变化而变化，通过与<strong>定值电阻分压即可得到模拟电压输出，再通过电压比较器进行二值化即可得到数字电压输出</strong>。</p><h1>ADC</h1><h2 id="概述">概述</h2><p>Analog-to-Digital Converter的缩写。指模/数转换器或者模拟/数字转换器。是指将连续变量的<strong>模拟信号</strong>转换为离散的<strong>数字信号</strong>的器件。</p><p>典型的模拟数字转换器将<strong>模拟信号</strong>转换为表示一定比例<strong>电压值的数字信号。</strong></p><p><a href="https://blog.csdn.net/as480133937/article/details/99627062">【STM32】HAL库 STM32CubeMX教程九—ADC_cubemx adc-CSDN博客</a></p><p><strong>重要概念</strong>：</p><ol><li>转换模式：<strong>单次转换模式，连续转换模式，扫描模式，间断模式</strong>等</li><li>ADC单/多通道</li><li>数据左/右对齐</li><li>电压输入范围</li><li>ADC输入通道</li><li>注入通道(和中断类似)，规则通道</li><li>ADC时钟</li><li>外部触发转换(定时器、中断)</li><li>中断触发条件三个：<strong>规则通道转换结束</strong>、<strong>注入通道转换结束</strong>、<strong>模拟看门狗状态位被设置</strong></li><li>DMA触发：只有ADC1和ADC3才可，通常使用ADC都开启DMA</li></ol><h2 id="参数配置">参数配置</h2><p>CubeMX中配置</p><ol><li></li></ol><blockquote><p><strong>ADCs_Common_Settings</strong>:<br><strong>Mode</strong>     ADC_Mode_Independent<br>这里设置为独立模式</p><p>独立模式模式下，双ADC不能同步，每个ADC接口独立工作。所以如果不需要ADC同步或者只是用了一个ADC的时候，应该设成独立模式，多个ADC同时使用时会有其他模式，如双重ADC同步模式，两个ADC同时采集一个或多个通道，可以提高采样率</p><p><strong>Data Alignment</strong> (数据对齐方式): 右对齐/左对齐</p><p>这个上方有讲解，数据的左右对齐</p><p><strong>Scan Conversion Mode</strong>( 扫描模式 ) ：</p><p>如果只是用了一个通道的话，DISABLE就可以了(也只能DISABLE)，如果使用了多个通道的话，会自动设置为ENABLE。 就是是否开启扫描模式</p><p><strong>Continuous Conversion Mode</strong>(连续转换模式)</p><p>设置为ENABLE，即连续转换。如果设置为DISABLE，则是单次转换。两者的区别在于连续转换直到所有的数据转换完成后才停止转换，而单次转换则只转换一次数据就停止，要再次触发转换才可以进行转换</p><p><strong>Discontinuous Conversion Mode</strong>(间断模式)</p><p>因为我们只用到了1个ADC,所以这个直接不使能即可</p><hr><p><strong>ADC_RegularConversionMode(规则通道设置)</strong>:</p><p><strong>Enable Regular Conversions</strong> (启用常规转换模式)</p><p>使能 否则无发进行下方配置</p><p><strong>Number OF Conversion</strong>(转换通道数)   <br>用到几个通道就设置为几<br>多个通道自动使能扫描模式</p><p><strong>Extenal Trigger Conversion Source</strong> (外部触发转换源)</p><p>设定ADC的触发方式:</p><ul><li><p>Regular Conversion launched by software 规则的软件触发 调用函数触发即可</p></li><li><p>Timer X Capture Compare X event 外部引脚触发,</p></li><li><p>Timer X Trigger Out event 定时器通道输出触发 需要设置相应的定时器设置</p></li></ul><hr><p><strong>Rank(转换顺序)</strong>：         <br>这个只修改通道Sampling Time(采样时间)即可，设置为239.5Cycles</p><blockquote><p><strong>不同的采样时间会影响到ADC的转换精度和转换速度。较长的采样时间可以提供更稳定的转换结果，适合高阻抗的信号源，但会增加总的转换时间；而较短的采样时间可以提高转换速度，但可能会降低精度，特别是在处理高阻抗信号时。</strong></p></blockquote><p>多个通道时会有多个Rank，可以设定每个通道的转换顺序<br>ADC总转换时间如下计算：</p><p>TCONV = 采样时间+ 12.5个周期</p><p>当ADCCLK=14MHz(最大)，采样时间为1.5周期(最快)时，TCONV =1.5+12.5=14周期=1μs。</p><p>因此，ADC的最小采样时间1us（ADC时钟=14MHz，采样周期为1.5周期下得到）</p><hr><p><strong>ADC_injected_ConversionMode</strong>(注入通道设置):<br>也就是注入通道的设置，和转换通道没啥太大区别，这里不再详解</p><hr><p><strong>WahchDog</strong>：<br>Enable Analog WatchDog Mode(使能模拟看门狗中断)</p><p>本质也测量值就是超出测量范围或者低于最低范围，启动看门狗</p></blockquote><ol start="2"><li>ADC转换结束中断配置</li><li>ADC 的DMA传输配置</li></ol><h2 id="相关函数-4">相关函数</h2><ul><li>开启ADC的3种模式(轮询模式 中断模式 DMA模式)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_Start(&amp;hadcx);       <span class="comment">//轮询模式开启ADC</span></span><br><span class="line">• HAL_ADC_Start_IT(&amp;hadcx);       <span class="comment">//中断轮询模式开启ADC</span></span><br><span class="line">• HAL_ADC_Start_DMA(&amp;hadcx)；       <span class="comment">//DMA模式开启ADC</span></span><br></pre></td></tr></table></figure><ul><li>关闭ADC的3种模式（轮询模式 中断模式 DMA模式）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_Stop()</span><br><span class="line">• HAL_ADC_Stop_IT()</span><br><span class="line">• HAL_ADC_Stop_DMA()</span><br></pre></td></tr></table></figure><ul><li>读取ADC转换值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_GetValue()</span><br></pre></td></tr></table></figure><ul><li>ADC校准函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADCEx_Calibration_Start()</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通常精度要求时使用，一般添加在初始化ADC之后.</span></span><br><span class="line"><span class="comment"> * 注意F4系列不支持！！！！</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>等待转换结束函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_PollForConversion(&amp;hadc1, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">第一个参数为指定的ADC,第二个参数为最大等待时间</span><br></pre></td></tr></table></figure><ul><li>ADC中断回调函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_ConvCpltCallback()</span><br><span class="line"></span><br><span class="line">转换完成后回调，DMA模式下DMA传输完成后调用</span><br></pre></td></tr></table></figure><ul><li>规则通道以及看门狗的配置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• HAL_ADC_ConfigChannel() 配置规则组通道</span><br><span class="line">• HAL_ADC_AnalogWDGConfig(）</span><br></pre></td></tr></table></figure><h2 id="实验-使用ADC读取电位器电压-单通道">实验-使用ADC读取电位器电压(单通道)</h2><h3 id="电位器介绍">电位器介绍</h3><p><strong>电位器</strong>（Potentiometer）是一种三端的可调电阻器，常用于调节电压、电流或信号强度。它通过转动或滑动一个机械部件（如旋钮或滑杆）来改变电阻值，实现电路中的电压分配或控制。</p><blockquote><ol><li><p><strong>在stm32单片机上使用VOL标注</strong></p></li><li><p>原理图中标注为<strong>Variable resistor（可变电阻）</strong></p></li></ol></blockquote><h3 id="CubeMX配置-9">CubeMX配置</h3><blockquote><ol><li><p>配置Debug，打开外部晶振，配置时钟树。<strong>为了ADC转换结果的准确性，配置时钟树时注意分频后的ADC时钟信号最好不超过14Mhz</strong></p></li><li><p>从原理图中找到对应引脚，查看其对应ADC通道，然后在对应ADC中勾选通道</p></li><li><ul><li>ADC_Settings -&gt; Continuous Conversion Mode设为Enable，使ADC转换持续进行，不需要每次获取之前手动触发转换</li><li>ADC_Regular_ConversionMode -&gt; Rank -&gt; Sampling Time设为239.5 Cycles，最长采样时间，可以获得更稳定的转换结果，采样时间越长，转换结果越准确</li></ul></li><li><p>若有OLED显示等配置即可</p></li><li><p>生成项目</p></li></ol></blockquote><h3 id="业务代码-6">业务代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> message2[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ADValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> voltage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// AHT20_Init();</span></span><br><span class="line"></span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">   <span class="comment">/*启动ADC连续转换*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*ADC读取原始值获取*/</span></span><br><span class="line">     ADValue = HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line"><span class="comment">/*12位精度的ADC，测量范围为0~3.3V,进行电压计算*/</span></span><br><span class="line">    <span class="comment">/*该处电压范围可以在对应原理图上的VOL找到*/</span></span><br><span class="line">    voltage = ADValue * <span class="number">3.3</span> / <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;ADValue:%d&quot;</span>, ADValue);</span><br><span class="line">    <span class="built_in">sprintf</span>(message2, <span class="string">&quot;voltage:%.2fV&quot;</span>, voltage);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>,<span class="number">16</span>,message2,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实验-使用NTC热敏传感器测量温度-单通道">实验-使用NTC热敏传感器测量温度(单通道)</h2><h3 id="NTC介绍">NTC介绍</h3><p><strong>NTC</strong> 是指 <strong>负温度系数热敏电阻</strong>（<strong>Negative Temperature Coefficient thermistor</strong>），是一种随着<strong>温度升高电阻值下降</strong>的热敏电阻器件。它的主要特点是电阻值与温度呈反比关系。</p><h3 id="原理-4">原理</h3><p>NTC热敏电阻本身是一个单独的电阻。在这个电路中，通常会与一个已知电阻（如10kΩ）串联，以形成一个分压器，这样可以通过测量电压来推算出NTC的电阻值。具体来说，NTC传感器的电阻值会随着温度变化而变化，而通过这个分压器电路可以得到一个对应的电压信号。</p><p>单片机上的原理图如下：</p><p><img src="../assets/image-20240927235951857-17375302847795.png" alt="image-20240927235951857"></p><blockquote><p><strong>电路工作原理</strong>：</p><ol><li><strong>NTC与固定电阻串联</strong>：电路中有一个NTC热敏电阻R_ntc和一个已知固定电阻R1串联。</li><li>电源：整个电路连接到一个电源Vcc（例如3.3V）。</li><li><strong>分压器</strong>：在NTC热敏电阻上得到的电压V_ntc 。</li></ol><p><strong>计算步骤</strong>：</p><ol><li><p><strong>通过ADC(12位)读取电压</strong>：ADC测量得到的值adc_value 代表的是在NTC热敏电阻上的电压：V_ntc = (adc_value / 4096 )* Vcc</p></li><li><p><strong>由分压公式</strong>有: V_ntc = (R_ntc/R_ntc+R1 ) * Vcc</p></li></ol><p>R_ntc = R1 * (v_ntc / vcc - v_ntc)</p><ol start="3"><li><strong>将ADC的值带入后简化得到R_ntc的值</strong>：</li></ol><p><strong>R_ntc = R1 * (adc_value / 4096 - adc_value)</strong></p><p><strong>计算公式为</strong>：<br>$$<br>R_{ntc} = R_1*\frac{adValue}{4096-adValue}<br>$$</p></blockquote><blockquote><p>得到R_ntc的值之后，使用B值公式计算出NTC热敏电阻的阻值对应温度T_ntc<br>$$<br>T_{ntc} = \frac{B}{ln\frac{R_{ntc}}{R1}+\frac{B}{T_0}}<br>$$<br>R_ntc：T_ntc温度下通过ADC计算得到的NTC电阻(单位为Ω)</p><p>R1：参考温度下ntc的电阻值(常温25°c，298.15K)</p><p>B：给出的B值(NTC热敏电阻的材料常数，单位K)</p><p>T0：常温(25℃，298.15K)</p></blockquote><h3 id="CubeMX配置-10">CubeMX配置</h3><blockquote><ol><li><p>配置Debug，打开外部晶振，配置时钟树。<strong>为了ADC转换结果的准确性，配置时钟树时注意分频后的ADC时钟信号最好不超过14Mhz</strong></p></li><li><p>从原理图中找到对应引脚，查看其对应ADC通道，然后在对应ADC中勾选通道</p></li><li><ul><li>ADC_Settings -&gt; Continuous Conversion Mode设为Enable，使ADC转换持续进行，不需要每次获取之前手动触发转换</li><li>ADC_Regular_ConversionMode -&gt; Rank -&gt; Sampling Time设为239.5 Cycles，最长采样时间，可以获得更稳定的转换结果，采样时间越长，转换结果越准确</li></ul></li><li><p>若有OLED显示等配置即可</p></li><li><p>生成项目</p></li></ol></blockquote><h3 id="业务代码-7">业务代码</h3><ul><li><strong>通过ADC值计算NTC电阻值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">getResistance</span><span class="params">(<span class="type">uint32_t</span> adValue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (adValue / (<span class="number">4096.0f</span> - adValue)) * <span class="number">10000.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*参数adValue:ADC转换的结果*/</span></span><br><span class="line"><span class="comment">/*10000.f 为串联电阻值大小10KΩ*/</span></span><br><span class="line"><span class="comment">/*返回值：NTC电阻值，浮点数类型，单位Ω*/</span></span><br></pre></td></tr></table></figure><ul><li><strong>通过NTC阻值计算温度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">calTemperature</span><span class="params">(<span class="type">float</span> R)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> B = <span class="number">3950.0f</span>;</span><br><span class="line">    <span class="type">float</span> R1 = <span class="number">10000.0f</span>;</span><br><span class="line">    <span class="type">float</span> T0 = <span class="number">25.0f</span>;</span><br><span class="line">    <span class="keyword">return</span>  B /(<span class="built_in">log</span>(R/R1)+ B/(<span class="number">273.15</span>+T0)) - <span class="number">273.15</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*C语言中log函数就是以e为底数的函数，即lnx*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 参数R：通过adValue计算得到的电阻</span></span><br><span class="line"><span class="comment">  * B：手册上给出的B值常数</span></span><br><span class="line"><span class="comment">  * R1: 串联电阻大小10KΩ</span></span><br><span class="line"><span class="comment">  * T0: 常温25℃</span></span><br><span class="line"><span class="comment">  * 返回值：温度，float类型，单位摄氏度</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">getResistance</span><span class="params">(<span class="type">uint32_t</span> adValue)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">calTemperature</span><span class="params">(<span class="type">float</span> R)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> message2[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> adValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> R = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> temp = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line"></span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    adValue = HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line"></span><br><span class="line">    R  = getResistance(adValue);</span><br><span class="line">    <span class="comment">/*计算当前NTC电阻*/</span></span><br><span class="line">    temp = calTemperature(R);   </span><br><span class="line">     <span class="comment">/*C语言中log函数就是以e为底数的函数，即ln*/</span></span><br><span class="line"></span><br><span class="line">    OLED_NewFrame();</span><br><span class="line">    <span class="built_in">sprintf</span>(message, <span class="string">&quot;ADValue:%d&quot;</span>, adValue);</span><br><span class="line">    <span class="built_in">sprintf</span>(message2, <span class="string">&quot;temp:%.2f&quot;</span>, temp);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>, <span class="number">0</span>, message,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_PrintString(<span class="number">0</span>,<span class="number">16</span>,message2,&amp;font16x16,OLED_COLOR_NORMAL);</span><br><span class="line">    OLED_ShowFrame();</span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>DMA</h1><h2 id="概念-5">概念</h2><p><strong>DMA，全称Direct Memory Access，即直接存储器访问。</strong></p><p><strong>DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输，无须CPU的干预，通过DMA数据可以快速地移动。这就节省了CPU的资源来做其他操作。</strong></p><p><strong>DMA的作用就是实现数据的直接传输，而去掉了传统数据传输需要CPU寄存器参与的环节</strong></p><blockquote><p><strong>一般在 数据量大的时候，频繁进入中断可能会出现问题，此时采用DMA搬运</strong></p><p><strong>DMA是CPU的小助手</strong></p></blockquote><p><a href="https://blog.csdn.net/as480133937/article/details/104827639">【STM32】HAL库 STM32CubeMX教程十一—DMA (串口DMA发送接收)_stm32h7 串口dma 发送 第一次成功-CSDN博客</a></p><h2 id="DMA传输方式">DMA传输方式</h2><ul><li><strong>方法1</strong>：DMA_Mode_Normal，正常模式。</li></ul><p>当一次DMA数据传输完后，停止DMA传送 ，也就是只传输一次</p><ul><li><strong>方法2</strong>：DMA_Mode_Circular，循环传输模式。</li></ul><p>当传输结束时，硬件自动会将传输数据量寄存器进行重装，进行下一轮的数据传输。 也就是多次传输模式</p><h2 id="串口DMA模式与收发不定长数据">串口DMA模式与收发不定长数据</h2><h3 id="DMA模式">DMA模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*只需要将串口中断发送函数改为DMA即可*/</span></span><br><span class="line"></span><br><span class="line">串口DMA发送数据：</span><br><span class="line">HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span><br><span class="line"></span><br><span class="line">串口DMA接收数据：</span><br><span class="line">HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span><br><span class="line"></span><br><span class="line">串口DMA恢复函数</span><br><span class="line">HAL_UART_DMAResume(&amp;huart1)</span><br></pre></td></tr></table></figure><blockquote><p>使用DMA方式时，还是有中断参与其中，RxCpltCallback函数同样是由中断触发，只不过不是串口中断，而是<strong>DMA传输完成中断</strong>，DMA还有的就是<strong>传输过半中断</strong></p></blockquote><h3 id="收发不定长数据-Idle">收发不定长数据-Idle</h3><blockquote><p><strong>收发不定长数据主要依靠IDLE(串口空闲中断)</strong>，所谓<strong>串口空闲中断</strong>就是，中断触发条件与接收的字节数无关，串口无数据接收时不会触发，必须要从接收到第一个数据开售，当RX引脚上无后续数据进入，串口接收从忙碌转为空闲时才会触发。可以认为空闲中断IDLE发生时就是一帧的数据包接收完成了，此时对数据进行分析处理即可。</p><p>一般用于接收大量数据</p></blockquote><ul><li><strong>串口接收数据</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAL_UARTEx_ReceiveToIdle();<span class="comment">//阻塞</span></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_IT();<span class="comment">//中断</span></span><br><span class="line">HAL_UARTEx_ReceiveToIdle_DMA(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size);<span class="comment">//DMA</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ex代表扩展，Idle代表空闲中断</span></span><br><span class="line"><span class="comment"> * 以DMA为例，参数1，2不变，参数3并不是想要接收的长度，而是一次接收的最大长度</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li><strong>空闲中断对应回调函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart2, rData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="keyword">sizeof</span>(rData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ex代表扩展，Idle代表空闲中断</span></span><br><span class="line"><span class="comment"> * 参数2：size代表接收的数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><blockquote><p>使用ReceiveToIdle相关函数时，<strong>不再调用RxCpltCallback回调，而是使用了RxEventCallback进行回调</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="type">uint16_t</span> pwmVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> mode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*首先还是要以Idle，启动中断或DMA模式*/</span></span><br><span class="line">    HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// HAL_UARTEx_ReceiveToIdle_IT(&amp;huart2,rData,50);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart2, rData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="keyword">sizeof</span>(rData));<span class="comment">//再次开启串口DMA或中断接收模式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DMA传输过半中断">DMA传输过半中断</h3><blockquote><p>可以使用IT或DMA方式启动空闲中断，但是使用DMA模式时，除了串口的空闲中断外，<strong>DMA的传输过半中断</strong>也会触发RxEventCallback回调函数，即接收的数据量到达我们设置的最大值的一半时，也会触发这个回调函数，一般场景不适用，但某些场景有用。</p><p>可以通过加大数组长度或关闭DMA传输过半中断解决</p><p>所以一般情况下要关闭DMA传输过半中断</p></blockquote><ul><li><strong>关闭DMA传输过半中断</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__HAL_DMA_DISABLE_IT(&amp;hdma_usart2_rx,DMA_IT_HT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数1：DMA通道的指针地址，上面是usart2的rx通道</span></span><br><span class="line"><span class="comment">//参数2：需要关闭的中断,DMA_IT_HT就是传输过半中断</span></span><br><span class="line"><span class="comment">//每次DMA方式启动时都需要关闭!!!!</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：如果勾选了外设.c/.h文件单独生成，那么需要在usart.h中使用extern DMA_HandleTypeDef hdma_usart2_rx,否则找不到定义</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> DMA_HandleTypeDef hdma_usart2_rx;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> pwmVal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">bool</span> mode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData[<span class="number">10</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);</span></span><br><span class="line"></span><br><span class="line">    HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="number">10</span>);</span><br><span class="line">    __HAL_DMA_DISABLE_IT(&amp;hdma_usart2_rx,DMA_IT_HT);</span><br><span class="line">    <span class="comment">/*关闭DMA半传输中断*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart2)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart2, rData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart2,rData,<span class="keyword">sizeof</span>(rData));</span><br><span class="line">        __HAL_DMA_DISABLE_IT(&amp;hdma_usart2_rx,DMA_IT_HT);</span><br><span class="line">        <span class="comment">/*再次关闭DMA半传输中断*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>蓝牙模块与简易数据包解析</h1><h2 id="蓝牙模块介绍">蓝牙模块介绍</h2><p>蓝牙通信是其常见的无线通信方式之一。蓝牙模块可以帮助STM32实现与其他设备（如手机、电脑、其他蓝牙设备）之间的无线通信。蓝牙模块在STM32系统中可以通过<strong>UART、SPI、I2C</strong>等接口与主控制器连接。</p><p><strong>蓝牙主要分类是</strong>：<strong>经典蓝牙</strong>和<strong>低功耗蓝牙</strong>(Bluetooth Low Energy,<strong>简称BLE</strong>)</p><p><strong>经典蓝牙：一般像耳机这种持续传输数据的</strong></p><p><strong>低功耗蓝牙：间歇性同步数据设备常用于嵌入式，如手环</strong></p><h2 id="协议">协议</h2><p>…</p><h2 id="实验-蓝牙发送数据控制LED-UART">实验(蓝牙发送数据控制LED-UART)</h2><h3 id="简易数据包解析">简易数据包解析</h3><blockquote><p>首先三个小灯、亮灭对应：</p><p>0x01   0x02  0x03        0xFF      0x00</p><p>红灯   绿灯   蓝灯        亮           灭</p><p>例如： 0x01 0x00 0x03 0xFF 代表红灯熄灭，蓝灯亮</p><ul><li><p>指令一般都会有包头，表示一帧数据的开始，这里规定包头为0xAA</p></li><li><p>包头后往往有一位数据包长度，指示此数据包一共多长</p></li><li><p>最后一位为校验和，为前面所有数据的和取<strong>1字节(16进制最后两位)</strong>，当收到数据后自行计算出的结果与数据包中自带的校验位比较，相同则用，不同舍弃</p></li></ul><p>假定:</p><p>AA 09 01 FF 02 FF 03 FF</p><p>AA + 9 +1 + FF + 3 + FF = 3B6  故校验位为B6</p><p>当向蓝色发送数据为</p><p>AA 09 01 FF 02 FF 03 FF B6(校验位) 代表包头0xAA 长度0x09 红灯绿灯蓝灯都亮</p></blockquote><h3 id="蓝牙发送数据控制LED开关">蓝牙发送数据控制LED开关</h3><p><a href="https://www.bilibili.com/video/BV1114y1D7a4/?spm_id_from=333.788&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【keysking的STM32教程】第11集 使用蓝牙模块与简易数据包解析_哔哩哔哩_bilibili</a></p><ul><li>使用<strong>DX-BT24模块(BLE5.1)，实现蓝牙透传通信</strong>，波特率设置为9600</li><li>使用<strong>UART</strong>连接，UARTEx扩展库，实现不定长数据快速传输，不占用CPU资源</li><li>使用DMA通道，实现串口数据的快速传输，不占用cpu资源</li></ul><p>CubeMX配置：<a href="https://docs.keysking.com/docs/stm32/example/UART_BLE_ECHO">【BLE 蓝牙】蓝牙透传通信 | 波特律动 (keysking.com)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rData[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ReceiveData[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart3,ReceiveData,<span class="keyword">sizeof</span>(ReceiveData));</span><br><span class="line">    __HAL_DMA_DISABLE_IT(&amp;hdma_usart3_rx,DMA_IT_HT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    GPIO_PinState state = GPIO_PIN_RESET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(huart == &amp;huart3)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ReceiveData[<span class="number">0</span>] == <span class="number">0xAA</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ReceiveData[<span class="number">1</span>] == Size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">uint8_t</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Size<span class="number">-1</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum += ReceiveData[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sum == ReceiveData[Size<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;Size<span class="number">-1</span>;i+=<span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(ReceiveData[i+<span class="number">1</span>] == <span class="number">0xFF</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            state = GPIO_PIN_SET;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(ReceiveData[i] == <span class="number">0x01</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            HAL_GPIO_WritePin(LED_BLUE_GPIO_Port,LED_BLUE_Pin,state);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(ReceiveData[i] == <span class="number">0x03</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            HAL_GPIO_WritePin(LED_RED_GPIO_Port,LED_RED_Pin,state);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_UART_Transmit_DMA(&amp;huart3, ReceiveData, Size);</span><br><span class="line"></span><br><span class="line">        HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart3,ReceiveData,<span class="keyword">sizeof</span>(ReceiveData));</span><br><span class="line">        __HAL_DMA_DISABLE_IT(&amp;hdma_usart3_rx,DMA_IT_HT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后使用蓝牙调试助手蓝牙，打开微信小程序【大夏无线传输助手】，点击【搜索】，找到 BT24，连接后发送</p><p><strong>注意：切换16进制发送</strong></p></blockquote><h1>IIC</h1><h2 id="介绍-3">介绍</h2><p><strong>I²C(Inter－Integrated Circuit)总线</strong>是一种由<a href="https://so.csdn.net/so/search?q=NXP&amp;spm=1001.2101.3001.7020">NXP</a>（原PHILIPS）公司开发的两线式串行总线，用于连接微控制器及其外围设备。多用于主控制器和从器件间的主从通信，在小数据量场合使用，传输距离短，主从模式下，任意时刻只能有一个主机等特性，可以有多个从机。</p><p><strong>IIC是一种低速的，半双工，同步</strong>的通信总线 ，常用于连接微控制器与各种外围设备。</p><p>在 STM32 中，I²C 接口可以应用于以下几种场景：</p><blockquote><ol><li><strong>传感器读取</strong>：许多环境传感器（如温度、湿度、加速度等）使用 I²C 作为通信方式。通过 STM32 的 I²C 接口可以轻松地与这些传感器进行数据交换。</li><li><strong>显示模块控制</strong>：一些小型的 <strong>OLED 或 LCD 显示屏</strong>使用 I²C 接口进行命令和数据传输。STM32 可以用来驱动这些显示模块以显示信息或图像。</li><li><strong>音频编解码器</strong>：部分音频编解码芯片使用 I²C 作为配置接口，STM32 可以通过 I²C 配置这些芯片的工作模式，并接收或发送音频信号。</li><li><strong>实时时钟模块（RTC）</strong>：某些 RTC 模块也采用 I²C 接口来同步时间和日期信息，STM32 可以用作主控来更新 RTC 或从 RTC 获取时间。</li><li>…</li></ol></blockquote><blockquote><p><strong>这里要注意IIC是为了与低速设备通信而发明的，所以IIC的传输速率比不上SPI</strong></p></blockquote><p><a href="https://blog.csdn.net/as480133937/article/details/105366932">IIC原理超详细讲解—值得一看-CSDN博客</a>！！！！！！！！</p><h2 id="分类">分类</h2><p><strong>IIC分为软件IIC和硬件IIC</strong></p><p><strong>软件IIC</strong>：软件IIC通信指的是用单片机的两个I/O端口模拟出来的IIC，用软件控制管脚状态以模拟I2C通信波形，软件模拟寄存器的工作方式。</p><p><strong>硬件IIC</strong>：一块硬件电路，硬件I2C对应芯片上的I2C外设，有相应I2C驱动电路，其所使用的I2C管脚也是专用的，硬件（固件）I2C是直接调用内部寄存器进行配置。</p><p>硬件I2C的效率要远高于软件的，而软件I2C由于不受管脚限制，接口比较灵活。</p><h2 id="特点">特点</h2><p>IIC一共有只有两个总线： <strong>一条是双向的串行数据线SDA，一条是串行时钟线SCL</strong>，数据线同时间只能发送或接收数据，故为<strong>半双工通信</strong>。</p><ul><li><p>SDA(Serial data)是数据线，D代表Data也就是数据，Send Data 也就是用来传输数据的。</p></li><li><p>SCL(Serial clock line)是时钟线，C代表Clock 也就是时钟 也就是控制数据发送的时序的</p></li></ul><blockquote><p>所有接到I2C总线设备上的串行数据SDA都接到总线的SDA上，各设备的时钟线SCL接到总线的SCL上。I2C总线上的每个设备都自己一个唯一的地址，来确保不同设备之间访问的准确性。</p></blockquote><h2 id="物理层与协议层">物理层与协议层</h2><ul><li><strong>物理层</strong></li></ul><blockquote><p>I2C 总线在物理连接上非常简单，分别由<strong>SDA(串行数据线)和SCL(串行时钟线)及上拉电阻</strong>组成。</p><p><strong>SCL和SDA都需要接上拉电阻</strong> (大小由速度和容性负载决定一般在3.3K-10K之间) 保证数据的稳定性，减少干扰。</p><p>通信原理：是通过对SCL和SDA线高低电平时序的控制，来产生I2C总线协议所需要的信号进行数据的传递。<strong>在总线空闲状态时，SCL和SDA被上拉电阻Rp拉高，使SDA和SCL线都保持高电平。</strong></p></blockquote><ul><li><strong>协议层</strong></li></ul><blockquote><p>I2C 总线在传送数据过程中共有三种类型信号， 它们分别是：开始信号、结束信号和应答信号。</p><ul><li><p><strong>开始信号</strong>：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。</p></li><li><p><strong>结束信号</strong>：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。</p></li><li><p><strong>应答信号</strong>：每当主机向从机发送完一个字节的数据，主机总是需要等待从机给出一个应答信号，以确认从机是否成功接收到了数据。</p></li></ul><p><strong>应答信号：主机SCL拉高，读取从机SDA的电平，为低电平表示产生应答</strong></p><p><strong>应答信号为低电平时，规定为有效应答位（ACK，简称应答位），表示接收器已经成功地接收了该字节；</strong><br><strong>应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。</strong></p><p><strong>每发送一个字节</strong>（8个bit）在一个字节传输的8个时钟后的第九个时钟期间，接收器接收数据后必须回一个ACK应答信号给发送器，这样才能进行数据传输。</p><p>应答出现在每一次主机完成8个数据位传输后紧跟着的时钟周期，低电平0表示应答，1表示非应答。</p><p><strong>注意：这些信号中，起始信号是必需的，结束信号和应答信号，都可以不要。</strong></p></blockquote><ul><li><strong>时序图</strong></li></ul><p><img src="../assets/image-20241103171954458-17375302847796.png" alt="image-20241103171954458"></p><ul><li><strong>应答</strong></li></ul><p><img src="../assets/image-20241103174539094-17375302847797.png" alt="image-20241103174539094"></p><h2 id="主从">主从</h2><p><strong>主机和从机的概念</strong>：</p><p>主机就是负责整个系统的任务协调与分配，从机一般是通过接收主机的指令从而完成某些特定的任务，主机和从机之间通过总线连接，进行数据通讯。</p><ul><li>发布主要命令的称为主机</li><li>接受命令的称为从机</li></ul><blockquote><p>I2C是一种主从通信协议，允许多个设备连接在同一条总线上。每个从设备都有一个唯一的地址，称为<strong>Slave Address</strong>，以便主设备能够与特定的从设备进行通信。</p><p><strong>Slave Address</strong>是由7位或10位组成的二进制数字，在通信时主设备将此地址发送到总线上，从设备根据地址进行识别。</p></blockquote><blockquote><p>当主设备想要与某个从设备通信时，它会发送从设备的地址。如果从设备检测到自己的地址匹配，它将响应通信请求。主设备可以发送读命令或写命令，以此来从从设备获取数据或向其发送数据。</p><p>例如，假设STM32作为I2C主设备，而一个SSD1306 OLED显示屏作为从设备。SSD1306的I2C地址为<code>0x3C</code>（或<code>0x78</code>表示为8位地址）。主设备通过发送<code>0x3C</code>的地址来选择并与这个显示屏通信。</p></blockquote><h2 id="IIC相关函数">IIC相关函数</h2><h3 id="IIC读写">IIC读写</h3><ul><li><strong>IIC写函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, <span class="type">uint16_t</span> DevAddress, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);</span><br><span class="line"></span><br><span class="line">- hi2c 设置使用的是那个IIC 例：&amp;hi2c2</span><br><span class="line">- DevAddress 写入的地址 设置写入数据的地址 例 <span class="number">0xA0</span></span><br><span class="line">- *pData 需要写入的数据</span><br><span class="line">- Size 要发送的字节数</span><br><span class="line">- Timeout 最大传输时间，超过传输时间将自动退出传输函数</span><br></pre></td></tr></table></figure><ul><li><strong>IIC读函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, <span class="type">uint16_t</span> DevAddress, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);</span><br><span class="line"></span><br><span class="line">- 参数同上</span><br></pre></td></tr></table></figure><ul><li><strong>IIC写数据函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, <span class="type">uint16_t</span> DevAddress, <span class="type">uint16_t</span> MemAddress, <span class="type">uint16_t</span> MemAddSize, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);</span><br><span class="line"><span class="comment">/* 第1个参数为I2C操作句柄</span></span><br><span class="line"><span class="comment">   第2个参数为从机设备地址</span></span><br><span class="line"><span class="comment">   第3个参数为从机寄存器地址</span></span><br><span class="line"><span class="comment">   第4个参数为从机寄存器地址长度</span></span><br><span class="line"><span class="comment">   第5个参数为发送的数据的起始地址</span></span><br><span class="line"><span class="comment">   第6个参数为传输数据的大小</span></span><br><span class="line"><span class="comment">   第7个参数为操作超时时间 　　*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- *hi2c： I2C设备号指针，设置使用的是那个IIC 例：&amp;hi2c2</span><br><span class="line">- DevAddress： 从设备地址 从设备的IIC地址 例E2PROM的设备地址 <span class="number">0xA0</span></span><br><span class="line">- MemAddress： 从机寄存器地址 ，每写入一个字节数据，地址就会自动+<span class="number">1</span>,如果是<span class="number">256</span>K的寄存器，那么就是<span class="number">00</span>~FF</span><br><span class="line">- MemAddSize： 从机寄存器地址字节长度 <span class="number">8</span>位或<span class="number">16</span>位</span><br><span class="line">  写入数据的字节类型 <span class="number">8</span>位还是<span class="number">16</span>位</span><br><span class="line">  <span class="number">8b</span>it:I2C_MEMADD_SIZE_8BIT</span><br><span class="line">  <span class="number">16b</span>it:I2C_MEMADD_SIZE_16BIT</span><br><span class="line">- *pData： 需要写入的的数据的起始地址</span><br><span class="line">- Size： 传输数据的大小 多少个字节</span><br><span class="line">- Timeout： 最大读取时间，超过时间将自动退出函数</span><br><span class="line">      </span><br></pre></td></tr></table></figure><p><strong>8位读写</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Mem_Write(&amp;hi2c2, ADDR, i, I2C_MEMADD_SIZE_8BIT,&amp;(I2C_Buffer_Write[i]),<span class="number">8</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">HAL_I2C_Mem_Read(&amp;hi2c2, ADDR, i, I2C_MEMADD_SIZE_8BIT,&amp;(I2C_Buffer_Write[i]),<span class="number">8</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>16位读写</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Mem_Write(&amp;hi2c2, ADDR, i, I2C_MEMADD_SIZE_16BIT,&amp;(I2C_Buffer_Write[i]),<span class="number">8</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">HAL_I2C_Mem_Read(&amp;hi2c2, ADDR, i, I2C_MEMADD_SIZE_16BIT,&amp;(I2C_Buffer_Write[i]),<span class="number">8</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>与上方写函数区别</strong>：</p><p><strong>IIC写多个数据</strong> 该函数<strong>适用于IIC外设里面还有子地址寄存器的设备，比方说E2PROM,除了设备地址，每个存储字节都有其对应的地址</strong></p><p>**如果只往某个外设中写数据，则用Master_Transmit。　如果是外设里面还有子地址，例如我们的E2PROM，有设备地址，还有每个数据的寄存器存储地址。则用Mem_Write。<br>Mem_Write是2个地  **</p><p><strong>址，Master_Transmit只有从机地址</strong></p></blockquote><h3 id="IIC中断">IIC中断</h3><ul><li><strong>中断和DMA相关函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Master_Transmit_IT(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer));</span><br><span class="line"><span class="comment">/*中断读写*/</span></span><br><span class="line">HAL_I2C_Master_Receive_IT(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Transmit_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"><span class="comment">/*DMA模式读写*/</span></span><br><span class="line">HAL_I2C_Master_Receive_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断回调函数和DMA模式下进入的回调函数相同，都是下面的函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterTxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span>;<span class="comment">//发送回调</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterRxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span>;<span class="comment">//接收回调</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><h2 id="实验-读写EEPROM-AT24C02">实验-读写EEPROM(AT24C02)</h2><p><a href="https://blog.csdn.net/as480133937/article/details/105259075">【STM32】HAL库 STM32CubeMX教程十二—IIC(读取AT24C02 )_hal iic-CSDN博客</a></p><h3 id="EEPROM介绍">EEPROM介绍</h3><p>AT24C02是一个2K Bit的串行EEPROM存储器（掉电不丢失），内部含有256个字节。在<strong>24C02里面有一个8字节的页写缓冲器</strong>。</p><p><img src="../assets/image-20241103234626099-17375302847798.png" alt="image-20241103234626099"></p><blockquote><p>可以通过存储IC的型号来计算芯片的存储容量是多大，比如<strong>24C02后面的02表示的是可存储2Kbit的数据，转换为字节的存储量为2*1024/8 = 256byte。</strong></p><p>那么24C04后面的04表示的是可存储4Kbit的数据，转换为字节的储存量为41024/8 = 512byte，以此来类推其它型号的存储空间。</p></blockquote><h3 id="设备地址">设备地址</h3><p><strong>下图为芯片从地址：</strong></p><p>可以看出对于不同大小的24Cxx，具有不同的从器件地址。由于24C02为2k容量，也就是说只需要参考图中第一行的内容：</p><p><img src="../assets/image-20241103234639611-17375302847799.png" alt="image-20241103234639611"></p><blockquote><p><strong>这些只需要查看对应的手册都能找到</strong></p></blockquote><p><strong>芯片的寻址</strong>：<br>AT24C设备地址为如下，前四位固定为1010，A2~A0为由管脚电平。AT24CXX EEPROM Board模块中默认为接地。所以A2~A0默认为000，最后一位表示读写操作。所以AT24Cxx的读地址为0xA1,写地址为0xA0。</p><p>也就是说如果是<br>写24C02的时候，从器件地址为10100000（0xA0）；<br>读24C02的时候，从器件地址为10100001（0xA1）。</p><p><strong>片内地址寻址</strong>：</p><p>芯片寻址可对内部256Byte中的任一个进行读/写操作，其寻址范围为00~FF，共256个寻址单位。</p><p>对应的修改 A2A1A0 三位数据即可</p><h3 id="写读数据">写读数据</h3><blockquote><p><strong>注意：</strong></p><ol><li><p>在写数据的过程中，<strong>每成功写入一个字节，E2PROM存储空间的地址就会自动加1，当加到0xFF后，再写一个字节，地址就会溢出又变成0x00</strong>。</p></li><li><p><strong>写数据的时候需要注意，E2PROM是先写到缓冲区，然后再“搬运到”到掉电非易失区。所以这个过程需要一定的时间，AT24C02这个过程是不超过5ms！</strong><br>所以，当我们在写多个字节时，写入一个字节之后，再写入下一个字节之前，必须<strong>延时5ms</strong>才可以</p></li></ol></blockquote><p><strong>对应教程</strong>:<a href="https://blog.csdn.net/as480133937/article/details/105259075">https://blog.csdn.net/as480133937/article/details/105259075</a></p><h3 id="CubeMX配置-11">CubeMX配置</h3><blockquote><ol><li>查看芯片手册打开对应I2C外设，参数全部默认即可</li><li>启动对应的串口</li></ol></blockquote><h3 id="代码">代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-11-4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;userCode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i2c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AT24C02_ADDR_WRITE 0xA0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AT24C02_ADDR_READ 0xA1</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> message[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> sendBuffer[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> receiveBuffer[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   HAL_GPIO_WritePin(LED0_GPIO_Port,LED0_Pin,GPIO_PIN_RESET);</span><br><span class="line">   HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,GPIO_PIN_RESET);</span><br><span class="line">   HAL_GPIO_WritePin(LED2_GPIO_Port,LED2_Pin,GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// HAL_UART_Transmit(&amp;huart1,&quot;Hello World&quot;,11,1000);</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      sendBuffer[i] = i;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(HAL_I2C_Mem_Write(&amp;hi2c1,AT24C02_ADDR_WRITE,j*<span class="number">8</span>,</span><br><span class="line">         I2C_MEMADD_SIZE_8BIT,sendBuffer+j*<span class="number">8</span>,<span class="number">8</span>,<span class="number">1000</span>) == HAL_OK)</span><br><span class="line">      &#123;</span><br><span class="line">         HAL_UART_Transmit(&amp;huart1,<span class="string">&quot;Write Test OK\n&quot;</span>,<span class="number">14</span>,<span class="number">1000</span>);</span><br><span class="line">         HAL_Delay(<span class="number">20</span>);<span class="comment">//写数据的时候大于5ms的延时</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         HAL_UART_Transmit(&amp;huart1,<span class="string">&quot;Write Test Failed\n&quot;</span>,<span class="number">18</span>,<span class="number">1000</span>);</span><br><span class="line">         HAL_Delay(<span class="number">20</span>);<span class="comment">//同上</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">      // wrinte date to EEPROM   如果要一次写一个字节，写256次，用这里的代码</span></span><br><span class="line"><span class="comment">      for(i=0;i&lt;BufferSize;i++)</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">          HAL_I2C_Mem_Write(&amp;hi2c1, ADDR_24LCxx_Write, i, I2C_MEMADD_SIZE_8BIT,&amp;WriteBuffer[i],1，0xff);//使用I2C块读，出错。因此采用此种方式，逐个单字节写入</span></span><br><span class="line"><span class="comment">        HAL_Delay(5);//此处延时必加，与AT24C02写时序有关</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      printf(&quot;\r\n EEPROM 24C02 Write Test OK \r\n&quot;);</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">   HAL_I2C_Mem_Read(&amp;hi2c1,AT24C02_ADDR_READ,<span class="number">0</span>,I2C_MEMADD_SIZE_8BIT,receiveBuffer,<span class="number">256</span>,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">256</span>;k++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(message,<span class="string">&quot;0x%02X &quot;</span>,receiveBuffer[k]);</span><br><span class="line">      HAL_UART_Transmit(&amp;huart1,message,<span class="number">6</span>,<span class="number">1000</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// HAL_UART_Transmit(&amp;huart1,&quot;Hello World&quot;,11,1000);</span></span><br><span class="line">   <span class="comment">// HAL_Delay(1000);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意事项</strong>：</p><ul><li><p><strong>AT24C02的IIC每次写之后要延时一段时间才能继续写 每次写之后要delay 5ms左右 不管硬件IIC采用何种形式（DMA，IT），都要确保两次写入的间隔大于5ms;</strong></p></li><li><p><strong>AT24C02页写入只支持8个byte，所以需要分32次写入。这不是HAL库的bug，而是AT24C02的限制，其他的EEPROM可以支持更多byte的写入。</strong><br><strong>当然，你也可以每次写一个字节，分成256次写入，也是可以的 那就用注释了的代码即可</strong></p></li><li><p><strong>读写函数最后一个超时调整为1000以上 因为我们一次写8个字节，延时要久一点</strong></p></li><li><p><strong>注意读取AT24C02数据的时候延时也要久一点，否则会造成读的数据不完整</strong></p></li></ul></blockquote><h2 id="实验-使用AHT20温湿度传感器-轮询">实验-使用AHT20温湿度传感器(轮询)</h2><p><a href="https://docs.keysking.com/docs/stm32/example/I2C_AHT20">【I²C总线】AHT20温湿度传感器 | 波特律动 (keysking.com)</a></p><p><a href="https://www.bilibili.com/video/BV1QN411D7ak/?spm_id_from=pageDriver&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32入门教程-2024】第12集 IIC通信与温湿度传感器AHT20(DHT20)_哔哩哔哩_bilibili</a></p><h3 id="CubeMX配置：-2">CubeMX配置：</h3><blockquote><ol><li>打开I2C外设，参数全部默认即可</li><li>启动对应的串口</li></ol></blockquote><h3 id="传感器读取流程">传感器读取流程</h3><p>打开温湿度传感器AHT20数据手册，找到5.4传感器读取流程</p><p><img src="../assets/image-20240920220016640-173753028478010.png" alt="image-20240920220016640"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*读取流程1*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer;</span><br><span class="line">    HAL_Delay(<span class="number">40</span>);</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,&amp;readBuffer,<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( (readBuffer &amp; <span class="number">0x08</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xBE</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">        HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>(readBuffer &amp; 0x08) == 0x00 这里按位与就是确定第4位Bit[3]是否为1，不为1就发送sendBuffer</strong></p><p>注意&amp;的优先级很低，要加括号</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AHT20_ReadData</span><span class="params">(<span class="type">float</span>* temperature, <span class="type">float</span>* humidity)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xAC</span>,<span class="number">0x33</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*流程2*/</span> HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    HAL_Delay(<span class="number">75</span>);</span><br><span class="line">    HAL_I2C_Master_Receive(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer),<span class="number">100</span>);</span><br><span class="line">    ----------------------------------------</span><br><span class="line">   <span class="comment">/*流程3*/</span></span><br><span class="line">    <span class="keyword">if</span>((readBuffer[<span class="number">0</span>] &amp; <span class="number">0x80</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> data = <span class="number">0</span>;</span><br><span class="line">        data = ((<span class="type">uint32_t</span>)readBuffer[<span class="number">1</span>] &lt;&lt; <span class="number">12</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>);</span><br><span class="line">     <span class="comment">/*流程4*/</span>   </span><br><span class="line">        *humidity = (data * <span class="number">100.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        data = ( ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>]&amp;<span class="number">0x0F</span>) &lt;&lt; <span class="number">16</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) + (<span class="type">uint32_t</span>)readBuffer[<span class="number">5</span>];</span><br><span class="line">     <span class="comment">/*流程4*/</span></span><br><span class="line">        *temperature = (data*<span class="number">200.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-50</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../assets/image-20240920221150638-173753028478011.png" alt="image-20240920221150638"></p><blockquote><p>上图中蓝色为从机发送给主机的数据，可得温度和湿度都是2.5个字节</p><p><strong>需要将其拆开后拼接起来可得到温湿度数据，使用位操作，此时注意强制转换为uint32_t避免移动时丢失数据</strong></p></blockquote><p><strong>最后计算</strong>：<img src="../assets/image-20240920221420656-173753028478012.png" alt="image-20240920221420656"></p><blockquote><p><strong>SRH就是拼接后的湿度，ST就是拼接后的温度</strong></p></blockquote><h3 id="代码-2">代码</h3><blockquote><p>我们通常会为不同的模块单独建立驱动文件, <strong>新建.c/.h文件aht20.c和aht20.h，在main.c中进行获取温湿度并显示</strong></p></blockquote><p><img src="../assets/image-20240920220428021-173753028478013.png" alt="image-20240920220428021"></p><p>设备地址7位，但是发送时通常是8位，包括一位读写为，故要左移一位即01110000故设备地址为0x70，使用函数时会根据读或写，自动帮我们确定最后一位为0还是1，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*aht20.h文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AHT20_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHT20_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHT20_ADDRESS 0x70</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_ReadData</span><span class="params">(<span class="type">float</span>* temperature,<span class="type">float</span>* humidity)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//AHT20_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*aht20.c文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aht20.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer;</span><br><span class="line">    HAL_Delay(<span class="number">40</span>);</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,&amp;readBuffer,<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>( (readBuffer &amp; <span class="number">0x08</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xBE</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">        HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_ReadData</span><span class="params">(<span class="type">float</span>* temperature, <span class="type">float</span>* humidity)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xAC</span>,<span class="number">0x33</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    HAL_Delay(<span class="number">75</span>);</span><br><span class="line">    HAL_I2C_Master_Receive(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer),<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((readBuffer[<span class="number">0</span>] &amp; <span class="number">0x80</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> data = <span class="number">0</span>;</span><br><span class="line">        data = ((<span class="type">uint32_t</span>)readBuffer[<span class="number">1</span>] &lt;&lt; <span class="number">12</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        *humidity = (data * <span class="number">100.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        data = ( ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>]&amp;<span class="number">0x0F</span>) &lt;&lt; <span class="number">16</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) + (<span class="type">uint32_t</span>)readBuffer[<span class="number">5</span>];</span><br><span class="line">        *temperature = (data*<span class="number">200.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-50</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aht20.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> temperature;</span><br><span class="line"><span class="type">float</span> humidity;</span><br><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    AHT20_Init();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    AHT20_ReadData(&amp;temperature,&amp;humidity);</span><br><span class="line">    <span class="built_in">sprintf</span>(message,<span class="string">&quot;温度：%.lf°c 湿度: %.lf %%&quot;</span>,temperature,humidity);</span><br><span class="line">   <span class="comment">/*sprintf函数可以拼接字符串,需要包含stdio.h文件*/</span> HAL_UART_Transmit(&amp;huart2,message,<span class="keyword">sizeof</span>(message),<span class="number">1000</span>);</span><br><span class="line"><span class="comment">/*发送到串口，使用串口调试助手*/</span></span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="IIC中断与DMA以及状态机编程">IIC中断与DMA以及状态机编程</h2><blockquote><p><strong>IIC中断和DMA使用方法和串口类似</strong></p></blockquote><h3 id="相关函数-5">相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HAL_I2C_Master_Transmit_IT(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer));</span><br><span class="line"><span class="comment">/*中断读写*/</span></span><br><span class="line">HAL_I2C_Master_Receive_IT(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"></span><br><span class="line">HAL_I2C_Master_Transmit_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"><span class="comment">/*DMA模式读写*/</span></span><br><span class="line">HAL_I2C_Master_Receive_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断回调函数和DMA模式下进入的回调函数相同，都是下面的函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterTxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span>;<span class="comment">//发送回调</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterRxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span>;<span class="comment">//接收回调</span></span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="状态机编程">状态机编程</h3><blockquote><p>在STM32微控制器（MCU）编程中，状态机（State Machine）是一种常用的设计模式，用来管理复杂系统的不同状态以及在状态之间进行的切换。<strong>状态机编程有助于使代码结构清晰、易于维护，特别适用于处理嵌入式系统中的顺序逻辑、通信协议、控制流程等问题</strong>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*状态机编程通常是使用枚举设定状态，例如该模块实验中可以设置如下状态*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AHT_MEASURE,</span><br><span class="line">    AHT_SEND,</span><br><span class="line">    AHT_GET,</span><br><span class="line">    AHT_RECEIVE,</span><br><span class="line">    AHT_ANALYSIS</span><br><span class="line">&#125; AHT20State;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 0:初始状态发送测量命令</span></span><br><span class="line"><span class="comment"> * 1：发送中</span></span><br><span class="line"><span class="comment"> * 2：发送完成,75ms后进行读取</span></span><br><span class="line"><span class="comment"> * 3：读取中</span></span><br><span class="line"><span class="comment"> * 4：读取完成，数据解析</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*轮询中对应处理*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">switch</span> (aht20State)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> AHT_MEASURE:</span><br><span class="line">            AHT20_Measure();</span><br><span class="line">            aht20State = AHT_SEND;</span><br><span class="line">        <span class="keyword">case</span> AHT_GET:</span><br><span class="line">            HAL_Delay(<span class="number">75</span>);</span><br><span class="line">            AHT20_Get();</span><br><span class="line">            aht20State = AHT_RECEIVE;</span><br><span class="line">        <span class="keyword">case</span> AHT_ANALYSIS:</span><br><span class="line">            AHT20_Analysis(&amp;temperature,&amp;humidity);</span><br><span class="line">            <span class="built_in">sprintf</span>(message,<span class="string">&quot;温度：%.1lf°c 湿度:%.1lf %%&quot;</span>,temperature,humidity);</span><br><span class="line"></span><br><span class="line">            HAL_UART_Transmit(&amp;huart2,message,<span class="keyword">sizeof</span>(message),<span class="number">1000</span>);</span><br><span class="line">            HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">            aht20State =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实验-使用AHT20温湿度传感器-状态机">实验-使用AHT20温湿度传感器(状态机)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*aht20.h文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AHT20_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHT20_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHT20_ADDRESS 0x70</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AHT_MEASURE,</span><br><span class="line">    AHT_SEND,</span><br><span class="line">    AHT_GET,</span><br><span class="line">    AHT_RECEIVE,</span><br><span class="line">    AHT_ANALYSIS</span><br><span class="line">&#125; AHT20State;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 0:初始状态发送测量命令</span></span><br><span class="line"><span class="comment"> * 1：发送中</span></span><br><span class="line"><span class="comment"> * 2：发送完成,75ms后进行读取</span></span><br><span class="line"><span class="comment"> * 3：读取中</span></span><br><span class="line"><span class="comment"> * 4：读取完成，数据解析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//void AHT20_ReadData(float* temperature,float* humidity);</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Measure</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Get</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Analysis</span><span class="params">(<span class="type">float</span>* temperature, <span class="type">float</span>* humidity)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//AHT20_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*aht20.c文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aht20.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> readBuffer[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> readBuffer;</span><br><span class="line">    HAL_Delay(<span class="number">40</span>);</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,&amp;readBuffer,<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>( (readBuffer &amp; <span class="number">0x08</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xBE</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">        HAL_I2C_Master_Transmit(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Measure</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*此处的sendBuffer为了避免该函数作用域结束后回收，故设置为static方便多次测量*/</span></span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> sendBuffer[<span class="number">3</span>] = &#123;<span class="number">0xAC</span>,<span class="number">0x33</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">    HAL_I2C_Master_Transmit_DMA(&amp;hi2c1,AHT20_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer));<span class="comment">//或者以中断模式启动，都是非阻塞模式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Get</span><span class="params">()</span></span><br><span class="line">&#123; HAL_I2C_Master_Receive_DMA(&amp;hi2c1,AHT20_ADDRESS,readBuffer,<span class="keyword">sizeof</span>(readBuffer));<span class="comment">//或者以中断模式启动，都是非阻塞模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AHT20_Analysis</span><span class="params">(<span class="type">float</span>* temperature, <span class="type">float</span>* humidity)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((readBuffer[<span class="number">0</span>] &amp; <span class="number">0x80</span>) == <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> data = <span class="number">0</span>;</span><br><span class="line">        data = ((<span class="type">uint32_t</span>)readBuffer[<span class="number">1</span>] &lt;&lt; <span class="number">12</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        *humidity = (data * <span class="number">100.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        data = ( ((<span class="type">uint32_t</span>)readBuffer[<span class="number">3</span>]&amp;<span class="number">0x0F</span>) &lt;&lt; <span class="number">16</span>) + ((<span class="type">uint32_t</span>)readBuffer[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) + (<span class="type">uint32_t</span>)readBuffer[<span class="number">5</span>];</span><br><span class="line">        *temperature = (data*<span class="number">200.0</span>)/(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-50</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 24-9-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;aht20.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f1xx_hal.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdbool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> temperature;</span><br><span class="line"><span class="type">float</span> humidity;</span><br><span class="line"><span class="type">char</span> message[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">AHT20State aht20State;<span class="comment">//状态机枚举变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    AHT20_Init();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">switch</span> (aht20State)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> AHT_MEASURE:</span><br><span class="line">            AHT20_Measure();</span><br><span class="line">            aht20State = AHT_SEND;</span><br><span class="line">        <span class="keyword">case</span> AHT_GET:</span><br><span class="line">            HAL_Delay(<span class="number">75</span>);</span><br><span class="line">            AHT20_Get();</span><br><span class="line">            aht20State = AHT_RECEIVE;</span><br><span class="line">        <span class="keyword">case</span> AHT_ANALYSIS:</span><br><span class="line">            AHT20_Analysis(&amp;temperature,&amp;humidity);</span><br><span class="line">            <span class="built_in">sprintf</span>(message,<span class="string">&quot;温度：%.1lf°c 湿度:%.1lf %%&quot;</span>,temperature,humidity);</span><br><span class="line"></span><br><span class="line">            HAL_UART_Transmit(&amp;huart2,message,<span class="keyword">sizeof</span>(message),<span class="number">1000</span>);</span><br><span class="line">            HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">            aht20State =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterTxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi2c == &amp;hi2c1)</span><br><span class="line">    &#123;</span><br><span class="line">        aht20State = AHT_GET;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_I2C_MasterRxCpltCallback</span><span class="params">(I2C_HandleTypeDef *hi2c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi2c == &amp;hi2c1)</span><br><span class="line">    &#123;</span><br><span class="line">        aht20State = AHT_ANALYSIS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>SPI</h1><h2 id="介绍-4">介绍</h2><p><strong>SPI 是英语Serial Peripheral interface的缩写</strong>，顾名思义就是<strong>串行外围设备接口</strong>。是Motorola(摩托罗拉)首先在其MC68HCXX系列处理器上定义的。</p><p><strong>SPI是一种高速的，全双工，同步</strong>的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便。</p><p>主要应用在 EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。</p><blockquote><p><strong>SPI是全双工且SPI没有定义速度限制，一般的实现通常能达到甚至超过10 Mbps</strong></p></blockquote><p><strong>学习资料</strong>：</p><p><a href="https://blog.csdn.net/as480133937/article/details/105764119">SPI原理超详细讲解—值得一看-CSDN博客</a></p><p><a href="https://blog.csdn.net/as480133937/article/details/105849607?spm=1001.2014.3001.5502">【STM32】HAL库 STM32CubeMX教程十四—SPI_cubemx spi-CSDN博客</a></p><h2 id="主从模式">主从模式</h2><blockquote><p><strong>SPI分为主、从两种模式</strong>，一个SPI通讯系统需要包含<strong>一个（且只能是一个）主设备</strong>，一个或多个从设备。<strong>提供时钟的为主设备（Master</strong>），<strong>接收时钟的设备为从设备（Slave）</strong>。</p><p>SPI接口的读写操作，都是由主设备发起。当存在多个从设备时，通过各自的<strong>片选信号</strong>进行管理。</p></blockquote><h2 id="信号线">信号线</h2><p><strong>SPI接口有四条信号线通信</strong>:</p><ol><li><p><strong>SDI(数据输入)</strong></p></li><li><p><strong>SDO(数据输出)</strong></p></li><li><p><strong>SCK(时钟)</strong></p></li><li><p><strong>CS(片选)</strong></p></li></ol><blockquote><ul><li><strong>MISO</strong>(Master input Slave output)： 主设备输入/从设备输出引脚。该引脚在从模式下发送数据，在主模式下接收数据。</li><li><strong>MOSI</strong>： 主设备输出/从设备输入引脚。该引脚在主模式下发送数据，在从模式下接收数据。</li><li><strong>SCLK</strong>：<strong>串行时钟信号</strong>，由主设备产生。</li><li><strong>CS/SS</strong>：<strong>从设备片选信号</strong>，由主设备控制。它的功能是用来作为“片选引脚”，<strong>也就是选择指定的从设备，让主设备可以单独地与特定从设备通讯，避免数据线上的冲突。</strong></li></ul></blockquote><p><strong>对应硬件上为4根线</strong></p><p><strong>SPI一对一</strong>：</p><p><img src="../assets/image-20241106150546130-173753028478014.png" alt="image-20241106150546130"></p><p><strong>SPI一对多</strong>:</p><p><img src="../assets/image-20241106150618856-173753028478015.png" alt="image-20241106150618856"></p><h2 id="数据发送和接收">数据发送和接收</h2><blockquote><p><strong>SPI主机和从机都有一个串行移位寄存器(8位)，主机通过向它的SPI串行寄存器写入一个字节来发起一次传输。</strong></p><ol><li>首先拉低对应SS信号线，表示与该设备进行通信</li><li>主机通过发送SCLK时钟信号，来告诉从机写数据或者读数据<br>这里要注意，SCLK时钟信号可能是低电平有效，也可能是高电平有效，因为SPI有四种模式，这个我们在下面会介绍</li><li>主机(Master)将要发送的数据写到发送数据缓存区(Memory)，缓存区经过移位寄存器(0~7)，串行移位寄存器通过MOSI信号线将字节一位一位的移出去传送给从机，，同时MISO接口接收到的数据经过移位寄存器一位一位的移到接收缓存区。</li><li>从机(Slave)也将自己的串行移位寄存器(0~7)中的内容通过MISO信号线返回给主机。同时通过MOSI信号线接收主机发送的数据，这样，<strong>两个移位寄存器中的内容就被交换。</strong></li></ol></blockquote><p><img src="../assets/image-20241106151444762-173753028478016.png" alt="image-20241106151444762"></p><h2 id="工作模式">工作模式</h2><blockquote><p><strong>根据时钟极性（CPOL）及相位（CPHA）不同</strong>，<strong>SPI有四种工作模式</strong>。<br>时钟极性(CPOL)定义了时钟空闲状态电平：</p><p>CPOL=0为时钟空闲时为<strong>低电平</strong><br>CPOL=1为时钟空闲时为<strong>高电平</strong><br>时钟相位(CPHA)定义数据的采集时间。</p><p>CPHA=0:在时钟的<strong>第一个跳变沿</strong>（上升沿或下降沿）进行数据采样。<br>CPHA=1:在时钟的<strong>第二个跳变沿</strong>（上升沿或下降沿）进行数据采样。</p></blockquote><p><strong>对应组合四种模式为</strong>：</p><p><img src="../assets/image-20241106151100423-173753028478017.png" alt="image-20241106151100423"></p><p><a href="https://blog.csdn.net/as480133937/article/details/105764119">SPI原理超详细讲解—值得一看-CSDN博客</a></p><h2 id="W25Q128-FLASH芯片">W25Q128 FLASH芯片</h2><p><strong>W25Q128是一款SPI通信的FLASH芯片，可以通过标准/两线/四线SPI控制</strong></p><p>FLASH的大小为16M，分为 256 个块（Block），每个块大小为 64K 字节，每个块又分为 16个扇区（Sector），每个扇区 4K 个字节。</p><p>通过SPI通信协议即可实现MCU(STM32)和 W25Q128 之间的通信。实现W25Q128的控制需要通过SPI协议发送相应的控制指令，并满足一定的时序。</p><p>打开芯片手册可以找到对应的操作：</p><ol><li><strong>写使能</strong></li></ol><p><img src="../assets/image-20241106154535945-173753028478018.png" alt="image-20241106154535945"></p><blockquote><p>阅读最后一段英文可知：</p><p>写入使能通过将 /CS 驱动为低电平，将指令代码“06H(0x06)”在 CLK 的上升沿时移至数据输入 （DI） 引脚，然后驱动 /CS 为高电平</p><p><strong>即：向FLASH发送0x06 写使能命令即可开启写使能，首先CS片选拉低，控制写入字节函数写入命令，CS片选拉高。</strong></p></blockquote><ol start="2"><li><strong>扇区擦除指令(Sector Erase)</strong></li></ol><p><img src="../assets/image-20241106155057196-173753028478019.png" alt="image-20241106155057196"></p><blockquote><p>第二排可以看到</p><p>必须先执行 Write Enable 指令，设备才会接受 Sector Erase。通过将 /CS 引脚驱动为低电平来启动该指令，再将指令代码“20H”+24为扇区地址 （A23-A0）</p><p>在最后一个字节的第 8 位被锁存后，必须将 /CS 引脚驱动为高电平。如果未执行此操作，则Sector Erase 指令将不会被执行。</p><p>即：</p><p><strong>扇区擦除指令，数据写入前必须擦除对应的存储单元，该指令先拉低/CS引脚电平,接着传输“20H”指令和要24位要擦除扇区的地址。</strong></p></blockquote><ol start="3"><li><strong>读命令</strong></li></ol><p><img src="../assets/image-20241106175057582-173753028478120.png" alt="image-20241106175057582"></p><blockquote><p><strong>第一排：读取可以一次读取一个或多个数据字节</strong></p><p><strong>先拉低CS电平，再传输03H，接着通过DI管教传输24为地址，最终数据通过DO引脚引出。每传输一个字节地址自动递增，所以只要时钟继续传输，就可以不断读取出储存器中的数据。</strong></p></blockquote><ol start="4"><li><p>状态读取命令(Read Status Register)</p></li><li><p>写入命令(Page Program)</p></li></ol><p><img src="../assets/image-20241106175641621-173753028478121.png" alt="image-20241106175641621"></p><blockquote><p>在对W25Q128 FLASH的写入数据的操作中一<strong>定要先擦出扇区，在进行写入，否则将会发生数据错误。</strong><br>W25Q128 FLASH一次性最大写入只有256个字节。<br>在进行写操作之前，一定要开启写使能(Write Enable)。<br>当只接收数据时不但能只检测RXNE状态 ，必须同时向发送缓冲区发送数据才能驱动SCK时钟跳变。</p></blockquote><h2 id="实验读写FLASH-W25Q128">实验读写FLASH(W25Q128)</h2><h3 id="CubeMX配置-12">CubeMX配置</h3><p><strong>主要说SPI配置页面</strong>：</p><ol><li><strong>Mode</strong>： Full-Duplex为全双工  Half-Duplex半双工</li></ol><ul><li>有主机模式全双工/半双工</li><li>从机模式全双工/半双工</li><li>只接收主机模式/只接收从机模式</li><li>只发送主机模式</li></ul><p><strong>2. Hardware NSS Signal</strong>(硬件片选信号)：片选分为软件片选和硬件片选。STM32有硬件片选信号，可以选择使能，也可以使用其他IO口接到芯片的NSS上进行代替</p><p><strong>其中SIP1的片选NSS ： SPI1_NSS（PA4）<br>其中SIP2的片选NSS ： SPI2_NSS（PB12）</strong></p><p>如果片选引脚没有连接 SPI1_NSS（PA4）或者SPI2_NSS（PB12），则需要选择软件片选</p><blockquote><p>NSS管脚及我们熟知的片选信号，作为主设备NSS管脚为高电平，从设备NSS管脚为低电平。当NSS管脚为低电平时，该spi设备被选中，可以和主设备进行通信。在stm32中，每个spi控制器的NSS信号引脚都具有两种功能，即输入和输出。</p><p>所谓的输入就是NSS管脚的信号给自己。所谓的输出就是将NSS的信号送出去，给从机。</p><p>对于NSS的输入，又分为软件输入和硬件输入。</p><p><strong>软件输入</strong>：<br>NSS分为内部管脚和外部管脚，通过设置spi_cr1寄存器的ssm位和ssi位都为1可以设置NSS管脚为软件输入模式且内部管脚提供的电平为高电平，其中SSM位为使能软件输入位。SSI位为设置内部管脚电平位。同理通过设置SSM和SSI位1和0则此时的NSS管脚为软件输入模式但内部管脚提供的电平为0。若从设备是一个其他的带有spi接口的芯片，并不能选择NSS管脚的方式，则可以有两种办法：</p><p><strong>1. 将NSS管脚直接接低电平。</strong></p><p><strong>2. 通过主设备的任何一个gpio口去输出低电平选中从设备。</strong></p><p><strong>硬件输入</strong>：<br>主机接高电平，从机接低电平。</p></blockquote><p><strong>硬件片选信号直接配置即可，下面说软件片选</strong></p><blockquote><p>只需要对应软件片选引脚(选择硬件片选对应引脚)，选择GPIO_Output,然后设置下备注即可SPI2_CS</p></blockquote><blockquote><p>W25Q128V芯片闪存芯片进行通信，所以设置为<strong>主机全双工</strong></p></blockquote><hr><p>然后进行基本参数配置：</p><blockquote><p><strong>Basic Parameters</strong>:</p><p>Frame Format(帧格式):默认Motorola通信格式</p><p>Data Size: 默认8bit</p><p>First Bit：有MSB First(高位在前)和LSB First(低位在前)</p><p><strong>Clock Parameters:</strong></p><p>Prescaler(for Baud Rate):SPI波特率分频值，决定SPI时钟参数</p><p>Baud Rate：上面设置分频后得到的传输速率</p><p>Clock Polarity(CPOL)：时钟极性，选择是高还是低电平</p><p>Clock Phase(CPHA)：时钟相位，选择第几个跳变沿(上升/下降沿)采样</p><p><strong>Advanced Parameters</strong>:</p><p>CRC Calculation：CRC校验项，提高通信可靠性</p><p>NSS Signal Type：选择软件片选或者硬件片选</p><p>SPI配置中设置数据长度为8bit,MSB先输出分频为64分频，则波特率为125KBits/s。其他为默认设置。<br>Motorla格式，CPOL设置为Low,CPHA设置为第一个边沿。不开启CRC检验，NSS为软件控制。</p></blockquote><h3 id="代码-3">代码</h3><p>因为我们是软件使能片选，定义片选引脚，<strong>CS片选低电平为有效使能</strong>， <strong>CS片选高电平不使能</strong></p><p>这里用两个宏定义来代替</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以W25Q128为例</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CS_Enable() HAL_GPIO_WritePin(GPIOA, SPI1_CS_Pin, GPIO_PIN_RESET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_CS_Disable() HAL_GPIO_WritePin(GPIOA, SPI1_CS_Pin, GPIO_PIN_SET)</span></span><br></pre></td></tr></table></figure><p>使用野火官方提供的驱动即可</p><h2 id="函数-3">函数</h2><p>从对应SPI头文件可以看到对应<strong>轮询，中断和DMA三种方式</strong></p><ul><li><strong>SPI发送/接收数据函数</strong>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);<span class="comment">//发送数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * hspi: 选择SPI1/2，比如&amp;hspi1，&amp;hspi2</span></span><br><span class="line"><span class="comment">  * pData ： 需要发送的数据，可以为数组</span></span><br><span class="line"><span class="comment">  * Size： 发送数据的字节数，1 就是发送一个字节数据</span></span><br><span class="line"><span class="comment">  * Timeout： 超时时间，就是执行发送函数最长的时间，超过该时间自动退出发送函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">HAL_SPI_Receive(SPI_HandleTypeDef *hspi, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout);<span class="comment">//接收数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>SPI中断函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　</span><br><span class="line">HAL_SPI_TransmitReceive_IT(&amp;hspi1, TXbuf,RXbuf,CommSize);</span><br><span class="line"><span class="comment">//中断启动,当SPI上接收出现了 CommSize个字节的数据后，中断函数会调用SPI回调函数：</span></span><br><span class="line">HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)</span><br><span class="line"><span class="comment">//中断回调</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>OLED</h1><h2 id="介绍-5">介绍</h2><p>所谓OLED，就是由一个个发光的二极管(发光小灯)组成，<strong>每个小灯称为一个像素</strong>，只要在屏幕上有选择的点亮一部分小灯，就可以显示我们想要的图案，<strong>而小灯排列的数目就是分辨率</strong>。</p><blockquote><p><strong>常见尺寸分辨率：128X64 -&gt;128列，64行小灯</strong>，此时如果再按照之前的方法一个引脚控制一个小灯的话消耗太大,显然不可能。所以我们<strong>需要屏幕驱动芯片</strong></p></blockquote><p>有了屏幕驱动芯片，我们只需要通过<strong>IIC或者SPI</strong>等通讯协议与屏幕驱动芯片进行通信，就可以操控这些小灯的亮灭。</p><p><strong>常见屏幕驱动芯片有SSD1306、CH1116、SH1106等</strong></p><p><a href="https://www.bilibili.com/video/BV19u4y197df/?spm_id_from=333.788&amp;vd_source=830e63bd86bd9268c1b7cd9ff383f386">【STM32入门教程-2024】第14集 如何在OLED屏幕上挥毫_哔哩哔哩_bilibili</a></p><h2 id="原理-5">原理</h2><p><strong>与CH1116的通信分为两类：指令和数据</strong></p><p>以CH1116为例：分辨率为64X128，将64行划分为page0~page7(8页)，</p><p>每一个page从0到7共8行，列数为128不变。</p><p><strong>从芯片数据手册可以查到，CH1116的从地址为0x7A</strong></p><blockquote><p>通常在对应芯片手册(下面为CH1116芯片)中可以找到I2C地址，如下图7位为:0111100或0111101，第8位为R/W位，故为0x7A</p></blockquote><p><img src="../assets/image-20240922165310629-173753028478122.png" alt="image-20240922165310629"></p><blockquote><ol><li><strong>指令通讯格t式</strong>：</li></ol><p><strong>0x7A + 0x00  一字节指令</strong></p><p>0x7A为IIC地址，0x00开头+一字节指令是我们需要发送的。</p><p>设置页地址只分为一次，例如：</p><p>想设置页地址为page0  0xB0   -&gt; 0x7A 0x00 0xB0</p><p>想设置页地址为 page7  0xB7  -&gt; 0x7A 0x00 0xB7</p><p>设置列地址需要发送两次指令，假设我们需要设置列地址为0x5A</p><p>第一次发送  0x0A，将列地址低4位设置为A</p><p>第二次发送   0x15，将列地址高4位设置为5</p><p>即，低位0x0，高位0x1</p><ol start="2"><li><strong>数据通讯格式</strong>：</li></ol><p><strong>0x7A +  0x40  任意数量的数据</strong></p><p>0x7A为IIC地址，(0x40开头+任意数量数据)为我们发送的。</p></blockquote><blockquote><p><strong>CH1116等芯片特性</strong>：设置完一字节的8个像素后，列地址会自动+1，这样下一个数据就可以写到本页的下一列里。</p><p>利用这特性我们只需要将页地址和列地址都设置为0，然后一次性发送128个字节，就可以直接完成一页屏幕的像素设置</p><p>设置第0页: 0x7A 0x00 0xB0  -&gt;需要在循环中手动自增,遍历</p><p>设置第0列: 0x7A 0x00 0x0<strong>0</strong> &amp; 0x7A 0x00 0x1<strong>0</strong> -&gt;自动自增</p><p>发送显示数据： 0xFF 0xFF …共128个</p></blockquote><h2 id="驱动函数">驱动函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*OLED在使用之前需要初始化*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    OLED_SendCmd(<span class="number">0xAE</span>); <span class="comment">/*关闭显示 display off*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0x02</span>); <span class="comment">/*设置列起始地址 set lower column address*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x10</span>); <span class="comment">/*设置列结束地址 set higher column address*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0x40</span>); <span class="comment">/*设置起始行 set display start line*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xB0</span>); <span class="comment">/*设置页地址 set page address*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0x81</span>); <span class="comment">/*设置对比度 contract control*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0xCF</span>); <span class="comment">/*128*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xA1</span>); <span class="comment">/*设置分段重映射 从右到左 set segment remap*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xA6</span>); <span class="comment">/*正向显示 normal / reverse*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xA8</span>); <span class="comment">/*多路复用率 multiplex ratio*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x3F</span>); <span class="comment">/*duty = 1/64*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xAD</span>); <span class="comment">/*设置启动电荷泵 set charge pump enable*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x8B</span>); <span class="comment">/*启动DC-DC */</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0x33</span>); <span class="comment">/*设置泵电压 set VPP 10V */</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xC8</span>); <span class="comment">/*设置输出扫描方向 COM[N-1]到COM[0] Com scan direction*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xD3</span>); <span class="comment">/*设置显示偏移 set display offset*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x00</span>); <span class="comment">/* 0x00 */</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xD5</span>); <span class="comment">/*设置内部时钟频率 set osc frequency*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0xC0</span>);</span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xD9</span>); <span class="comment">/*设置放电/预充电时间 set pre-charge period*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x1F</span>); <span class="comment">/*0x22*/</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xDA</span>); <span class="comment">/*设置引脚布局 set COM pins*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x12</span>);</span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xDB</span>); <span class="comment">/*设置电平 set vcomh*/</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OLED_NewFrame();</span></span><br><span class="line">    <span class="comment">// OLED_ShowFrame();</span></span><br><span class="line"></span><br><span class="line">    OLED_SendCmd(<span class="number">0xAF</span>); <span class="comment">/*开启显示 display ON*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该函数内容一般厂商会提供，网上搜即可，当然没有的话只有自己写了*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*发送指令*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_SendCmd</span><span class="params">(<span class="type">uint8_t</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[<span class="number">2</span>] = &#123;<span class="number">0x00</span>,cmd&#125;;</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,OLED_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),HAL_MAX_DELAY);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_SendCmd(<span class="number">0xB0</span>);<span class="comment">//设置页</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x02</span>);<span class="comment">//设置列低四位</span></span><br><span class="line">    OLED_SendCmd(<span class="number">0x10</span>);<span class="comment">//设置列高四位</span></span><br><span class="line">    <span class="comment">/*发送指令，设置页和列*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[] = &#123;<span class="number">0x40</span>,<span class="number">0xAA</span>&#125;;</span><br><span class="line">    HAL_I2C_Master_Transmit(&amp;hi2c1,OLED_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),HAL_MAX_DELAY);</span><br><span class="line">    <span class="comment">/*发送数据，设置亮灭*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于屏幕任意点亮灭是随机的，启动时会花屏，所以需要我们利用显存刷新一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> GRAM[<span class="number">8</span>][<span class="number">128</span>];<span class="comment">//定义显存</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_NewFrame</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">memset</span>(GRAM,<span class="number">0</span>,<span class="keyword">sizeof</span>(GRAM));</span><br><span class="line">&#125;<span class="comment">//将所有像素清空</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowFrame</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> sendBuffer[<span class="number">129</span>];</span><br><span class="line">    sendBuffer[<span class="number">0</span>] = <span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint8_t</span> j=<span class="number">0</span>;j&lt;<span class="number">128</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sendBuffer[j+<span class="number">1</span>] = GRAM[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        OLED_SendCmd(<span class="number">0xB0</span>+i);</span><br><span class="line">        OLED_SendCmd(<span class="number">0x02</span>);</span><br><span class="line">        OLED_SendCmd(<span class="number">0x10</span>);       HAL_I2C_Master_Transmit(&amp;hi2c1,OLED_ADDRESS,sendBuffer,<span class="keyword">sizeof</span>(sendBuffer),HAL_MAX_DELAY);</span><br><span class="line">        <span class="comment">/*只需要对page进行增加，列由于特性会自增，故不需要增加*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_SetPixel</span><span class="params">(<span class="type">uint8_t</span> x,<span class="type">uint8_t</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*该函数作用是使指定坐标亮起*/</span></span><br><span class="line">    <span class="comment">/*描述屏幕时，使用的是下x，y坐标系第四象限,x为列坐标，y为行坐标*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">128</span> || y&gt;=<span class="number">64</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    GRAM[y/<span class="number">8</span>][x] = <span class="number">0x01</span> &lt;&lt; (y%<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint8_t</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_NewFrame();<span class="comment">//清空显存</span></span><br><span class="line"></span><br><span class="line">        OLED_SetPixel(<span class="number">2</span>*i,i);<span class="comment">//画点</span></span><br><span class="line">        OLED_ShowFrame();<span class="comment">//显示显存</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/*你将会得到一个在屏幕上移动的点*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*OLED初始化通常前面跟一个延时,*/</span></span><br><span class="line">    HAL_Delay(<span class="number">20</span>);</span><br><span class="line">    OLED_Init();</span><br><span class="line">    <span class="comment">/*STM32启动比OLED上电快, 可等待20ms再初始化OLED,避免LED比STM32启动更早*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取模-图模-字模">取模(图模+字模)</h2><h2 id="CubeMX配置-13">CubeMX配置</h2><blockquote><p>正常启动I2C配置，由于有大量数据，故只需要将I2C模式标准模式切换为快速模式(Fast Mode)，使用外部高速时钟即可.。</p></blockquote><h2 id="移植">移植</h2><p>为了便于使用，驱动库可以直接移植</p><p><a href="https://led.baud-dance.com/">波特律动LED字模生成器 (baud-dance.com)</a></p><p>图模和字模的使用方法：</p><blockquote><p>使用波特率动取模后，将取模后的代码复制到font.c文件最下方，最后再调用OLED_DrawImage或OLED_PrintString即可使用</p></blockquote>]]></content>
    
    
    <summary type="html">STM32单片机开发</summary>
    
    
    
    <category term="嵌入式" scheme="https://www.thekqd.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="https://www.thekqd.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
</feed>
