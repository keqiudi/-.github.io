<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Walnut🍭</title>
  
  
  <link href="https://www.thekqd.top/atom.xml" rel="self"/>
  
  <link href="https://www.thekqd.top/"/>
  <updated>2023-10-15T12:02:36.892Z</updated>
  <id>https://www.thekqd.top/</id>
  
  <author>
    <name>Walnut🍭</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>视图</title>
    <link href="https://www.thekqd.top/posts/50a54d3c.html"/>
    <id>https://www.thekqd.top/posts/50a54d3c.html</id>
    <published>2023-10-14T08:19:25.000Z</published>
    <updated>2023-10-15T12:02:36.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视图介绍"><a href="#视图介绍" class="headerlink" title="视图介绍"></a>视图介绍</h1><ul><li>介绍</li></ul><p>视图(view)是一种<strong>虚拟存在的表</strong>。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p><p>通俗的讲，<strong>视图只保存了查询的SQL逻辑，不保存查询结果</strong>。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><h1 id="视图语法"><a href="#视图语法" class="headerlink" title="视图语法"></a>视图语法</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a><strong>创建</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- OR REPLACE &#x27;或替代&#x27; , 可选项</span></span><br><span class="line"><span class="comment">-- </span></span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a><strong>查询</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看创建视图的语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称；</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看视图数据(把视图当作表来查，可以像操作表一样来操作视图)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 视图名称 WHERE...;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> stu_v_1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1 <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a><strong>修改视图</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式一：关键在or replace上，修改必须加</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span>[<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure><h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a><strong>删除视图</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] 视图名称，... ;</span><br></pre></td></tr></table></figure><h1 id="视图的检查选项"><a href="#视图的检查选项" class="headerlink" title="视图的检查选项"></a>视图的检查选项</h1><p>当使用with check option子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使符合视图的定义。<strong>MySQL允许基于另一个视图创建视图</strong>，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：cascaded 和 local，<strong>默认值为cascaded(级联)</strong>。</p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意：</strong></p><ul><li><p><strong>只有添加了with check option的视图才会在插入时进行where条件的检查，没有检查时直接会添加成功到表</strong></p></li><li><p><strong>插入的数据是存放到基表中的，视图中不存放数据</strong></p></li></ul></div><h2 id="CASCADED-级联"><a href="#CASCADED-级联" class="headerlink" title="CASCADED(级联)"></a>CASCADED(级联)</h2><p><strong>cascade 会去递归检查当前视图以及创建时依赖的视图，并且看是否加了检查选项，如果其依赖的视图中没有加入检查选项，则会将cascaded向下传递，使其向下的视图都加上检查选项使其都能检查</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_1 <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;TOM&#x27;</span>)</span><br><span class="line"><span class="comment">-- 成功添加到student中</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_1 <span class="keyword">values</span>(<span class="number">30</span>,<span class="string">&#x27;TOM&#x27;</span>)</span><br><span class="line"><span class="comment">-- 添加成功到student中，用select搜索该视图中找不到该数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加cascaded选项后</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_1 <span class="keyword">values</span>(<span class="number">30</span>,<span class="string">&#x27;TOM&#x27;</span>)</span><br><span class="line"><span class="comment">-- 添加失败，因为id&gt;20，故会阻止该数据的添加</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span>  </span><br><span class="line"><span class="comment">-- 由于stu_2使用cascaded检查选项，则stu_1也会继承到该检查选项</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_3 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_3 <span class="keyword">values</span>(<span class="number">11</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入成功</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_3 <span class="keyword">values</span>(<span class="number">17</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入成功，stu_3没有检查选项，不会检查</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_3 <span class="keyword">values</span>(<span class="number">28</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入失败，stu_3没有检查选项，直接到依赖视图stu_2中，stu_2中有检查选项并且是cascaded，满足id&gt;=10,递归进入stu_1中，由于stu_1继承到了cascaded, 会进行判断,不满足id&lt;=20，阻止该数据插入.</span></span><br></pre></td></tr></table></figure><h2 id="LOCAL"><a href="#LOCAL" class="headerlink" title="LOCAL"></a>LOCAL</h2><p><strong>local 会去递归检查当前视图以及创建时依赖的视图，并且看是否加了检查选项，如果有，则进行条件的检查看是否满足条件，如果没有则不进行检查继续递归</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图1,没有依赖视图，没有检查选项</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span>  student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">15</span>;</span><br><span class="line"><span class="comment">-- 创建视图2，依赖于视图1,没有检查选项</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_1 <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">10</span> ;</span><br><span class="line"><span class="comment">-- 创建视图3，依赖于视图2,设置local检查选项</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_3 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_2 <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">with</span> <span class="keyword">local</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_3 <span class="keyword">values</span>(<span class="number">13</span>,<span class="string">&#x27;TOM&#x27;</span>);</span><br><span class="line"><span class="comment">-- 由于stu_3设置了检查选项,该语句会先判断id&lt;20(如果没设置就不会判断而是会直接进入stu_2中),然后递归到stu_2发现stu_2没有添加检查选项，则不进行判断id&gt;=10，如果添加了，则会判断id&gt;=10，再依次递归到stu_1，直到没有依赖其他视图建立的视图为止</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果任意一次条件判断不满足则会插入失败</span></span><br></pre></td></tr></table></figure><h1 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h1><p><strong>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。</strong>如果视图包含以下任何一项，则该视图不可更新：</p><ul><li>聚合函数或窗口函数(SUM()、MIN()、MAX()、COUNT()等）</li><li>DISTINCT </li><li>GROUP BY</li><li>HAVING</li><li>UNION或 UNION ALL </li></ul><h1 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h1><ul><li>简单</li></ul><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经<strong>常使用的查询可以被定义为视图</strong>，从而使得用户不必为以后的操作每次指定全部的条件。</p><ul><li>安全</li></ul><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。</p>]]></content>
    
    
    <summary type="html">视图相关知识</summary>
    
    
    
    <category term="MySQL" scheme="https://www.thekqd.top/categories/MySQL/"/>
    
    
    <category term="MySQL进阶篇" scheme="https://www.thekqd.top/tags/MySQL%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="https://www.thekqd.top/posts/b69403ff.html"/>
    <id>https://www.thekqd.top/posts/b69403ff.html</id>
    <published>2023-10-14T08:19:05.000Z</published>
    <updated>2023-10-14T15:32:45.710Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>储存引擎</title>
    <link href="https://www.thekqd.top/posts/470cdf10.html"/>
    <id>https://www.thekqd.top/posts/470cdf10.html</id>
    <published>2023-10-14T08:18:20.000Z</published>
    <updated>2023-10-14T15:32:45.712Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>索引</title>
    <link href="https://www.thekqd.top/posts/df9a61f7.html"/>
    <id>https://www.thekqd.top/posts/df9a61f7.html</id>
    <published>2023-10-14T08:18:07.000Z</published>
    <updated>2023-10-15T11:43:34.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h1><p>索引(index) 是帮助MySQL<strong>高效获取数据</strong>的<strong>数据结构(有序)</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p><strong>优点：</strong></p><ul><li><strong>提高数据检索的效率，降低数据库的IO成本</strong></li><li><strong>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</strong></li></ul><p><strong>缺点：</strong></p><ul><li><strong>索引列需要占用空间</strong></li><li><strong>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低</strong></li></ul><h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1><p>MySQL的索引是在储存引擎层实现的，不同的储存引擎有不同的结构，主要包含以下几种：</p><ul><li><strong>B+Tree索引：最常见的索引类型，大部分引擎都支持B+树索引</strong></li><li><strong>Hash索引：底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</strong></li><li><strong>R-tree：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</strong></li><li><strong>Full-text：是一种通过建立倒排索引，快速匹配文档的方式，类似于Lucene，Solr，ES</strong></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</strong></p></div><h1 id="索引结构-1"><a href="#索引结构-1" class="headerlink" title="索引结构"></a>索引结构</h1><ul><li>二叉树</li></ul><p><strong>二叉树缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量的情况下，层级较深，检索速度慢。</strong></p><p><strong>红黑树：大数据量的情况下，层级较深，检索速度慢。</strong></p><ul><li>B-Tree(<strong>多路</strong>平衡查找树)</li></ul><p>以一颗最大度数为5(5个子节点)的b-tree为例(每个节点最多储存四个key，5个指针)，指针数 = key + 1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插入 <span class="number">100</span> <span class="number">65</span> <span class="number">169</span> <span class="number">368</span> <span class="number">900</span> <span class="number">556</span> <span class="number">780</span> <span class="number">35</span> <span class="number">215</span> <span class="number">1200</span> <span class="number">234</span> <span class="number">888</span> <span class="number">158</span> <span class="number">90</span> <span class="number">1000</span> <span class="number">88</span> <span class="number">120</span> <span class="number">268</span> <span class="number">250</span>  为例</span><br></pre></td></tr></table></figure><p>B-Tree 动态变化的过程可以参考网站：</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-Tree Visualization (usfca.edu)</a></p><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization (usfca.edu)</a></p><h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><ul><li><strong>主键索引</strong>：针对于表中主键创建的索引，建表时默认自动创建，只能有一个，关键字是PRIMARY。</li><li><strong>唯一索引</strong>：避免同一个表中某数据列中的值重复，可以有多个，关键字UNIQUE。</li><li><strong>常规索引</strong>：快速定位特定的数据，可以有多个。</li><li><strong>全文索引</strong>：全文索引查找的是文本中的关键词，而不是比较索引中的值，可以有多个，关键字FULLTEXT。</li><li><strong>空间索引：</strong> 使用了SPATIAL关键字的索引，适用于GEOMETRY ,POINT,POLYGON等空间类型数据的列</li></ul><p>在InnoDB储存引擎中，根据索引的存储形式，又可以分为以下两种：</p><ul><li>聚集索引(Clustered Index)：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据(记录)，<strong>必须有，而且只有一个</strong></li><li>二级索引(Secondary Index)：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键，<strong>可以存在多个</strong></li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>聚集索引的选取规则：</strong></p><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表中没有主键，或没有适合的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ul></div><p>回表查询：先根据字段对应的二级索引去查对应的主键值，在根据主键对应的聚集索引去查行数据。</p><h1 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h1><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><ul><li>建表之后创建索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用create创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name <span class="keyword">ON</span> table_name(字段名[(索引字符长度) [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]],...);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一个索引可关联多个字段</span></span><br><span class="line"><span class="comment">-- 索引字符长度和排序是可选项</span></span><br><span class="line"><span class="comment">-- 不加可选项UNIQUE或FULLTEXT代表默认创建常规索引</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用alter为创建索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line"><span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name(字段名[(索引字符长度) [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]],...)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">--  以name字段为姓名字段，该字段的值可能会重复，且索引针对name的前3个字符以降序排序,为该字段创建索引。</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name(<span class="number">3</span>) <span class="keyword">desc</span>);</span><br><span class="line"><span class="comment">-- phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">UNIQUE</span> index idx_user_phone <span class="keyword">on</span> tb_user(phone);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为profession、age、status创建联合索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_status <span class="keyword">on</span> tb_user(profession、age、status);</span><br><span class="line">联合索引中字段索引是有讲究的</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为email建立合适的索引来提升查询效率</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_email <span class="keyword">on</span> tb_user(email);</span><br></pre></td></tr></table></figure><ul><li><strong>可以在建表时创建索引</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 数据类型 列约束 comment <span class="string">&#x27;注释&#x27;</span>,</span><br><span class="line">    字段<span class="number">2</span> 数据类型 列约束 comment <span class="string">&#x27;注释&#x27;</span>，</span><br><span class="line">    ...</span><br><span class="line">    [表约束]，</span><br><span class="line">    [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name(字段名[(索引字符长度) [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]],...),</span><br><span class="line">    ...</span><br><span class="line">     [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name(字段名[(索引字符长度) [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]],...),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例:</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> classroom(</span><br><span class="line">cid <span class="type">int</span> auto_increment,</span><br><span class="line">    crno <span class="type">varchar</span>(<span class="number">13</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    cbn <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(cid),</span><br><span class="line">    <span class="keyword">unique</span> index cn_cb_index(crno,cbn)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在表约束后，可以使用index关键字为表创建索引，与<span class="keyword">create</span> index用法相同。</span><br><span class="line"><span class="number">2.</span><span class="keyword">create</span> <span class="keyword">table</span>语句可以一次附带多个索引，不同索引间使用逗号分隔</span><br><span class="line"><span class="number">3.</span><span class="keyword">create</span> <span class="keyword">table</span>创建索引时无需提供表名，而是使用<span class="keyword">create</span> index语句创建索引时要指明表名</span><br></pre></td></tr></table></figure><h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看tb_user表的索引</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure><h2 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h2><p><a href="https://blog.csdn.net/challenglistic/article/details/129166717">Mysql 索引（三）—— 不同索引的创建方式（主键索引、普通索引、唯一键索引）-CSDN博客</a></p><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接使用drop删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例：删除email的索引</span></span><br><span class="line"><span class="keyword">drop</span> index idx_user_email <span class="keyword">on</span> tb_user;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用alter删除索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> index 索引名；</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">索引相关知识</summary>
    
    
    
    <category term="MySQL" scheme="https://www.thekqd.top/categories/MySQL/"/>
    
    
    <category term="MySQL进阶篇" scheme="https://www.thekqd.top/tags/MySQL%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="https://www.thekqd.top/posts/93ac284c.html"/>
    <id>https://www.thekqd.top/posts/93ac284c.html</id>
    <published>2023-10-02T14:07:18.000Z</published>
    <updated>2023-10-14T15:38:51.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h1><p><strong>事务（transaction）</strong>是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作<strong>要么同时成功，要么同时失败</strong></p><h1 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><ul><li>查看/设置事务提交方式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="comment">-- 查看事务的自动提交方式：1为自动，0为手动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 设置系统变量的提交方式：1为自动，0为手动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这种方法可作用于全局</span></span><br></pre></td></tr></table></figure><ul><li>提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 在设置了手动提交后，任意的sql语句，只有在sql语句之后使用了commit才会提交修改数据库，否则不会修改</span></span><br></pre></td></tr></table></figure><ul><li>回滚事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="comment">-- 遇到异常时可以回滚已经执行的sql语句</span></span><br><span class="line"><span class="comment">-- 提交之后不能回滚</span></span><br></pre></td></tr></table></figure><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><ul><li>开启事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION 或 <span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 这句话执行后代表开启事务，代表我们要手动控制事务，只要没有commit数据库就不会改变、</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这种方法可作用于某些语句,执行完成后事务自动关闭</span></span><br></pre></td></tr></table></figure><ul><li>提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- commit事务后代表事务完成了</span></span><br></pre></td></tr></table></figure><ul><li>回滚事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h1 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性(ACID)"></a>事务的四大特性(ACID)</h1><ul><li>原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态(合理加减)。</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变使永久的。</li></ul><h1 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h1><ul><li><p><strong>丢失更新</strong>：两个事务读入同一数据，并发执行修改操作时，一个事务将另一个事务的修改覆盖，导致这些修改好像丢失了一样</p></li><li><p><strong>读取脏数据(脏读)：</strong>一个事务读到另外一个事务<strong>还没有提交</strong>的数据(未commit)</p></li><li><p><strong>不可重复读：</strong>在一个事务中先后读取同一条数据，但两次读取的数据不同，称为不可重复读。</p></li><li><strong>幻象读(幻读)：</strong>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在了，好像出现了”幻影”</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- (查询)不可重复读：现在分别开启A,B两个事务，A第一次读取数据，在A第二次读取前，B事务修改了该数据，导致该事务再次读取数据时数据与第一次读取不同(A事务始终没有结束)</span></span><br><span class="line"><span class="comment">-- 如果解决了不可重复读，在一个事务中，两次读取同一个数据，数据相同，但在该事务结束后，再读取，数据就会更新了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- (增删)幻读: 在解决了不可重复读之后才会出现，A事务查询数据时，没有对应的数据行，A准备插入，但是在A插入前，B插入了数据,A就会得到数据已经存在，但是之后第二次查询，又发现没有该数据行。</span></span><br><span class="line"><span class="comment">-- 因为设置了可重复读（解决不可重复读），所以才会满足在同一个事务中两次读取到的数据应该是相同的，但是实际数据确实存在</span></span><br></pre></td></tr></table></figure><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 四种事务隔离级别，从上到下性能降低，安全升高</span></span><br><span class="line"><span class="comment">-- 通常要综合性能和安全选择隔离级别</span></span><br><span class="line"></span><br><span class="line">脏读      不可重复读     幻读</span><br><span class="line">Read uncommitted:  会出现       会出现      会出现</span><br><span class="line">Read committed:     不会会  会</span><br><span class="line">Repeatable Read:不会不会 会</span><br><span class="line">Serializable:不会不会不会</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Mysql默认：Repeatable Read 可重复读</span></span><br><span class="line"><span class="comment">-- Oracle默认: Read committed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Read uncommitted：未提交读</span></span><br><span class="line"><span class="comment">-- Read committed：提交读</span></span><br><span class="line"><span class="comment">-- Repeatable Read：可重复读</span></span><br><span class="line"><span class="comment">-- Serializable：序列化(串行化)，代表在进行并发事务操作时，同一时间只能执行一个事务，只有在该事务提交之后，才能执行其他事务，其他事务在这之前会被阻塞,避免所有的并发问题</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看事务隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@TRANSACTION_ISOLATION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED<span class="operator">|</span> READ COMMITTED<span class="operator">|</span> REPEATABLE READ<span class="operator">|</span> SERIALIZABLE]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SESSION：会话级别,代表针对当前客户端窗口有效,某一个console控制台</span></span><br><span class="line"><span class="comment">-- GLOBAL：代表所有客户端有效</span></span><br></pre></td></tr></table></figure><ul><li><strong>注意事务隔离级别越高，数据越安全，但是性能越低</strong></li></ul>]]></content>
    
    
    <summary type="html">事务的相关知识</summary>
    
    
    
    <category term="MySQL" scheme="https://www.thekqd.top/categories/MySQL/"/>
    
    
    <category term="MySQL基础篇" scheme="https://www.thekqd.top/tags/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>多表查询</title>
    <link href="https://www.thekqd.top/posts/f0cb7806.html"/>
    <id>https://www.thekqd.top/posts/f0cb7806.html</id>
    <published>2023-09-26T14:19:46.000Z</published>
    <updated>2023-10-14T16:26:24.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h1><p>项目开发中，在进行数据库表结构设计师，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所有各个表结构之间也存在着各种联系，基本分为三种:</p><ul><li><p>一对多(多对一)</p><p>   案例：部门与 员工的关系</p><p>   关系：一个部门对应多个员工，一个员工对应多个部门</p></li></ul><p>​     实现：<strong>在多的一方建立外键，指向一的一方主键</strong></p><ul><li>多对多</li></ul><p>​        案例：学生与课程的关系</p><p>​        关系：一个学生可以选修多么课程，一门课程也可以供多个学生选择</p><p>​        实现：<strong>建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</strong></p><ul><li><p>一对一</p><p>案例：用户与用户详情的关系</p><p>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详细字段放在另一张表中,以提升操作效率</p><p>实现：<strong>在任意一方加入外键，关联另一方的主键，并设置外键为唯一的UNIQUE</strong></p></li></ul><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>概述：指从多张表中查询数据</p><p>笛卡尔积：笛卡尔乘积是指在数学中，两个集合A集合和B集合的所有组合情况。(<strong>在多表查询时，需要消除无效的笛卡尔积</strong>)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 后面这个where就可以保证出来的两个id对应</span></span><br><span class="line">连接条件为: emp.dept_id <span class="operator">=</span> dept.id</span><br></pre></td></tr></table></figure><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p><strong>内连接将两张表连接起来，内连接查询的是两张表的交集的部分</strong></p><p>隐式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>，表<span class="number">2</span> <span class="keyword">WHERE</span> 条件 ...;</span><br><span class="line"><span class="comment">-- 不使用内连接实现方式</span></span><br></pre></td></tr></table></figure><p>显示内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 写法一</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 连接条件...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 写法二</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 连接条件 <span class="keyword">and</span> 连接条件 ...;</span><br></pre></td></tr></table></figure><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> (<span class="keyword">OUTER</span>) <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 <span class="keyword">LEFT</span> (<span class="keyword">OUTER</span>) <span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 连接条件...;</span><br></pre></td></tr></table></figure><p><strong>注：相当于查询左表(表1)的所有数据包含表1和表2交集部分的数据</strong></p><h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> (<span class="keyword">OUTER</span>) <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 <span class="keyword">LEFT</span> (<span class="keyword">OUTER</span>) <span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 连接条件...;</span><br></pre></td></tr></table></figure><p><strong>注：相当于查询右表(表2)的所有数据包含表1和表2交集部分的数据</strong></p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意:</strong></p><ul><li><strong>左外连接可以和右外连接互相转换，只需要交换字段位置</strong></li><li>外连接和内连接的区别:<strong>内连接只会展示两张表的交集部分当连接的部分中没有原表中的某条数据，即为NULL时，就不会显示出来，而外连接可以将某一张表的所有数据和交集部分显示出来，即可以显示想要知道的NULL</strong></li></ul></div><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A <span class="keyword">AS</span> 别名A <span class="keyword">JOIN</span> 表A <span class="keyword">AS</span> 别名B <span class="keyword">ON</span> 条件 ...;</span><br><span class="line"></span><br><span class="line">一定要将该表取两个别名，看成两张表</span><br></pre></td></tr></table></figure><p><strong>自连接查询，可以是内连接查询，也可以是外连接查询</strong></p><h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><p>把多次查询的结果合并起来，形成一个新的查询结果集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A ...</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B ...;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">50</span> </span><br><span class="line"></span><br><span class="line">有<span class="keyword">ALL</span>可能会导致有重复，但去掉<span class="keyword">ALL</span>只用<span class="keyword">union</span>则会去除相同的</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意:</strong></p><ul><li><strong>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</strong></li><li><strong>union all 会将全部的数据直接合并在一起，union会对合并之后的数据去重</strong></li><li><strong>or只能单表查询，而union可以多表查询</strong></li></ul></div><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><ul><li>概念：SQL语句中嵌套SELECT语句，成为<strong>嵌套查询</strong>，又称<strong>子查询</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> column1 <span class="operator">=</span> (<span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> t2);</span><br><span class="line"></span><br><span class="line">子查询外部的语句可以是：<span class="keyword">INSERT</span><span class="operator">/</span><span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span><span class="operator">/</span><span class="keyword">SELECT</span>的任何一个。</span><br></pre></td></tr></table></figure><ul><li><p>根据子查询结果不同，分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询 （子查询结果为多行多列）</li></ul></li></ul><ul><li>根据子查询位置,分为：WHERE之后、FROM之后、SELECT之后。</li></ul><h3 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h3><p>子查询返回的结果是单个值(数字、字符串、日期等), 是最简单的形式，这种子查询称为<strong>标量子查询</strong></p><p>常用的操作符：<strong>= ，&lt;&gt; ，&gt;， &gt;=， &lt;， &lt;=</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例如:</span></span><br><span class="line"><span class="comment">-- 查询&#x27;销售部&#x27;的所有员工信息(id和名称在两张表)</span></span><br><span class="line"><span class="comment">-- 我们分为两步</span></span><br><span class="line"><span class="comment">-- 1.查询&#x27;销售部&#x27;部门ID</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.根据销售部的部门ID，查询员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.使用标量子查询合并之后就是</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h3><p>子查询返回的结果是一列(可以是多行), 这种子查询成为列子查询。</p><p>常用的操作符： <strong>IN 、NOT IN 、ANY 、SOME 、ALL</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IN</span> ：在指定的集合范围之内  ，多选一</span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">IN</span> ： 不在指定的集合范围之内</span><br><span class="line"><span class="keyword">ANY</span> ：子查询返回列表中，有任意一个满足即可</span><br><span class="line"><span class="keyword">SOME</span> ： 与<span class="keyword">ANY</span>等同，使用<span class="keyword">SOME</span>的地方都可以使用<span class="keyword">ANY</span></span><br><span class="line"><span class="keyword">ALL</span> : 子查询返回列表的所有值都必须满足</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="comment">-- 列子查询</span></span><br><span class="line"><span class="comment">-- 1.查询&#x27;销售部&#x27;和&#x27;市场部&#x27;的所有员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.查询比财务部所有人工资都高的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询所有财务部人员工资</span></span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b. 比财务部所有人工资都高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">ALL</span>(<span class="keyword">select</span>  salary <span class="keyword">from</span> <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>)salary )</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.查询比研发部任意一人工资高的员工该信息</span></span><br><span class="line"><span class="comment">-- a. 查询研发部所有人工资</span></span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b. 比研发部其中任意一人工资高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">ANY</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h3><p>子查询返回的结果是一行（可以是多列），这种子查询成为<strong>行子查询</strong></p><p>常用的操作符：<strong>= ，&lt;&gt; ，IN、NOT IN</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 行子查询</span></span><br><span class="line"><span class="comment">-- 1.查询与&#x27;张无忌&#x27;的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询张无忌的薪资及直属领导</span></span><br><span class="line"><span class="keyword">select</span> salary,managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b. 查询与&#x27;张无忌&#x27;的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">=</span> <span class="number">12500</span> <span class="keyword">and</span> managerid <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 组合作为条件</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="number">12500</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 表示salary =12500，managerid = 1 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 行子查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="keyword">select</span> salary,managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>);</span><br><span class="line"><span class="comment">-- 刚好是两条数据两两对应，等号的组合写法</span></span><br></pre></td></tr></table></figure><h3 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h3><p>子查询返回的结果是多行多列，这种子查询称为<strong>表子查询</strong></p><p>常用操作符: <strong>IN</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表子查询</span></span><br><span class="line"><span class="comment">-- 1. 查询与 &#x27;lzk&#x27; ,&#x27;syq&#x27; 的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="comment">-- a. 查询 lzk，syq的职位和薪资</span></span><br><span class="line"><span class="keyword">select</span> job,salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;lzk&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;lyq&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b.查询与lzk，syq的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="comment">-- 组合写法</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (job,salary) <span class="keyword">in</span> (<span class="keyword">select</span> job,salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;lzk&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;lyq&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多表建立关系</summary>
    
    
    
    <category term="MySQL" scheme="https://www.thekqd.top/categories/MySQL/"/>
    
    
    <category term="MySQL基础篇" scheme="https://www.thekqd.top/tags/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="https://www.thekqd.top/posts/71adb096.html"/>
    <id>https://www.thekqd.top/posts/71adb096.html</id>
    <published>2023-09-25T12:46:55.000Z</published>
    <updated>2023-10-14T15:38:39.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><a href="https://blog.csdn.net/hzbooks/article/details/118561808?ops_request_misc=%7B%22request%5Fid%22%3A%22169564664916800227428260%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169564664916800227428260&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-118561808-null-null.142^v94^insert_down1&amp;utm_term=mysql常用字符串函数&amp;spm=1018.2226.3001.4187">MySQL 十大常用字符串函数_hzbooks的博客-CSDN博客</a></p><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>常用的函数:</p><h3 id="CONCAT"><a href="#CONCAT" class="headerlink" title="CONCAT"></a>CONCAT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(s1,s2,..sn)</span><br><span class="line">将字符串拼接，S1,S2,...Sn拼接成一个字符串，返回该字符串</span><br></pre></td></tr></table></figure><h3 id="LOWER"><a href="#LOWER" class="headerlink" title="LOWER"></a>LOWER</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LOWER</span>(str) </span><br><span class="line">将字符串str全部转换为小写,返回该函数</span><br></pre></td></tr></table></figure><h3 id="UPPER"><a href="#UPPER" class="headerlink" title="UPPER"></a>UPPER</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPPER</span>(str)</span><br><span class="line">将字符串str全部转换为大写,返回该函数</span><br></pre></td></tr></table></figure><h3 id="LPAD"><a href="#LPAD" class="headerlink" title="LPAD"></a>LPAD</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LPAD(str,n,pad)</span><br><span class="line">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</span><br><span class="line"></span><br><span class="line">lpad(<span class="string">&#x27;01&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">代表用<span class="string">&#x27;-&#x27;</span>填充左边的得到<span class="string">&#x27;---01&#x27;</span>,一共五个字符，下面的rpad同理</span><br></pre></td></tr></table></figure><h3 id="RPAD"><a href="#RPAD" class="headerlink" title="RPAD"></a>RPAD</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RPAD(str,n,pad)</span><br><span class="line">右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</span><br></pre></td></tr></table></figure><h3 id="TRIM"><a href="#TRIM" class="headerlink" title="TRIM"></a>TRIM</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TRIM</span>(str)</span><br><span class="line">去掉字符串头部和尾部的空格(不除去中间)</span><br></pre></td></tr></table></figure><h3 id="SUBSTRING"><a href="#SUBSTRING" class="headerlink" title="SUBSTRING"></a>SUBSTRING</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUBSTRING</span>(str,<span class="keyword">start</span>,len)</span><br><span class="line">返回从字符串str从<span class="keyword">start</span>位置起的len个长度的字符串</span><br></pre></td></tr></table></figure><h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><h3 id="CEIL"><a href="#CEIL" class="headerlink" title="CEIL"></a>CEIL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CEIL</span>()</span><br><span class="line">向上取整</span><br></pre></td></tr></table></figure><h3 id="FLOOR"><a href="#FLOOR" class="headerlink" title="FLOOR"></a>FLOOR</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FLOOR</span>()</span><br><span class="line">向下取整</span><br></pre></td></tr></table></figure><h3 id="MOD"><a href="#MOD" class="headerlink" title="MOD"></a>MOD</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MOD</span>(x,y)</span><br><span class="line">返回x<span class="operator">/</span>y的模</span><br></pre></td></tr></table></figure><h3 id="RAND"><a href="#RAND" class="headerlink" title="RAND"></a>RAND</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAND()</span><br><span class="line">返回<span class="number">0</span><span class="operator">~</span><span class="number">1</span>内的随机数</span><br></pre></td></tr></table></figure><h3 id="ROUND"><a href="#ROUND" class="headerlink" title="ROUND"></a>ROUND</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ROUND(x,y)</span><br><span class="line">求参数x的四舍五入的值，保留y位小数</span><br></pre></td></tr></table></figure><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><h3 id="CURDATE"><a href="#CURDATE" class="headerlink" title="CURDATE"></a>CURDATE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curdate()</span><br><span class="line">返回当前日期,年<span class="operator">-</span>月<span class="operator">-</span>日</span><br></pre></td></tr></table></figure><h3 id="CURTIME"><a href="#CURTIME" class="headerlink" title="CURTIME"></a>CURTIME</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curtime()</span><br><span class="line">返回当前时间</span><br></pre></td></tr></table></figure><h3 id="NOW"><a href="#NOW" class="headerlink" title="NOW"></a>NOW</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">now()</span><br><span class="line">返回当前日期和时间</span><br></pre></td></tr></table></figure><h3 id="YEAR"><a href="#YEAR" class="headerlink" title="YEAR"></a>YEAR</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">year</span>(<span class="type">date</span>)</span><br><span class="line">获取指定<span class="type">date</span>的年份</span><br></pre></td></tr></table></figure><h3 id="MONTH"><a href="#MONTH" class="headerlink" title="MONTH"></a>MONTH</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">month</span>(<span class="type">date</span>)</span><br><span class="line">获取指定<span class="type">date</span>的月份</span><br></pre></td></tr></table></figure><h3 id="DAY"><a href="#DAY" class="headerlink" title="DAY"></a>DAY</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">day</span>(<span class="type">date</span>)</span><br><span class="line">获取指定<span class="type">date</span>的日期</span><br></pre></td></tr></table></figure><h3 id="DATE-ADD"><a href="#DATE-ADD" class="headerlink" title="DATE_ADD"></a>DATE_ADD</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DATE_ADD(<span class="type">date</span>,<span class="type">INTERVAL</span> expr type)</span><br><span class="line">返回一个日期<span class="operator">/</span>时间值加上一个时间间隔expr后的时间值</span><br><span class="line"></span><br><span class="line">expr 指定数字</span><br><span class="line">type 指定类型:年<span class="operator">/</span>月<span class="operator">/</span>日(<span class="keyword">DAY</span><span class="operator">/</span><span class="keyword">MONTH</span><span class="operator">/</span><span class="keyword">YEAR</span>)</span><br><span class="line">例：</span><br><span class="line">DATE_ADD(now(),<span class="type">INTERVAL</span> <span class="number">70</span> <span class="keyword">day</span>)<span class="comment">-- 70天之后的时间</span></span><br><span class="line">DATE_ADD(now(),<span class="type">INTERVAL</span> <span class="number">70</span> <span class="keyword">month</span>)<span class="comment">-- 70个月之后的时间</span></span><br></pre></td></tr></table></figure><h3 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF"></a>DATEDIFF</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DATEDIFF(date1,date2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回起始时间date1和结束时间date2</span></span><br><span class="line">之间的天数</span><br><span class="line"><span class="comment">-- 一般用于求入职，入学时间等</span></span><br></pre></td></tr></table></figure><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IF(<span class="keyword">value</span>,t,f)</span><br><span class="line">如果<span class="keyword">value</span>为<span class="literal">true</span>，则返回t，否则返回f</span><br><span class="line"><span class="comment">-- 类似三目运算符</span></span><br></pre></td></tr></table></figure><h3 id="IFNULL"><a href="#IFNULL" class="headerlink" title="IFNULL"></a>IFNULL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(value1,value2)</span><br><span class="line">如果value1不为<span class="keyword">null</span>，返回value1，否则返回value2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用于聚合函数的筛选</span></span><br><span class="line"><span class="comment">-- 例： 求成绩大于60分才有学分，求同学的总学分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sno <span class="keyword">as</span> <span class="string">&#x27;学号&#x27;</span>,sn <span class="keyword">as</span> <span class="string">&#x27;姓名&#x27;</span>,<span class="built_in">sum</span>(IF(score<span class="operator">&gt;=</span><span class="number">60</span>,credit,<span class="keyword">NULL</span>)) <span class="keyword">from</span> s;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这里的if会判断，如果score&gt;=60分就会返回credit，即sum(credit)计算学分和,如果不满足则会返回NULL，就不会计算该值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CASE-WHEN"><a href="#CASE-WHEN" class="headerlink" title="CASE WHEN"></a>CASE WHEN</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> [expr] <span class="keyword">WHEN</span> [val1] <span class="keyword">THEN</span> [res1] ...<span class="keyword">ELSE</span>[<span class="keyword">default</span>] <span class="keyword">END</span></span><br><span class="line">如果expr(表达式<span class="operator">/</span>字段)的值等于val1，返回res1，...否则返回<span class="keyword">default</span>默认值</span><br><span class="line"><span class="comment">-- 一般用于给出具体的条件的值</span></span><br><span class="line"></span><br><span class="line">例：查询emp表的员工姓名和工作地址，如果工作地址在北京<span class="operator">/</span>上海，则标明一线城市，其他则为二线城市</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">name,</span><br><span class="line">(<span class="keyword">case</span> workaddress <span class="keyword">when</span> <span class="string">&#x27;北京&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">when</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;二线城市&#x27;</span> <span class="keyword">end</span> ) <span class="keyword">as</span> <span class="string">&#x27;工作地址&#x27;</span></span><br><span class="line"><span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> [val <span class="number">1</span>] <span class="keyword">THEN</span> [RES1] ... <span class="keyword">ELSE</span> [<span class="keyword">default</span>] <span class="keyword">END</span></span><br><span class="line">如果val1为<span class="literal">true</span>，返回res1，...否则返回<span class="keyword">default</span>默认值</span><br><span class="line"><span class="comment">-- 一般用于范围</span></span><br><span class="line"></span><br><span class="line">例如：统计成绩，<span class="number">85</span>分以上为优秀，<span class="number">60</span>分以上为及格，<span class="number">60</span>分以下为不及格</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">id,</span><br><span class="line">name,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> math<span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span> ) <span class="keyword">as</span> <span class="string">&#x27;数学&#x27;</span>,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> english<span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span> ) <span class="keyword">as</span> <span class="string">&#x27;英语&#x27;</span>,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> chinese<span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span> ) <span class="keyword">as</span> <span class="string">&#x27;语文&#x27;</span>,</span><br><span class="line"><span class="keyword">from</span> score;</span><br><span class="line"></span><br><span class="line">其中math，english，chinese 三个字段使用了流程函数,使<span class="keyword">select</span>出来的值进行了指定</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">MySQL的一些函数</summary>
    
    
    
    <category term="MySQL" scheme="https://www.thekqd.top/categories/MySQL/"/>
    
    
    <category term="MySQL基础篇" scheme="https://www.thekqd.top/tags/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>MySQL通用语法及操作</title>
    <link href="https://www.thekqd.top/posts/f2e69609.html"/>
    <id>https://www.thekqd.top/posts/f2e69609.html</id>
    <published>2023-09-16T09:09:12.000Z</published>
    <updated>2023-10-18T03:32:11.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h1><ul><li>SQL语句可以单行或多行书写，使用回车可换行继续书写<strong>最后以分号结尾</strong>。</li><li>SQL语句可以使用空格/缩进来增加语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>注释：<ul><li>单行注释：— 注释内容 或 # 注释内容（MySQL特有）</li><li>多行注释：/*注释内容*/</li></ul></li></ul><h1 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DDL<span class="punctuation">:</span> 数据定义语言，用来定义数据库对象（数据库，表，字段）</span><br><span class="line">DML<span class="punctuation">:</span> 数据操作语言，用来对数据库表中的数据进行增删改</span><br><span class="line">DQL<span class="punctuation">:</span> 数据查询语言，用来查询数据库中表的记录</span><br><span class="line">DCL<span class="punctuation">:</span> 数据控制语言，用来创建数据库的用户、控制数据库的访问权限</span><br></pre></td></tr></table></figure><h1 id="SQL数据类型"><a href="#SQL数据类型" class="headerlink" title="SQL数据类型"></a>SQL数据类型</h1><p>见这篇blog-&gt;<a href="https://blog.csdn.net/wangkun_j/article/details/113500282?ops_request_misc=%7B%22request%5Fid%22%3A%22169493216516800197069763%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169493216516800197069763&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-113500282-null-null.142^v94^chatsearchT3_1&amp;utm_term=mysql字段类型&amp;spm=1018.2226.3001.4187">MySQL字段类型最全解析<em>kun</em>行者的博客-CSDN博客</a></p><h1 id="SQL运算符"><a href="#SQL运算符" class="headerlink" title="SQL运算符"></a>SQL运算符</h1><p><a href="https://blog.csdn.net/heart2070292037/article/details/122562132?ops_request_misc=%7B%22request%5Fid%22%3A%22169522393616800180688568%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169522393616800180688568&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-122562132-null-null.142^v94^chatsearchT3_1&amp;utm_term=sql运算符&amp;spm=1018.2226.3001.4187">SQL学习之运算符_sql运算符有哪些_heart-szu的博客-CSDN博客</a></p><h1 id="SQL七大约束"><a href="#SQL七大约束" class="headerlink" title="SQL七大约束"></a>SQL七大约束</h1><p><strong>约束条件用法参考这篇blog</strong><a href="https://blog.csdn.net/m0_64338546/article/details/128547998?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mysql约束&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-128547998.nonecase&amp;spm=1018.2226.3001.4187">【MySQL基础】MySQL表的七大约束<em>mysql 表级约束</em>小杨MiManchi的博客-CSDN博客</a></p><h2 id="DDL-数据库操作和表操作"><a href="#DDL-数据库操作和表操作" class="headerlink" title="DDL(数据库操作和表操作)"></a>DDL(数据库操作和表操作)</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p><strong>查看所有数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure><p><strong>查询当前数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE<span class="operator">|</span>SCHEMA [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [<span class="keyword">DEFAULT</span> (CHARSET)<span class="operator">|</span>(<span class="type">CHARACTER</span> <span class="keyword">SET</span>) 字符集] [<span class="keyword">COLLATE</span> 排序规则];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">DEFAULT</span>这个单词在写代码的时候可以加也可以不加,最好加上</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> ETISTS teaching</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="keyword">COLLATE</span> utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] 数据库名;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>结果会显示出创建命令和各参数设置(字符集，校对规则)</span><br></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE<span class="operator">|</span>SCHEMA [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [<span class="keyword">DEFAULT</span> (CHARSET)<span class="operator">|</span>(<span class="type">CHARACTER</span> <span class="keyword">SET</span>) 字符集] [<span class="keyword">COLLATE</span> 排序规则];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>注意：用户必须有数据库的修改权限才能使用该命令修改数据库</span><br></pre></td></tr></table></figure><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><p>查询当前数据库所有表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><p>查询表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 表明;</span><br></pre></td></tr></table></figure><p>查询指定表的建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>会显示出详细注释，引擎，字符集，校对规则</span><br></pre></td></tr></table></figure><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型 [约束条件] [COMMENT <span class="string">&#x27;字段1注释&#x27;</span>],</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型 [约束条件] [COMMENT <span class="string">&#x27;字段2注释&#x27;</span>],</span><br><span class="line">    字段<span class="number">3</span> 字段<span class="number">3</span>类型 [约束条件] [COMMENT <span class="string">&#x27;字段3注释&#x27;</span>],</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[COMMENT 表注释];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例子:</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">    id <span class="type">int</span> comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;姓名&#x27;</span></span><br><span class="line">    ) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li>表名和字段只能用反引号或不用符号，<strong>不能用单引号</strong></li><li>最后一个字段结尾不要有逗号</li><li>comment后的字段注释或表注释必须使用引号，而且<strong>是单引号</strong>而不是反引号</li></ul></div><h4 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h4><p><strong>添加字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型(长度) [COMMENT 注释] [约束];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">alter</span>: 修改</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">add</span>: 添加</span><br></pre></td></tr></table></figure><p><strong>修改指定字段数据类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型(长度);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>modify: 修改</span><br></pre></td></tr></table></figure><p><strong>修改字段数据名和字段类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>change: 修改</span><br></pre></td></tr></table></figure><p><strong>删除字段</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br></pre></td></tr></table></figure><p><strong>修改表名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新表名;</span><br></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p><strong>删除表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 表名;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>数据全部删除</span><br></pre></td></tr></table></figure><p><strong>删除指定表，并重新创建该表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>数据全部删除，结构不变</span><br></pre></td></tr></table></figure><h2 id="DML-数据操作"><a href="#DML-数据操作" class="headerlink" title="DML(数据操作)"></a>DML(数据操作)</h2><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><ul><li><strong>给指定字段添加一条数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span><span class="operator">|</span>REPLACE <span class="keyword">INTO</span> 表名(字段名<span class="number">1</span>，字段名<span class="number">2</span>，字段名<span class="number">3</span>,..) <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..);</span><br></pre></td></tr></table></figure><ul><li><strong>给全部字段添加一条数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span><span class="operator">|</span>REPLACE <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，...);</span><br></pre></td></tr></table></figure><ul><li><strong>批量添加多条数据</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span><span class="operator">|</span>REPLACE <span class="keyword">INTO</span> 表名(字段名<span class="number">1</span>，字段名<span class="number">2</span>，字段名<span class="number">3</span>,..) <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>指定字段添加多份数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span>(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>，..);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>所有字段添加多份数据</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意：</p><ul><li><strong>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</strong></li><li><strong>字符串和日期型(date型)数据应该包含在引号中</strong></li><li><strong>插入的数据大小应该在字段的规定范围内</strong></li></ul></div><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p><strong>修改</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>, 字段名<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,...[<span class="keyword">WHERE</span> 条件]；</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;kqd&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>将id为<span class="number">1</span>的字段name数据修改为kqd</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意：</p><ul><li>修改语句的条件可以有，也可以没有，<strong>如果没有条件，则会修改整张表的所有数据。</strong></li></ul></div><p><strong>删除</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件]</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除gender为女的员工</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employee <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除所有员工</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意：</p><ul><li><strong>DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。</strong></li><li><strong>DELETE语句不能删除某一个字段的值(但可以使用UPDATE)。</strong></li></ul></div><h2 id="DQL-查询"><a href="#DQL-查询" class="headerlink" title="DQL(查询)"></a>DQL(查询)</h2><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><p>1.查询多个字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>，字段<span class="number">2.</span>.. <span class="keyword">FROM</span> 表名；</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 ; </span><br><span class="line"></span><br><span class="line"><span class="operator">*</span>代表查询所有的字段</span><br></pre></td></tr></table></figure><p>2.设置别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span> [<span class="keyword">AS</span> 别名<span class="number">1</span>]，字段<span class="number">2</span> [<span class="keyword">AS</span> 别名<span class="number">2</span>]... <span class="keyword">FROM</span> 表名；</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">AS</span> 可省略</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对字段起别名 </span></span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> <span class="keyword">as</span> <span class="string">&#x27;别名&#x27;</span>,...</span><br><span class="line">为字段<span class="number">1</span>取别名</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对表取别名</span></span><br><span class="line"><span class="keyword">select</span> a.name</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> a</span><br><span class="line">为student表取别名a</span><br></pre></td></tr></table></figure><p>3.去除重复记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件列表;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">条件:</span><br><span class="line">运算符</span><br><span class="line"><span class="number">1.</span>算数</span><br><span class="line"><span class="operator">+</span>, <span class="operator">-</span>, <span class="operator">*</span>, <span class="operator">/</span></span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"><span class="number">2.</span>判断</span><br><span class="line"><span class="operator">&gt;</span>, <span class="operator">&lt;</span>, <span class="operator">&gt;=</span>, <span class="operator">&lt;=</span>, <span class="operator">!=</span>, <span class="operator">&lt;&gt;</span>(不等于) </span><br><span class="line"><span class="keyword">IS</span> <span class="keyword">NULL</span><span class="operator">|</span><span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>(判断是否为<span class="keyword">NULL</span>)</span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"><span class="number">3.</span>逻辑 </span><br><span class="line"><span class="keyword">AND</span>(<span class="operator">&amp;&amp;</span>), <span class="keyword">OR</span>(<span class="operator">||</span>),<span class="keyword">NOT</span><span class="operator">||</span><span class="operator">!</span></span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"><span class="number">4.</span>范围 </span><br><span class="line"><span class="keyword">BETWEEN</span> 最小值 <span class="keyword">AND</span> 最大值,</span><br><span class="line"><span class="keyword">IN</span>(值<span class="number">1</span>，值<span class="number">2</span>，...)  <span class="operator">/</span><span class="operator">/</span><span class="keyword">IN</span>之后的列表的值为范围</span><br><span class="line"><span class="number">5.</span>模糊匹配 </span><br><span class="line"><span class="keyword">LIKE</span> <span class="string">&#x27;_||%||&#x27;</span></span><br><span class="line"><span class="string">&#x27;_&#x27;</span> 表示代表一个字符</span><br><span class="line"><span class="string">&#x27;%&#x27;</span> 表示<span class="number">0</span>各或多个字符</span><br><span class="line"><span class="string">&#x27;[]&#x27;</span> 表示某一范围的字符,例如[<span class="number">0</span><span class="number">-9</span>],<span class="number">0</span><span class="operator">~</span><span class="number">9</span>之间的字符</span><br><span class="line"><span class="string">&#x27;[^]&#x27;</span> 表示不再某一范围的字符</span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><strong>介绍:</strong></p><p>将一列数据作为一个整体，进行纵向计算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">聚合函数：</span><br><span class="line"><span class="built_in">count</span>() 统计元组数量（行数）</span><br><span class="line"><span class="built_in">max</span>() 最大值</span><br><span class="line"><span class="built_in">min</span>() 最小值</span><br><span class="line"><span class="built_in">avg</span>() 平均值</span><br><span class="line"><span class="built_in">sum</span>() 求和</span><br></pre></td></tr></table></figure><p><strong>语法:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数(字段列表),聚合函数,... <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li><strong>所有的NULL值不参与所有聚合函数运算，对某个字段中有NULL在使用count时将不会计算数据条数。</strong></li><li><strong>count(*)统计的是表中所有的行数,count(字段)是统计该字段非NULL的行数,一般使用前者较多</strong></li></ul></div><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件] GEOUP <span class="keyword">BY</span> 分组字段名 [<span class="keyword">HAVING</span> 分组后过滤条件]</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>where和having的区别:</strong></p><p>执行时机不同: where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果的过滤。</p><p>判断条件不同：where不能对聚合函数进行判断，而having可以。</p></div><p>注意：</p><ul><li>执行顺序：where &gt; 聚合函数 &gt; having.</li><li>分组之后，<strong>查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</strong></li></ul><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p><strong>语法:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>，字段二 排序方式</span><br><span class="line"></span><br><span class="line">排序方式:</span><br><span class="line"><span class="keyword">ASC</span>: 升序（默认值）</span><br><span class="line"><span class="keyword">DESC</span>: 降序</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT 起始索引(偏移量)，查询记录数</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一般LIMIT加在所有代码的最后</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><strong>起始索引从0开始，起始索引 = (查询页码-1) * 每页显示记录数，起始索引也叫偏移量，表示从起始索引所在行数的下一行开始查询</strong></li></ul><ul><li><p><strong>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT</strong></p></li><li><p><strong>如果查询的是第一页数据，起始索引可以省略，直接简写为LIMIT 10。</strong></p></li></ul><h3 id="DQL执行顺序"><a href="#DQL执行顺序" class="headerlink" title="DQL执行顺序"></a>DQL执行顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">执行顺序:了解了执行顺序后我们就可以知道哪些部分可以使用别名来访问数据，哪些不能使用</span><br><span class="line"><span class="number">1.</span><span class="keyword">FROM</span></span><br><span class="line"><span class="number">2.</span><span class="keyword">WHERE</span></span><br><span class="line"><span class="number">3.</span><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="number">4.</span><span class="keyword">HAVING</span></span><br><span class="line"><span class="number">5.</span><span class="keyword">SELECT</span></span><br><span class="line"><span class="number">6.</span><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line"><span class="number">7.</span>LIMIT</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> emp <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">若取别名 <span class="keyword">select</span> e.name,e.age <span class="keyword">from</span> emp <span class="keyword">as</span> e age <span class="keyword">where</span> e.age<span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">ASC</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>执行成功，先执行<span class="keyword">from</span>为emp取别名e，再执行<span class="keyword">where</span>,<span class="keyword">select</span></span><br><span class="line"></span><br><span class="line">若取别名<span class="keyword">select</span> e.name <span class="keyword">AS</span> ename, e.age <span class="keyword">AS</span> eage <span class="keyword">from</span> emp <span class="keyword">AS</span> e age <span class="keyword">where</span> eage<span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">ASC</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>错误，<span class="keyword">select</span>语句在<span class="keyword">where</span>之后执行，在执行<span class="keyword">select</span>之前没有eage这个别名</span><br></pre></td></tr></table></figure><h2 id="DCL-管理"><a href="#DCL-管理" class="headerlink" title="DCL(管理)"></a>DCL(管理)</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><h4 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只写主机名代表在当前主机创建</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;tom&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>设置任意主机访问该数据库</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;#&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>设置只能在本机访问数据库</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除用户时自动收回权限</span></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意：</strong></p><ul><li><strong>主机名可以使用%通配</strong></li><li><strong>这类SQL开发人员操作的比较少，主要是DBA （数据库管理员)使用</strong></li></ul></div><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><h4 id="查询权限"><a href="#查询权限" class="headerlink" title="查询权限"></a>查询权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span><span class="operator">|</span><span class="string">&#x27;角色名&#x27;</span> [<span class="keyword">with</span> <span class="keyword">grant</span> option]</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALL</span><span class="operator">/</span><span class="keyword">all</span> 代表所有的权限</span><br><span class="line">数据库.<span class="operator">*</span> 代表所有的表</span><br><span class="line"><span class="operator">*</span>.<span class="operator">*</span> 代表所有数据库的所有表</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当授予某指定字段权限时，在select，update后加上字段名即可，例如：</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>(c_name,c_mail,c_phone) <span class="keyword">on</span> finance.client  <span class="keyword">to</span> <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- with grant option 该选项加上后代表被授权的用户可以将其自己获得的权限再授予给别人,不加上则无再次授予权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>(c_name,c_mail,c_phone) <span class="keyword">on</span> finance.client  <span class="keyword">to</span> <span class="string">&#x27;tom&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></table></figure><h4 id="撤销权限"><a href="#撤销权限" class="headerlink" title="撤销权限"></a>撤销权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span><span class="operator">|</span><span class="string">&#x27;角色名&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALL</span><span class="operator">/</span><span class="keyword">all</span> 代表所有的权限</span><br><span class="line"><span class="operator">*</span> 代表所有的表</span><br><span class="line"><span class="operator">*</span>.<span class="operator">*</span> 代表所有数据库的所有表</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><strong>注意：</strong></p><ul><li><strong>多个权限之间，使用逗号分隔</strong></li><li><strong>授权时，数据库名和表名可以使用*进行通配，代表所有</strong>,</li></ul></div><h2 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h2><h3 id="角色概念"><a href="#角色概念" class="headerlink" title="角色概念"></a>角色概念</h3><p>角色(role)是对权限集中管理的一种机制，通常根据特定需要，将一系列权限集中在一起构成角色，再将角色赋予给了用户，不同的角色就代表了不同的权限集合。</p><h3 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role <span class="string">&#x27;角色名称&#x27;</span>@<span class="string">&#x27;主机信息&#x27;</span> [,<span class="string">&#x27;角色名称&#x27;</span>@<span class="string">&#x27;主机信息&#x27;</span>]...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可以一次性使用create role 创建多个角色</span></span><br><span class="line"><span class="comment">-- 使用create role 语句需要具有全局create role权限或create user权限。</span></span><br><span class="line"><span class="comment">-- 如果使用主机信息，则约束该角色的使用主机。如果不提供主机信息，则表明主机信息为&#x27;%&#x27;,即在任意主机上均可以使用该角色</span></span><br></pre></td></tr></table></figure><h3 id="角色授权"><a href="#角色授权" class="headerlink" title="角色授权"></a>角色授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 角色授权与用户授权语句相同</span></span><br></pre></td></tr></table></figure><h3 id="分配角色"><a href="#分配角色" class="headerlink" title="分配角色"></a>分配角色</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="string">&#x27;角色名&#x27;</span> <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用户授予角色后，用户便拥有了角色的权限</span></span><br></pre></td></tr></table></figure><h3 id="角色激活"><a href="#角色激活" class="headerlink" title="角色激活"></a>角色激活</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">DEFAULT</span> ROLE <span class="string">&#x27;角色名&#x27;</span> <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为用户分配角色后，必须激活角色才能使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用户上的所有角色生效</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">DEFAULT</span> ROLE <span class="keyword">ALL</span> <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="角色查看"><a href="#角色查看" class="headerlink" title="角色查看"></a>角色查看</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;角色名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看某角色的权限</span></span><br></pre></td></tr></table></figure><h3 id="角色撤销"><a href="#角色撤销" class="headerlink" title="角色撤销"></a>角色撤销</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 收回用户的角色</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="string">&#x27;用户名&#x27;</span> <span class="keyword">FROM</span> <span class="string">&#x27;角色名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除角色</span></span><br><span class="line"><span class="keyword">DROP</span> ROLE <span class="string">&#x27;角色名&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">sql的一些操作</summary>
    
    
    
    <category term="MySQL" scheme="https://www.thekqd.top/categories/MySQL/"/>
    
    
    <category term="MySQL基础篇" scheme="https://www.thekqd.top/tags/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>MySQl安装</title>
    <link href="https://www.thekqd.top/posts/4484a8c6.html"/>
    <id>https://www.thekqd.top/posts/4484a8c6.html</id>
    <published>2023-09-16T08:25:42.000Z</published>
    <updated>2023-10-14T15:38:31.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h1><p><a href="https://www.mysql.com/downloads/">MySQL :: MySQL Downloads</a></p><h1 id="MySQL启动与停止"><a href="#MySQL启动与停止" class="headerlink" title="MySQL启动与停止"></a>MySQL启动与停止</h1><p><strong>启动：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql80</span><br></pre></td></tr></table></figure><p><strong>停止：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql80</span><br></pre></td></tr></table></figure><h1 id="MySQL的客户端连接"><a href="#MySQL的客户端连接" class="headerlink" title="MySQL的客户端连接"></a>MySQL的客户端连接</h1><p><strong>方法一：</strong>通过直接提供的MySQL 8.0 Command Line Client输入密码连接</p><p><strong>方法二：</strong>系统的cmd连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql [-h 127.0.0.1] [-p 3306] -u root -p</span><br><span class="line"></span><br><span class="line">可选项1：指定连接ip，不填默认本机</span><br><span class="line">可选项2：指定端口号，不填默认3306</span><br></pre></td></tr></table></figure><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>注意：要想在任意目录使用这种方式执行mysql指令就必须配置系统环境变量</p><p>系统环境变量path中添加：C:\Program Files\MySQL\MySQL Server 8.0\bin(mysql的路径)</p></div>]]></content>
    
    
    <summary type="html">MySQL启动与安装与连接</summary>
    
    
    
    <category term="MySQL" scheme="https://www.thekqd.top/categories/MySQL/"/>
    
    
    <category term="MySQL基础篇" scheme="https://www.thekqd.top/tags/MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>实验室管理系统</title>
    <link href="https://www.thekqd.top/posts/b088c444.html"/>
    <id>https://www.thekqd.top/posts/b088c444.html</id>
    <published>2023-07-29T15:10:02.000Z</published>
    <updated>2023-07-31T14:15:03.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目及源码"><a href="#题目及源码" class="headerlink" title="题目及源码"></a>题目及源码</h1><p>相关题目以及源码放在github仓库</p><p><a href="https://github.com/keqiudi/Cpp_internal_exam">keqiudi/Cpp_internal_exam (github.com)</a></p><h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><h2 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h2><p>见线程池篇</p><p><a href="https://keqiudi.github.io/posts/aa76cb12.html">线程池C++版 | Walnut🍭 (keqiudi.github.io)</a></p><h2 id="线程池下的socket"><a href="#线程池下的socket" class="headerlink" title="线程池下的socket"></a>线程池下的socket</h2><p><code>分为两个部分</code>:</p><ul><li>主线程中添加一个任务，单独让一个线程，进行一个任务，该任务处于循环中，一直检测是否有客户端连接。(该线程始终存在)</li><li>如果连接成功，则每一次循环添加所需要工作的任务进线程池中，让其它线程进行处理。(可能管理者被销毁)</li></ul><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>此项目中，利用封装后的用户类放入vector容器中，用于保存数据。</p><ul><li>以下只有本项目中使用的函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>()<span class="comment">//尾部插入元素</span></span><br><span class="line"><span class="built_in">emplace_back</span>()<span class="comment">//尾部插入元素</span></span><br><span class="line">userList.<span class="built_in">emplace_back</span>(userName,password,userType,realName);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">pop_back</span>()<span class="comment">//删除最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>()<span class="comment">//删除元素，允许使用迭代器</span></span><br><span class="line"><span class="built_in">erase</span>(userList.<span class="built_in">begin</span>()+i<span class="number">-1</span>)<span class="comment">//删除第i个元素    </span></span><br></pre></td></tr></table></figure>  <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li><p><code>emplace_back()</code> 可以允许直接传入构造函数参数，直接在容器内部创建一个对象，示例见上方。</p></li><li><p><code>push_back()</code>则是需要先用构造函数创建一个对象，再使用拷贝(复制)构造函数插入集合。</p></li></ul><p>即：使用<code>emplace_back()</code>比常规的<code>push_back()</code>少调用了一次复制构造函数，<strong>可提高代码的效率</strong>。</p></div><p><strong>以下为vector详细用法：</strong></p><ul><li><a href="https://blog.csdn.net/qq_52324409/article/details/121000029?spm=1001.2014.3001.5506">C++ vector容器详解<em>c++容器vector</em>＆不逝的博客-CSDN博客</a></li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>需要的到一个全新对象对=进行重载时，返回值最好为引用类型</p><p>返回值不是引用的话有以下几个坏处:</p><ul><li>不能实现链式赋值，例如m1 = m2 = m3 = u这样的语句就会报错，因为m2 = m3 = u返回的是一个临时对象，不能再赋值给m1。</li><li>会造成额外的拷贝开销，因为每次赋值都要创建一个新的对象，并调用拷贝构造函数和析构函数，这会降低程序的效率。</li><li>会导致对象的一致性问题，因为赋值后的对象和原对象不是同一个对象，它们的地址不同，如果对其中一个对象进行修改，另一个对象不会受到影响。</li></ul><p><code>例</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Manager&amp; <span class="keyword">operator</span>=(User&amp; user)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserName</span>(user.<span class="built_in">getUserName</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserPassword</span>(user.<span class="built_in">getUserPassword</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserRealName</span>(user.<span class="built_in">getUserRealName</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserType</span>(user.<span class="built_in">getUserType</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserSeatNumber</span>(user.<span class="built_in">getUserSeatNumber</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserSeatStatus</span>(user.<span class="built_in">getUserSeatStatus</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserGarbageTime</span>(user.<span class="built_in">getUserGarbageTime</span>());</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">setUserActivityNumber</span>(user.<span class="built_in">getUserActivityNumber</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//User对象赋值给一个Manager对象。这个运算符的返回值是一个Manager的引用，也就是*this</span></span><br></pre></td></tr></table></figure><p><code>附上常用重载：</code></p><p><a href="https://blog.csdn.net/qq_27278957/article/details/85269245?ops_request_misc=%7B%22request%5Fid%22%3A%22169081199116800222867695%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169081199116800222867695&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-85269245-null-null.142^v91^control_2,239^v12^insert_chatgpt&amp;utm_term=运算符重载&amp;spm=1018.2226.3001.4187"> C++ 运算符重载<em>c++ 重载=</em>高祥xiang的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">一个简单的实验室管理系统后端</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
    <category term="多线程" scheme="https://www.thekqd.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="socket" scheme="https://www.thekqd.top/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="https://www.thekqd.top/posts/ad18462f.html"/>
    <id>https://www.thekqd.top/posts/ad18462f.html</id>
    <published>2023-07-29T04:16:49.000Z</published>
    <updated>2023-07-29T15:00:20.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-github术语"><a href="#1-github术语" class="headerlink" title="1.github术语"></a>1.github术语</h1><p><strong>Repository</strong>：简称Repo，可以理解为“仓库”，我们的项目就存放在仓库之中。也就是说，如果我们想要建立项目，就得先建立仓库；有多个项目，就建立多个仓库。</p><p><strong>Issues</strong>：可以理解为“问题”，举一个简单的例子，如果我们开源一个项目，如果别人看了我们的项目，并且发现了bug，或者感觉那个地方有待改进，他就可以给我们提出Issue，等我们把Issues解决之后，就可以把这些Issues关闭；反之，我们也可以给他人提出Issue。</p><p><strong>Star</strong>：可以理解为“点赞”，当我们感觉某一个项目做的比较好之后，就可以为这个项目点赞，而且我们点赞过的项目，都会保存到我们的Star之中，方便我们随时查看。在 GitHub 之中，如果一个项目的点星数能够超百，那么说明这个项目已经很不错了。</p><p><strong>Fork</strong>：可以理解为“拉分支”，如果我们对某一个项目比较感兴趣，并且想在此基础之上开发新的功能，这时我们就可以Fork这个项目，这表示复制一个完成相同的项目到我们的 GitHub 账号之中，而且独立于原项目。之后，我们就可以在自己复制的项目中进行开发了。</p><p><strong>Pull Request</strong>：可以理解为“提交请求”，此功能是建立在Fork之上的，如果我们Fork了一个项目，对其进行了修改，而且感觉修改的还不错，我们就可以对原项目的拥有者提出一个Pull请求，等其对我们的请求审核，并且通过审核之后，就可以把我们修改过的内容合并到原项目之中，这时我们就成了该项目的贡献者。</p><p><strong>Merge</strong>：可以理解为“合并”，如果别人Fork了我们的项目，对其进行了修改，并且提出了Pull请求，这时我们就可以对这个Pull请求进行审核。如果这个Pull请求的内容满足我们的要求，并且跟我们原有的项目没有冲突的话，就可以将其合并到我们的项目之中。当然，是否进行合并，由我们决定。</p><p><strong>Watch</strong>：可以理解为“观察”，如果我们Watch了一个项目，之后，如果这个项目有了任何更新，我们都会在第一时候收到该项目的更新通知。</p><p><strong>Gist</strong>：如果我们没有项目可以开源或者只是单纯的想分享一些代码片段的话，我们就可以选择Gist。不过说心里话，如果不翻墙的话，Gist并不好用。</p><h1 id="2-git安装"><a href="#2-git安装" class="headerlink" title="2.git安装"></a>2.git安装</h1><p>前往官网安装git</p><p><a href="https://git-scm.com/download/win">Git - Downloading Package (git-scm.com)</a></p><h1 id="3-git常用命令介绍"><a href="#3-git常用命令介绍" class="headerlink" title="3.git常用命令介绍"></a>3.git常用命令介绍</h1><p>接下来介绍 Git 的命令操作，包含 init、add 等，在 Git 中，所有的命令都是以<code>git</code>开头，例如，<code>git init</code>其作用就是初始一个 Git 仓库。</p><p>此外，在这里还要强调一点，那就是：在我们进行任何的git操作之前，我们都得先切换到 Git 的仓库目录。</p><p>换言之，我们得到先进入到（我们定义的）Git 仓库的最顶层文件目录下，然后从此目录中进入 Git Bash，这样之后的操作才能顺利进行。</p><p>如果是 Linux 操作系统，则可以直接cd到仓库目录。</p><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>在命令行窗口的光标处，输入git status命令，查看仓库的状态：</p><p><img src="https://pic1.zhimg.com/80/v2-41af87497f490ee0e93147921a3dfa4c_720w.webp" alt="img"></p><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>在命令行窗口的光标处，输入git init命令，初始化 Git 仓库：</p><p><img src="https://pic3.zhimg.com/80/v2-2d758c4a4090bce9fb8d4d0447f88546_720w.webp" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-0215d2df12ba1ceb300c4fe7f512b890_720w.webp" alt="img"></p><p>我们初始化仓库之后，demo目录已经成为一个 Git 仓库了，并且默认进入 Git 仓库的master分支，即主分支。在这里，我们需要注意的是Untracked fies提示，它表示demo仓库中有文件没有被追踪，并提示了具体没有被追踪的文件为hit.txt，还提示了我们可以使用git add命令操作这个文件，简直不要太好。</p><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>在命令行窗口的光标处，输入git add hit.txt命令，将hit.txt文件添加到 Git 仓库：</p><p><img src="https://pic3.zhimg.com/80/v2-6932af42aa149c735cd429ae5d8b350a_720w.webp" alt="img"></p><p>如上图所示，如果没有报错，就说明命令已经执行啦！接下来，输入git status命令查看仓库状态：</p><p><img src="https://pic2.zhimg.com/80/v2-7658f1c05af7c4dfd277d85889026275_720w.webp" alt="img"></p><p>如上图所示，已经显示Initial commit初始化提交了，同时已经没有Untracked files提示了，这说明文件hit.txt已经被添加到 Git 仓库了，而在我们没有进行git add操作之前，文件hit.txt并不被 Git 仓库认可，因此才会出现提示初始化仓库为空的现象。在这里，需要声明一点，那就是：git add命令并没有把文件提交到 Git 仓库，而是把文件添加到了「临时缓冲区」，这个命令有效防止了我们错误提交的可能性。</p><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>在命令行窗口的光标处，输入git commit -m “text commit”命令，将hit.txt文件提交到 Git 仓库：</p><p><img src="https://pic2.zhimg.com/80/v2-7bae7e33584a12b55dbaf6268769afe1_720w.webp" alt="img"></p><p>如上图所示，我们成功将文件hit.txt提交到了 Git 仓库，其中commit表示提交，-m表示提交信息，提交信息写在双引号””内。接下来，再输入git status命令查看仓库状态：</p><p><img src="https://pic3.zhimg.com/80/v2-341e2394a657effef0c38f445bbe9bb6_720w.webp" alt="img"></p><p>如上图所示，结果显示nothing to commit, working tree clean，这表示已经没有内容可以提交了，即全部内容已经提交完毕。</p><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>在命令行窗口的光标处，输入git log”命令，打印 Git 仓库提交日志：</p><p><img src="https://pic3.zhimg.com/80/v2-365628061daef5e1b857f4337990981e_720w.webp" alt="img"></p><p>如上图所示，显示了我们的提交记录，提交记录的内容包括Author提交作者、Date提交日期和提交信息。</p><p>通过以上的操作，我们会发现一个现象，那就是：在每个git操作之后，我们基本都会输入git status命令，查看仓库状态。</p><p>这也从侧面说明了git status命令使用的频率之高，也建议大家在操作 Git 仓库的时候多使用git status命令，这能帮助我们实时了解仓库的状态，显然非常有用。</p><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p>在命令行窗口的光标处，输入git branch命令，查看 Git 仓库的分支情况：</p><p><img src="https://pic4.zhimg.com/80/v2-229c8f677bea969708a39a4c853ba98f_720w.webp" alt="img"></p><p>如上图所示，显示了仓库demo中的分支情况，现在仅有一个master分支，其中master分支前的<em>号表示“当前所在的分支”，例如</em> master就意味着我们所在的位置为demo仓库的主分支。输入命令git branch a，再输入命令git branch，结果如下图所示：</p><p><img src="https://pic2.zhimg.com/80/v2-ce8506d523068e526e5b9164846f18f5_720w.webp" alt="img"></p><p>如上图所示，我们创建了一个名为a的分支，并且当前的位置仍然为主分支。</p><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>在命令行窗口的光标处，输入git checkout a命令，切换到a分支：</p><p><img src="https://pic2.zhimg.com/80/v2-ce8506d523068e526e5b9164846f18f5_720w.webp" alt="img"></p><p>如上图所示，我们已经切换到a分支啦！也可以通过命令git branch查看分支情况：</p><p><img src="https://pic3.zhimg.com/80/v2-3b28d0015bd823222db84211c034741e_720w.webp" alt="img"></p><p>在这里，我们还有一个更简单的方法来查看当前的分支，即通过观察上图中用红色框圈起来的部分。此外，我们也可以在创建分支的同时，直接切换到新分支，命令为git checkout -b，例如输入git checkout -b b命令：</p><p><img src="https://pic2.zhimg.com/80/v2-bd7b115a3f411746658bf44eb78b00f9_720w.webp" alt="img"></p><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>切换到master分支，然后输入git merge a命令，将a分支合并到master分支：</p><p><img src="https://pic2.zhimg.com/80/v2-807514785bdbb725053f4e30458bf5f5_720w.webp" alt="img"></p><p>如上图所示，我们已经将a分支合并到主分支啦！此外，在这里需要注意一点，那就是：在合并分支的时候，要考虑到两个分支是否有冲突，如果有冲突，则不能直接合并，需要先解决冲突；反之，则可以直接合并。</p><h2 id="git-branch-d-amp-git-branch-D"><a href="#git-branch-d-amp-git-branch-D" class="headerlink" title="git branch -d &amp; git branch -D"></a>git branch -d &amp; git branch -D</h2><p>在命令行窗口的光标处，输入git branch -d a命令，删除a分支：</p><p><img src="https://pic4.zhimg.com/80/v2-e22b97be855bf2c358db3c158d9cdc3f_720w.webp" alt="img"></p><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><p>在命令行窗口的光标处，输入git tag v1.0命令，为当前分支添加标签：</p><p><img src="https://pic1.zhimg.com/80/v2-341de31e1046fe7dbd0f7d5d823a198c_720w.webp" alt="img"></p><p>如上图所示，我们为当前所在的a分支添加了一个v1.0标签。通过命令git tag即可查看标签记录：</p><p><img src="https://pic4.zhimg.com/80/v2-7f4bbacebd1903677fb9e3235edbf36f_720w.webp" alt="img"></p><p>如上图所示，显示了我们添加标签的记录。通过命令git checkout v1.0即可切换到该标签下的代码状态：</p><p><img src="https://pic1.zhimg.com/80/v2-36840bbe7c7f25a4afd62580348a1550_720w.webp" alt="img"></p><h1 id="4-SSH绑定git与github"><a href="#4-SSH绑定git与github" class="headerlink" title="4.SSH绑定git与github"></a>4.SSH绑定git与github</h1><p>们就一起完成 Git 和 GitHub 的绑定，体验通过 Git 向 GitHub 提交代码的能力。不过在这之前，我们需要先了解 SSh（安全外壳协议），因为在 GitHub 上，一般都是通过 SSH 来授权的，而且大多数 Git 服务器也会选择使用 SSH 公钥来进行授权，所以想要向 GitHub 提交代码，首先就得在 GitHub 上添加 SSH key配置。</p><h2 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h2><ol><li>输入ssh 查看本机是否安装ssh</li></ol><ol><li>输入ssh-keygen -t rsa命令</li></ol><ul><li>表示我们指定 RSA 算法生成密钥，然后敲三次回车键，期间不需要输入密码，之后就就会生成两个文件，分别为id_rsa和id_rsa.pub，即密钥id_rsa和公钥id_rsa.pub. 对于这两个文件，其都为隐藏文件，默认生成在以下目录：<ul><li>Linux 系统：~/.ssh</li><li>Mac 系统：~/.ssh</li><li>Windows 系统：C:\Documents and Settings\username\.ssh</li><li>Windows 10 ThinkPad：C:\Users\think.ssh</li></ul></li></ul><p>密钥和公钥生成之后，我们要做的事情就是把公钥id_rsa.pub的内容添加到 GitHub，这样我们本地的密钥id_rsa和 GitHub 上的公钥id_rsa.pub才可以进行匹配，授权成功后，就可以向 GitHub 提交代码啦！</p><ol><li>添加 SSH key</li></ol><ul><li>进入github中的settings，再点击SSH and GPG Keys进入此子界面，然后点击New SSH key按钮：</li><li>将公钥id_rsa.pub的内容粘贴到Key处的位置（Titles的内容不填写也没事），然后点击Add SSH key 即可。</li></ul><ol><li>验证绑定是否成功</li></ol><p>在 Git Bash 中输入ssh -T git@github.com进行测试：</p><p><img src="https://pic4.zhimg.com/80/v2-aa1938b4970cd5ccddd82406f58aee83_720w.webp" alt="img"></p><p>结果即为Git 与 GitHub 绑定成功的标志。</p><h1 id="5-通过git将代码提交到github"><a href="#5-通过git将代码提交到github" class="headerlink" title="5.通过git将代码提交到github"></a>5.通过git将代码提交到github</h1><h2 id="pull与push"><a href="#pull与push" class="headerlink" title="pull与push"></a>pull与push</h2><p>push：该单词直译过来就是“推”的意思，如果我们本地的代码有了更新，为了保持本地与远程的代码同步，我们就需要把本地的代码推到远程的仓库，代码示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>pull：该单词直译过来就是“拉”的意思，如果我们远程仓库的代码有了更新，同样为了保持本地与远程的代码同步，我们就需要把远程的代码拉到本地，代码示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>pull request它表示：如果我们fork了别人的项目（或者说代码），并对其进行了修改，想要把我们的代码合并到原始项目（或者说原始代码）中，我们就需要提交一个pull request，让原作者把我们的代码拉到 ta 的项目中，至少对于 ta 来说，我们都是属于远程端的。</p>   <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>一般情况下，我们在push操作之前都会先进行pull操作，这样不容易造成冲突。</p></div><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><p>对于向远处仓库（GitHub）提交代码分为两种情况：</p><p><code>第一种：</code></p><ol><li>本地没有 Git 仓库，这时我们就可以直接将远程仓库clone到本地。通过clone命令创建的本地仓库，其本身就是一个 Git 仓库了，不用我们再进行init初始化操作啦，而且自动关联远程仓库。我们只需要在这个仓库进行修改或者添加等操作，然后commit即可。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/guobinhit/mybatis-tutorial.git (仓库链接)</span><br></pre></td></tr></table></figure><ol><li>将需要提交的文件复制到该仓库中</li></ol><ol><li><p>使用git status、git add、git commit -m “ “、git log、git status</p></li><li><p>将本地仓库的内容push到远程仓库，输入git push origin master</p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>在第一次向远程仓库提交代码的时候，需要输入账号及密码进行验证，验证成功后即可。</p></div></li></ol><p><code>第二种</code>本地有 Git 仓库，并且我们已经进行了多次commit操作。</p><ol><li>进入该仓库，git init初始化操作：</li><li>命令，关联远程仓库（在此，默认大家都知道如何获取远程仓库的地址），其中origin为远程仓库的名字：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/guobinhit/springmvc-tutorial.git//例子</span><br></pre></td></tr></table></figure><ol><li>输入git pull origin master命令，同步远程仓库和本地仓库：</li><li>再回到本地springmvc-tutorial仓库，看看我们是否已经把远程仓库的内容同步到了本地：</li><li>输入git add和git commit命令，将文件添加并提交到springmvc-tutorial仓库：</li><li>git push origin master命令，将本地仓库修改（或者添加）的内容提交到远程仓库：</li></ol><p>在这个例子中，我们将远程仓库命名为origin，本地仓库名为springmvc-tutorial，其实两者的名字咱们可以随意取，一般来说，我们习惯性将远程仓库命名为origin，不过在需要关联多个远程仓库的时候，就需要我们再取别的名字啦！</p><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>在我们向远程仓库提交代码的时候，一定要先进行pull操作，再进行push操作，防止本地仓库与远程仓库不同步导致冲突的问题，尤其是第二种提交代码的情况，很容易就出现问题。</p></div><p><a href="https://zhuanlan.zhihu.com/p/369486197">还不会使用 GitHub ？ GitHub 教程来了！万字图文详解 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <summary type="html">git的使用</summary>
    
    
    
    <category term="github" scheme="https://www.thekqd.top/categories/github/"/>
    
    
    <category term="github" scheme="https://www.thekqd.top/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>服务器并发</title>
    <link href="https://www.thekqd.top/posts/11572ff3.html"/>
    <id>https://www.thekqd.top/posts/11572ff3.html</id>
    <published>2023-07-21T07:24:19.000Z</published>
    <updated>2023-07-21T07:42:28.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-单线程-进程"><a href="#1-单线程-进程" class="headerlink" title="1.单线程/进程"></a>1.单线程/进程</h1><p>在TCP通信过程中，服务器端启动之后可以同时和多个客户端建立连接，并进行网络通信，但是在介绍TCP通信流程的时候，提供的服务器代码却不能完成这样的需求，先简单的看一下之前的服务器代码的处理思路，再来分析代码中的弊端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 2. 将socket()返回值和本地的IP端口绑定到一起</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">10000</span>);   <span class="comment">// 大端端口</span></span><br><span class="line">    <span class="comment">// INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址</span></span><br><span class="line">    <span class="comment">// 这个宏可以代表任意一个IP地址</span></span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 这个宏的值为0 == 0.0.0.0</span></span><br><span class="line">    <span class="type">int</span> ret = bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">// 3. 设置监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">// 4. 阻塞等待并接受客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">int</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">    <span class="comment">// 5. 和客户端通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端say: %s\n&quot;</span>, buf);</span><br><span class="line">            write(cfd, buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len  == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端断开了连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中用到了三个会引起程序阻塞的函数，分别是：</p><ul><li><p>accept()：如果服务器端没有新客户端连接，阻塞当前进程/线程，如果检测到新连接解除阻塞，建立连接</p></li><li><p>read()：如果通信的套接字对应的读缓冲区没有数据，阻塞当前进程/线程，检测到数据解除阻塞，接收数据</p></li><li>write()：如果通信的套接字写缓冲区被写满了，阻塞当前进程/线程（这种情况比较少见）</li></ul><p>如果需要和发起新的连接请求的客户端建立连接，那么就必须在服务器端通过一个循环调用accept()函数，另外已经和服务器建立连接的客户端需要和服务器通信，发送数据时的阻塞可以忽略，当接收不到数据时程序也会被阻塞，这时候就会非常矛盾，被accept()阻塞就无法通信，被read()阻塞就无法和客户端建立新连接。因此得出一个结论，基于上述处理方式，在单线程/单进程场景下，服务器是无法处理多连接的，解决方案也有很多，常用的有三种：</p><ol><li>使用多线程实现</li><li>使用多进程实现</li><li>使用IO多路转接（复用）实现</li><li>使用IO多路转接 + 多线程实现</li></ol><h1 id="2-多线程并发"><a href="#2-多线程并发" class="headerlink" title="2.多线程并发"></a>2.多线程并发</h1><p>多线程中的线程有两大类：主线程（父线程）和子线程，他们分别要在服务器端处理监听和通信流程。根据多进程的处理思路，就可以这样设计了：</p><ul><li>主线程<ul><li>负责监听，处理客户端的连接请求，也就是在父进程中循环调用accept()函数</li><li>创建子线程：建立一个新的连接，就创建一个新的子进程，让这个子进程和对应的客户端通信</li><li>回收子线程资源：由于回收需要调用阻塞函数，这样就会影响accept()，直接做<strong>线程分离</strong>即可。</li></ul></li><li>子线程：负责通信，基于主线程建立新连接之后得到的文件描述符，和对应的客户端完成数据的接收和发送。<ul><li>发送数据：send() / write()</li><li>发送数据：recv() / read()</li></ul></li></ul><p>在多线程版的服务器端程序中，多个线程共用同一个地址空间，有些数据是共享的，有些数据的独占的，下面来分析一些其中的一些细节：</p>   <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li><p>同一地址空间中的多个线程的栈空间是独占的</p></li><li><p>多个线程共享全局数据区，堆区，以及内核区的文件描述符等资源，因此需要注意数据覆盖问题，并且在多个线程访问共享资源的时候，还需要进行线程同步。</p></li></ul></div><p>多线程版TCP服务器示例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> fd;                      <span class="comment">// 通信</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;               <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span>     <span class="comment">// 地址信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span> <span class="title">infos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">info</span> =</span> (<span class="keyword">struct</span> SockInfo*)arg;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> ret = read(info-&gt;fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端已经关闭连接...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;接收数据失败...\n&quot;</span>);</span><br><span class="line">            info-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            write(info-&gt;fd, buf, <span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建用于监听的套接字</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;          <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = htons(<span class="number">8989</span>);        <span class="comment">// 字节序应该是网络字节序</span></span><br><span class="line">    addr.sin_addr.s_addr =  INADDR_ANY; <span class="comment">// == 0, 获取IP的操作交给了内核</span></span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.设置监听</span></span><br><span class="line">    ret = listen(fd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 等待, 接受连接请求</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据初始化</span></span><br><span class="line">    <span class="type">int</span> max = <span class="keyword">sizeof</span>(infos) / <span class="keyword">sizeof</span>(infos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(&amp;infos[i], <span class="keyword">sizeof</span>(infos[i]));</span><br><span class="line">        infos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        infos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程监听, 子进程通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">SockInfo</span>* <span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;max; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(infos[i].fd == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pinfo = &amp;infos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> connfd = accept(fd, (<span class="keyword">struct</span> sockaddr*)&amp;pinfo-&gt;addr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent thread, connfd: %d\n&quot;</span>, connfd);</span><br><span class="line">        <span class="keyword">if</span>(connfd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pinfo-&gt;fd = connfd;</span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    close(fd);  <span class="comment">// 监听</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ol><li><p>在编写多线程版并发服务器代码的时候，需要注意父子线程共用同一个地址空间中的文件描述符，因此每当在主线程中建立一个新的连接，都需要将得到文件描述符值保存起来，不能在同一变量上进行覆盖，这样做丢失了之前的文件描述符值也就不知道怎么和客户端通信了。</p></li><li><p>在上面示例代码中是将成功建立连接之后得到的用于通信的文件描述符值保存到了一个全局数组中，每个子线程需要和不同的客户端通信，需要的文件描述符值也就不一样，只要保证存储每个有效文件描述符值的变量对应不同的内存地址，在使用的时候就不会发生数据覆盖的现象，造成通信数据的混乱了。</p></li></ol></div><h1 id="3-多进程并发"><a href="#3-多进程并发" class="headerlink" title="3.多进程并发"></a>3.多进程并发</h1>]]></content>
    
    
    <summary type="html">多线程/进程</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>线程池C++版</title>
    <link href="https://www.thekqd.top/posts/aa76cb12.html"/>
    <id>https://www.thekqd.top/posts/aa76cb12.html</id>
    <published>2023-07-18T14:50:42.000Z</published>
    <updated>2023-07-31T13:57:24.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-任务队列"><a href="#1-任务队列" class="headerlink" title="1.任务队列"></a>1.任务队列</h1><h2 id="类声明-Task-TaskQueue"><a href="#类声明-Task-TaskQueue" class="headerlink" title="类声明(Task,TaskQueue)"></a>类声明(Task,TaskQueue)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> C___PRACTICE_TASKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C___PRACTICE_TASKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> function = <span class="built_in">void</span>(*)(<span class="type">void</span>* arg);<span class="comment">//为一个函数指针类型取别名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>()&#123;</span><br><span class="line">        working = <span class="literal">nullptr</span>;</span><br><span class="line">        arg = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*无参构造*/</span></span><br><span class="line">    <span class="built_in">Task</span>(function working, <span class="type">void</span>* arg)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;working = working;</span><br><span class="line">        <span class="keyword">this</span>-&gt;arg = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*有参构造*/</span></span><br><span class="line">    function working;</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;Task&gt; taskQueue;<span class="comment">//任务队列,用容器实现</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span>  QueueLock;<span class="comment">//互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task&amp; task)</span></span>;</span><br><span class="line">    <span class="comment">/*添加任务*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(function working, <span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">/*addTask重载函数*/</span></span><br><span class="line">    <span class="function">Task <span class="title">takeTask</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*取出任务*/</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">getTaskSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> taskQueue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取任务队列大小*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//C___PRACTICE_TASKQUEUE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<span class='p red'>Task</span> 是任务类，里边有两个成员，分别是两个指针 <span class='p red'>void(*)(void*)</span>和 <span class='p red'>void*</span></p><p>另外一个类<span class='p red'>TaskQueue</span>是任务队列，提供了添加任务、取出任务、存储任务、获取任务个数、线程同步的功能。</p><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskQueue::<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;QueueLock, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">TaskQueue::~<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;QueueLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(Task&amp; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);<span class="comment">//此处如果资源已经被释放，就会发生段错误</span></span><br><span class="line">    taskQueue.<span class="built_in">push</span>(task);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(function working, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);</span><br><span class="line">    taskQueue.<span class="built_in">push</span>(<span class="built_in">Task</span>(working, arg));</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">TaskQueue::takeTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);</span><br><span class="line">    Task t;</span><br><span class="line">    <span class="keyword">if</span>(!taskQueue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        t = taskQueue.<span class="built_in">front</span>();<span class="comment">//取出队列头部元素</span></span><br><span class="line">        taskQueue.<span class="built_in">pop</span>();<span class="comment">//删除队列头部元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2.线程池"></a>2.线程池</h1><h2 id="类声明-ThreadPool"><a href="#类声明-ThreadPool" class="headerlink" title="类声明(ThreadPool)"></a>类声明(ThreadPool)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> C___PRACTICE_THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C___PRACTICE_THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaskQueue* taskQueue = <span class="literal">nullptr</span>;<span class="comment">//任务队列</span></span><br><span class="line">    <span class="type">pthread_t</span> managerID;<span class="comment">//管理者线程id</span></span><br><span class="line">    <span class="type">pthread_t</span>* threadIDs;</span><br><span class="line">    <span class="type">int</span> minNum;<span class="comment">//最小线程数</span></span><br><span class="line">    <span class="type">int</span> maxNum;<span class="comment">//最大线程数</span></span><br><span class="line">    <span class="type">int</span> busyNum;<span class="comment">//忙线程数</span></span><br><span class="line">    <span class="type">int</span> liveNum;<span class="comment">//活着的线程数</span></span><br><span class="line">    <span class="type">int</span> exitNum;<span class="comment">//要销毁的线程数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> threadLock;<span class="comment">//锁住整个线程池</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> busyLock;<span class="comment">//单独锁住busyNum，提高效率</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;<span class="comment">//任务队列为空时阻塞，不为空时唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> shutdown;<span class="comment">//是否要销毁线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//工作线程函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//管理者线程函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadExit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> min,<span class="type">int</span> max);</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task task)</span></span>;</span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getBusyNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取忙线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getAliveNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取活着的线程数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//C___PRACTICE_THREADPOOL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类定义-1"><a href="#类定义-1" class="headerlink" title="类定义"></a>类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_TIME 5<span class="comment">//默认管理者线程检测时间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_NUM 2<span class="comment">//一次添加3个线程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_NUM 2<span class="comment">//一次销毁3个线程</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">safe_delete_void_ptr</span><span class="params">(<span class="type">void</span>* &amp;target)</span></span>;</span><br><span class="line"></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> min, <span class="type">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">        taskQueue = <span class="built_in">new</span> (std::nothrow)TaskQueue;</span><br><span class="line">          <span class="comment">/*没有std::nothrow则if条件始终为false*/</span></span><br><span class="line">        <span class="keyword">if</span>(taskQueue == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;new taskQueue error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        threadIDs = <span class="built_in">new</span> (std::nothrow)<span class="type">pthread_t</span>[max];<span class="comment">//分配动态数组</span></span><br><span class="line"><span class="comment">/*没有std::nothrow则if条件始终为false*/</span></span><br><span class="line">        <span class="keyword">if</span>(threadIDs == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new threadIDs error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(threadIDs, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        minNum = min;</span><br><span class="line">        maxNum = max;</span><br><span class="line">        busyNum = <span class="number">0</span>;</span><br><span class="line">        liveNum = min;</span><br><span class="line">        exitNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;threadLock, <span class="literal">nullptr</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_mutex_init</span>(&amp;busyLock, <span class="literal">nullptr</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_cond_init</span>(&amp;notEmpty, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;init the lock or cond error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shutdown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 类的成员函数传递地址时失败报错:Reference to non-static member function must be called</span></span><br><span class="line"><span class="comment">         * 原因:类的成员函数不是静态时，函数没有地址，只有实例化之后才会有地址，所以不能传递地址</span></span><br><span class="line"><span class="comment">         * 两种解决方案:</span></span><br><span class="line"><span class="comment">         * 1.将成员函数改为静态函数</span></span><br><span class="line"><span class="comment">         * 2.将成员函数改为全局函数，独立于类之外（想要访问成员变量就必须加上友元函数）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;managerID, <span class="literal">nullptr</span>, manager, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;threadIDs[i], <span class="literal">nullptr</span>, worker, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//此处不返回将会导致之后的释放资源</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] threadIDs;</span><br><span class="line">        threadIDs = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="comment">//如果threadIDs不为空，释放内存</span></span><br><span class="line">    <span class="keyword">if</span>(taskQueue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> taskQueue;</span><br><span class="line">        taskQueue = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="comment">//如果taskQueue不为空，释放内存</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadPool::worker</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);<span class="comment">//传递的是(void*)this,所以要强制类型转换</span></span><br><span class="line">    <span class="comment">/*此处static_cast为C++的强制类型转换，也可用C中的(ThreadPool*)形式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 静态函数不能访问成员变量，所以必须传入该类的实例化对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        <span class="keyword">while</span>(pool-&gt;taskQueue-&gt;<span class="built_in">getTaskSize</span>()==<span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;thread &quot;</span>&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot; is waiting&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notEmpty, &amp;pool-&gt;threadLock);</span><br><span class="line">            <span class="comment">//如果任务队列为空，且线程池没有关闭，则等待</span></span><br><span class="line">            <span class="comment">//等待条件变量，会先解锁，等待被唤醒，再次拿到了这把锁</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*管理者销毁线程逻辑</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 唤醒后判断是否要销毁线程</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;exitNum &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pool-&gt;exitNum--;<span class="comment">//不能放在if里面，否则可能在产生新线程时，Num&gt;0,直接就被销毁了，不符合期望，故保证每次循环都减一</span></span><br><span class="line">                <span class="comment">/*限定当存活的线程个数大于最小个数时才销毁*/</span></span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum) &#123;</span><br><span class="line">                    pool-&gt;liveNum--;</span><br><span class="line">                    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//解锁</span></span><br><span class="line">                    pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;shutdown)<span class="comment">//如果线程池关闭，则线程全部退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//避免死锁</span></span><br><span class="line">            pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出任务工作</span></span><br><span class="line">        Task task = pool-&gt;taskQueue-&gt;<span class="built_in">takeTask</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处生产者不需要被唤醒了，任务队列可以无限大,即可以无限量的任务</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">        pool-&gt;busyNum++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; start working&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        task.<span class="built_in">working</span>(task.arg);<span class="comment">//执行任务</span></span><br><span class="line">        <span class="built_in">safe_delete_void_ptr</span>&lt;<span class="type">int</span>&gt;(task.arg);<span class="comment">//直接delete task.arg 有危险</span></span><br><span class="line">        task.arg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; end working&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">        pool-&gt;busyNum--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadPool::manager</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(CHECK_TIME);<span class="comment">//每隔3秒检测一次</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        <span class="type">size_t</span> queueSize = pool-&gt;taskQueue-&gt;<span class="built_in">getTaskSize</span>();<span class="comment">//取出任务个数</span></span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;<span class="comment">//取出存活线程个数</span></span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加线程规则</span></span><br><span class="line">        <span class="comment">//1.任务个数&gt;存活线程个数&amp;&amp;存活线程个数&lt;最大线程个数时，创建线程</span></span><br><span class="line">        <span class="keyword">if</span>(queueSize&gt;liveNum&amp;&amp;liveNum&lt;pool-&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*for循环三个条件</span></span><br><span class="line"><span class="comment">             * 1.遍历线程id</span></span><br><span class="line"><span class="comment">             * 2.counter&lt;ADD_NUM</span></span><br><span class="line"><span class="comment">             * 3.在存活线程个数小于最大线程个数时才添加*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pool-&gt;maxNum&amp;&amp;counter&lt;ADD_NUM&amp;&amp;pool-&gt;liveNum&lt;pool-&gt;maxNum;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到空闲的线程id，创建线程</span></span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threadIDs[i]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">pthread_create</span>(&amp;pool-&gt;threadIDs[i],<span class="literal">nullptr</span>,worker,pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//销毁线程规则</span></span><br><span class="line">        <span class="comment">//1.忙线程*2&lt;存活线程&amp;&amp;存活线程&gt;最小线程个数时，销毁线程</span></span><br><span class="line">        <span class="keyword">if</span>(busyNum*<span class="number">2</span>&lt;liveNum&amp;&amp;liveNum&gt;pool-&gt;minNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">            pool-&gt;exitNum = EXIT_NUM;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">            <span class="comment">//唤醒线程池中所有的线程，让他们自己执行，判断是否退出</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;EXIT_NUM;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadExit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*使线程退出时线程id归0*/</span></span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="built_in">pthread_self</span>();<span class="comment">//获取当前线程的id</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(threadIDs[i] == tid)</span><br><span class="line">        &#123;</span><br><span class="line">            threadIDs[i] = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;threadExit() called, threadID: &quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot; exiting...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);<span class="comment">//C的函数，此处不用nullptr，而是用NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::addTask</span><span class="params">(Task task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处不用判断任务队列是否满，因为任务队列可以无限大</span></span><br><span class="line">    <span class="keyword">if</span>(shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="comment">//如果线程池关闭，则不添加任务</span></span><br><span class="line"></span><br><span class="line">    taskQueue-&gt;<span class="built_in">addTask</span>(task);<span class="comment">//添加任务,此时不用上锁原因，因为addTask中已经上锁了</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);<span class="comment">//唤醒线程池中的消费者线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ThreadPool::getBusyNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用busyNum自己的锁，提高效率</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;busyLock);</span><br><span class="line">    <span class="type">int</span> busyNum = <span class="keyword">this</span>-&gt;busyNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;busyLock);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ThreadPool::getAliveNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用线程池的锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;threadLock);</span><br><span class="line">    <span class="type">int</span> liveNum = <span class="keyword">this</span>-&gt;liveNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;threadLock);</span><br><span class="line">    <span class="keyword">return</span> liveNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shutdown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(<span class="keyword">this</span>-&gt;managerID, <span class="literal">nullptr</span>);<span class="comment">//等待管理者线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;liveNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);<span class="comment">//唤醒所有线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;threadLock);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;busyLock);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;notEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(taskQueue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> taskQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] threadIDs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_delete_void_ptr</span><span class="params">(<span class="type">void</span>* &amp;target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target)</span><br><span class="line">    &#123;</span><br><span class="line">        T* temp = <span class="built_in">static_cast</span>&lt;T*&gt;(target);</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line">        target = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><div class="tip warning faa-horizontal animated"><p>注意25行用new分配内存C++中，new操作符默认不会返回NULL，而是会在分配内存失败时抛出一个std::bad_alloc异常。这样做的好处是，你不需要在每次使用new操作符后检查返回值是否为NULL，而是可以用try/catch语句统一处理异常。如果你想让new操作符在分配内存失败时返回NULL，而不是抛出异常，你可以使用std::nothrow参数</p></div><p>解决方案:</p><ul><li>try/catch语句统一处理异常</li><li>std::nothrow参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.第一种</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            taskQueue = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (std::bad_alloc &amp;e) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new taskQueue error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadIDs = <span class="keyword">new</span> <span class="type">pthread_t</span>[max];<span class="comment">//分配动态数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (std::bad_alloc &amp;e) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new threadIDs error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种，见上方代码中使用方法,25行</span></span><br></pre></td></tr></table></figure><div class="tip warning faa-horizontal animated"><p>注意这里133行代码，C++中不能用delete直接删除一个void*指针，因为delete需要调用被删除对象的析构函数，而void指针没有类型信息，所以无法确定调用哪个析构函数。这样做会导致未定义行为，可能会出现崩溃或内存泄漏。你必须在delete之前把void指针转换回它原来的类型，才能正确地释放内存。</p></div><ul><li>解决方案一：使用模板定义内联函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">safe_delete_void_ptr</span><span class="params">(<span class="type">void</span>* &amp;target)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_delete_void_ptr</span><span class="params">(<span class="type">void</span>* &amp;target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target)</span><br><span class="line">    &#123;</span><br><span class="line">        T* temp = <span class="built_in">static_cast</span>&lt;T*&gt;(target);</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line">        target = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/SweetTool/article/details/77688337?ops_request_misc=%7B%22request%5Fid%22%3A%22168977949416800222881353%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168977949416800222881353&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-77688337-null-null.142^v90^insert_down28v1,239^v2^insert_chatgpt&amp;utm_term=c%2B%2B delete void* 指针&amp;spm=1018.2226.3001.4187"> C++指针编程你要小心的陷阱——如何优雅的释放指针void<em>_c++释放void</em>指针_二流小宝的博客-CSDN博客</a></p><ul><li>解决方案二：用模板类</li></ul><h1 id="3-修改为模板类处理指针释放问题"><a href="#3-修改为模板类处理指针释放问题" class="headerlink" title="3.修改为模板类处理指针释放问题"></a>3.修改为模板类处理指针释放问题</h1><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">TaskQueue.h</button></li><li class="tab"><button type="button" data-href="#分栏-2">TaskQueue.cpp</button></li><li class="tab"><button type="button" data-href="#分栏-3">ThreadPool.h</button></li><li class="tab"><button type="button" data-href="#分栏-4">ThreadPool.cpp</button></li><li class="tab"><button type="button" data-href="#分栏-5">test.cpp</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> C___PRACTICE_TASKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C___PRACTICE_TASKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> function = <span class="built_in">void</span>(*)(<span class="type">void</span>* arg);<span class="comment">//为一个函数指针类型取别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//含有模板类的函数或类都要加这个</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>&lt;T&gt;()&#123;</span><br><span class="line">        working = <span class="literal">nullptr</span>;</span><br><span class="line">        arg = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*无参构造*/</span></span><br><span class="line">    <span class="built_in">Task</span>&lt;T&gt;(function working, <span class="type">void</span>* arg)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;working = working;</span><br><span class="line">        <span class="keyword">this</span>-&gt;arg = (T*)arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*有参构造*/</span></span><br><span class="line">    function working;</span><br><span class="line">    T* arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;Task&lt;T&gt;&gt; taskQueue;<span class="comment">//任务队列,用容器实现</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span>  QueueLock;<span class="comment">//互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task&lt;T&gt; task)</span></span>;</span><br><span class="line">    <span class="comment">/*添加任务*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(function working, <span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">/*addtask重载函数*/</span></span><br><span class="line">    <span class="function">Task&lt;T&gt; <span class="title">takeTask</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*取出任务*/</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">getTaskSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> taskQueue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取任务队列大小*/</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//C___PRACTICE_TASKQUEUE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">TaskQueue&lt;T&gt;::<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;QueueLock, <span class="literal">nullptr</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//模板类前面都要加这个</span></span><br><span class="line">TaskQueue&lt;T&gt;::~<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;QueueLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> TaskQueue&lt;T&gt;::<span class="built_in">addTask</span>(Task&lt;T&gt; task)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);<span class="comment">//此处如果资源已经被释放，就会发生段错误</span></span><br><span class="line">    taskQueue.<span class="built_in">push</span>(task);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> TaskQueue&lt;T&gt;::<span class="built_in">addTask</span>(function working, <span class="type">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);</span><br><span class="line">    taskQueue.<span class="built_in">push</span>(<span class="built_in">Task</span>&lt;T&gt;(working, arg));</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Task&lt;T&gt; TaskQueue&lt;T&gt;::<span class="built_in">takeTask</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;QueueLock);</span><br><span class="line">    Task&lt;T&gt; t;</span><br><span class="line">    <span class="keyword">if</span>(!taskQueue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      t = taskQueue.<span class="built_in">front</span>();<span class="comment">//取出队列头部元素</span></span><br><span class="line">      taskQueue.<span class="built_in">pop</span>();<span class="comment">//删除队列头部元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;QueueLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> C___PRACTICE_THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C___PRACTICE_THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TaskQueue.cpp&quot;</span></span></span><br><span class="line"><span class="comment">/*特殊:</span></span><br><span class="line"><span class="comment"> * 当有类模板时,类模板的声明和定义分开写时，需要包含头文件和源文件*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    TaskQueue&lt;T&gt;* taskQueue;<span class="comment">//任务队列</span></span><br><span class="line">    <span class="type">pthread_t</span> managerID;<span class="comment">//管理者线程id</span></span><br><span class="line">    <span class="type">pthread_t</span>* threadIDs;</span><br><span class="line">    <span class="type">int</span> minNum;<span class="comment">//最小线程数</span></span><br><span class="line">    <span class="type">int</span> maxNum;<span class="comment">//最大线程数</span></span><br><span class="line">    <span class="type">int</span> busyNum;<span class="comment">//忙线程数</span></span><br><span class="line">    <span class="type">int</span> liveNum;<span class="comment">//活着的线程数</span></span><br><span class="line">    <span class="type">int</span> exitNum;<span class="comment">//要销毁的线程数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> threadLock;<span class="comment">//锁住整个线程池</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> busyLock;<span class="comment">//单独锁住busyNum，提高效率</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;<span class="comment">//任务队列为空时阻塞，不为空时唤醒</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> shutdown;<span class="comment">//是否要销毁线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//工作线程函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//管理者线程函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadExit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> min,<span class="type">int</span> max);</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task&lt;T&gt; task)</span></span>;</span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getBusyNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取忙线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getAliveNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取活着的线程数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//C___PRACTICE_THREADPOOL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by keqiu on 2023/7/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_TIME 5<span class="comment">//默认管理者线程检测时间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD_NUM 2<span class="comment">//一次添加3个线程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_NUM 2<span class="comment">//一次销毁3个线程</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ThreadPool&lt;T&gt;::<span class="built_in">ThreadPool</span>(<span class="type">int</span> min, <span class="type">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        taskQueue = <span class="keyword">new</span> TaskQueue&lt;T&gt;;</span><br><span class="line">        <span class="keyword">if</span>(taskQueue == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new taskQueue error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threadIDs = <span class="keyword">new</span> <span class="type">pthread_t</span>[max];<span class="comment">//分配动态数组</span></span><br><span class="line">        <span class="keyword">if</span>(threadIDs == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new threadIDs error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(threadIDs, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        minNum = min;</span><br><span class="line">        maxNum = max;</span><br><span class="line">        busyNum = <span class="number">0</span>;</span><br><span class="line">        liveNum = min;</span><br><span class="line">        exitNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;threadLock, <span class="literal">nullptr</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_mutex_init</span>(&amp;busyLock, <span class="literal">nullptr</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_cond_init</span>(&amp;notEmpty, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;init the lock or cond error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shutdown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 类的成员函数传递地址时失败报错:Reference to non-static member function must be called</span></span><br><span class="line"><span class="comment">         * 原因:类的成员函数不是静态时，函数没有地址，只有实例化之后才会有地址，所以不能传递地址</span></span><br><span class="line"><span class="comment">         * 两种解决方案:</span></span><br><span class="line"><span class="comment">         * 1.将成员函数改为静态函数</span></span><br><span class="line"><span class="comment">         * 2.将成员函数改为全局函数，独立于类之外（想要访问成员变量就必须加上友元函数）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">         <span class="built_in">pthread_create</span>(&amp;managerID, <span class="literal">nullptr</span>, manager, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;threadIDs[i], <span class="literal">nullptr</span>, worker, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//此处不返回将会导致之后的释放资源</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] threadIDs;</span><br><span class="line">        threadIDs = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="comment">//如果threadIDs不为空，释放内存</span></span><br><span class="line">    <span class="keyword">if</span>(taskQueue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> taskQueue;</span><br><span class="line">        taskQueue = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="comment">//如果taskQueue不为空，释放内存</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* ThreadPool&lt;T&gt;::<span class="built_in">worker</span>(<span class="type">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">auto</span> pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);<span class="comment">//传递的是(void*)this,所以要强制类型转换</span></span><br><span class="line">     <span class="comment">/*此处为C++的强制类型转换，也可用C中的(ThreadPool*)</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * 静态函数不能访问成员变量，所以必须传入该类的实例化对象</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">         <span class="keyword">while</span>(pool-&gt;taskQueue-&gt;<span class="built_in">getTaskSize</span>()==<span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">         &#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;thread &quot;</span>&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot; is waiting&quot;</span>&lt;&lt;endl;</span><br><span class="line">             <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notEmpty, &amp;pool-&gt;threadLock);</span><br><span class="line">             <span class="comment">//如果任务队列为空，且线程池没有关闭，则等待</span></span><br><span class="line">             <span class="comment">//等待条件变量，会先解锁，等待被唤醒，再次拿到了这把锁</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">/*管理者销毁线程逻辑</span></span><br><span class="line"><span class="comment">              *</span></span><br><span class="line"><span class="comment">              * 唤醒后判断是否要销毁线程</span></span><br><span class="line"><span class="comment">              * */</span></span><br><span class="line">             <span class="keyword">if</span> (pool-&gt;exitNum &gt; <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 pool-&gt;exitNum--;<span class="comment">//不能放在if里面，否则可能在产生新线程时，Num&gt;0,直接就被销毁了，不符合期望，故保证每次循环都减一</span></span><br><span class="line">                 <span class="comment">/*限定当存活的线程个数大于最小个数时才销毁*/</span></span><br><span class="line">                 <span class="keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum) &#123;</span><br><span class="line">                     pool-&gt;liveNum--;</span><br><span class="line">                     <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//解锁</span></span><br><span class="line">                     pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(pool-&gt;shutdown)<span class="comment">//如果线程池关闭，则线程全部退出</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//避免死锁</span></span><br><span class="line">                 pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//取出任务工作</span></span><br><span class="line">             Task task = pool-&gt;taskQueue-&gt;<span class="built_in">takeTask</span>();</span><br><span class="line"></span><br><span class="line">             <span class="comment">//此处生产者不需要被唤醒了，任务队列可以无限大,即可以无限量的任务</span></span><br><span class="line">             <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line">             <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">             pool-&gt;busyNum++;</span><br><span class="line">             <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; start working&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             task.<span class="built_in">working</span>(task.arg);<span class="comment">//执行任务</span></span><br><span class="line">             <span class="keyword">delete</span> task.arg;<span class="comment">//释放参数资源</span></span><br><span class="line">             task.arg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; end working&quot;</span> &lt;&lt; endl;</span><br><span class="line">             <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">             pool-&gt;busyNum--;</span><br><span class="line">             <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;busyLock);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>* ThreadPool&lt;T&gt;::<span class="built_in">manager</span>(<span class="type">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(CHECK_TIME);<span class="comment">//每隔3秒检测一次</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        <span class="type">size_t</span> queueSize = pool-&gt;taskQueue-&gt;<span class="built_in">getTaskSize</span>();<span class="comment">//取出任务个数</span></span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;<span class="comment">//取出存活线程个数</span></span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加线程规则</span></span><br><span class="line">        <span class="comment">//1.任务个数&gt;存活线程个数&amp;&amp;存活线程个数&lt;最大线程个数时，创建线程</span></span><br><span class="line">        <span class="keyword">if</span>(queueSize&gt;liveNum&amp;&amp;liveNum&lt;pool-&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*for循环三个条件</span></span><br><span class="line"><span class="comment">             * 1.遍历线程id</span></span><br><span class="line"><span class="comment">             * 2.counter&lt;ADD_NUM</span></span><br><span class="line"><span class="comment">             * 3.在存活线程个数小于最大线程个数时才添加*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pool-&gt;maxNum&amp;&amp;counter&lt;ADD_NUM&amp;&amp;pool-&gt;liveNum&lt;pool-&gt;maxNum;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//找到空闲的线程id，创建线程</span></span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threadIDs[i]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">pthread_create</span>(&amp;pool-&gt;threadIDs[i],<span class="literal">nullptr</span>,worker,pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//销毁线程规则</span></span><br><span class="line">        <span class="comment">//1.忙线程*2&lt;存活线程&amp;&amp;存活线程&gt;最小线程个数时，销毁线程</span></span><br><span class="line">        <span class="keyword">if</span>(busyNum*<span class="number">2</span>&lt;liveNum&amp;&amp;liveNum&gt;pool-&gt;minNum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">            pool-&gt;exitNum = EXIT_NUM;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;threadLock);</span><br><span class="line">            <span class="comment">//唤醒线程池中所有的线程，让他们自己执行，判断是否退出</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;EXIT_NUM;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ThreadPool&lt;T&gt;::<span class="built_in">threadExit</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*使线程退出时线程id归0*/</span></span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="built_in">pthread_self</span>();<span class="comment">//获取当前线程的id</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(threadIDs[i] == tid)</span><br><span class="line">        &#123;</span><br><span class="line">            threadIDs[i] = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;threadExit() called, threadID: &quot;</span> &lt;&lt; tid &lt;&lt; <span class="string">&quot; exiting...&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);<span class="comment">//C的函数，此处不用nullptr，而是用NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> ThreadPool&lt;T&gt;::<span class="built_in">addTask</span>(Task&lt;T&gt; task)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处不用判断任务队列是否满，因为任务队列可以无限大</span></span><br><span class="line">    <span class="keyword">if</span>(shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="comment">//如果线程池关闭，则不添加任务</span></span><br><span class="line"></span><br><span class="line">    taskQueue-&gt;<span class="built_in">addTask</span>(task);<span class="comment">//添加任务,此时不用上锁原因，因为addTask中已经上锁了</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);<span class="comment">//唤醒线程池中的消费者线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> ThreadPool&lt;T&gt;::<span class="built_in">getBusyNumber</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用busyNum自己的锁，提高效率</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;busyLock);</span><br><span class="line">    <span class="type">int</span> busyNum = <span class="keyword">this</span>-&gt;busyNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;busyLock);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> ThreadPool&lt;T&gt;::<span class="built_in">getAliveNumber</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用线程池的锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;threadLock);</span><br><span class="line">    <span class="type">int</span> liveNum = <span class="keyword">this</span>-&gt;liveNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;threadLock);</span><br><span class="line">    <span class="keyword">return</span> liveNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ThreadPool&lt;T&gt;::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shutdown = <span class="literal">true</span>;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(<span class="keyword">this</span>-&gt;managerID, <span class="literal">nullptr</span>);<span class="comment">//等待管理者线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;liveNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);<span class="comment">//唤醒所有线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;threadLock);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;busyLock);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;notEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(taskQueue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> taskQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] threadIDs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ThreadPool.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span>*)arg;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; is working, number = &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadPool&lt;<span class="type">int</span>&gt; <span class="title">pool</span><span class="params">(<span class="number">3</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>*num = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//分配空间</span></span><br><span class="line">        *num = i+<span class="number">100</span>;</span><br><span class="line">        pool.<span class="built_in">addTask</span>(<span class="built_in">Task</span>&lt;<span class="type">int</span>&gt;(working, num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tip warning faa-horizontal animated"><p>特殊:当有类模板时,类模板的声明和定义分开写时，需要包含头文件和源文件，否则会报找不到定义的错误</p></div><div class="tag link"><a class="link-card" title="线程池C++版" href="https://keqiudi.github.io/posts/de7c53fe.html"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">线程池C++版</p><p class="url">https://keqiudi.github.io/posts/de7c53fe.html</p></div></a></div>]]></content>
    
    
    <summary type="html">线程池C++版</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.thekqd.top/posts/4a17b156.html"/>
    <id>https://www.thekqd.top/posts/4a17b156.html</id>
    <published>2023-07-17T05:14:05.532Z</published>
    <updated>2023-07-17T11:17:07.783Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">你好世界</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>线程池C语言版</title>
    <link href="https://www.thekqd.top/posts/de7c53fe.html"/>
    <id>https://www.thekqd.top/posts/de7c53fe.html</id>
    <published>2023-07-16T11:14:40.000Z</published>
    <updated>2023-07-18T15:37:45.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-线程池原理"><a href="#1-线程池原理" class="headerlink" title="1.线程池原理"></a>1.线程池原理</h1><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p><p><strong>线程池</strong>是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）, 则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p><p>在各个编程语言的语种中都有<strong>线程池</strong>的概念，并且很多语言中直接提供了线程池，作为程序猿直接使用就可以了，下面给大家介绍一下<strong>线程池</strong>的实现原理：</p><p><strong>线程池的组成主要分为 3 个部分，这三部分配合工作就可以得到一个完整的线程池：</strong></p><ol><li><p><strong>任务队列，存储需要处理的任务，由工作的线程来处理这些任务</strong></p><ul><li>通过线程池提供的 API 函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除</li><li>已处理的任务会被从任务队列中删除</li><li>线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程</li></ul></li><li><p><strong>工作的线程（任务队列任务的消费者） ，N个</strong></p><ul><li>线程池中维护了一定数量的工作线程，他们的作用是是不停的读任务队列，从里边取出任务并处理</li><li>工作的线程相当于是任务队列的消费者角色，</li><li>如果任务队列为空，工作的线程将会被阻塞 (使用条件变量 / 信号量阻塞)</li><li>如果阻塞之后有了新的任务，由生产者将阻塞解除，工作线程开始工作</li></ul></li></ol><ol><li><strong>管理者线程（不处理任务队列中的任务），1个</strong></li></ol><ul><li><ul><li>它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测</li><li>当任务过多的时候，可以适当的创建一些新的工作线程</li><li>当任务过少的时候，可以适当的销毁一些工作的线程</li></ul></li></ul><h1 id="2-任务队列-Task"><a href="#2-任务队列-Task" class="headerlink" title="2.任务队列(Task)"></a>2.任务队列(Task)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">void</span>* arg);</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125;Task;</span><br></pre></td></tr></table></figure><h1 id="3-线程池定义-ThreadPool"><a href="#3-线程池定义-ThreadPool" class="headerlink" title="3.线程池定义(ThreadPool)"></a>3.线程池定义(ThreadPool)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    Task* taskQ;</span><br><span class="line">    <span class="type">int</span> queueCapacity;  <span class="comment">// 容量</span></span><br><span class="line">    <span class="type">int</span> queueSize;      <span class="comment">// 当前任务个数</span></span><br><span class="line">    <span class="type">int</span> queueFront;     <span class="comment">// 队头 -&gt; 取数据</span></span><br><span class="line">    <span class="type">int</span> queueRear;      <span class="comment">// 队尾 -&gt; 放数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> managerID;    <span class="comment">// 管理者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span> *threadIDs;   <span class="comment">// 工作的线程ID</span></span><br><span class="line">    <span class="type">int</span> minNum;             <span class="comment">// 最小线程数量</span></span><br><span class="line">    <span class="type">int</span> maxNum;             <span class="comment">// 最大线程数量</span></span><br><span class="line">    <span class="type">int</span> busyNum;            <span class="comment">// 忙的线程的个数</span></span><br><span class="line">    <span class="type">int</span> liveNum;            <span class="comment">// 存活的线程的个数</span></span><br><span class="line">    <span class="type">int</span> exitNum;            <span class="comment">// 要销毁的线程个数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexPool;  <span class="comment">// 锁整个的线程池</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexBusy;  <span class="comment">// 锁busyNum变量</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notFull;     <span class="comment">// 任务队列是不是满了</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;    <span class="comment">// 任务队列是不是空了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> shutdown;           <span class="comment">// 是不是要销毁线程池, 销毁为1, 不销毁为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="4-头文件声明-ThreadPool-h"><a href="#4-头文件声明-ThreadPool-h" class="headerlink" title="4.头文件声明(ThreadPool.h)"></a>4.头文件声明(ThreadPool.h)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span> <span class="title">ThreadPool</span>;</span></span><br><span class="line"><span class="comment">// 创建线程池并初始化</span></span><br><span class="line">ThreadPool *<span class="title function_">threadPoolCreate</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queueSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁线程池</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolDestroy</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池添加任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadPoolAdd</span><span class="params">(ThreadPool* pool, <span class="type">void</span>(*func)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程池中工作的线程的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolBusyNum</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程池中活着的线程的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolAliveNum</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////</span></span><br><span class="line"><span class="comment">// 工作的线程(消费者线程)任务函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span>;</span><br><span class="line"><span class="comment">// 管理者线程任务函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">manager</span><span class="params">(<span class="type">void</span>* arg)</span>;</span><br><span class="line"><span class="comment">// 单个线程退出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadExit</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// _THREADPOOL_H</span></span></span><br></pre></td></tr></table></figure><h1 id="5-源文件定义-ThreadPool-c"><a href="#5-源文件定义-ThreadPool-c" class="headerlink" title="5.源文件定义(ThreadPool.c)"></a>5.源文件定义(ThreadPool.c)</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool* <span class="title function_">threadPoolCreate</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queueSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadPool));</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadpool fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool-&gt;threadIDs = (<span class="type">pthread_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threadIDs == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadIDs fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;threadIDs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        pool-&gt;minNum = min;</span><br><span class="line">        pool-&gt;maxNum = max;</span><br><span class="line">        pool-&gt;busyNum = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;liveNum = min;    <span class="comment">// 和最小个数相等</span></span><br><span class="line">        pool-&gt;exitNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;pool-&gt;mutexPool, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_mutex_init(&amp;pool-&gt;mutexBusy, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_cond_init(&amp;pool-&gt;notEmpty, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_cond_init(&amp;pool-&gt;notFull, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mutex or condition init fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务队列</span></span><br><span class="line">        pool-&gt;taskQ = (Task*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Task) * queueSize);</span><br><span class="line">        pool-&gt;queueCapacity = queueSize;</span><br><span class="line">        pool-&gt;queueSize = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueFront = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueRear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pool-&gt;shutdown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        pthread_create(&amp;pool-&gt;managerID, <span class="literal">NULL</span>, manager, pool);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_create(&amp;pool-&gt;threadIDs[i], <span class="literal">NULL</span>, worker, pool);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (pool &amp;&amp; pool-&gt;threadIDs) <span class="built_in">free</span>(pool-&gt;threadIDs);</span><br><span class="line">    <span class="keyword">if</span> (pool &amp;&amp; pool-&gt;taskQ) <span class="built_in">free</span>(pool-&gt;taskQ);</span><br><span class="line">    <span class="keyword">if</span> (pool) <span class="built_in">free</span>(pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolDestroy</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    pool-&gt;shutdown = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 阻塞回收管理者线程</span></span><br><span class="line">    pthread_join(pool-&gt;managerID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 唤醒阻塞的消费者线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;liveNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放堆内存</span></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;taskQ)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;taskQ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;threadIDs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threadIDs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;mutexPool);</span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;notEmpty);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;notFull);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadPoolAdd</span><span class="params">(ThreadPool* pool, <span class="type">void</span>(*func)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">while</span> (pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞生产者线程</span></span><br><span class="line">        pthread_cond_wait(&amp;pool-&gt;notFull, &amp;pool-&gt;mutexPool);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    pool-&gt;taskQ[pool-&gt;queueRear].function = func;</span><br><span class="line">    pool-&gt;taskQ[pool-&gt;queueRear].arg = arg;</span><br><span class="line">    pool-&gt;queueRear = (pool-&gt;queueRear + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">    pool-&gt;queueSize++;</span><br><span class="line"></span><br><span class="line">    pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolBusyNum</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolAliveNum</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="type">int</span> aliveNum = pool-&gt;liveNum;</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> aliveNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">// 当前任务队列是否为空</span></span><br><span class="line">        <span class="keyword">while</span> (pool-&gt;queueSize == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 阻塞工作线程</span></span><br><span class="line">            pthread_cond_wait(&amp;pool-&gt;notEmpty, &amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是不是要销毁线程</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;exitNum &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pool-&gt;exitNum--;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    pool-&gt;liveNum--;</span><br><span class="line">                    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">                    threadExit(pool);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断线程池是否被关闭了</span></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            threadExit(pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从任务队列中取出一个任务</span></span><br><span class="line">        Task task;</span><br><span class="line">        task.function = pool-&gt;taskQ[pool-&gt;queueFront].function;</span><br><span class="line">        task.arg = pool-&gt;taskQ[pool-&gt;queueFront].arg;</span><br><span class="line">        <span class="comment">// 移动头结点</span></span><br><span class="line">        pool-&gt;queueFront = (pool-&gt;queueFront + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">        pool-&gt;queueSize--;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_cond_signal(&amp;pool-&gt;notFull);</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %ld start working...\n&quot;</span>, pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;busyNum++;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        task.function(task.arg);</span><br><span class="line">        <span class="built_in">free</span>(task.arg);</span><br><span class="line">        task.arg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %ld end working...\n&quot;</span>, pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;busyNum--;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)arg;</span><br><span class="line">    <span class="keyword">while</span> (!pool-&gt;shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每隔3s检测一次</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出线程池中任务的数量和当前线程的数量</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="type">int</span> queueSize = pool-&gt;queueSize;</span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出忙的线程的数量</span></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加线程</span></span><br><span class="line">        <span class="comment">// 任务的个数&gt;存活的线程个数 &amp;&amp; 存活的线程数&lt;最大线程数</span></span><br><span class="line">        <span class="keyword">if</span> (queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;maxNum &amp;&amp; counter &lt; NUMBER</span><br><span class="line">                &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;threadIDs[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    pthread_create(&amp;pool-&gt;threadIDs[i], <span class="literal">NULL</span>, worker, pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 销毁线程</span></span><br><span class="line">        <span class="comment">// 忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程&gt;最小线程数</span></span><br><span class="line">        <span class="keyword">if</span> (busyNum * <span class="number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;exitNum = NUMBER;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="comment">// 让工作的线程自杀</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadExit</span><span class="params">(ThreadPool* pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;maxNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threadIDs[i] == tid)</span><br><span class="line">        &#123;</span><br><span class="line">            pool-&gt;threadIDs[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;threadExit() called, %ld exiting...\n&quot;</span>, tid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-测试代码"><a href="#6-测试代码" class="headerlink" title="6.测试代码"></a>6.测试代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">taskFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread %ld is working, number = %d\n&quot;</span>,</span><br><span class="line">        pthread_self(), num);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    ThreadPool* pool = threadPoolCreate(<span class="number">3</span>, <span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>* num = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *num = i + <span class="number">100</span>;</span><br><span class="line">        threadPoolAdd(pool, taskFunc, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    threadPoolDestroy(pool);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tag link"><a class="link-card" title="线程池C++版" href="https://keqiudi.github.io/posts/aa76cb12.html"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">线程池C++版</p><p class="url">https://keqiudi.github.io/posts/aa76cb12.html</p></div></a></div>]]></content>
    
    
    <summary type="html">线程池C语言版</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>线程同步</title>
    <link href="https://www.thekqd.top/posts/895e9db.html"/>
    <id>https://www.thekqd.top/posts/895e9db.html</id>
    <published>2023-07-15T09:04:29.000Z</published>
    <updated>2023-07-18T15:19:38.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-线程同步概念"><a href="#1-线程同步概念" class="headerlink" title="1.线程同步概念"></a>1.线程同步概念</h1><p>线程同步的真实意思，其实是“<strong>排队</strong>”：几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。 而最让人无语的是，线程同步的目的就是让各个线程去排队使用资源，而不是让线程同时去使用资源。</p><p>假设有 4 个线程 A、B、C、D，当前一个线程 A 对内存中的共享资源进行访问的时候，其他线程 B, C, D 都不可以对这块内存进行操作，直到线程 A 对这块内存访问完毕为止，B，C，D 中的一个才能访问这块内存，剩余的两个需要继续阻塞等待，以此类推，直至所有的线程都对这块内存操作完毕。 线程对内存的这种访问方式就称之为线程同步，通过对概念的介绍，我们可以了解到所谓的同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次进行的。</p><h2 id="为什么要线程同步"><a href="#为什么要线程同步" class="headerlink" title="为什么要线程同步"></a>为什么要线程同步</h2><p><strong>在研究线程同步之前，先来看一个两个线程交替计数（每个线程数 50 个数，交替数到 100）的例子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 50</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcA_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcB_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个子线程</span></span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，资源回收</span></span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译并执行上面的测试程序，得到如下结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out </span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">1</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">2</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">2</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">3</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">4</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">5</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">6</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">7</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">8</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">7</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">8</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">9</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">8</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">9</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">9</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">10</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">11</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">10</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">11</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">11</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">12</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">13</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">14</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">15</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">16</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">17</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">18</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">19</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">17</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">18</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">19</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">19</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">20</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">20</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">21</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">21</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">22</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">22</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">23</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">23</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">24</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">24</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">25</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">25</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">26</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">26</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">27</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">27</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">28</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">28</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">29</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">29</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">30</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">30</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">31</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">31</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">32</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">32</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">33</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">33</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">34</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">34</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">35</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">35</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">36</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">36</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">37</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">37</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">38</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">38</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">39</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">39</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">40</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">41</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">42</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">42</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">43</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">44</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">45</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">45</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">46</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">46</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">47</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">47</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">48</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">48</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">49</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">50</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">51</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">51</span></span><br><span class="line">Thread B, id = <span class="number">140504473724672</span>, number = <span class="number">52</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">53</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">54</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">55</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">56</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">57</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">58</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">59</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">60</span></span><br><span class="line">Thread A, id = <span class="number">140504482117376</span>, number = <span class="number">61</span></span><br></pre></td></tr></table></figure><p>通过对上面例子的测试，可以看出虽然每个线程内部循环了 50 次每次数一个数，但是最终没有数到 100，通过输出的结果可以看到，有些数字被重复数了多次，其原因就是没有对线程进行同步处理，造成了<strong>数据的混乱。</strong></p><p>两个线程在数数的时候需要分时复用 CPU 时间片，并且测试程序中调用了 sleep() 导致线程的 CPU 时间片没用完就被迫挂起了，这样就能让 CPU 的上下文切换（保存当前状态，下一次继续运行的时候需要加载保存的状态）更加频繁，更容易再现数据混乱的这个现象。</p><p>在测试程序中两个线程共用全局变量 <strong>number</strong> 当线程变成运行态之后开始数数，从物理内存加载数据，让后将数据放到 CPU 进行运算，最后将结果更新到物理内存中。如果数数的两个线程都可以顺利完成这个流程，那么得到的结果肯定是正确的。</p><p>如果线程 A 执行这个过程期间就失去了 CPU 时间片，线程 A 被挂起了最新的数据没能更新到物理内存。线程 B 变成运行态之后从物理内存读数据，很显然它没有拿到最新数据，只能基于旧的数据往后数，然后失去 CPU 时间片挂起。线程 A 得到 CPU 时间片变成运行态，第一件事儿就是将上次没更新到内存的数据更新到内存，但是这样会导致线程 B 已经更新到内存的数据被覆盖，活儿白干了，最终导致有些数据会被重复数很多次。</p><h2 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h2><p>对于多个线程访问共享资源出现数据混乱的问题，需要进行线程同步。常用的线程同步方式有四种：<strong>互斥锁、读写锁、条件变量、信号量</strong>。所谓的共享资源就是多个线程共同访问的变量，这些变量通常为全局数据区变量或者堆区变量，这些变量对应的共享资源也被称之为<strong>临界资源</strong>。</p><p><img src="https://subingwen.cn/linux/thread-sync/image-20200106092600543.png" alt="image-20200106092600543"></p><p>找到临界资源之后，再找和临界资源相关的上下文代码，这样就得到了一个代码块，这个代码块可以称之为临界区。确定好临界区（临界区越小越好）之后，就可以进行线程同步了，线程同步的大致处理思路是这样的：</p><ul><li>在临界区代码的上边，添加加锁函数，对临界区加锁。<ul><li>哪个线程调用这句代码，就会把这把锁锁上，其他线程就只能阻塞在锁上了。</li></ul></li><li>在临界区代码的下边，添加解锁函数，对临界区解锁。<ul><li>出临界区的线程会将锁定的那把锁打开，其他抢到锁的线程就可以进入到临界区了。</li></ul></li><li>通过锁机制能保证临界区代码最多只能同时有一个线程访问，这样并行访问就变为串行访问了。</li></ul><h1 id="2-互斥锁"><a href="#2-互斥锁" class="headerlink" title="2.互斥锁"></a>2.互斥锁</h1><h2 id="互斥锁函数"><a href="#互斥锁函数" class="headerlink" title="互斥锁函数"></a>互斥锁函数</h2><p>互斥锁是线程同步最常用的一种方式，通过互斥锁可以锁定一个代码块，被锁定的这个代码块，所有的线程只能顺序执行 (不能并行处理)，这样多线程访问共享资源数据混乱的问题就可以被解决了，需要付出的代价就是执行效率的降低，因为默认临界区多个线程是可以并行处理的，现在只能串行处理。</p><p>在 Linux 中互斥锁的类型为 <strong>pthread_mutex_t</strong>，创建一个这种类型的变量就得到了一把互斥锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span>  mutex;</span><br></pre></td></tr></table></figure><p>在创建的锁对象中保存了当前这把锁的状态信息：锁定还是打开，如果是锁定状态还记录了给这把锁加锁的线程信息（线程 ID）。一个互斥锁变量只能被一个线程锁定，被锁定之后其他线程再对互斥锁变量加锁就会被阻塞，直到这把互斥锁被解锁，被阻塞的线程才能被解除阻塞。<strong>一般情况下，每一个共享资源对应一个把互斥锁(全局共享的锁)，锁的个数和线程的个数无关。</strong></p><p><strong>Linux 提供的互斥锁操作函数如下，如果函数调用成功会返回 0，调用失败会返回相应的错误号：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放互斥锁资源            </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>参数</p><ul><li><p>mutex: 互斥锁变量的地址</p></li><li><p>attr: 互斥锁的属性，一般使用默认属性即可，这个参数指定为 NULL</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改互斥锁的状态, 将其设定为锁定状态, 这个状态被写入到参数 mutex 中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>这个函数被调用，首先会判断参数 mutex 互斥锁中的状态是不是锁定状态:</p><ul><li><p>没有被锁定，是打开的，这个线程可以加锁成功，这个这个锁中会记录是哪个线程加锁成功了</p></li><li><p>如果被锁定了，其他线程加锁就失败了，这些线程都会阻塞在这把锁上</p></li><li><p>当这把锁被解开之后，这些阻塞在锁上的线程就解除阻塞了，并且这些线程是通过竞争的方式对这把锁加锁，没抢到锁的线程继续阻塞</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数对互斥锁变量加锁还是有两种情况:</p><ul><li>如果这把锁没有被锁定是打开的，线程加锁成功</li><li>如果锁变量被锁住了，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对互斥锁解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 不是所有的线程都可以对互斥锁解锁，哪个线程加的锁，哪个线程才能解锁成功。</p><h2 id="互斥锁的使用"><a href="#互斥锁的使用" class="headerlink" title="互斥锁的使用"></a>互斥锁的使用</h2><p>我们可以将上面多线程交替数数的例子修改一下，使用互斥锁进行线程同步。两个线程一共操作了同一个全局变量，因此需要添加一互斥锁，来控制这两个线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一把互斥锁</span></span><br><span class="line"><span class="comment">// 全局变量, 多个线程共享</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcA_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果线程A加锁成功, 不阻塞</span></span><br><span class="line">        <span class="comment">// 如果B加锁成功, 线程A阻塞</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcB_num</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// a加锁成功, b线程访问这把锁的时候是锁定的</span></span><br><span class="line">        <span class="comment">// 线程B先阻塞, a线程解锁之后阻塞解除</span></span><br><span class="line">        <span class="comment">// 线程B加锁成功了</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        number = cur;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个子线程</span></span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB_num, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，资源回收</span></span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    <span class="comment">// 线程销毁之后, 再去释放互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h1><p>当多个线程访问共享资源，需要加锁，如果锁使用不当，就会造成死锁这种现象。如果线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。</p><p>造成死锁的场景有如下几种：</p><ul><li><p>1.加锁后忘记解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功, 当前循环完毕没有解锁, 在下一轮循环的时候自己被阻塞了</span></span><br><span class="line">        <span class="comment">// 其余的线程也被阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        <span class="comment">// 忘记解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程被阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        <span class="keyword">if</span>(xxx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 函数退出, 没有解锁（解锁函数无法被执行了）</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>2.重复加锁，形成死锁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 锁被锁住了, A线程阻塞</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏的比较深的情况</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">funcA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">funcB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前线程A加锁成功</span></span><br><span class="line">        <span class="comment">// 其余的线程阻塞</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        funcA();<span class="comment">// 重复加锁</span></span><br><span class="line">    ....</span><br><span class="line">    .....</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>3.在程序中有多个共享资源，因此有很多把锁，随意加锁，导致相互被阻塞</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">场景描述:</span><br><span class="line">  1. 有两个共享资源:X, Y，X对应锁A, Y对应锁B</span><br><span class="line">     - 线程A访问资源X, 加锁A</span><br><span class="line">     - 线程B访问资源Y, 加锁B</span><br><span class="line">  2. 线程A要访问资源Y, 线程B要访问资源X，因为资源X和Y已经被对应的锁锁住了，因此这个两个线程被阻塞</span><br><span class="line">     - 线程A被锁B阻塞了, 无法打开A锁</span><br><span class="line">     - 线程B被锁A阻塞了, 无法打开B锁</span><br></pre></td></tr></table></figure></li></ul><p><strong>在使用多线程编程的时候，如何避免死锁呢？</strong></p><ul><li><p>避免多次锁定，多检查</p></li><li><p>对共享资源访问完毕之后，一定要解锁，或者在加锁的使用 trylock</p></li><li><p>如果程序中有多把锁，可以控制对锁的访问顺序 (顺序访问共享资源，但在有些情况下是做不到的)，另外也可以在对其他互斥锁做加锁操作之前，先释放当前线程拥有的互斥锁。</p></li><li><p>项目程序中可以引入一些专门用于死锁检测的模块</p></li></ul><h1 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4.读写锁"></a>4.读写锁</h1><p>读写锁是互斥锁的升级版，在做读操作的时候可以提高程序的执行效率，如果所有的线程都是做读操作, 那么读是并行的，但是使用互斥锁，读操作也是串行的。</p><p>读写锁是一把锁，锁的类型为 <strong>pthread_rwlock_t</strong>，有了类型之后就可以创建一把互斥锁了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br></pre></td></tr></table></figure><p>之所以称其为读写锁，是因为这把锁既可以锁定读操作，也可以锁定写操作。为了方便理解，可以大致认为在这把锁中记录了这些信息：</p><ul><li>锁的状态：锁定 / 打开</li><li>锁定的是什么操作：读操作 / 写操作，使用读写锁锁定了读操作，需要先解锁才能去锁定写操作，反之亦然。</li><li>哪个线程将这把锁锁上了</li></ul><p>读写锁的使用方式也互斥锁的使用方式是完全相同的：找共享资源，确定临界区，在临界区的开始位置加锁（读锁 / 写锁），临界区的结束位置解锁。</p><p>因为通过一把读写锁可以锁定读或者写操作，下面介绍一下关于读写锁的特点：</p><ol><li>使用读写锁的读锁锁定了临界区，线程对临界区的访问是并行的，读锁是共享的。</li><li>使用读写锁的写锁锁定了临界区，线程对临界区的访问是串行的，写锁是独占的。</li><li>使用读写锁分别对两个临界区加了读锁和写锁，两个线程要同时访问者两个临界区，访问写锁临界区的线程继续运行，访问读锁临界区的线程阻塞，因为<strong>写锁比读锁的优先级高。</strong></li></ol><p>如果说程序中所有的线程都对共享资源做写操作，使用读写锁没有优势，和互斥锁是一样的，如果说程序中所有的线程都对共享资源有写也有读操作，并且对共享资源读的操作越多，读写锁更有优势。</p><p><strong>Linux 提供的读写锁操作函数原型如下，如果函数调用成功返回 0，失败返回对应的错误号：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放读写锁占用的系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>rwlock: 读写锁的地址，传出参数</li><li>attr: 读写锁属性，一般使用默认属性，指定为 NULL</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加读锁, 锁定的是读操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数的线程会被阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加读锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数加锁失败，对应的线程不会被阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加写锁, 锁定的是写操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数的线程会被阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这个函数可以有效的避免死锁</span></span><br><span class="line"><span class="comment">// 如果加写锁失败, 不会阻塞当前线程, 直接返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数加锁失败，但是线程不会阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解锁, 不管锁定了读还是写都可用解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><h2 id="读写锁的使用"><a href="#读写锁的使用" class="headerlink" title="读写锁的使用"></a>读写锁的使用</h2><p>题目要求：8 个线程操作同一个全局变量，3 个线程不定时写同一全局资源，5 个线程不定时读同一全局资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义读写锁</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写的线程的处理函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">writeNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur ++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++写操作完毕, number : %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">// 添加sleep目的是要看到多个线程交替工作</span></span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程的处理函数</span></span><br><span class="line"><span class="comment">// 多个线程可以如果处理动作相同, 可以使用相同的处理函数</span></span><br><span class="line"><span class="comment">// 每个线程中的栈资源是独享</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">readNum</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--全局变量number = %d, tid = %ld\n&quot;</span>, number, pthread_self());</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(rand() % <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化读写锁</span></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3个写线程, 5个读的线程</span></span><br><span class="line">    <span class="type">pthread_t</span> wtid[<span class="number">3</span>];</span><br><span class="line">    <span class="type">pthread_t</span> rtid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;wtid[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;rtid[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(wtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(rtid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-条件变量"><a href="#5-条件变量" class="headerlink" title="5.条件变量"></a>5.条件变量</h1><h2 id="条件变量函数"><a href="#条件变量函数" class="headerlink" title="条件变量函数"></a>条件变量函数</h2><p>严格意义上来说，条件变量的主要作用不是处理线程同步，<strong>而是进行线程的阻塞</strong>。如果在多线程程序中只使用条件变量无法实现线程的同步，必须要配合互斥锁来使用。虽然条件变量和互斥锁都能阻塞线程，但是二者的效果是不一样的，二者的区别如下：</p><ul><li>设有 A-Z 26 个线程，这 26 个线程共同访问同一把互斥锁，如果线程 A 加锁成功，那么其余 B-Z 线程访问互斥锁都阻塞，所有的线程只能顺序访问临界区</li><li>条件变量只有在满足指定条件下才会阻塞线程，如果条件不满足，多个线程可以同时进入临界区，同时读写临界资源，这种情况下还是会出现共享资源中数据的混乱。</li></ul><p>一般情况下条件变量用于处理生产者和消费者模型，并且和互斥锁配合使用。条件变量类型对应的类型为 <strong>pthread_cond_t</strong>，这样就可以定义一个条件变量类型的变量了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;<span class="comment">//cond(condition)</span></span><br></pre></td></tr></table></figure><ul><li>被条件变量阻塞的线程的线程信息会被记录到这个变量中，以便在解除阻塞的时候使用。</li></ul><p><strong>条件变量操作函数函数原型如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">      <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 销毁释放资源        </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数:</p><ul><li>cond: 条件变量的地址</li><li>attr: 条件变量属性，一般使用默认属性，指定为 NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure><p>通过函数原型可以看出，该函数在阻塞线程的时候，需要一个互斥锁参数，这个互斥锁主要功能是进行线程同步，让线程顺序进入临界区，避免出现数共享资源的数据混乱。该函数会对这个互斥锁做以下几件事情：</p><ol><li>在阻塞线程时候，如果线程已经对互斥锁 mutex 上锁，那么会将这把锁打开，这样做是为了避免死锁</li><li>当线程解除阻塞的时候，函数内部会帮助这个线程再次将这个 mutex 互斥锁锁上，继续向下访问临界区</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这个函数的前两个参数和 <strong>pthread_cond_wait</strong> 函数是一样的，第三个参数表示线程阻塞的时长，但是需要额外注意一点：<strong>struct timespec</strong> 这个结构体中记录的时间是从1971.1.1到某个时间点的时间，总长度使用秒/纳秒表示。因此赋值方式相对要麻烦一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> mytim = time(<span class="literal">NULL</span>);<span class="comment">// 1970.1.1 0:0:0 到当前的总秒数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tmsp</span>;</span></span><br><span class="line">tmsp.tv_nsec = <span class="number">0</span>;</span><br><span class="line">tmsp.tv_sec = time(<span class="literal">NULL</span>) + <span class="number">100</span>;<span class="comment">// 线程阻塞100s</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><p>调用上面两个函数中的任意一个，都可以唤醒被 pthread_cond_wait 或者 pthread_cond_timedwait 阻塞的线程，区别就在于 pthread_cond_signal 是唤醒至少一个被阻塞的线程（总个数不定），pthread_cond_broadcast 是唤醒所有被阻塞的线程。</p><h2 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h2><p><strong>生产者和消费者模型组成：</strong></p><ol><li>生产者线程 -&gt; 若干个<ul><li>生产商品或者任务放入到任务队列中</li><li>任务队列满了就阻塞，不满的时候就工作</li><li>通过一个生产者的条件变量控制生产者线程阻塞和非阻塞</li></ul></li><li>消费者线程 -&gt; 若干个<ul><li>读任务队列，将任务或者数据取出</li><li>任务队列中有数据就消费，没有数据就阻塞</li><li>通过一个消费者的条件变量控制消费者线程阻塞和非阻塞</li></ul></li><li>队列 -&gt; 存储任务 / 数据，对应一块内存，为了读写访问可以通过一个数据结构维护这块内存<ul><li>可以是数组、链表，也可以使用 stl 容器：queue /stack/list/vector</li></ul></li></ol><p><strong>场景描述：使用条件变量实现生产者和消费者模型，生产者有 5 个，往链表头部添加节点，消费者也有 5 个，删除链表头部的节点。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义条件变量, 控制消费者线程</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产了任务, 通知消费者消费</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span><span class="comment">//rand()产生0-32767之间的随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* consumer(<span class="type">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 一直消费, 删除链表中的一个节点</span></span><br><span class="line"><span class="comment">//        if(head == NULL)   // 这样写有bug</span></span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 任务队列, 也就是链表中已经没有节点可以消费了</span></span><br><span class="line">            <span class="comment">// 消费者线程需要阻塞</span></span><br><span class="line">            <span class="comment">// 线程加互斥锁成功, 但是线程阻塞在这行代码上, 锁还没解开</span></span><br><span class="line">            <span class="comment">// 其他线程在访问这把锁的时候也会阻塞, 生产者也会阻塞 ==&gt; 死锁</span></span><br><span class="line">            <span class="comment">// 这函数会自动将线程拥有的锁解开</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">            <span class="comment">// 当消费者线程解除阻塞之后, 会自动将这把锁锁上</span></span><br><span class="line">            <span class="comment">// 这时候当前这个线程又重新拥有了这把互斥锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="keyword">struct</span> Node* pnode = head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);        </span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化条件变量</span></span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 一直消费, 删除链表中的一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)   <span class="comment">// 这样写有bug</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);        </span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么在第7行使用if 有bug:</span></span><br><span class="line"><span class="comment">    当任务队列为空, 所有的消费者线程都会被这个函数阻塞 pthread_cond_wait(&amp;cond, &amp;mutex);</span></span><br><span class="line"><span class="comment">    也就是阻塞在代码的第9行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当生产者生产了1个节点, 调用 pthread_cond_broadcast(&amp;cond); 唤醒了所有阻塞的线程</span></span><br><span class="line"><span class="comment">      - 有一个消费者线程通过 pthread_cond_wait()加锁成功, 其余没有加锁成功的线程继续阻塞</span></span><br><span class="line"><span class="comment">      - 加锁成功的线程向下运行, 并成功删除一个节点, 然后解锁</span></span><br><span class="line"><span class="comment">      - 没有加锁成功的线程解除阻塞继续抢这把锁, 另外一个子线程加锁成功</span></span><br><span class="line"><span class="comment">      - 但是这个线程删除链表节点的时候链表已经为空了, 后边访问这个空节点的时候就会出现段错误</span></span><br><span class="line"><span class="comment">    解决方案:</span></span><br><span class="line"><span class="comment">      - 需要循环的对链表是否为空进行判断, 需要将if 该成 while</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="6-信号量"><a href="#6-信号量" class="headerlink" title="6.信号量"></a>6.信号量</h1><h2 id="信号量函数"><a href="#信号量函数" class="headerlink" title="信号量函数"></a>信号量函数</h2><p>信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。信号量不一定是锁定某一个资源，而是流程上的概念，比如：有 A，B 两个线程，B 线程要等 A 线程完成某一任务以后再进行自己下面的步骤，这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。</p><p><strong>信号量（信号灯）</strong>与互斥锁和条件变量的主要不同在于” 灯” 的概念，灯亮则意味着资源可用，灯灭则意味着不可用。信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。</p><p><strong>信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。</strong>信号的类型为 sem_t 对应的头文件为 <strong><semaphore.h>：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br></pre></td></tr></table></figure><ul><li>Linux 提供的信号量操作函数原型如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">// 初始化信号量/信号灯</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">          </span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">// 资源释放, 线程销毁之后调用这个函数即可</span></span><br><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br></pre></td></tr></table></figure><ul><li><p>参数:</p><ul><li><p>sem: 信号量变量地址</p></li><li><p>pshared：</p><ul><li><p>0：线程同步</p></li><li><p>非 0：进程同步  </p></li></ul></li><li><p>value：初始化当前信号量拥有的资源数（&gt;=0），如果资源数为 0，线程就会被阻塞了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，因此线程也就被阻塞了。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 sem 就是 sem_init() 的第一个参数  </span></span><br><span class="line"><span class="comment">// 函数被调用sem中的资源就会被消耗1个, 资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li>当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，但是线程不会被阻塞，直接返回错误号，因此可以在程序中添加判断分支，用于处理获取资源失败之后的情况。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="type">time_t</span> tv_sec;      <span class="comment">/* Seconds */</span></span><br><span class="line"><span class="type">long</span>   tv_nsec;     <span class="comment">/* Nanoseconds [0 .. 999999999] */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用该函数线程获取sem中的一个资源，当资源数为0时，线程阻塞，在阻塞abs_timeout对应的时长之后，解除阻塞。</span></span><br><span class="line"><span class="comment">// abs_timeout: 阻塞的时间长度, 单位是s, 是从1970.1.1开始计算的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li>该函数的参数 abs_timeout 和 pthread_cond_timedwait 的最后一个参数是一样的，使用方法不再过多赘述。当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，线程被阻塞，当阻塞指定的时长之后，线程解除阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用该函数给sem中的资源数+1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><ul><li>调用该函数会将 sem 中的资源数 +1，如果有线程在调用 sem_wait、sem_trywait、sem_timedwait 时因为 sem 中的资源数为 0 被阻塞了，这时这些线程会解除阻塞，获取到资源之后继续向下运行。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看信号量 sem 中的整形数的当前值, 这个值会被写入到sval指针对应的内存中</span></span><br><span class="line"><span class="comment">// sval是一个传出参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span>;</span><br></pre></td></tr></table></figure><ul><li>通过这个函数可以查看 sem 中现在拥有的资源个数，通过第二个参数 sval 将数据传出，也就是说第二个参数的作用和返回值是一样的。</li></ul><h2 id="生产者和消费者-1"><a href="#生产者和消费者-1" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h2><p>由于生产者和消费者是两类线程，并且在还没有生成之前是不能进行消费的，在使用信号量处理这类问题的时候可以定义两个信号量，分别用于记录生产者和消费者线程拥有的总资源数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者线程 </span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量初始化</span></span><br><span class="line">sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);    <span class="comment">// 5个生产者可以同时生产</span></span><br><span class="line">sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// 消费者线程没有资源, 因此不能消费</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="comment">// 在生产之前, 从信号量中取出一个资源</span></span><br><span class="line">sem_wait(&amp;psem);</span><br><span class="line"><span class="comment">// 生产者商品代码, 有商品了, 放到任务队列</span></span><br><span class="line">...... </span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 通知消费者消费，给消费者信号量添加资源，让消费者解除阻塞</span></span><br><span class="line">sem_post(&amp;csem);<span class="comment">//消费者资源+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="comment">// 消费者需要等待生产, 默认启动之后应该阻塞</span></span><br><span class="line">sem_wait(&amp;csem);<span class="comment">//生产者资源-1</span></span><br><span class="line"><span class="comment">// 开始消费</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 消费完成, 通过生产者生产，给生产者信号量添加资源</span></span><br><span class="line">sem_post(&amp;psem);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上面的代码可以知道，初始化信号量的时候没有消费者分配资源，消费者线程启动之后由于没有资源自然就被阻塞了，等生产者生产出产品之后，再给消费者分配资源，这样二者就可以配合着完成生产和消费流程了。</p><h2 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h2><p><strong>场景描述：使用信号量实现生产者和消费者模型，生产者有 5 个，往链表头部添加节点，消费者也有 5 个，删除链表头部的节点。</strong></p><h3 id="总资源数为1"><a href="#总资源数为1" class="headerlink" title="总资源数为1"></a>总资源数为1</h3><p>如果生产者和消费者线程使用的信号量对应的总资源数为 1，那么不管线程有多少个，可以工作的线程只有一个，其余线程由于拿不到资源，都被迫阻塞了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费, 给消费者加信号灯</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="comment">// 生产者和消费者拥有的信号灯的总和为1</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 生成者线程一共有1个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过测试代码可以得到如下结论：如果生产者和消费者使用的信号量总资源数为 1，那么不会出现生产者线程和消费者线程同时访问共享资源的情况，不管生产者和消费者线程有多少个，它们都是顺序执行的。</strong></p><h3 id="总资源数大于1"><a href="#总资源数大于1" class="headerlink" title="总资源数大于1"></a>总资源数大于1</h3><p>如果生产者和消费者线程使用的信号量对应的总资源数为大于 1，这种场景下出现的情况就比较多了：</p><ul><li>多个生产者线程同时生产</li><li>多个消费者同时消费</li><li>生产者线程和消费者线程同时生产和消费</li></ul><p>以上不管哪一种情况都可能会出现多个线程访问共享资源的情况，如果想防止共享资源出现数据混乱，那么就需要使用互斥锁进行线程同步，处理代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="comment">// 消费者线程信号量</span></span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 指向头结点的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        <span class="comment">// 加锁, 这句代码放到 sem_wait()上边, 有可能会造成死锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 创建一个链表的新节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnew</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        <span class="comment">// 节点初始化</span></span><br><span class="line">        pnew-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 节点的连接, 添加到链表的头部, 新节点就新的头结点</span></span><br><span class="line">        pnew-&gt;next = head;</span><br><span class="line">        <span class="comment">// head指针前移</span></span><br><span class="line">        head = pnew;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pnode</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());</span><br><span class="line">        head  = pnode-&gt;next;</span><br><span class="line">        <span class="comment">// 取出链表的头结点, 将其删除</span></span><br><span class="line">        <span class="built_in">free</span>(pnode);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 生成者线程一共有5个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者, 5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> ptid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">pthread_t</span> ctid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;psem);</span><br><span class="line">    sem_destroy(&amp;csem);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写上述代码的时候还有一个需要注意是事项，不管是消费者线程的处理函数还是生产者线程的处理函数内部有这么两行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">sem_wait(&amp;csem);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure><p><strong>这两行代码的调用顺序是不能颠倒的，如果颠倒过来就有可能会造成死锁，下面来分析一种死锁的场景：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一直生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 生产者拿一个信号灯</span></span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">......</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 通知消费者消费</span></span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生产慢一点</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者的回调函数</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">......</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 通知生产者生成, 给生产者加信号灯</span></span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 生成者线程一共有5个信号灯</span></span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 消费者线程一共有0个信号灯</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，初始化状态下消费者线程没有任务信号量资源，假设某一个消费者线程先运行，调用 <strong>pthread_mutex_lock(&amp;mutex)</strong>; 对互斥锁加锁成功，然后调用 <strong>sem_wait(&amp;csem)</strong>; 由于没有资源，因此被阻塞了。其余的消费者线程由于没有抢到互斥锁，因此被阻塞在互斥锁上。对应生产者线程第一步操作也是调用 <strong>pthread_mutex_lock(&amp;mutex)</strong>;，但是这时候互斥锁已经被消费者线程锁上了，所有生产者都被阻塞，到此为止，多余的线程都被阻塞了，程序产生了死锁。</p><p><strong>请记住: 先拿信号灯，再加锁!!!</strong></p>]]></content>
    
    
    <summary type="html">线程同步</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>虚拟地址空间</title>
    <link href="https://www.thekqd.top/posts/fb84f8a3.html"/>
    <id>https://www.thekqd.top/posts/fb84f8a3.html</id>
    <published>2023-07-14T10:22:13.000Z</published>
    <updated>2023-09-17T06:48:52.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-虚拟地址空间"><a href="#1-虚拟地址空间" class="headerlink" title="1.虚拟地址空间"></a>1.虚拟地址空间</h1><p>虚拟地址空间是一个非常抽象的概念，先根据字面意思进行解释：</p><ul><li>它可以用来加载程序数据（数据可能被加载到物理内存上，空间不够就加载到虚拟内存中）</li><li>它对应着一段连续的内存地址，起始位置为 0。</li><li>之所以说虚拟是因为这个起始的 0 地址是被虚拟出来的， 不是物理内存的 0 地址</li></ul><p>虚拟地址空间的大小也由操作系统决定，32位的操作系统虚拟地址空间的大小为 232 字节，也就是 4G，64 位的操作系统虚拟地址空间大小为 264 字节，这是一个非常大的数，感兴趣可以自己计算一下。当我们运行磁盘上一个可执行程序, 就会得到一个进程，内核会给每一个运行的进程创建一块属于自己的虚拟地址空间，并将应用程序数据装载到虚拟地址空间对应的地址上。</p><p>进程在运行过程中，程序内部所有的指令都是通过 CPU 处理完成的，CPU 只进行数据运算并不具备数据存储的能力，其处理的数据都加载自物理内存，那么进程中的数据是如何进出入到物理内存中的呢？其实是通过 CPU 中的内存管理单元 MMU（Memory Management Unit）从进程的虚拟地址空间中映射过去的。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>通过上边的介绍大家会感觉到一头雾水， 为什么操作系统不直接将数据加载到物理内存中而是将数据加载到虚拟地址空间中，在通过 CPU 的 MMU 映射到物理内存中呢？</p><p>先来看一下如果直接将数据加载到物理内存会发生什么事情：</p><p><strong>假设计算机的物理内存大小为 1G, 进程 A 需要 100M 内存因此直接在物理内存上从 0 地址开始分配 100M, 进程 B 启动需要 250M 内存，因此继续在物理内存上为其分配 250M 内存，并且进程 A 和进程 B 占用的内存是连续的。之后再启动其他进程继续按照这种方法进行物理内存的分配。</strong></p><p>使用这种方式分配内存会有如下几个问题：</p><p>1.每个进程的地址不隔离，有安全风险。</p><p>由于程序都是直接访问物理内存，所以恶意程序可以通过内存寻址随意修改别的进程对应的内存数据，以达到破坏的目的。虽然有些时候是非恶意的，但是有些存在 bug 的程序可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。</p><p>2.内存效率低。</p><p>如果直接使用物理内存的话，一个进程对应的内存块就是作为一个整体操作的，如果出现物理内存不够用的时候，我们一般的办法是将不常用的进程拷贝到磁盘的交换分区（虚拟内存）中，以便腾出内存，因此就需要将整个进程一起拷走，如果数据量大，在内存和磁盘之间拷贝时间就会很长，效率低下。</p><p>3.进程中数据的地址不确定，每次都会发生变化。</p><p>由于物理内存的使用情况一直在动态的变化，我们无法确定内存现在使用到哪里了，如果直接将程序数据加载到物理内存，内存中每次存储数据的起始地址都是不一样的，这样数据的加载都需要使用相对地址，加载效率低（静态库是使用绝对地址加载的）。</p><p>总结：有了虚拟地址空间之后就可以完美的解决上边提到的所有问题了，<strong>虚拟地址空间就是一个中间层，相当于在程序和物理内存之间设置了一个屏障，将二者隔离开来。程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。</strong>这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>从操作系统层级上看，虚拟地址空间主要分为两个部分<strong>内核区</strong>和<strong>用户区</strong>。</p><ul><li>内核区：<ul><li>内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</li><li>内核总是驻留在内存中，是操作系统的一部分。</li><li>系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（系统内核只有一个）。</li></ul></li></ul><p><img src="https://subingwen.cn/linux/file-descriptor/image-20210130093015907.png" alt="img"></p><p>每个进程的虚拟地址空间都是从 0 地址开始的，我们在程序中打印的变量地址也其在虚拟地址空间中的地址，程序是无法直接访问物理内存的。虚拟地址空间中用户区地址范围是 0~3G，里边分为多个区块：</p><ul><li><p>保留区: 位于虚拟地址空间的最底部，未赋予物理地址。任何对它的引用都是非法的，程序中的空指针（NULL）指向的就是这块内存地址。</p></li><li><p>.text段: 代码段也称正文段或文本段，通常用于存放程序的执行代码 (即 CPU 执行的机器指令)，代码段一般情况下是只读的，这是对执行代码的一种保护机制。</p></li><li><p>.data段: 数据段通常用于存放程序中已初始化且初值不为 0 的全局变量和静态变量。数据段属于静态内存分配 (静态存储区)，可读可写。</p></li><li><p>.bss段: 未初始化以及初始为 0 的全局变量和静态变量，操作系统会将这些未初始化变量初始化为 0</p></li><li><p>堆(heap)：用于存放进程运行时动态分配的内存。</p><ul><li><p>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。</p></li><li><p>堆向高地址扩展 (即 “向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。</p></li></ul></li></ul><ul><li>内存映射区(mmap)：作为内存映射区加载磁盘文件，或者加载程序运作过程中需要调用的动态库。</li><li>栈(stack): 存储函数内部声明的非静态局部变量，函数参数，函数返回地址等信息，栈内存由编译器自动分配释放。栈和堆相反地址 “向下生长”，分配的内存是连续的。</li><li>命令行参数：存储进程执行的时候传递给 main() 函数的参数，argc，argv []</li><li>环境变量: 存储和进程相关的环境变量，比如：工作路径，进程所有者等信息</li></ul>]]></content>
    
    
    <summary type="html">虚拟地址空间概述</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="https://www.thekqd.top/posts/15fc6e8c.html"/>
    <id>https://www.thekqd.top/posts/15fc6e8c.html</id>
    <published>2023-07-14T09:01:14.000Z</published>
    <updated>2023-07-18T15:20:54.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-线程概述"><a href="#1-线程概述" class="headerlink" title="1.线程概述"></a>1.线程概述</h1><ul><li><p><strong>多线程和多进程都能够提高程序的并发性，但多线程对系统资源消耗更少，且多线程和多进程效率都是差不多的</strong></p></li><li><p>cpu会将单位时间分为很多份，每一份叫时间片，由系统进行调度，每个线程执行时都需要抢时间片，抢到的线程就执行成为<strong>运行态</strong>，没抢到就处于<strong>就绪态</strong>，执行完之后又成为就绪态继续抢时间片（都是随机的，无序运行）。</p></li></ul><div class="tip "><p>线程是轻量级的进程（LWP：light weight process），在 Linux 环境下线程的本质仍是进程。在计算机上运行的程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行。操作系统会以进程为单位，分配系统资源，可以这样理解，<strong>进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。</strong></p></div><p>先从概念上了解一下线程和进程之间的区别：</p><ul><li>进程有自己<strong>独立</strong>的地址空间，多个线程<strong>共用</strong>同一个地址空间</li></ul><ul><li><p>线程更加节省系统资源，效率不仅可以保持的，而且能够更高</p></li><li><p>在一个<strong>地址空间</strong>中多个线程<strong>独享</strong>：每个线程都有属于自己的栈区，寄存器 (内核中管理的)</p></li><li><p>在一个<strong>地址空间</strong>中多个线程<strong>共享</strong>：代码段，堆区，全局数据区，打开的文件 (文件描述符表) 都是线程共享的</p></li></ul><p>  (详细见blog篇)虚拟地址空间：于每一个程序在执行时（如a.out），此时会产生一个相应的进程，系统都会自动为其分配一个0~4G的虚拟地址空间，其中1G的内核空间用于：进程管理、内存管理、设备管理和虚拟文件系统等。</p><p>  下面详细介绍0~3G的用户空间：</p><pre><code>       强调一点：以下说明的各段都是与编程相关的，不包括虚拟地址空间的全部。      0~3G的用户空间。从小到大（从下往上）依次为：保留区（受保护的地址）、代码段、数据段（.data段）、.bss段、堆空间、内存映射段、栈空间、命令行参数和环境变量。下面依次对每一个段做简单的介绍：</code></pre><ul><li><p>线程是程序的最小执行单位，进程是操作系统中最小的资源分配单位</p><ul><li><p>每个进程对应一个虚拟地址空间，一个进程只能抢一个 CPU 时间片</p></li><li><p>一个地址空间中可以划分出多个线程，在有效的资源基础上，能够抢更多的 CPU 时间片</p></li></ul></li></ul><ul><li><p>CPU 的调度和切换：线程的上下文切换比进程要快的多</p><p>上下文切换：进程 / 线程分时复用 CPU 时间片，在切换之前会将上一个任务的状态进行保存，下次切换回这个任务的时候，加载这个状态继续运行，任务从保存到再次加载这个过程就是一次上下文切换。</p></li></ul><ul><li>线程更加廉价，启动速度更快，退出也快，对系统资源的冲击小。</li></ul><p>  <strong>一般考虑多线程，只执行任务的话，考虑多线程</strong></p><p>  <strong>当同时启动多个程序时，考虑多进程</strong></p>  <div class="tip "><p><strong>在处理多任务程序的时候使用多线程比使用多进程要更有优势，但是线程并不是越多越好，如何控制线程的个数呢？</strong></p></div><p>  1.文件 IO 操作：文件 IO 对 CPU 是使用率不高，因此可以分时复用 CPU 时间片，线程的个数 = 2 * CPU 核心数 (效率最高)</p><p>  2.处理复杂的算法 (主要是 CPU 进行运算，压力大)，线程的个数 = CPU 的核心数 (效率最高)</p><h1 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2.创建线程"></a>2.创建线程</h1><h2 id="线程函数"><a href="#线程函数" class="headerlink" title="线程函数"></a>线程函数</h2><p>每一个线程都有一个唯一的线程 ID，ID 类型为 <strong>pthread_t</strong>，这个 ID 是一个<strong>无符号长整形数</strong>，如果想要得到当前线程的线程 ID，可以调用如下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>）<span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">// 返回当前线程的线程ID</span></span><br></pre></td></tr></table></figure><p>在一个进程中调用线程创建函数，就可得到一个子线程，和进程不同，需要给每一个创建出的线程指定一个处理函数，否则这个线程无法工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> <span class="comment">//线程库</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// Compile and link with -pthread, 线程库的名字叫pthread</span></span><br><span class="line"><span class="comment">//全名: libpthread.so libptread.a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>参数:<ul><li>thread: 传出参数，是无符号长整形数，线程创建成功，会将线程 ID 写入到这个指针指向的内存中</li><li>attr: 线程的属性，一般情况下使用默认属性即可，写 NULL</li><li>start_routine: 函数指针，创建出的子线程的处理动作，也就是该（回调函数）工作函数在子线程中执行。</li><li>arg: 作为实参传递到 start_routine 指针指向的函数内部，工作函数的参数，会自动传入</li></ul></li></ul><p>返回值：线程创建成功返回 0，创建失败返回对应的错误号</p><div class="note warning flat"><p>注意：1.回调函数返回值为void <em>型，参数为void </em> arg。2.回调函数 的参数当有多个时，可以用结构体储存，再将该结构体传入</p></div><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>下面是创建线程的示例代码，在创建过程中一定要保证编写的线程函数与规定的函数指针类型一致：<strong>void *(*start_routine) (void *)</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_create.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//sleep函数所在头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 休息, 休息一会儿...</span></span><br><span class="line">    <span class="comment">// sleep(1);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>linux下编译测试程序，会看到如下错误信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc pthread_create.c</span> </span><br><span class="line">/tmp/cctkubA6.o: In function `main&#x27;:</span><br><span class="line">pthread_create.c:(.text+0x7f): undefined reference to `pthread_create&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>错误原因是因为编译器链接不到线程库文件（动态库），需要在编译的时候通过参数指定出来，动态库名为 libpthread.so 需要使用的参数为 -l，根据规则掐头去尾最终形态应该写成：-lpthread（参数和参数值中间可以有空格）。正确的编译命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pthread_create 函数的定义在某一个库中, 编译的时候需要加库名 pthread</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc pthread_create.c -lpthread</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./a.out</span> </span><br><span class="line">子线程创建成功, 线程ID: 139712560109312</span><br><span class="line">我是主线程, 线程ID: 139712568477440</span><br><span class="line">i = 0</span><br><span class="line">i = 1</span><br><span class="line">i = 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意：在打印的日志输出中为什么子线程处理函数没有执行完毕呢（只看到了子线程的部分日志输出）？<br>主线程一直在运行，执行期间创建出了子线程，说明主线程有 CPU 时间片，在这个时间片内将代码执行完毕了，主线程就退出了。<strong>子线程被创建出来之后需要抢cpu时间片, 抢不到就不能运行，如果主线程退出了, 虚拟地址空间就被释放了, 子线程就一并被销毁了。但是如果某一个子线程退出了, 主线程仍在运行, 虚拟地址空间依旧存在。</strong></p></div><p>得到的结论：<strong>在没有人为干预的情况下，虚拟地址空间的生命周期和主线程是一样的，与子线程无关</strong>。</p><p>目前的解决方案：让子线程执行完毕，主线程再退出，可以在主线程中添加挂起函数 sleep()，避免主线程先执行完毕后虚拟地址空间被释放;</p><h1 id="3-线程退出"><a href="#3-线程退出" class="headerlink" title="3.线程退出"></a>3.线程退出</h1><div class="tip "><p>在编写多线程程序的时候，如果想要让线程退出，<strong>但是不会导致虚拟地址空间的释放（针对于主线程退出后，不想释放虚拟空间地址的情况）</strong>，我们就可以调用线程库中的线程退出函数，只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，<strong>不管是在子线程或者主线程中都可以使用。</strong></p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数(void *retval)：线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为 NULL</li></ul><p>线程退出示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);<span class="comment">// 直接退出子线程</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程调用退出函数退出, 地址空间不会被释放</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-线程回收"><a href="#4-线程回收" class="headerlink" title="4.线程回收"></a>4.线程回收</h1><h2 id="线程函数-1"><a href="#线程函数-1" class="headerlink" title="线程函数"></a>线程函数</h2><div class="tip "><p>线程和进程一样，子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做  <strong>pthread_join()</strong>，这个函数是一个阻塞函数，<strong>如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</strong></p></div><p>另外通过线程回收函数还可以获取到子线程退出时传递出来的数据，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这是一个阻塞函数, 子线程在运行这个函数就阻塞</span></span><br><span class="line"><span class="comment">// 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>参数:</p><ul><li>thread: 要被回收的子线程的线程 ID</li><li>retval: 二级指针，指向一级指针的地址，是一个传出参数，这个地址中存储了 pthread_exit () 传递出的数据，如果不需要这个参数，可以指定为 NULL</li></ul></li><li><p>返回值：线程回收成功返回 0，回收失败返回错误号。</p></li></ul><h2 id="回收子线程数据"><a href="#回收子线程数据" class="headerlink" title="回收子线程数据"></a>回收子线程数据</h2><p>在子线程退出的时候可以使用 pthread_exit() 的参数将数据传出，在回收这个子线程的时候可以通过 phread_join() 的第二个参数来接收子线程传递出的数据。接收数据有很多种处理方式，下面来列举几种：</p><h3 id="使用子线程栈"><a href="#使用子线程栈" class="headerlink" title="使用子线程栈"></a>使用子线程栈</h3><p>通过函数 <em>pthread_exit(void \</em>retval);<em> 可以得知，子线程退出的时候，需要将数据记录到一块内存中，通过参数传出的是存储数据的内存的地址，而不是具体数据，由因为参数是 </em>void** 类型，所有这个万能指针可以指向任意类型的内存地址。先来看第一种方式，将子线程退出数据保存在子线程自己的栈区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_join.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span></span><br><span class="line">            p.age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p.id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(&amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">// 代码执行不到这个位置就退出了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">pp</span> =</span> (<span class="keyword">struct</span> Persion*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程返回数据: name: %s, age: %d, id: %d\n&quot;</span>, pp-&gt;name, pp-&gt;age, pp-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行测试程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 编译代码</span><br><span class="line">$ gcc pthread_join.c -lpthread</span><br><span class="line"># 执行程序</span><br><span class="line">$ ./a.out </span><br><span class="line">子线程创建成功, 线程ID: <span class="number">140652794640128</span></span><br><span class="line">我是主线程, 线程ID: <span class="number">140652803008256</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">我是子线程, 线程ID: <span class="number">140652794640128</span></span><br><span class="line">child == i: = <span class="number">0</span></span><br><span class="line">child == i: = <span class="number">1</span></span><br><span class="line">child == i: = <span class="number">2</span></span><br><span class="line">child == i: = <span class="number">3</span></span><br><span class="line">child == i: = <span class="number">4</span></span><br><span class="line">child == i: = <span class="number">5</span></span><br><span class="line">child == i: = <span class="number">6</span></span><br><span class="line">子线程返回数据: name: , age: <span class="number">0</span>, id: <span class="number">0</span></span><br><span class="line">子线程资源被成功回收...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过打印的日志可以发现，在主线程中没有没有得到子线程返回的数据信息，具体原因是这样的：</p><p><strong>如果多个线程共用同一个虚拟地址空间，每个线程在栈区都有一块属于自己的内存，相当于栈区被这几个线程平分了，当线程退出，线程在栈区的内存也就被回收了，因此随着子线程的退出，写入到栈区的数据也就被释放了。</strong></p><h3 id="使用全局变量"><a href="#使用全局变量" class="headerlink" title="使用全局变量"></a>使用全局变量</h3><p>位于同一虚拟地址空间中的线程，虽然<strong>不能共享栈区数据，但是可以共享全局数据区和堆区数据</strong>，因此在子线程退出的时候可以将传出数据存储到全局变量、静态变量或者堆内存中。在下面的例子中将数据存储到了全局变量中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span><span class="comment">// 定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用全局变量</span></span><br><span class="line">            p.age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p.name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p.id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(&amp;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">pp</span> =</span> (<span class="keyword">struct</span> Persion*)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s, age: %d, id: %d\n&quot;</span>, pp-&gt;name, pp-&gt;age, pp-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用主线程栈"><a href="#使用主线程栈" class="headerlink" title="使用主线程栈"></a>使用主线程栈</h3><p>虽然每个线程都有属于自己的栈区空间，但是<strong>位于同一个地址空间的多个线程是可以相互访问对方的栈空间上的数据的</strong>。由于很多情况下还需要在主线程中回收子线程资源，所以主线程一般都是最后退出，基于这个原因在下面的程序中将子线程返回的数据保存到了主线程的栈区内存中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">36</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>* <span class="title">p</span> =</span> (<span class="keyword">struct</span> Persion*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用主线程的栈内存</span></span><br><span class="line">            p-&gt;age  =<span class="number">12</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(p-&gt;name, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">            p-&gt;id = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 该函数的参数将这个地址传递给了主线程的pthread_join()</span></span><br><span class="line">            pthread_exit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Persion</span> <span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">// 主线程的栈内存传递给子线程</span></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待子线程退出</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存</span></span><br><span class="line">    <span class="comment">// 这个内存地址就是pthread_exit() 参数指向的内存</span></span><br><span class="line">    pthread_join(tid, &amp;ptr);</span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s, age: %d, id: %d\n&quot;</span>, p.name, p.age, p.id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程资源被成功回收...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的程序中，调用 pthread_create() 创建子线程，并将主线程中栈空间变量 p 的地址传递到了子线程中，在子线程中将要传递出的数据写入到了这块内存中。也就是说在程序的 main() 函数中，通过指针变量 ptr 或者通过结构体变量 p 都可以读出子线程传出的数据。</p><h2 id="手动和自动回收资源"><a href="#手动和自动回收资源" class="headerlink" title="手动和自动回收资源"></a>手动和自动回收资源</h2><div class="tip "><p><strong>线程退出有多种方式，如return，pthread_exit,pthread_cancel等；线程分为可结合的（joinable）和 分离的（detached）两种，如果没有在创建线程时将线程分离，则线程默认是可结合的。可结合的线程在线程退出后不会立即释放资源，必须要调用pthread_join来显式的结束线程。分离的线程在线程退出时系统会自动回收资源。</strong></p></div><p>　</p><ul><li><p>pthread_exit()：只退出当前子线程。<strong>注意</strong>：在主线程退出时，其它线程不会结束。同样可以执行。所以这个只字非常重要。并且，与return一样，pthread_exit退出的线程也需要调用pthread_join去回收子线程的资源(8k左右)，不会自行回收，否则服务器长时间运行会浪费资源导致无法再创建新线程。</p></li><li><p>pthread_detach()，自行回收资源</p></li></ul><h1 id="5-线程分离"><a href="#5-线程分离" class="headerlink" title="5.线程分离"></a>5.线程分离</h1><div class="tip "><p><strong>某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用 pthread_join() 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。</strong></p></div><p>在线程库函数中为我们提供了线程分离函数 <strong>pthread_detach()</strong>，调用这个函数之后指定的<strong>子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。</strong>线程分离之后在主线程中使用 <strong>pthread_join()</strong> 就回收不到子线程资源了。<strong>(detach后资源自动回收)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p>下面的代码中，在主线程中创建子线程，并调用线程分离函数，实现了主线程和子线程的分离：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child == i: = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子线程和主线程分离</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程自己退出即可，必须有这个，否则虚拟地址空间内存会被释放</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="6-其他线程函数"><a href="#6-其他线程函数" class="headerlink" title="6.其他线程函数"></a>6.其他线程函数</h1><h2 id="线程取消函数"><a href="#线程取消函数" class="headerlink" title="线程取消函数"></a>线程取消函数</h2><p>线程取消的意思就是在某些特定情况下在一个线程中杀死另一个线程。使用这个函数杀死一个线程需要分两步：</p><ul><li>在线程 A 中调用线程取消函数 pthread_cancel，指定杀死线程 B，这时候线程 B 是死不了的</li><li>在线程 B 中进程一次系统调用（从用户区切换到内核区），否则线程 B 可以一直运行。<br>这其实和七步断肠散、含笑半步癫的功效是一样的，吃了毒药不动或者不笑也没啥事儿</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数是子线程的线程ID</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数：要杀死的线程的线程 ID</p></li><li><p>返回值：函数调用成功返回 0，调用失败返回非 0 错误号。</p></li></ul><p>在下面的示例代码中，主线程调用线程取消函数，只要在子线程中进行了系统调用，当子线程执行到这个位置就挂掉了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程的处理代码</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">working</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf这个函数会调用系统函数, 因此这是个间接的系统调用,运行到子线程就挂了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; child i: %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, working, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);</span><br><span class="line">    <span class="comment">// 2. 子线程不会执行下边的代码, 主线程执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 杀死子线程, 如果子线程中做系统调用, 子线程就结束了</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程自己退出即可</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>关于系统调用有两种方式：</strong></p><ul><li>直接调用 Linux 系统函数</li><li>调用标准 C 库函数，为了实现某些功能，在 Linux 平台下标准 C 库函数会调用相关的系统函数</li></ul><h2 id="线程ID比较"><a href="#线程ID比较" class="headerlink" title="线程ID比较"></a>线程ID比较</h2><p>在 Linux 中线程 ID 本质就是一个无符号长整形，因此可以直接使用比较操作符比较两个线程的 ID，但是线程库是可以跨平台使用的，在某些平台上 <strong>pthread_t</strong> 可能不是一个单纯的整形，这中情况下比较两个线程的 ID 必须要使用比较函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：t1 和 t2 是要比较的线程的线程 ID</li><li>返回值：如果两个线程 ID 相等返回非 0 值，如果不相等返回 0</li></ul><h1 id="7-C-线程类（std-thread）"><a href="#7-C-线程类（std-thread）" class="headerlink" title="7.C++线程类（std::thread）"></a>7.C++线程类（std::thread）</h1><p><a href="https://blog.csdn.net/sjc_0910/article/details/118861539?spm=1001.2014.3001.5506"> C++11 多线程（std::thread）详解_c++多线程_jcShan709的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">线程相关知识（pthread）</summary>
    
    
    
    <category term="Linux" scheme="https://www.thekqd.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.thekqd.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Clion快捷键</title>
    <link href="https://www.thekqd.top/posts/70b69f96.html"/>
    <id>https://www.thekqd.top/posts/70b69f96.html</id>
    <published>2023-04-11T01:18:44.000Z</published>
    <updated>2023-07-17T11:17:07.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CLion编辑快捷键"><a href="#CLion编辑快捷键" class="headerlink" title="CLion编辑快捷键"></a>CLion编辑快捷键</h1><p><strong>Ctrl+Spacebar</strong> 基本代码完成(任何类、方法或变量的名称)</p><p><strong>Ctrl+Shift+Spacebar</strong> 智能代码完成(按预期类型筛选方法和变量列表)</p><p><strong>Ctrl+Shift+Enter</strong> 完整的语句</p><p><strong>Ctrl+P</strong> 参数信息(在方法调用参数内)</p><p><strong>Ctrl+Q</strong> 快速查找文档</p><p><strong>Ctrl+Mouse over code</strong> 简短的信息</p><p><strong>Ctrl+F1</strong> 在插入符号处显示错误或警告的说明</p><p><strong>Alt+Insert</strong> 生成代码…(Getters, Setters, Constructors, hashCode/equals, toString)</p><p><strong>Ctrl+O</strong> 覆盖方法</p><p><strong>Ctrl+I</strong> 实现方法</p><p><strong>Ctrl+Alt+T</strong> 围绕与…(如果. .其他,试试. .catch, for, synchronized等)</p><p><strong>Ctrl+/</strong> 注释/取消注释行注释</p><p><strong>Ctrl+Shift+/</strong> 注释/取消注释块注释</p><p><strong>Ctrl+W</strong> 选择连续递增代码块</p><p><strong>Ctrl+Shift+W</strong> 减少当前选择到以前的状态</p><p><strong>Alt+Q</strong> 显示强度动作和快速修复</p><p><strong>Ctrl+Alt+L</strong> 重新格式化代码</p><p><strong>Ctrl+Alt+O</strong> 优化进口</p><p><strong>Ctrl+Alt+I</strong> 自动缩进线(年代)</p><p><strong>Tab/Shift+Tab</strong> 缩进/ unindent选定的行</p><p><strong>Ctrl+X</strong> 剪切当前行或选定块到剪贴板</p><p><strong>Ctrl+C</strong> 复制当前行或选定块到剪贴板</p><p><strong>Ctrl+V</strong> 从剪贴板粘贴</p><p><strong>Ctrl+Shift+V</strong> 从最近的缓冲区粘贴…</p><p><strong>Ctrl+D</strong> 复制当前行或选定块</p><p><strong>Ctrl+Y</strong> 删除插入符号处的行</p><p><strong>Ctrl+Shift+J</strong> 智能线连接</p><p><strong>Ctrl+Enter</strong> 智能线分裂</p><p><strong>Shift+Enter</strong> 开始新的一行</p><p><strong>Ctrl+Shift+U</strong> 在插入符号或选定块上切换大小写</p><p><strong>Ctrl+Shift+]/[</strong> 选择直到代码块结束/开始</p><p><strong>Ctrl+Delete</strong> 删除到字尾</p><p><strong>Ctrl+Backspace</strong> 删除到单词开始</p><p><strong>Ctrl+ NumPad +/-</strong> 展开/折叠代码块</p><p><strong>Ctrl+Alt+ NumPad +/-</strong> 展开所有/折叠所有</p><p><strong>Ctrl+F4</strong> 关闭活动编辑器选项卡</p><p><strong>Alt+Shift+Click</strong> 将插入符号放置在多个位置</p><p><strong>Esc</strong> 恢复单插入字符模式</p><p><strong>Alt+G/Alt+Shift+G</strong> 添加/删除下次出现的当前单词选择</p><h1 id="CLion查找和替换"><a href="#CLion查找和替换" class="headerlink" title="CLion查找和替换"></a>CLion查找和替换</h1><p><strong>Double Shift</strong> 到处寻找</p><p><strong>Ctrl+F</strong> 找到</p><p><strong>F3 / Shift+F3</strong> 查找下一个/找到之前</p><p><strong>Ctrl+R</strong> 取代</p><p><strong>Ctrl+Shift+F</strong> 找到的路径</p><p><strong>Ctrl+Shift+R</strong> 在路径替换</p><h1 id="CLion编译、运行快捷键"><a href="#CLion编译、运行快捷键" class="headerlink" title="CLion编译、运行快捷键"></a>CLion编译、运行快捷键</h1><p><strong>Ctrl+F9</strong> 建设项目</p><p><strong>Alt+Shift+F10</strong> 选择配置并运行</p><p><strong>Alt+Shift+F9</strong> 选择配置和调试</p><p><strong>Shift+F10</strong> 运行</p><p><strong>Shift+F9</strong> 调试</p><h1 id="CLion-Debug快捷键"><a href="#CLion-Debug快捷键" class="headerlink" title="CLion Debug快捷键"></a>CLion Debug快捷键</h1><p><strong>F8</strong> 步进</p><p><strong>F7</strong> 进入</p><p><strong>Shift+F8</strong> 步出</p><p><strong>Alt+F9</strong> 运行到光标</p><p><strong>Alt+F8</strong> 计算表达式</p><p><strong>F9</strong> 恢复程序</p><p><strong>Ctrl+F8</strong> Toggle breakpoint</p><p><strong>Ctrl+Shift+F8</strong> 查看断点</p><h1 id="CLion-Live模板快捷键"><a href="#CLion-Live模板快捷键" class="headerlink" title="CLion Live模板快捷键"></a>CLion Live模板快捷键</h1><p><strong>Ctrl+Alt+J</strong> 使用Live模板包围</p><p><strong>Ctrl+J</strong> 插入Live模板</p><p><strong>for</strong> (索引;,)循环</p><p><strong>iter</strong> 迭代范围(C + + 11)</p><p><strong>itit</strong> 使用Begin/End成员函数迭代</p><p><strong>incboost</strong> 在CMake中包含使用Boost的指示</p><p><strong>function</strong> 在CMake中创建新的函数定义器</p><h1 id="CLion搜索文件、导航快捷键"><a href="#CLion搜索文件、导航快捷键" class="headerlink" title="CLion搜索文件、导航快捷键"></a>CLion搜索文件、导航快捷键</h1><p><strong>Ctrl+N</strong> 搜索类文件</p><p><strong>Ctrl+Shift+N</strong> 搜索文件</p><p><strong>Ctrl+Alt+Shift+N</strong> 定位到符号</p><p><strong>Alt+Right Arrow/Left Arrow</strong> 转到下一个/上一个编辑器选项卡</p><p><strong>F12</strong> 返回到前一个工具窗口</p><p><strong>Esc</strong> 转到编辑器(从工具窗口)</p><p><strong>Shift+Esc</strong> 隐藏活动的或最近活动的窗口</p><p><strong>Ctrl+Shift+F4</strong> 关闭活动运行/信息/发现/…选项卡</p><p><strong>Ctrl+G</strong> 去行</p><p><strong>Ctrl+E</strong> 最近文件弹出</p><p><strong>Ctrl+Alt+Left Arrow/Right Arrow</strong> 向后/向前导航</p><p><strong>Ctrl+Shift+Backspace</strong> 导航到最后一次编辑位置</p><p><strong>Alt+F1</strong> 在任意视图中选择当前文件或符号</p><p><strong>Ctrl+B</strong> 定位声明 或 <strong>Ctrl + 鼠标左键</strong></p><p><strong>Ctrl+Alt+B</strong> 搜索实现类(年代)</p><p><strong>Ctrl+Alt+Home</strong> 转到相关符号(头/源)</p><p><strong>Ctrl+Shift+I</strong> 文件)</p><p><strong>Ctrl+Shift+B</strong> 开放快速定义查找</p><p><strong>Ctrl+U</strong> 进入类型声明</p><p><strong>Alt+Up Arrow/Down Arrow</strong> 父类方法/超类</p><p><strong>Ctrl+]/[</strong> 转到前一个/下一个方法</p><p><strong>Ctrl+F12</strong> 移动到代码块结束/移动到代码开始</p><p><strong>Ctrl+H</strong> 弹出文件结构</p><p><strong>Ctrl+Alt+H</strong> 类型层次结构</p><p><strong>F2/Shift+F2</strong> 调用层次结构</p><p><strong>F11</strong> 下一个/以前的错误突出显示</p><p><strong>Ctrl+F11</strong> 切换书签</p><p><strong>Ctrl+0…9</strong> 用助记符切换书签</p><p><strong>Shift+F11</strong> 转到编号书签</p><h1 id="CLion常用快捷键"><a href="#CLion常用快捷键" class="headerlink" title="CLion常用快捷键"></a>CLion常用快捷键</h1><p><strong>Alt+0…9</strong> 打开相应的工具窗口</p><p><strong>Alt+Shift+I</strong> 用当前配置文件检查当前文件</p><p><strong>Ctrl+`</strong> 快速开关电流方案</p><p><strong>Ctrl+Alt+S</strong> 编辑应用程序设置</p><p><strong>Ctrl+Shift+F12</strong> 隐藏所有工具窗口</p><p><strong>Alt+Shift+F</strong> 添加到收藏夹</p><h1 id="CLion-使用过的搜索"><a href="#CLion-使用过的搜索" class="headerlink" title="CLion 使用过的搜索"></a>CLion 使用过的搜索</h1><p><strong>Alt+F7</strong> 发现使用</p><p><strong>Ctrl+F7</strong> 在文件中查找用法</p><p><strong>Ctrl+Shift+F7</strong> 突出显示文件中的用法</p><p><strong>Ctrl+Alt+F7</strong> 显示用法</p><h1 id="VCS-Git快捷键"><a href="#VCS-Git快捷键" class="headerlink" title="VCS/Git快捷键"></a>VCS/Git快捷键</h1><p><strong>Ctrl+K</strong> 向VCS/Git提交项目</p><p><strong>Ctrl+T</strong> 从VCS更新项目</p><p><strong>Alt+Shift+C</strong> 查看最近的变化</p><p><strong>Alt+`</strong> VCS/Git快速弹出</p><h1 id="CLion重构快捷键"><a href="#CLion重构快捷键" class="headerlink" title="CLion重构快捷键"></a>CLion重构快捷键</h1><p><strong>Ctrl+Alt+Shift+T</strong> 重构</p><p><strong>F5</strong> 复制</p><p><strong>F6</strong> 移动</p><p><strong>Alt+Delete</strong> 安全的删除</p><p><strong>Shift+F6</strong> 重命名</p><p><strong>Ctrl+F6</strong> 更改签名</p><p><strong>Ctrl+Alt+M</strong> 提取功能</p><p><strong>Ctrl+Alt+N</strong> 内联</p><p><strong>Ctrl+Alt+P</strong> 引入参数</p><p><strong>Ctrl+Alt+V</strong> 引入变量</p><p><strong>Ctrl+Alt+C</strong> 介绍常数</p><p><strong>Ctrl+Alt+D</strong> 介绍定义</p>]]></content>
    
    
    <summary type="html">一些Clion常用的快捷键一共120个</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>STM32</title>
    <link href="https://www.thekqd.top/posts/b900f0d0.html"/>
    <id>https://www.thekqd.top/posts/b900f0d0.html</id>
    <published>2023-04-02T15:03:08.000Z</published>
    <updated>2023-07-18T15:21:46.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-IDE选择"><a href="#1-IDE选择" class="headerlink" title="1.IDE选择"></a>1.IDE选择</h1><p><strong>keil</strong></p><p><strong>Clion</strong></p><p><a href="https://zhuanlan.zhihu.com/p/145801160">配置CLion用于STM32开发【优雅の嵌入式开发】 - 知乎 (zhihu.com)</a></p><h1 id="2-时钟RCC"><a href="#2-时钟RCC" class="headerlink" title="2.时钟RCC"></a>2.时钟RCC</h1><p><a href="https://blog.csdn.net/as480133937/article/details/98845509">【STM32】系统时钟RCC详解(超详细，超全面)_rcc时钟_Z小旋的博客-CSDN博客</a></p><h1 id="3-STM32-GPIO介绍"><a href="#3-STM32-GPIO介绍" class="headerlink" title="3.STM32-GPIO介绍"></a>3.STM32-GPIO介绍</h1><p><a href="https://blog.csdn.net/qq_44016222/article/details/123206403?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=stm32GPIO&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-123206403.nonecase&amp;spm=1018.2226.3001.4187"> STM32-GPIO介绍_stm32gpio_KevinFlyn的博客-CSDN博客</a></p><h2 id="HAL库-GPIO函数库"><a href="#HAL库-GPIO函数库" class="headerlink" title="HAL库 GPIO函数库"></a>HAL库 GPIO函数库</h2><p><a href="https://blog.csdn.net/as480133937/article/details/98983268"> 【STM32】HAL库 STM32CubeMX教程三——外部中断(HAL库GPIO讲解)_HAL_GPIO_EXTI_callback_Z小旋的博客-CSDN博客</a></p><h2 id="单片机引脚的上拉、下拉和三态"><a href="#单片机引脚的上拉、下拉和三态" class="headerlink" title="单片机引脚的上拉、下拉和三态"></a>单片机引脚的上拉、下拉和三态</h2><p><strong>上拉：</strong>上拉是指单片机的引脚通过电阻接VCC，这样可以把这个引脚的电平固定为高电平。</p><p><strong>下拉：</strong>下拉的情况和上拉的相反，是为了把引脚固定为低电平，要有下拉电阻也是为了防止误配置导致烧掉芯片。</p><p><strong>三态：</strong>三态又称为高阻态，简单理解就是电平的高低由这根线上的外部电路决定，当外部电路为高电平的时候，它也是高电平；当外部电路为低电平的时候，它也是低电平；当外部电路为高阻态的时候，它就是高阻态的，状态完全和外部电路一样。</p><h2 id="上升沿和下降沿"><a href="#上升沿和下降沿" class="headerlink" title="上升沿和下降沿"></a><strong>上升沿和下降沿</strong></h2><p><strong>电平：</strong>简单理解就是电压，但却不相同。</p><p><strong>上升沿触发：</strong>数字电路中，数字电平从低电平（数字“0”代表低电平）变为高电平（数字“1”代表高电平）的那一瞬间叫作上升沿。上升沿触发是当信号有上升沿时的开关动作，当电位由低变高而触发输出变化的就叫上升沿触发。也就是当测到的信号电位是从低到高也就是上升时就触发，叫做上升沿触发。</p><p><strong>下降沿触发：</strong>数字电路中，数字电平从高电平（数字“1”）变为低电平（数字“0”）的那一瞬间叫作下降沿。 下降沿触发是当信号有下降沿时的开关动作，当电位由高变低而触发输出变化的就叫下降沿触发。也就是当测到的信号电位是从高到低也就是下降时就触发，叫做下降沿触发。</p><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="定时器的介绍"><a href="#定时器的介绍" class="headerlink" title="定时器的介绍"></a>定时器的介绍</h2><h3 id="STM32G070RBT6定时器资源"><a href="#STM32G070RBT6定时器资源" class="headerlink" title="STM32G070RBT6定时器资源"></a>STM32G070RBT6定时器资源</h3><blockquote><p>  STM32G070RBT6拥有一个PWM高级定时器，五个16位通用定时器，两个基础定时器，两个看门狗定时器，一个SysTick定时器，共有11个定时器。</p></blockquote><p>基本定时器 TIM6 和 TIM7 是一个 16 位的只能向上计数的定时器，只能定时，没有外部 IO。通用定时器 TIM14/15/16/17 是 16 位的只能向上计数的定时器，可以定时，可以输出比较，可以输入捕获，其中TIM15拥有外部输入引脚，和两个输出通道，TIM14/16/17都仅只有一个通道。高级定时器 TIM1 是一个 16 位的可以向上/下计数的定时器，可以定时，可以输出比较，可以输入捕捉，还可以有三相电机互补输出信号，有 8 个外部 IO。</p><h3 id="基本定时器功能框图讲解"><a href="#基本定时器功能框图讲解" class="headerlink" title="基本定时器功能框图讲解"></a>基本定时器功能框图讲解</h3><p>基本定时器的核心是时基，不仅基本定时器有，通用定时器和高级定时器也有。学习定时器时，我们先从简单的基本定时器学起。</p><h4 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h4><p>定时器时钟 TIMxCLK，即内部时钟 CK_INT，经 APB 预分频器后分频提供，如果APB1 预分频系数等于 1，则频率不变，否则频率乘以 2，库函数中 APB 预分频的系数是 1，即TPCLK=64M，所以定时器TIMxCLK=64MHz。</p><h4 id="计数器时钟"><a href="#计数器时钟" class="headerlink" title="计数器时钟"></a>计数器时钟</h4><p>定时器时钟经过 PSC 预分频器之后，即计数器时钟 CK_CNT，用来驱动计数器计数。PSC 是一个16 位的预分频器，可以对定时器时钟 TIMxCLK 进行 1~65536 之间的任何一个数进行分频。具体计算方式为：CK_CNT=TIMxCLK/(PSC+1)。</p><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>计数器 CNT 是一个 16 位的计数器，只能往上计数，最大计数值为 65535。当计数达到自动重装载寄存器的时候产生更新事件，并清零从头开始计数。</p><h4 id="自动重装载寄存器"><a href="#自动重装载寄存器" class="headerlink" title="自动重装载寄存器"></a>自动重装载寄存器</h4><p>自动重装载寄存器 ARR 是一个 16 位的寄存器，这里面装着计数器能计数的最大数值。当计数到这个值的时候，如果使能了中断的话，定时器就产生溢出中断。</p><h4 id="定时器时间的计算"><a href="#定时器时间的计算" class="headerlink" title="定时器时间的计算"></a>定时器时间的计算</h4><p>定时器的定时时间等于计数器的中断周期乘以中断的次数。计数器在 CK_CNT 的驱动下，计一个数的时间则是 CK_CNT 的倒数，等于：1/（TIMxCLK/(PSC+1)），产生一次中断的时间则等于：(1/CK_CNT) <em> (ARR+1)。如果在中断服务程序里面设置一个变量 time，用来记录中断的次数，那么就可以计算出我们需要的定时时间等于：(1/CK_CNT) </em> (ARR+1) * time。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="Ⅰ-定时器控制小灯每秒闪烁一次"><a href="#Ⅰ-定时器控制小灯每秒闪烁一次" class="headerlink" title="Ⅰ.定时器控制小灯每秒闪烁一次"></a>Ⅰ.定时器控制小灯每秒闪烁一次</h3><h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><p>定时器溢出时间（us）= (定时器预分频值+1)*(定时器自动重装载值+1)/(定时器输入时钟频率(MHz))</p><p>通过配置基础定时器TIM7的 <strong><em>Psc</em></strong> (预分频值)与 <strong><em>Arr</em></strong> (自动重装载值)，使得其溢出时间为1 s；在定时器中断回调函数中调用GPIO状态翻转函数控制LED的引脚电平翻转，从而实现小灯每秒闪烁一次。</p><h3 id="STM32CubeMX的配置"><a href="#STM32CubeMX的配置" class="headerlink" title="STM32CubeMX的配置"></a>STM32CubeMX的配置</h3><p><a href="https://blog.csdn.net/as480133937/article/details/99231677">【STM32】HAL库 STM32CubeMX教程七—-PWM输出(呼吸灯)_stm32cubemx pwm呼吸灯_Z小旋的博客-CSDN博客</a></p><h4 id="Keil工程代码讲解"><a href="#Keil工程代码讲解" class="headerlink" title="Keil工程代码讲解"></a>Keil工程代码讲解</h4><h4 id="引用或定义的函数"><a href="#引用或定义的函数" class="headerlink" title="引用或定义的函数"></a>引用或定义的函数</h4><h5 id="需要引用的函数："><a href="#需要引用的函数：" class="headerlink" title="需要引用的函数："></a>需要引用的函数：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数原型 */</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_TIM_Base_Start_IT</span><span class="params">(TIM_HandleTypeDef *htim)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数引用举例 */</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim7);<span class="comment">//以中断工作方式启动定时器TIM7，发生UEV事件时产生中断</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数原型 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_TogglePin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数引用举例 */</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); <span class="comment">//控制PC13翻转电平</span></span><br></pre></td></tr></table></figure><h4 id="需要定义的函数："><a href="#需要定义的函数：" class="headerlink" title="需要定义的函数："></a>需要定义的函数：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数原型 */</span></span><br><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数重定义举例 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 判断进入中断定时器是否为TIM7 */</span></span><br><span class="line"><span class="keyword">if</span> (htim == &amp;htim7)&#123;</span><br><span class="line"><span class="comment">/* 控制PC13引脚翻转电平 */</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h5 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h5><p>  <a href="https://baike.baidu.com/item/%E4%B8%AD%E6%96%AD/3933007?fromModule=lemma_search-box">中断（Interrupt）</a>：是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p><p>  <a href="https://zhidao.baidu.com/question/345550524.html#:~:text=UEV%EF%BC%8C%E9%95%BF%E7%A7%B0%EF%BC%8Cupdate,event%EF%BC%8C%E4%B8%AD%E6%96%87%E4%B8%BA%E6%9B%B4%E6%96%B0%E4%BA%8B%E4%BB%B6%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%B4%E4%BA%8B%E4%BB%B6%E6%9B%B4%E6%96%B0%E5%8F%91%E7%94%9F%EF%BC%8C%E6%98%AF%E6%8C%87%E8%BF%99%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E5%90%8E%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%B0%86%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%96%B0%EF%BC%8C%E4%BB%A5%E4%BD%BF%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%9C%A8%E6%96%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8B%EF%BC%8C%E4%BE%8B%E5%A6%82%E5%BD%93%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%91%A8%E6%9C%9F%E7%BB%93%E6%9D%9F%EF%BC%88%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%8A%E6%BA%A2%EF%BC%89%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E4%BA%8B%E4%BB%B6%E3%80%82">UEV事件</a>：全称——update event，中文为更新事件，或者说事件更新发生，是指这个事件发生后，将会将定时器的寄存器进行更新，以使定时器工作在新的配置下，例如当一个定时周期结束（计数器上溢）或者其他事件。</p><p>  <a href="https://baike.baidu.com/item/%E8%BD%AE%E8%AF%A2?fromModule=lemma_search-box">轮询（Polling）</a>：是一种CPU决策如何提供周边设备服务的方式，又称“程控输入输出”（Programmed I/O）。轮询法的概念是：由CPU定时发出询问，依序询问每一个周边设备是否需要其服务，有即给予服务，服务结束后再问下一个周边，接着不断周而复始。</p><p>  <strong>控制基础定时器启动的HAL库函数</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start(&amp;htimx); <span class="comment">// 以轮询工作方式启动定时器，不会产生中断。</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htimx); <span class="comment">// 以中断工作方式启动定时器，发生UEV事件时产生中断</span></span><br><span class="line">HAL_TIM_Base_Start_DMA(&amp;htimx); <span class="comment">// 以DMA工作方式启动定时器</span></span><br></pre></td></tr></table></figure><p>  <strong>GPIO引脚相关的部分HAL库函数</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOX, GPIO_PIN_XX, GPIO_PIN_RESET); <span class="comment">// 控制PX_XX引脚输出低电平</span></span><br><span class="line">HAL_GPIO_WritePin(GPIOX, GPIO_PIN_XX, GPIO_PIN_SET); <span class="comment">// 控制PX_XX引脚输出高电平</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOX, GPIO_PIN_XX); <span class="comment">// 控制PX_XX引脚翻转电平</span></span><br><span class="line">HAL_GPIO_ReadPin(GPIOX, GPIO_PIN_XX); <span class="comment">// 读取PX_XX引脚当前状态</span></span><br></pre></td></tr></table></figure><p>  <a href="https://blog.csdn.net/qq562029186/article/details/76216311">__weak修饰符</a>：在 HAL 库中，很多<a href="https://so.csdn.net/so/search?q=回调&amp;spm=1001.2101.3001.7020">回调</a>函数前面使用__weak 修饰符。例如本次实验所用到的定时器中断回调函数：<code>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</code>其函数原型为：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>;</span><br></pre></td></tr></table></figure><p>  加上了__weak 修饰符的函数,用户可以在用户文件中重新定义一个同名函数，最终编译器编译的时候，会选择用户定义的函数，如果用户没有重新定义这个函数，那么编译器就会执行 weak 声明的函数，并且编译器不会报错。</p></blockquote><h4 id="在main-c文件中在所指示的位置添加以下代码"><a href="#在main-c文件中在所指示的位置添加以下代码" class="headerlink" title="在main.c文件中在所指示的位置添加以下代码"></a>在main.c文件中在所指示的位置添加以下代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*以中断模式开启定时器7 */</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim7);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器中断回调函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 判断进入中断定时器是否为TIM7 */</span></span><br><span class="line"><span class="keyword">if</span> (htim == &amp;htim7)&#123;</span><br><span class="line"><span class="comment">/* 控制连接LED的引脚翻转电平 */</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在单片机上观察实验现象</strong></p><h3 id="Ⅱ-软件PWM实现控制蜂鸣器响度"><a href="#Ⅱ-软件PWM实现控制蜂鸣器响度" class="headerlink" title="Ⅱ.软件PWM实现控制蜂鸣器响度"></a>Ⅱ.软件PWM实现控制蜂鸣器响度</h3><h4 id="实验原理-1"><a href="#实验原理-1" class="headerlink" title="实验原理"></a>实验原理</h4><h5 id="（1）PWM"><a href="#（1）PWM" class="headerlink" title="（1）PWM"></a>（1）PWM</h5><p><a href="https://baike.baidu.com/item/PWM%E6%8A%80%E6%9C%AF/10204668">脉冲宽度调制(PWM)</a>，是英文“Pulse Width Modulation”的缩写，简称<strong>脉宽调制</strong>，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，广泛应用在从测量、通信到功率控制与变换的许多领域中。</p><p>以单片机为例，我们知道，单片机的IO口输出的是<strong>数字信号</strong>，<strong>IO口只能输出高电平和低电平</strong></p><p>假设高电平为5V 低电平则为0V 那么我们要<strong>输出不同的模拟电压</strong>，就要用到PWM，通过改变IO口输出的<strong>方波的占空比</strong>从而获得使用数字信号模拟成的模拟电压信号</p><p>我们知道，电压是以一种连接1或断开0的重复脉冲序列被夹到模拟负载上去的（例如LED灯，直流电机等），连接即是直流供电输出，断开即是直流供电断开。通过对连接和断开时间的控制，理论上来讲，可以输出任意不大于最大电压值（即0~5V之间任意大小）的模拟电压</p><p>比方说 占空比为50% 那就是高电平时间一半，低电平时间一半，在一定的频率下，就可以得到模拟的2.5V输出电压 那么75%的占空比 得到的电压就是3.75V</p><p>pwm的调节作用来源于对“占周期”的宽度控制，“占周期”变宽，输出的能量就会提高，通过阻容变换电路所得到的平均电压值也会上升，“占周期”变窄，输出的电压信号的电压平均值就会降低，通过阻容变换电路所得到的平均电压值也会下降</p><p>也就是，<strong>在一定的频率下，通过不同的占空比即可得到不同的输出模拟电压</strong></p><p>pwm就是通过这种原理实现D/A转换的。</p><ul><li><strong>占空比是指在一个脉冲循环内，通电时间相对于总时间所占的比例。 占空比(Duty Ratio)在电信领域中有如下含义：例如：脉冲宽度1μs，信号周期4μs的脉冲序列占空比为0.25</strong></li></ul><h5 id="（2）PWM控制蜂鸣器响度的原理"><a href="#（2）PWM控制蜂鸣器响度的原理" class="headerlink" title="（2）PWM控制蜂鸣器响度的原理"></a>（2）PWM控制蜂鸣器响度的原理</h5><p><strong>蜂鸣器音量的大小与电压大小成正比</strong>，因此通过调节软件pwm的占空比，来得到不同的输出模拟电压，即可控制蜂鸣器的响度。</p><h4 id="STM32CubeMX的配置-1"><a href="#STM32CubeMX的配置-1" class="headerlink" title="STM32CubeMX的配置"></a>STM32CubeMX的配置</h4><p><strong>Step1：配置RCC</strong></p><p><strong>Step2：配置SYS</strong></p><p><strong>Step3：配置基础定时器TIM7</strong></p><p>要实现通过调节软件PWM的占空比模拟不同的输出电压，PWM需有较高频率。</p><p>所以此处设Psc = 31， Arr = 99；</p><p><strong>Step4：查看开发板原理图查找到蜂鸣器BEEP引脚 -&gt; PC12</strong></p><p><em>如果使用的是其他开发板，则根据所使用开发板的原理图寻找到接BEEP（蜂鸣器）的引脚，若该开发板无蜂鸣器，可寻找一个引出的引脚，准备一个蜂鸣器模块/蜂鸣器，按照蜂鸣器的正负极手动将蜂鸣器的一端与所选引脚相连，另一端与开发板上的GND相连</em></p><p><strong>Step5：配置BEEP引脚PC12为GPIO_Output（输出）模式</strong></p><p><strong>Step6：配置时钟树,主频率设为64HMz</strong></p><p><strong>Step7：配置工程属性</strong></p><p><strong>Step8：生成Keil工程</strong></p><h6 id="在main-c文件中在所指示的位置添加以下代码-1"><a href="#在main-c文件中在所指示的位置添加以下代码-1" class="headerlink" title="在main.c文件中在所指示的位置添加以下代码"></a>在main.c文件中在所指示的位置添加以下代码</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 所定义的全局变量 */</span></span><br><span class="line"><span class="type">uint8_t</span> counter = <span class="number">0</span>; <span class="comment">//计数器</span></span><br><span class="line"><span class="type">uint8_t</span> pwmrate = <span class="number">20</span>;<span class="comment">//软件PWM的占空比</span></span><br><span class="line"><span class="type">_Bool</span> sw = <span class="number">0</span>; <span class="comment">//用于控制pwmrate的自增或自减【_Bool为布尔类型变量，只有1位即0和1】</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 以中断模式开启定时器7 */</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim7);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器中断回调函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 软件PWM */</span></span><br><span class="line"><span class="keyword">if</span> (counter &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">counter++;</span><br><span class="line"><span class="comment">/* 当计数值小于等于pwmrate时PC12为1，反之为0 */</span></span><br><span class="line"><span class="comment">/* 占空比为 pwmrate/100％，即pamrate */</span></span><br><span class="line"><span class="keyword">if</span>(counter &lt;= pwmrate)</span><br><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_SET);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 当counter值超过100归零 */</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当pwmrate即占空比小于100，且sw为0时，占空比逐渐增加，直至100 */</span></span><br><span class="line"><span class="keyword">if</span> (pwmrate &lt; <span class="number">100</span> &amp;&amp; sw == <span class="number">0</span>)</span><br><span class="line">pwmrate++;</span><br><span class="line"><span class="comment">/* 当pwmrate即占空比大于或等于100时，sw置为1 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sw = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当pwmrate即占空比大于20，且sw为1时，占空比逐渐减小，直至20 */</span></span><br><span class="line"><span class="keyword">if</span> (pwmrate &gt; <span class="number">20</span> &amp;&amp; sw == <span class="number">1</span>)</span><br><span class="line">pwmrate--;</span><br><span class="line"><span class="comment">/* 当pwmrate即占空比小于或等于20时，sw置0 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sw = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 延时20ms，使现象可以被人观测到 */</span></span><br><span class="line">HAL_Delay(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h6 id="在单片机上观察实验现象"><a href="#在单片机上观察实验现象" class="headerlink" title="在单片机上观察实验现象"></a>在单片机上观察实验现象</h6><blockquote><h6 id="拓展：HAL库中的部分重定义变量类型"><a href="#拓展：HAL库中的部分重定义变量类型" class="headerlink" title="拓展：HAL库中的部分重定义变量类型"></a>拓展：HAL库中的部分重定义变量类型</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/* 位于“stdint.h”文件中 */</span></span><br><span class="line">&gt;<span class="comment">/* exact-width signed integer types */</span></span><br><span class="line">&gt;<span class="keyword">typedef</span>   <span class="type">signed</span>          <span class="type">char</span> <span class="type">int8_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span>   <span class="type">signed</span> <span class="type">short</span>     <span class="type">int</span> <span class="type">int16_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span>   <span class="type">signed</span>           <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span>   <span class="type">signed</span>       __INT64 <span class="type">int64_t</span>;</span><br><span class="line">&gt;<span class="comment">/* exact-width unsigned integer types */</span></span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span>          <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>     <span class="type">int</span> <span class="type">uint16_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span>           <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span>       __INT64 <span class="type">uint64_t</span>;</span><br></pre></td></tr></table></figure><p><strong>常用的类型有：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">typedef</span>   <span class="type">signed</span> <span class="type">short</span>     <span class="type">int</span> <span class="type">int16_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span>   <span class="type">signed</span>           <span class="type">int</span> <span class="type">int32_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span>          <span class="type">char</span> <span class="type">uint8_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>     <span class="type">int</span> <span class="type">uint16_t</span>;</span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="type">unsigned</span>           <span class="type">int</span> <span class="type">uint32_t</span>;</span><br></pre></td></tr></table></figure></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/dongxiaodong/p/14351398.html">【来源于网络】STM32定时器详细篇（基于HAL库）</a></p><p><a href="https://blog.csdn.net/as480133937/article/details/103439546">【来源于网络】PWM原理 PWM频率与占空比详解-z小旋</a></p><p><a href="https://blog.csdn.net/as480133937/article/details/99201209">【来源于网络】【STM32】HAL库 STM32CubeMX教程六——定时器中断-z小旋</a></p><p><a href="https://blog.csdn.net/as480133937/article/details/99231677">【来源于网络】【STM32】HAL库 STM32CubeMX教程七—-PWM输出(呼吸灯) -z小旋</a></p><h1 id="4-STM32串口通信、LCD的使用及SPI、IIC"><a href="#4-STM32串口通信、LCD的使用及SPI、IIC" class="headerlink" title="4.STM32串口通信、LCD的使用及SPI、IIC"></a>4.STM32串口通信、LCD的使用及SPI、IIC</h1><p><a href="https://blog.csdn.net/as480133937/article/details/99073783">【STM32】HAL库 STM32CubeMX教程四—-UART串口通信详解_hal_uart_transmit_Z小旋的博客-CSDN博客</a></p><h2 id="串口-USART-、SPI、IIC的介绍（文末附相关博客）"><a href="#串口-USART-、SPI、IIC的介绍（文末附相关博客）" class="headerlink" title="串口(USART)、SPI、IIC的介绍（文末附相关博客）"></a>串口(USART)、SPI、IIC的介绍（文末附相关博客）</h2><h3 id="STM32G070RBT6———串口"><a href="#STM32G070RBT6———串口" class="headerlink" title="STM32G070RBT6———串口"></a>STM32G070RBT6———串口</h3><p><strong>1.通信方式</strong></p><p>STM32G070RBT6拥有四个串口，每个串口都拥有多种不同的工作式，大致可以按照如下分类：</p><p> 第一分类为<strong>并行通信和串行通信</strong>，而由于串行通信的优点以及对缺点的弥补，导致如今基本都采用<strong>串行通信</strong>；</p><p>对于串行通信，又按照是否有同步时钟和收发间的数据传输方向分成两大类；</p><pre><code> 其中，按照是否有同步时钟分成同步和异步：</code></pre><p>同步通信：带时钟同步信号，发送方和接收方在同一时钟的控制下，实现同步传输。 </p><p>异步通信：不带时钟同步信号，使用各自的时钟控制。 但需要双方相互约定好数据传输速率。</p><pre><code> 传输速率的衡量方式——波特率—单位：bps（位/秒） 按照数据传输方向分成单工、半双工和全工：</code></pre><p>单工通信：数据只沿着一个方向传输，发送端和接受端固定，只需要一根数据线。</p><p>半双工通信：数据可以沿着两个方向传输，但不能同时进行，需要两根数据线。</p><p>全双工通信：数据可以沿着两个方向传输，可以同时进行，需要两根数据线。</p><p>大纲图：<a href="https://i.postimg.cc/TYmzmtBG/20210720113312701.png">https://i.postimg.cc/TYmzmtBG/20210720113312701.png</a></p><p><strong>2.UART协议</strong></p><ul><li><strong>USART-通用同步异步收发器(Universal Synchronous Asynchronous Receiver and Transmitter)是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换。</strong></li><li><strong>UART-通用异步收发器(Universal Asynchronous Receiver and Transmitter)，它是在 USART 基础上裁剪掉了同步通信功能（时钟同步），只有异步通信。简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是 UART。</strong></li></ul><p><strong>UART-全双工</strong></p><p><a href="https://blog.csdn.net/k666499436/article/details/124354165">STM32串口通信详解_rivencode的博客-CSDN博客</a></p><h3 id="STM32G070RBT6———SPI通讯协议"><a href="#STM32G070RBT6———SPI通讯协议" class="headerlink" title="STM32G070RBT6———SPI通讯协议"></a>STM32G070RBT6———SPI通讯协议</h3><p><strong>SPI-全双工</strong>    </p><p><a href="https://great.blog.csdn.net/article/details/109460814"> SPI协议详解（图文并茂+超详细）_小麦大叔的博客-CSDN博客</a></p><h3 id="STM32G070RBT6———IIC（I2C）"><a href="#STM32G070RBT6———IIC（I2C）" class="headerlink" title="STM32G070RBT6———IIC（I2C）"></a>STM32G070RBT6———IIC（I2C）</h3><p><strong>IIC-半双工</strong></p><p><a href="https://blog.csdn.net/weixin_44933419/article/details/114991088?ops_request_misc=%7B%22request%5Fid%22%3A%22168112795916800226579942%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168112795916800226579942&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-114991088-null-null.142^v82^insert_down1,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=IIC&amp;spm=1018.2226.3001.4187"> 常用通信协议——IIC详解（全网最全）<em>iic通信协议</em>阿波罗啦啦啦啦的博客-CSDN博客</a></p><p><strong>printf的重定向问题:</strong></p><p><a href="https://zhuanlan.zhihu.com/p/145801160">配置CLion用于STM32开发【优雅の嵌入式开发】 - 知乎 (zhihu.com)</a></p><h2 id="LCD显示"><a href="#LCD显示" class="headerlink" title="LCD显示"></a>LCD显示</h2><p><strong>见第四次培训</strong></p><h1 id="5-STM32ADC-外设"><a href="#5-STM32ADC-外设" class="headerlink" title="5.STM32ADC 外设"></a>5.STM32ADC 外设</h1><p><a href="https://blog.csdn.net/as480133937/article/details/99627062">【STM32】HAL库 STM32CubeMX教程九—-ADC_stm32cubemx adc_Z小旋的博客-CSDN博客</a></p><h2 id="ADC-介绍"><a href="#ADC-介绍" class="headerlink" title="ADC 介绍"></a>ADC 介绍</h2><p><strong>什么是 ADC？</strong></p><p>Analog-to-Digital Converter 的缩写。指模/数转换器或者模拟/数字转换器。是指将连续</p><p>变量的模拟信号转换为离散的数字信号的器件。典型的模拟数字转换器将模拟信号转换为</p><p>表示一定比例电压值的数字信号。简单地说就是将模拟电压值，转换成对应的肉眼可读数</p><p>值 12 位 ADC 是一种逐次逼近型模拟数字转换器。A/D 转换可以单次、连续、扫描或间断</p><p>模式执行。ADC 的结果可以左对齐或右对齐方式存储在 16 位数据寄存器中</p><p>“输入的模拟量”是输入电压信号，“START”用来控制 ADC 启动转换，“CLOCK”是 ADC 模块的输入时钟，“EOC”是 ADC 转换结束信号，</p><p>“OE”是 ADC 转换结果输出允许信号，“VREF”是参考电压。</p><h3 id="ADC-的转换模式-重要，请务必看懂"><a href="#ADC-的转换模式-重要，请务必看懂" class="headerlink" title="ADC 的转换模式 (重要，请务必看懂)"></a>ADC 的转换模式 (重要，请务必看懂)</h3><p><strong>单次转换模式</strong>：ADC 只执行一次转换；</p><p><strong>连续转换模式</strong>：转换结束之后马上开始新的转换；</p><p><strong>扫描模式</strong>：ADC 扫描被规则通道和注入通道选中的所有通道，在每个组的每个通道上执行单次转换。</p><p>在每个转换结束时，这一组的下一个通道被自动转换。如果设置了 CONT 位</p><p>（开启了连续 转换模式），转换不会在选择组的最后一个通道上停止，而是再次从选择组</p><p>的第一个通道继续转换。</p><p><strong>间断模式</strong>：触发一次，转换一个通道，再触发，再转换。在所选转换通道循环，由触发信号启动新一轮的转换，直到转换完成为止。（扫描模式简单的说是一次对所有所选中的通道进行转换，</p><p>比如开了 ch0，ch1，ch4，ch5。 ch0 转换完以后就会自动转换通道 1,4,5</p><p>直到转换完这个过程不能被打断。如果开启了连续转换模式，则会在转换完 ch5 之后开始</p><p>新一轮的转换。这就引入了间断模式，可以说是对扫描模式的一种补充。它可以把 0,1,4,5</p><p>这四个通道进行分组。可以分成 0,1 一组，4,5 一组。也可以每个通道单独配置为一组。</p><p>这样每一组转换之前都需要先触发一次。）</p><p><strong>ADC 单通道：</strong></p><p>只进行一次 ADC 转换：<strong>配置为“单次转换模式”，扫描模式关闭</strong>。ADC 通道转换一次后，</p><p>就停止转换。等待再次使能后才会重新转换</p><p>进行连续 ADC 转换：<strong>配置为“连续转换模式”，扫描模式关闭</strong>。ADC 通道转换一次后，</p><p>接着进行下一次转换，不断连续。</p><p><strong>ADC 多通道：</strong></p><p>只进行一次 ADC 转换：<strong>配置为“单次转换模式”，扫描模式使能</strong>。ADC 的多个通道，按照配置的顺序依次转换一次后，就停止转换。等待再次使能后才会重新转换</p><p>进行连续 ADC 转换：<strong>配置为“连续转换模式”，扫描模式使能</strong>。ADC 的多个通道，按照</p><p>配置的顺序依次转换一次后，接着进行下一次转换，不断连续。</p><p>也就是：<strong>多通道必须使能扫描模式</strong></p><p><strong>左对齐或右对齐</strong></p><p>因为 ADC 得到的数据是 12 位精度的，但是数据存储在 16 位，所以 ADC 的存储结果可</p><p>以分为左对齐或右对齐两种方式</p><p><strong>注入通道，规则通道：</strong></p><p><strong>注入通道：</strong></p><p>程序正常运行的通道</p><p><strong>规则通道：</strong></p><p>注入通道可以打断规则通道，如果在规则通道转换过程中，有注入通道进行转换，那么就</p><p>要先转换完注入通道，等注入通道转换完成后，再回到规则通道的转换流程（类似于中断）</p><h3 id="ADC-时钟"><a href="#ADC-时钟" class="headerlink" title="ADC 时钟"></a>ADC 时钟</h3><p>ADC 模块的时钟来源是 ADC 预分频器的 ADCCLK</p><p>RCC 控制器为 ADC 时钟提供一个专用的可编程预分频器。 分频因子由 RCC_CFGR 的</p><p>ADCPRE[1:0]配置，可配置 2/4/6/8 分频</p><p><strong>STM32 的 ADC 最大的转换速率为 1MHz,也就是说最快转换时间为 1us，为了保证 ADC转换结果的准确性，ADC 的时钟最好不超过 14M</strong></p><h3 id="ADC-工作流程"><a href="#ADC-工作流程" class="headerlink" title="ADC 工作流程"></a>ADC 工作流程</h3><p>ADC 一般用于采集小电压，其输入值不能超过 VDDA，即 ADC 输入范围：VREF- ≤ VIN ≤ VREF+. <strong>一般把VSSA 和VREF-接地，VREF+ 和VDDA 接 3V3，那么ADC的输入范围是0~3.3V！超过会烧坏单片机！！</strong></p><h3 id="ADC-函数"><a href="#ADC-函数" class="headerlink" title="ADC 函数"></a>ADC 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADC_Start(&amp;hadcx); <span class="comment">//轮询模式开启 ADC</span></span><br><span class="line">HAL_ADC_Start_IT(&amp;hadcx); <span class="comment">//中断轮询模式开启 ADC</span></span><br><span class="line">HAL_ADC_Start_DMA(&amp;hadcx)； <span class="comment">//DMA 模式开启 ADC</span></span><br><span class="line">HAL_ADC_Stop() <span class="comment">//轮询模式关闭 ADC</span></span><br><span class="line">HAL_ADC_Stop_IT() <span class="comment">//中断轮询模式关闭 ADC</span></span><br><span class="line">HAL_ADC_Stop_DMA() <span class="comment">//DMA 模式关闭 ADC</span></span><br><span class="line">HAL_ADCEx_Calibration_Start(&amp;hadcx); <span class="comment">//ADC 校准函数</span></span><br><span class="line">HAL_ADC_GetValue() <span class="comment">//读取 ADC 转换值</span></span><br><span class="line">HAL_ADC_PollForConversion(&amp;hadc1, <span class="number">50</span>); <span class="comment">//等待转换结束函数，50 为等待时间（ms）</span></span><br><span class="line">HAL_ADC_ConvCpltCallback() <span class="comment">//ADC 中断回调函数，转换完成后回调，DMA 模式下</span></span><br><span class="line">DMA 传输完成后调用</span><br><span class="line">HAL_ADC_ConfigChannel() <span class="comment">//配置规则组通道</span></span><br><span class="line">•HAL_ADC_AnalogWDGConfig(） <span class="comment">//看门狗配置</span></span><br></pre></td></tr></table></figure><h2 id="DMA-的基本介绍"><a href="#DMA-的基本介绍" class="headerlink" title="DMA 的基本介绍"></a>DMA 的基本介绍</h2><p><strong>什么是 DMA (DMA 的基本定义)</strong></p><p><strong>DMA，全称 Direct Memory Access，即直接存储器访问。</strong></p><p><strong>DMA 传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者</strong></p><p><strong>存储器和存储器之间的高速数据传输。</strong></p><p>我们知道 CPU 有转移数据、计算、控制程序转移等很多功能，系统运作的核心就是 CPU，CPU 无时不刻的在处理着大量的事务，但有些事情却没有那么重要，比方说数据的复制和存储数据，如果我们把这部分的 CPU 资源拿出来，让 CPU 去处理其他的复杂计算事务，是不是能够更好的利用 CPU 的资源呢？</p><p><strong>因此：转移数据（尤其是转移大量数据）是可以不需要 CPU 参与。</strong>比如希望外设 A 的数据拷贝到外设 B，只要给两种外设提供一条数据通路，直接让数据由 A 拷贝到 B 不经过CPU 的处理。</p><p>数据传输之间有一个<strong>独立的DMA通道</strong>。</p><p><strong>ADC</strong> <strong>使用</strong> <strong>DMA</strong> <strong>相关函数：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADC_Start_DMA(ADC_HandleTypeDef *hadc, <span class="type">uint32_t</span>* pData, <span class="type">uint32_t</span> Length);</span><br></pre></td></tr></table></figure><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>1.使用 ADC 查询模式，采集电阻分压值，显示在 LCD 上，同时控制 RGB 灯</p><p>2.查看开发板硬件原理图找到 ADC 采集</p><p>3.开启 ADC 外设，使能 IN0 端口</p><p>4.设置端口</p><p>5.设置 GPIO 输出</p><p>6.设置 SPI，及 LCD 端口*</p><p>7.设置时钟</p><p>8.设置储存位置及编译器</p><p>9.设置添加头文件，并生成代码</p><p>10.代码编写及注释</p>]]></content>
    
    
    <summary type="html">STM32单片机开发</summary>
    
    
    
    <category term="嵌入式" scheme="https://www.thekqd.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="https://www.thekqd.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
</feed>
